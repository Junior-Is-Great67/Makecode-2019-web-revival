var _____WB$wombat$assign$function_____ = function(name) {return (self._wb_wombat && self._wb_wombat.local_init && self._wb_wombat.local_init(name)) || self[name]; };
if (!self.__WB_pmw) { self.__WB_pmw = function(obj) { this.__WB_source = obj; return this; } }
{
  let window = _____WB$wombat$assign$function_____("window");
  let self = _____WB$wombat$assign$function_____("self");
  let document = _____WB$wombat$assign$function_____("document");
  let location = _____WB$wombat$assign$function_____("location");
  let top = _____WB$wombat$assign$function_____("top");
  let parent = _____WB$wombat$assign$function_____("parent");
  let frames = _____WB$wombat$assign$function_____("frames");
  let opener = _____WB$wombat$assign$function_____("opener");

var pxtTargetBundle = {
    "id": "arcade",
    "name": "arcade",
    "nickname": "arcade",
    "thumbnailName": "MakeCode Arcade",
    "title": "Microsoft MakeCode Arcade",
    "description": "Develop your programming skills by quickly creating and modding retro arcade games with Blocks and JavaScript in the MakeCode editor",
    "corepkg": "core",
    "cloud": {
        "workspace": false,
        "sharing": true,
        "thumbnails": true,
        "importing": true,
        "packages": true,
        "publishing": true,
        "githubPackages": true
    },
    "bundleddirs": [
        "libs/animation",
        "libs/accelerometer",
        "libs/lightsensor",
        "libs/thermometer",
        "libs/base",
        "libs/core",
        "libs/core---samd",
        "libs/core---stm32",
        "libs/core---linux",
        "libs/core---vm",
        "libs/serial",
        "libs/corgio",
        "libs/darts",
        "libs/keyboard",
        "libs/mouse",
        "libs/hw",
        "libs/hw---stm32f401",
        "libs/hw---samd51",
        "libs/hw---rpi",
        "libs/hw---vm",
        "libs/feather",
        "libs/sevenseg",
        "libs/settings",
        "libs/settings---files",
        "libs/screen",
        "libs/screen---st7735",
        "libs/screen---linux",
        "libs/screen---ext",
        "libs/game",
        "libs/game---hw",
        "libs/buttons",
        "libs/mixer",
        "libs/servo",
        "libs/light",
        "libs/mixer---samd",
        "libs/mixer---stm32",
        "libs/mixer---none",
        "libs/mixer---linux",
        "libs/mixer---ext",
        "libs/device",
        "libs/jacdac",
        "libs/jacdac-services",
        "libs/jacdac-game",
        "libs/power",
        "libs/controller",
        "libs/controller---none",
        "libs/edge-connector",
        "libs/esp32spi",
        "libs/mqtt",
        "libs/net",
        "libs/azureiot",
        "libs/color",
        "libs/palette",
        "libs/storyboard",
        "libs/rotary-encoder",
        "libs/d5prj",
        "libs/f4prj",
        "libs/rpiprj"
    ],
    "compile": {
        "useUF2": true,
        "deployDrives": ".*",
        "deployFileMarker": "INFO_UF2.TXT",
        "driveName": "ARCADE",
        "floatingPoint": true,
        "taggedInts": true,
        "nativeType": "thumb",
        "gc": true,
        "upgrades": [],
        "webUSB": true,
        "saveAsPNG": true,
        "patches": {
            "0.0.0 - *": [
                {
                    "type": "missingPackage",
                    "map": {
                        "(DigitalPin|AnalogPin|pins)\\.P\\d\\d?": "edge-connector",
                        "serial\\.": "serial"
                    }
                }
            ],
            "0.0.0 - 0.1.1": [
                {
                    "type": "api",
                    "map": {
                        "controller\\.controlSprite": "controller.moveSprite",
                        "controller\\.controlPlayer": "controller.movePlayer"
                    }
                }
            ],
            "0.0.0 - 0.3.23": [
                {
                    "type": "package",
                    "map": {
                        "local-multiplayer": ""
                    }
                }
            ],
            "0.0.0 - 0.3.24": [
                {
                    "type": "api",
                    "map": {
                        "sprites\\.createEmptySprite\\(([^)]+)\\)": "sprites.create(img`.`, $1)"
                    }
                },
                {
                    "type": "blockId",
                    "map": {
                        "keysdx": "keydx",
                        "keysdy": "keydy"
                    }
                }
            ],
            "0.0.0 - 0.11.20": [
                {
                    "type": "api",
                    "map": {
                        "SpriteKind": "SpriteKindLegacy"
                    }
                }
            ]
        },
        "switches": {},
        "jsRefCounting": false,
        "vtableShift": 2,
        "utf8": true
    },
    "compileService": {
        "buildEngine": "codal",
        "githubCorePackage": "lancaster-university/codal",
        "gittag": "v0.6.3",
        "dockerImage": "pext/yotta:latest",
        "codalTarget": {
            "branches": {}
        }
    },
    "variants": {
        "stm32f401": {
            "compile": {
                "hasHex": true,
                "openocdScript": "source [find interface/stlink-v2.cfg]; source [find target/stm32f4x.cfg]",
                "uf2Family": "0x57755a57",
                "vtableShift": 4
            },
            "compileService": {
                "codalTarget": {
                    "name": "codal-big-brainpad",
                    "url": "http://web.archive.org/web/20191229135125/https://github.com/lancaster-university/codal-big-brainpad",
                    "branch": "v1.1.3",
                    "type": "git"
                },
                "codalBinary": "STM32",
                "serviceId": "codal2stm32",
                "dockerImage": "pext/yotta:latest"
            }
        },
        "samd51": {
            "compile": {
                "hasHex": true,
                "openocdScript": "source [find interface/cmsis-dap.cfg]; set CHIPNAME at91samd51g19; source [find target/at91samdXX.cfg]",
                "openocdScriptAlt": "source [find interface/stlink-v2.cfg]; set CPUTAPID 0x2ba01477; set CHIPNAME at91samd51g19; source [find target/at91samdXX.cfg]",
                "ramSize": 196608,
                "flashEnd": 524288,
                "uf2Family": "0x55114460",
                "vtableShift": 4
            },
            "compileService": {
                "codalTarget": {
                    "name": "codal-itsybitsy-m4",
                    "url": "http://web.archive.org/web/20191229135125/https://github.com/lancaster-university/codal-itsybitsy-m4",
                    "branch": "v0.2.4",
                    "type": "git"
                },
                "codalBinary": "ITSYBITSY_M4",
                "serviceId": "codal2samd51",
                "dockerImage": "pext/yotta:latest"
            }
        },
        "rpi": {
            "compile": {
                "hasHex": true,
                "useELF": true,
                "runtimeIsARM": true,
                "vtableShift": 4,
                "flashCodeAlign": 256,
                "webUSB": false,
                "stackAlign": 2
            },
            "compileService": {
                "buildEngine": "dockermake",
                "dockerImage": "pext/rpi:alsa",
                "serviceId": "rpi"
            }
        },
        "vm": {
            "compile": {
                "hasHex": true,
                "useELF": true,
                "flashCodeAlign": 256,
                "webUSB": false,
                "nativeType": "vm",
                "stackAlign": 2
            },
            "compileService": {
                "buildEngine": "dockercross",
                "dockerImage": "pext/crossbuild",
                "serviceId": "crossbuild",
                "skipCloudBuild": true
            }
        }
    },
    "serial": {
        "useEditor": true,
        "log": true,
        "editorTheme": {
            "graphBackground": "#d9d9d9",
            "lineColors": [
                "#009DDC",
                "#FB48C7",
                "#40bf4a",
                "#8073E5",
                "#d25b33"
            ]
        }
    },
    "runtime": {
        "mathBlocks": true,
        "loopsBlocks": true,
        "logicBlocks": true,
        "variablesBlocks": true,
        "textBlocks": true,
        "functionBlocks": true,
        "functionsOptions": {
            "useNewFunctions": true,
            "extraFunctionEditorTypes": [
                {
                    "typeName": "Sprite",
                    "icon": "send",
                    "defaultName": "mySprite"
                }
            ]
        },
        "listsBlocks": true,
        "bannedCategories": [
            "pins",
            "control",
            "input",
            "serial",
            "power"
        ]
    },
    "simulator": {
        "autoRun": true,
        "autoRunLight": false,
        "emptyRunCode": "pxsim.pxtcore.updateScreen(new pxsim.RefImage(160, 120, 4))",
        "aspectRatio": 0.85,
        "dynamicBoardDefinition": true
    },
    "appTheme": {
        "logoUrl": "http://web.archive.org/web/20191229135125/https://github.com/Microsoft/pxt-arcade",
        "logo": "@cdnUrl@/blob/00e2af0edd17825c786b8cfc173695f51c598c72/static/logo.svg",
        "docsLogo": "@cdnUrl@/blob/00e2af0edd17825c786b8cfc173695f51c598c72/static/logo.svg",
        "portraitLogo": "@cdnUrl@/blob/00e2af0edd17825c786b8cfc173695f51c598c72/static/logo.svg",
        "footerLogo": "@cdnUrl@/blob/00e2af0edd17825c786b8cfc173695f51c598c72/static/logo.svg",
        "organization": "Microsoft MakeCode",
        "organizationUrl": "http://web.archive.org/web/20191229135125/https://makecode.com/org",
        "organizationLogo": "@cdnUrl@/blob/106597ae039a275897661651b96856220c9b0fad/static/Micorsoft_logo_rgb_W-white_D-square.png",
        "organizationWideLogo": "@cdnUrl@/blob/d6139e3d0af51f02aa5f8765ecb0985acbd98551/static/Micorsoft_logo_rgb_W-white_D.png",
        "homeUrl": "http://web.archive.org/web/20191229135125/https://arcade.makecode.com/",
        "embedUrl": "http://web.archive.org/web/20191229135125/https://arcade.makecode.com/",
        "privacyUrl": "http://web.archive.org/web/20191229135125/https://go.microsoft.com/fwlink/?LinkId=521839",
        "termsOfUseUrl": "http://web.archive.org/web/20191229135125/https://go.microsoft.com/fwlink/?LinkID=206977",
        "betaUrl": "http://web.archive.org/web/20191229135125/https://github.com/Microsoft/pxt-arcade",
        "githubUrl": "http://web.archive.org/web/20191229135125/https://github.com/Microsoft/pxt-arcade",
        "boardName": "Arcade",
        "addNewTypeScriptFile": true,
        "docMenu": [
            {
                "name": "Docs",
                "path": "/docs",
                "popout": true
            },
            {
                "name": "Hardware",
                "path": "/hardware",
                "popout": true
            },
            {
                "name": "Forum",
                "path": "http://web.archive.org/web/20191229135125/https://forum.makecode.com"
            }
        ],
        "coloredToolbox": true,
        "monacoToolbox": true,
        "selectLanguage": true,
        "availableLocales": [
            "en",
            "zh-CN",
            "zh-TW"
        ],
        "invertedMenu": true,
        "showHomeScreen": true,
        "highContrast": true,
        "greenScreen": true,
        "print": true,
        "hasAudio": true,
        "allowPackageExtensions": true,
        "homeScreenHero": "@cdnUrl@/blob/e5d3e905ec2357f3093544abbc006dc73c9e9a3e/static/hero.png",
        "socialOptions": {
            "orgTwitterHandle": "MSMakeCode",
            "hashtags": "MakeCode",
            "discourse": "http://web.archive.org/web/20191229135125/https://forum.makecode.com/",
            "discourseCategory": "Arcade"
        },
        "blocklyOptions": {
            "grid": {
                "spacing": 20,
                "length": 100,
                "colour": "rgba(107, 79, 118, 0.10)",
                "snap": true
            }
        },
        "blockColors": {
            "loops": "#20BF6B",
            "logic": "#45AAF2",
            "math": "#A55EEA",
            "variables": "#EC3B59",
            "text": "#F5D547",
            "arrays": "#FF8F08",
            "functions": "#1446A0"
        },
        "simAnimationEnter": "fly right in",
        "simAnimationExit": "fly right out",
        "crowdinProject": "kindscript",
        "monacoColors": {
            "editor.background": "#FFFAE7"
        },
        "monacoFieldEditors": [
            "image-editor"
        ],
        "scriptManager": true,
        "saveInMenu": false,
        "debugger": true,
        "importExtensionFiles": true,
        "experiments": [
            "python",
            "debugExtensionCode",
            "snippetBuilder",
            "simGif",
            "experimentalHw",
            "recipes"
        ],
        "extendEditor": true,
        "simScreenshot": true,
        "simScreenshotKey": "P",
        "simScreenshotMaxUriLength": 300000,
        "simGif": false,
        "simGifKey": "R",
        "qrCode": true,
        "shareFinishedTutorials": true,
        "nameProjectFirst": true,
        "TOC": [
            {
                "name": "About",
                "subitems": [],
                "path": "/about"
            },
            {
                "name": "FAQ",
                "subitems": [],
                "path": "/faq"
            },
            {
                "name": "Projects",
                "subitems": [],
                "path": "/projects"
            },
            {
                "name": "Reference",
                "subitems": [
                    {
                        "name": "sprites",
                        "subitems": [],
                        "path": "/reference/sprites"
                    },
                    {
                        "name": "controller",
                        "subitems": [],
                        "path": "/reference/controller"
                    },
                    {
                        "name": "game",
                        "subitems": [],
                        "path": "/reference/game"
                    },
                    {
                        "name": "music",
                        "subitems": [],
                        "path": "/reference/music"
                    },
                    {
                        "name": "scene",
                        "subitems": [],
                        "path": "/reference/scene"
                    },
                    {
                        "name": "info",
                        "subitems": [],
                        "path": "/reference/info"
                    },
                    {
                        "name": "images",
                        "subitems": [],
                        "path": "/reference/images"
                    }
                ],
                "path": "/reference"
            },
            {
                "name": "Blocks",
                "subitems": [
                    {
                        "name": "On Start",
                        "subitems": [],
                        "path": "/blocks/on-start"
                    },
                    {
                        "name": "Loops",
                        "subitems": [
                            {
                                "name": "repeat",
                                "subitems": [],
                                "path": "/blocks/loops/repeat"
                            },
                            {
                                "name": "for",
                                "subitems": [],
                                "path": "/blocks/loops/for"
                            },
                            {
                                "name": "while",
                                "subitems": [],
                                "path": "/blocks/loops/while"
                            },
                            {
                                "name": "for of",
                                "subitems": [],
                                "path": "/blocks/loops/for-of"
                            }
                        ],
                        "path": "/blocks/loops"
                    },
                    {
                        "name": "Logic",
                        "subitems": [
                            {
                                "name": "if",
                                "subitems": [],
                                "path": "/blocks/logic/if"
                            },
                            {
                                "name": "Boolean",
                                "subitems": [],
                                "path": "/blocks/logic/boolean"
                            }
                        ],
                        "path": "/blocks/logic"
                    },
                    {
                        "name": "Variables",
                        "subitems": [
                            {
                                "name": "assign",
                                "subitems": [],
                                "path": "/blocks/variables/assign"
                            },
                            {
                                "name": "change var",
                                "subitems": [],
                                "path": "/blocks/variables/change"
                            },
                            {
                                "name": "var",
                                "subitems": [],
                                "path": "/blocks/variables/var"
                            }
                        ],
                        "path": "/blocks/variables"
                    },
                    {
                        "name": "Math",
                        "subitems": [],
                        "path": "/blocks/math"
                    },
                    {
                        "name": "JavaScript blocks",
                        "subitems": [],
                        "path": "/blocks/javascript-blocks"
                    },
                    {
                        "name": "Custom blocks",
                        "subitems": [],
                        "path": "/blocks/custom"
                    }
                ],
                "path": "/blocks"
            },
            {
                "name": "JavaScript",
                "subitems": [
                    {
                        "name": "Calling",
                        "subitems": [],
                        "path": "/javascript/call"
                    },
                    {
                        "name": "Sequencing",
                        "subitems": [],
                        "path": "/javascript/sequence"
                    },
                    {
                        "name": "Variables",
                        "subitems": [],
                        "path": "/javascript/variables"
                    },
                    {
                        "name": "Operators",
                        "subitems": [],
                        "path": "/javascript/operators"
                    },
                    {
                        "name": "Statements",
                        "subitems": [],
                        "path": "/javascript/statements"
                    },
                    {
                        "name": "Functions",
                        "subitems": [],
                        "path": "/javascript/functions"
                    },
                    {
                        "name": "Types",
                        "subitems": [],
                        "path": "/javascript/types"
                    },
                    {
                        "name": "Classes",
                        "subitems": [],
                        "path": "/javascript/classes"
                    },
                    {
                        "name": "Interfaces",
                        "subitems": [],
                        "path": "/javascript/interfaces"
                    },
                    {
                        "name": "Generics",
                        "subitems": [],
                        "path": "/javascript/generics"
                    }
                ],
                "path": "/javascript"
            },
            {
                "name": "Types",
                "subitems": [
                    {
                        "name": "Number",
                        "subitems": [],
                        "path": "/types/number"
                    },
                    {
                        "name": "String",
                        "subitems": [],
                        "path": "/types/string"
                    },
                    {
                        "name": "Boolean",
                        "subitems": [],
                        "path": "/types/boolean"
                    },
                    {
                        "name": "Array",
                        "subitems": [],
                        "path": "/types/array"
                    },
                    {
                        "name": "Function",
                        "subitems": [],
                        "path": "/types/function"
                    },
                    {
                        "name": "Image",
                        "subitems": [],
                        "path": "/types/image"
                    },
                    {
                        "name": "Sprite",
                        "subitems": [],
                        "path": "/types/sprite"
                    }
                ],
                "path": "/types"
            },
            {
                "name": "Hardware",
                "subitems": [
                    {
                        "name": "Adding New Board",
                        "subitems": [],
                        "path": "/hardware/adding"
                    },
                    {
                        "name": "Debug connector",
                        "subitems": [],
                        "path": "/hardware/dbg"
                    }
                ],
                "path": "/hardware"
            },
            {
                "name": "",
                "subitems": [
                    {
                        "name": "About",
                        "subitems": [],
                        "path": "/about"
                    },
                    {
                        "name": "Support",
                        "subitems": [],
                        "path": "/support"
                    },
                    {
                        "name": "Translate",
                        "subitems": [],
                        "path": "/translate"
                    },
                    {
                        "name": "Sharing projects",
                        "subitems": [],
                        "path": "/share"
                    },
                    {
                        "name": "Offline support",
                        "subitems": [],
                        "path": "/offline"
                    },
                    {
                        "name": "Save",
                        "subitems": [],
                        "path": "/save"
                    }
                ]
            },
            {
                "name": "",
                "subitems": [
                    {
                        "name": "Command Line Interface",
                        "subitems": [],
                        "path": "/cli"
                    },
                    {
                        "name": "Visual Studio Code support",
                        "subitems": [],
                        "path": "/code"
                    },
                    {
                        "name": "Blocks Embed",
                        "subitems": [],
                        "path": "/blocks-embed"
                    }
                ]
            },
            {
                "name": "Lessons",
                "subitems": [
                    {
                        "name": "Cherry Pickr",
                        "subitems": [],
                        "path": "/lessons/cherry-pickr"
                    },
                    {
                        "name": "Barrel Dodger",
                        "subitems": [],
                        "path": "/lessons/barrel-dodger"
                    },
                    {
                        "name": "Dance Party",
                        "subitems": [],
                        "path": "/lessons/dance-party"
                    },
                    {
                        "name": "BlockOut",
                        "subitems": [],
                        "path": "/lessons/block-out"
                    }
                ],
                "path": "/lessons"
            },
            {
                "name": "Courses",
                "subitems": [
                    {
                        "name": "CS Intro 1",
                        "subitems": [],
                        "path": "/courses/csintro1"
                    },
                    {
                        "name": "CS Intro 2",
                        "subitems": [],
                        "path": "/courses/csintro2"
                    },
                    {
                        "name": "CS Intro 3",
                        "subitems": [],
                        "path": "/courses/csintro3"
                    }
                ],
                "path": "/courses"
            }
        ],
        "id": "arcade",
        "title": "Microsoft MakeCode Arcade",
        "name": "arcade",
        "description": "Develop your programming skills by quickly creating and modding retro arcade games with Blocks and JavaScript in the MakeCode editor",
        "htmlDocIncludes": {}
    },
    "unsupportedBrowsers": [
        {
            "id": "ie"
        }
    ],
    "versions": {
        "branch": "v0.14.9",
        "tag": "v0.14.9",
        "commits": "http://web.archive.org/web/20191229135125/https://github.com/microsoft/pxt-arcade/commits/aef4a4d5453f6bde5ba4cc774ed94f146deb6d68",
        "target": "0.14.9",
        "pxt": "5.21.14"
    },
    "blocksprj": {
        "id": "blocksprj",
        "config": {
            "name": "{0}",
            "dependencies": {
                "device": "*"
            },
            "description": "",
            "files": [
                "main.blocks",
                "main.ts",
                "README.md"
            ],
            "additionalFilePaths": []
        },
        "files": {
            "README.md": " ",
            "main.blocks": "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>",
            "main.ts": " "
        }
    },
    "tsprj": {
        "id": "tsprj",
        "config": {
            "name": "{0}",
            "dependencies": {
                "device": "*"
            },
            "description": "",
            "files": [
                "main.ts",
                "README.md"
            ],
            "additionalFilePaths": []
        },
        "files": {
            "README.md": " ",
            "main.ts": " "
        }
    },
    "bundledpkgs": {
        "animation": {
            "README.md": "# Animations\n\nA small animation library.",
            "animation.ts": "/*\n    Animation library for sprites\n*/\n//% color=\"#03AA74\" weight=78 icon=\"\\uf021\" block=\"Animation\"\n//% groups='[\"Animate\", \"Legacy\"]'\nnamespace animation {\n    const stateNamespace = \"__animation\";\n\n    interface AnimationState {\n        animations: SpriteAnimation[];\n    }\n\n    export class Point {\n        public x: number;\n        public y: number;\n        \n        constructor(x: number, y: number) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    //% fixedInstances blockId=animation_path block=\"path %pathString\"\n    export class PathPreset {\n        constructor(public pathString: string) {\n        }\n    }\n\n    export class Path {\n        protected nodes: PathNode[];\n        protected lastNode: number; // The index of the last node to fire\n\n        constructor() {\n            this.nodes = [];\n            this.lastNode = -1;\n        }\n\n        private static generateNode(p0: Point, command: string, args: number[], metadata: [ Point, PathNode ]): PathNode {\n            const [ pathStart, lastNode ] = metadata;\n            let node: PathNode;\n            switch (command) {\n                case \"M\": { // M x y\n                    const p1 = new Point(args[0], args[1]);\n                    node = new MoveTo(p1);\n                    break;\n                }\n                case \"m\": { // m dx dy\n                    const p1 = new Point(p0.x + args[0], p0.y + args[1]);\n                    node = new MoveTo(p1);\n                    break;\n                }\n                case \"L\": { // L x y\n                    const p1 = new Point(args[0], args[1]);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"l\": { // l dx dy\n                    const p1 = new Point(p0.x + args[0], p0.y + args[1]);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"H\": { // H x\n                    const p1 = new Point(args[0], p0.y);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"h\": { // h dx\n                    const p1 = new Point(p0.x + args[0], p0.y);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"V\": { // V y\n                    const p1 = new Point(p0.x, args[0]);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"v\": { // v dy\n                    const p1 = new Point(p0.x, p0.y + args[0]);\n                    node = new LineTo(p0, p1);\n                    break;\n                }\n                case \"Q\": { // Q x1 y1 x2 y2\n                    const p1 = new Point(args[0], args[1]);\n                    const p2 = new Point(args[2], args[3]);\n                    node = new QuadraticCurveTo(p0, p1, p2);\n                    break;\n                }\n                case \"q\": { // q dx1 dy1 dx2 dy2\n                    const p1 = new Point(p0.x + args[0], p0.y + args[1]);\n                    const p2 = new Point(p0.x + args[2], p0.y + args[3]);\n                    node = new QuadraticCurveTo(p0, p1, p2);\n                    break;\n                }\n                case \"T\": { // T x2 y2\n                    let lastControlPoint: Point = lastNode.getLastControlPoint();\n                    if (!lastControlPoint) break;\n\n                    const p1 = new Point(p0.x + (p0.x - lastControlPoint.x), p0.y + (p0.y - lastControlPoint.y));\n                    const p2 = new Point(args[0], args[1]);\n                    node = new QuadraticCurveTo(p0, p1, p2);\n                    break;\n                }\n                case \"t\": { // t dx2 dy2\n                    let lastControlPoint: Point = lastNode.getLastControlPoint();\n                    if (!lastControlPoint) break;\n\n                    const p1 = new Point(p0.x + (p0.x - lastControlPoint.x), p0.y + (p0.y - lastControlPoint.y));\n                    const p2 = new Point(p0.x + args[0], p0.y + args[1]);\n                    node = new QuadraticCurveTo(p0, p1, p2);\n                    break;\n                }\n                case \"C\": { // C x1 y1 x2 y2 x3 y3\n                    const p1 = new Point(args[0], args[1]);\n                    const p2 = new Point(args[2], args[3]);\n                    const p3 = new Point(args[4], args[5]);\n                    node = new CubicCurveTo(p0, p1, p2, p3);\n                    break;\n                }\n                case \"c\": { // c dx1 dy1 dx2 dy2 dx3 dy3\n                    const p1 = new Point(p0.x + args[0], p0.y + args[1]);\n                    const p2 = new Point(p0.x + args[2], p0.y + args[3]);\n                    const p3 = new Point(p0.x + args[4], p0.y + args[5]);\n                    node = new CubicCurveTo(p0, p1, p2, p3);\n                    break;\n                }\n                case \"S\": { // S x2 y2 x3 y3\n                    let lastControlPoint: Point = lastNode.getLastControlPoint();\n                    if (!lastControlPoint) break;\n\n                    const p1 = new Point(p0.x + (p0.x - lastControlPoint.x), p0.y + (p0.y - lastControlPoint.y));\n                    const p2 = new Point(args[0], args[1]);\n                    const p3 = new Point(args[2], args[3]);\n                    node = new CubicCurveTo(p0, p1, p2, p3);\n                    break;\n                }\n                case \"s\": { // s dx2 dy2 dx3 dy3\n                    let lastControlPoint: Point = lastNode.getLastControlPoint();\n                    if (!lastControlPoint) break;\n\n                    const p1 = new Point(p0.x + (p0.x - lastControlPoint.x), p0.y + (p0.y - lastControlPoint.y));\n                    const p2 = new Point(p0.x + args[0], p0.y + args[1]);\n                    const p3 = new Point(p0.x + args[2], p0.y + args[3]);\n                    node = new CubicCurveTo(p0, p1, p2, p3);\n                    break;\n                }\n                case \"Z\": // Z\n                case \"z\": { // z\n                    node = new LineTo(p0, pathStart);\n                    break;\n                }\n            }\n\n            return node;\n        }\n\n        private static commandToArgCount(command: string): number {\n            switch (command) {\n                case \"M\": // moveTo\n                case \"m\":\n                    return 2;\n                case \"L\": // lineTo\n                case \"l\":\n                    return 2;\n                case \"H\": // horizontalLineTo\n                case \"h\":\n                    return 1;\n                case \"V\": // verticalLineTo\n                case \"v\":\n                    return 1;\n                case \"Q\": // quadraticCurveTo\n                case \"q\":\n                    return 4;\n                case \"T\": // smoothQuadraticCurveTo\n                case \"t\":\n                    return 2;\n                case \"C\": // cubicCurveTo\n                case \"c\":\n                    return 6;\n                case \"S\": // smoothCubicCurveTo\n                case \"s\":\n                    return 4;\n                case \"A\": // arcTo\n                case \"a\":\n                    return 7;\n                case \"Z\": // closePath\n                case \"z\":\n                    return 0;\n                default:\n                    return -1;\n            }\n        }\n\n        public static parse(pathStart: Point, pathString: string): Path {\n            let path: Path = new Path();\n            let p0: Point = pathStart;\n\n            // This implementation of SVG parsing does not support the A/a commands, nor does it support exponents in arguments\n            const digits = \"0123456789\";\n            const separators = \", \\t\\n\\r\\f\\v\";\n            const signs = \"+-\";\n\n            let currentArg: string = \"\";\n            let command: string = null;\n            let args: number[] = [];\n\n            for (let i = 0; i < pathString.length; i++) {\n                const char = pathString.charAt(i);\n                const lastNode = path.nodes[path.nodes.length - 1];\n                \n                // This is an SVG path parser. It's kinda complicated. For each character, evaluate the following conditions:\n                // - if it's a digit, add it to the current argument\n                // - else if it's whitespace or newline, finish the current argument and prepare for the next one\n                // - else if it's a command, complete the previous argument, and prepare for the next one\n                //   - if there's sufficient data to make a node during this step, create it and continue\n                // - else if it's a plus/minus sign, and if it's the start of a new argument, add it to allow for positive/negative numbers\n                // - if it's the end of the string, complete the current argument before proceeding to the next step\n                // - if there's sufficient data to make a node after all of these steps, create it\n                if (digits.indexOf(char) > -1) { // Parses number arguments\n                    currentArg += char;\n                } else if (separators.indexOf(char) > -1 && currentArg) { // Terminates number arguments\n                    args.push(parseInt(currentArg));\n                    currentArg = \"\";\n                } else if (this.commandToArgCount(char) > -1) { // Parses command arguments\n                    if (command && currentArg) {\n                        args.push(parseInt(currentArg));\n                        \n                        // Try to finish up this node, otherwise just toss it out\n                        if (command && args.length >= this.commandToArgCount(command)) {\n                            let node: PathNode = this.generateNode(p0, command, args, [\n                                pathStart,\n                                lastNode\n                            ]);\n                            path.add(node);\n                            p0 = node.getEndPoint(); // Set the start for the next node to the end of this node\n                            if (node.setStart) pathStart = p0; // If this is a move command, then this sets the new start of the path (for the Z/z command)\n                        }\n                        \n                        // Clean up before continuing\n                        command = \"\";\n                        args = [];\n                        currentArg = \"\";\n                    }\n                    command = char;\n                } else if (signs.indexOf(char) > -1) { // Allows for positive/negative values\n                    if (currentArg) {\n                        args.push(parseInt(currentArg));\n                        currentArg = \"\";\n                    }\n                    currentArg = char;\n                }\n\n                // If the end of the path has been reached, cleans up the last argument before continuing parsing\n                if (i === pathString.length - 1) {\n                    if (currentArg) {\n                        args.push(parseInt(currentArg));\n                    }\n                }\n                \n                // If the command has a sufficient amount of arguments, then create a node for it\n                if (command && args.length >= this.commandToArgCount(command)) {\n                    // Generate the node\n                    let node: PathNode = this.generateNode(p0, command, args, [\n                        pathStart,\n                        lastNode\n                    ]);\n                    path.add(node);\n                    p0 = node.getEndPoint();\n                    if (node.setStart) pathStart = p0;\n                    \n                    // Reset and prepare for the next command\n                    command = \"\";\n                    args = [];\n                    currentArg = \"\";\n                }\n            }\n\n            return path;\n        }\n\n        public add(node: PathNode) {\n            this.nodes.push(node);\n        }\n\n        get length(): number {\n            return this.nodes.length;\n        }\n\n        public run(interval: number, target: Sprite, startedAt: number): boolean {\n            const runningTime = control.millis() - startedAt; // The time since the start of the path\n            const nodeIndex = Math.floor(runningTime / interval); // The current node\n            const nodeTime = runningTime % interval; // The time the current node has been animating\n            \n            if (this.lastNode > -1 && this.lastNode < nodeIndex && this.nodes.length) { // If the last node hasn't been completed yet\n                this.nodes[this.lastNode].apply(target, interval, interval); // Applies the last state of the previous node in case it was missed (this makes sure all moveTos fire)\n\n                if (nodeIndex >= this.nodes.length) return true; // Once the nodeIndex is past the last item of the array, only then end the animation\n            }\n            this.lastNode = nodeIndex;\n\n            this.nodes[nodeIndex].apply(target, nodeTime, interval);\n            return false;\n        }\n    }\n\n    export abstract class PathNode {\n        setStart: boolean;\n        constructor() {\n            this.setStart = false;\n        }\n\n        apply(target: Sprite, nodeTime: number, interval: number) {};\n        \n        getLastControlPoint(): Point {\n            return null;\n        };\n\n        getEndPoint(): Point {\n            return null;\n        };\n    }\n\n    export class MoveTo extends PathNode {\n        constructor(public p1: Point) {\n            super();\n\n            this.setStart = true;\n        }\n\n        apply(target: Sprite, nodeTime: number, interval: number) {\n            nodeTime >= interval && target.setPosition(this.p1.x, this.p1.y);\n        }\n\n        getEndPoint(): Point {\n            return this.p1;\n        }\n    }\n\n    export class LineTo extends PathNode {\n        constructor(public p0: Point, public p1: Point) {\n            super();\n        }\n\n        apply(target: Sprite, nodeTime: number, interval: number) {\n            const x = Math.round(((this.p1.x - this.p0.x) / interval) * nodeTime) + this.p0.x;\n            const y = Math.round(((this.p1.y - this.p0.y) / interval) * nodeTime) + this.p0.y;\n\n            target.setPosition(x, y);\n        }\n\n        getEndPoint(): Point {\n            return this.p1;\n        }\n    }\n\n    export class QuadraticCurveTo extends PathNode {\n        constructor(public p0: Point, public p1: Point, public p2: Point) {\n            super();\n        }\n\n        apply(target: Sprite, nodeTime: number, interval: number) {\n            const progress = nodeTime / interval;\n            const diff = 1 - progress;\n            const a = Math.pow(diff, 2);\n            const b = 2 * diff * progress;\n            const c = Math.pow(progress, 2);\n\n            const x = Math.round(a * this.p0.x + b * this.p1.x + c * this.p2.x);\n            const y = Math.round(a * this.p0.y + b * this.p1.y + c * this.p2.y);\n\n            target.setPosition(x, y);\n        }\n\n        getLastControlPoint(): Point {\n            return this.p1;\n        }\n\n        getEndPoint(): Point {\n            return this.p2;\n        }\n    }\n\n    export class CubicCurveTo extends PathNode {\n        constructor(public p0: Point, public p1: Point, public p2: Point, public p3: Point) {\n            super();\n        }\n\n        apply(target: Sprite, nodeTime: number, interval: number) {\n            const progress = nodeTime / interval;\n            const diff = 1 - progress;\n            const a = Math.pow(diff, 3);\n            const b = 3 * Math.pow(diff, 2) * progress;\n            const c = 3 * diff * Math.pow(progress, 2);\n            const d = Math.pow(progress, 3);\n\n            const x = Math.round(a * this.p0.x + b * this.p1.x + c * this.p2.x + d * this.p3.x);\n            const y = Math.round(a * this.p0.y + b * this.p1.y + c * this.p2.y + d * this.p3.y);\n\n            target.setPosition(x, y);\n        }\n\n        getLastControlPoint(): Point {\n            return this.p2;\n        }\n\n        getEndPoint(): Point {\n            return this.p3;\n        }\n    }\n\n    export abstract class SpriteAnimation {\n        protected startedAt: number;\n\n        constructor(public sprite: Sprite, protected loop: boolean) {\n        }\n\n        public init() {\n            let state: AnimationState = game.currentScene().data[stateNamespace];\n\n            // Register animation updates to fire when frames are rendered\n            if (!state) {\n                state = game.currentScene().data[stateNamespace] = {\n                    animations: []\n                } as AnimationState;\n\n                game.eventContext().registerFrameHandler(scene.ANIMATION_UPDATE_PRIORITY, () => {\n                    state.animations = state.animations.filter((anim: SpriteAnimation) => {\n                        return !anim.update(); // If update returns true, the animation is done and will be removed\n                    });\n                });\n            }\n\n            // Remove any other animations of this type and attached to this sprite\n            state.animations = state.animations.filter((anim: SpriteAnimation) => {\n                return !(anim.sprite === this.sprite &&\n                    ((anim instanceof ImageAnimation && this instanceof ImageAnimation) ||\n                    (anim instanceof MovementAnimation && this instanceof MovementAnimation)));\n            });\n\n            state.animations.push(this);\n        }\n\n        public update(): boolean {\n            // This should be implemented by subclasses\n            return false;\n        }\n    }\n\n    export class ImageAnimation extends SpriteAnimation {\n        private lastFrame: number;\n\n        constructor(sprite: Sprite, private frames: Image[], private frameInterval: number, loop?: boolean) {\n            super(sprite, loop);\n\n            this.lastFrame = -1;\n        }\n\n        public update(): boolean {\n            if (this.sprite.flags & sprites.Flag.Destroyed) return true;\n\n            if (this.startedAt == null) this.startedAt = control.millis();\n            const runningTime = control.millis() - this.startedAt;\n            const frameIndex = Math.floor(runningTime / this.frameInterval);\n\n            if (this.lastFrame > -1 && this.lastFrame < frameIndex && this.frames.length) { // Applies the first frame after the first interval has passed\n                const newImage = this.frames[frameIndex - 1];\n                if (this.sprite.image !== newImage) {\n                    this.sprite.setImage(newImage);\n                }\n\n                if (frameIndex >= this.frames.length) {\n                    if (!this.loop) return true;\n                    this.startedAt = control.millis();\n                }\n            }\n            this.lastFrame = frameIndex;\n            return false;\n        }\n    }\n\n    export class MovementAnimation extends SpriteAnimation {\n        constructor(sprite: Sprite, private path: Path, private nodeInterval: number, loop?: boolean) {\n            super(sprite, loop);\n\n            this.loop = loop;\n        }\n        \n        public update(): boolean {\n            if (this.sprite.flags & sprites.Flag.Destroyed) return true;\n            \n            if (this.startedAt == null) this.startedAt = control.millis();\n            \n            let result = this.path.run(this.nodeInterval, this.sprite, this.startedAt);\n            if (result) {\n                if (!this.loop) return true;\n                this.startedAt = control.millis();\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Create and run an image animation on a sprite\n     * @param frames the frames to animate through\n     * @param sprite the sprite to animate on\n     * @param frameInterval the time between changes, eg: 500\n     */\n    //% blockId=run_image_animation\n    //% block=\"animate $sprite=variables_get(mySprite) frames $frames=lists_create_with interval (ms) $frameInterval=timePicker loop $loop=toggleOnOff\"\n    //% frames.defl=screen_image_picker\n    //% group=\"Animate\"\n    export function runImageAnimation(sprite: Sprite, frames: Image[], frameInterval?: number, loop?: boolean) {\n        const anim = new ImageAnimation(sprite, frames, frameInterval || 500, !!loop);\n        anim.init();\n    }\n\n    /**\n     * Create and run a movement animation on a sprite\n     * @param sprite the sprite to move\n     * @param pathString the SVG path to animate\n     * @param duration how long the animation should play for, eg: 500\n     */\n    //% blockId=run_movement_animation\n    //% block=\"animate $sprite=variables_get(mySprite) with $pathString=animation_path for (ms) $duration=timePicker loop $loop=toggleOnOff\"\n    //% duration.defl=2000\n    //% group=\"Animate\"\n    export function runMovementAnimation(sprite: Sprite, pathString: string, duration?: number, loop?: boolean) {\n        const path = Path.parse(new Point(sprite.x, sprite.y), pathString);\n        const anim = new MovementAnimation(sprite, path, duration / path.length, !!loop);\n        anim.init();\n    }\n    \n    export enum AnimationTypes {\n        //% block=\"all\"\n        All,\n        //% block=\"frame\"\n        ImageAnimation,\n        //% block=\"path\"\n        MovementAnimation\n    }\n    \n    /**\n     * Stops all animations (simple and looping) of the specified type on a sprite\n     * @param type the animation type to stop\n     * @param sprite the sprite to filter animations by\n     */\n    //% blockId=stop_animations\n    //% block=\"stop %type animations on %sprite=variables_get(mySprite)\"\n    //% group=\"Animate\"\n    export function stopAnimation(type: AnimationTypes, sprite: Sprite) {\n        let state: AnimationState = game.currentScene().data[stateNamespace];\n        if (state && state.animations) {\n            state.animations = state.animations.filter((anim: SpriteAnimation) => {\n                if (anim.sprite === sprite) {\n                    switch (type) {\n                        case AnimationTypes.ImageAnimation:\n                            if (anim instanceof ImageAnimation) return false;\n                            break;\n                        case AnimationTypes.MovementAnimation:\n                            if (anim instanceof MovementAnimation) return false;\n                            break;\n                        case AnimationTypes.All:\n                            return false;\n                    }\n                }\n                return true;\n            });\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"fly to center\"\n    export const flyToCenter = new PathPreset(\"L 80 60\");\n    \n    //% fixedInstance whenUsed block=\"shake\"\n    export const shake = new PathPreset(\"m 4 -1 m 1 2 m -6 2 m -4 -8 m 8 8 m 2 -4 m -8 0 m 6 3 m -3 -2\");\n\n    //% fixedInstance whenUsed block=\"bounce (right)\"\n    export const bounceRight = new PathPreset(\"q 7 0 15 40 q 10 -30 15 -25 q 10 5 15 25 q 5 -25 10 0 q 4 -15 8 0 q 2 -10 4 0 q 1 -5 1 0 q 0 -2 1 0\");\n\n    //% fixedInstance whenUsed block=\"bounce (left)\"\n    export const bounceLeft = new PathPreset(\"q -7 0 -15 40 q -10 -30 -15 -25 q -10 5 -15 25 q -5 -25 -10 0 q -4 -15 -8 0 q -2 -10 -4 0 q -1 -5 -1 0 q 0 -2 -1 0\");\n\n    //% fixedInstance whenUsed block=\"parachute (right)\"\n    export const parachuteRight = new PathPreset(\"q 20 10 40 5 q 2 -2 0 0 q -15 10 -30 5 q -2 -2 0 0 q 10 10 20 5 q 2 -2 0 0 q -5 5 -10 3 q -1 -1 0 0 q 2 2 5 1 l 0 2 l 0 2 l 0 2\");\n\n    //% fixedInstance whenUsed block=\"parachute (left)\"\n    export const parachuteLeft = new PathPreset(\"q -20 10 -40 5 q -2 -2 0 0 q 15 10 30 5 q 2 -2 0 0 q -10 10 -20 5 q -2 -2 0 0 q 5 5 10 3 q 1 -1 0 0 q -2 2 -5 1 l 0 2 l 0 2 l 0 2\");\n\n    //% fixedInstance whenUsed block=\"ease (right)\"\n    export const easeRight = new PathPreset(\"h 5 h 10 h 20 h 30 h 20 h 10 h 5\");\n\n    //% fixedInstance whenUsed block=\"ease (left)\"\n    export const easeLeft = new PathPreset(\"h -5 h -10 h -20 h -30 h -20 h -10 h -5\");\n\n    //% fixedInstance whenUsed block=\"ease (down)\"\n    export const easeDown = new PathPreset(\"v 5 v 10 v 20 v 30 v 20 v 10 v 5\");\n\n    //% fixedInstance whenUsed block=\"ease (up)\"\n    export const easeUp = new PathPreset(\"v -5 v -10 v -20 v -30 v -20 v -10 v -5\");\n\n    //% fixedInstance whenUsed block=\"wave (right)\"\n    export const waveRight = new PathPreset(\"c 25 -15 15 -5 20 0\");\n\n    //% fixedInstance whenUsed block=\"wave (left)\"\n    export const waveLeft = new PathPreset(\"c -25 -15 -15 -5 -20 0\");\n\n    //% fixedInstance whenUsed block=\"bobbing (in place)\"\n    export const bobbing = new PathPreset(\"c 0 -20 0 20 0 0\");\n\n    //% fixedInstance whenUsed block=\"bobbing (right)\"\n    export const bobbingRight = new PathPreset(\"c 5 -20 15 20 20 0\");\n\n    //% fixedInstance whenUsed block=\"bobbing (left)\"\n    export const bobbingLeft = new PathPreset(\"c -5 -20 -15 20 -20 0\");\n\n    /**\n     * Generates a path string for preset animation\n     * @param animationPath The preset path\n     */\n    //% blockId=animation_path\n    //% block=\"%animationPath\"\n    //% group=\"Animate\"\n    //% blockHidden=1\n    export function animationPresets(animationPath: PathPreset) {\n        return animationPath.pathString;\n    }\n}\n",
            "legacy.ts": "/*\n    Animation library for sprites\n*/\nnamespace animation {\n    //Handles all the updates\n    let animations: Animation[];\n\n    let animationStateStack: {\n        state: Animation[],\n        scene: scene.Scene\n    }[];\n\n    game.addScenePushHandler(oldScene => {\n        if (animations) {\n            if (!animationStateStack) animationStateStack = [];\n            animationStateStack.push({\n                state: animations,\n                scene: oldScene\n            });\n            animations = undefined;\n        }\n    });\n\n    game.addScenePopHandler(() => {\n        const scene = game.currentScene();\n        animations = undefined;\n        if (animationStateStack && animationStateStack.length) {\n            const nextState = animationStateStack.pop();\n            if (nextState.scene == scene) {\n                animations = nextState.state;\n            } else {\n                animationStateStack.push(nextState);\n            }\n        }\n    });\n\n    export class Animation {\n\n        sprites: Sprite[];\n        frames: Image[];\n        index: number;\n        interval: number;\n        action: number;\n        lastTime: number;\n\n        constructor(action: number, interval: number) {\n            this.interval = interval;\n            this.index = -1;\n            this.action = action;\n            this.frames = [];\n            this.sprites = [];\n            this.lastTime = control.millis();\n\n            this._init();\n        }\n\n        _init() {\n            if (!animations) {\n                animations = [];\n                game.eventContext().registerFrameHandler(scene.ANIMATION_UPDATE_PRIORITY, () => {\n                    animations.forEach(anim => anim.update());\n                });\n            }\n            animations.push(this);\n        }\n\n        update() {\n            let currentTime = control.millis();\n            let dt = currentTime - this.lastTime;\n            if (dt >= this.interval && this.frames.length) {\n                this.index = (this.index + 1) % this.frames.length;\n                this.lastTime = currentTime;\n            }\n            \n            this.sprites = this.sprites.filter(sprite => !(sprite.flags & sprites.Flag.Destroyed));\n\n            this.sprites.forEach(sprite => {\n                if (sprite._action === this.action) {\n                    let newImage = this.getImage();\n                    //Update only if the image has changed\n                    if (sprite.image !== newImage) {\n                        sprite.setImage(newImage);\n                    }\n                }\n            });\n        }\n\n        getImage() {\n            return this.frames[this.index];\n        }\n\n        getAction() {\n            return this.action;\n        }\n\n        getInterval() {\n            return this.interval;\n        }\n\n        setInterval(interval: number) {\n            this.interval = interval;\n        }\n\n        /**\n        * Add an image frame to an animation\n        */\n        //% blockId=addAnimationFrame\n        //% block=\"add frame $frame=screen_image_picker to $this=variables_get(anim)\"\n        //% group=\"Legacy\"\n        //% weight=40\n        //% help=animation/add-animation\n        addAnimationFrame(frame: Image) {\n            this.frames[++this.index] = frame;\n        }\n\n        registerSprite(sprite: Sprite) {\n            if (this.sprites.indexOf(sprite) === -1) {\n                this.sprites.push(sprite);\n            }\n        }\n\n    }\n\n    //% shim=ENUM_GET\n    //% blockId=action_enum_shim\n    //% block=\"%arg\"\n    //% group=\"Legacy\"\n    //% enumName=\"ActionKind\"\n    //% enumMemberName=\"action\"\n    //% enumPromptHint=\"e.g. Walking, Idle, Jumping, ...\"\n    //% enumInitialMembers=\"Walking, Idle, Jumping\"\n    //% weight=10\n    export function _actionEnumShim(arg: number) {\n        // This function should do nothing, but must take in a single\n        // argument of type number and return a number value.\n        return arg;\n    }\n\n    /**\n     * Create an animation\n     */\n    //% blockId=createAnimation\n    //% block=\"create animation of $action=action_enum_shim with interval $interval ms\"\n    //% group=\"Legacy\"\n    //% interval.defl=1000\n    //% blockSetVariable=\"anim\"\n    //% weight=50\n    //% help=animation/create-animation\n    export function createAnimation(action: number, interval: number) {\n        return new Animation(action, interval);\n    }\n\n    /**\n     * Attach an animation to a sprite\n     */\n    //% blockId=attachAnimation\n    //% block=\"attach animation $set=variables_get(anim) to sprite $sprite=variables_get(mySprite)\"\n    //% group=\"Legacy\"\n    //% weight=30\n    //% help=animation/attach-animation\n    export function attachAnimation(sprite: Sprite, set: Animation) {\n        set.registerSprite(sprite);\n    }\n\n    /**\n     * Set an animation action to a sprite\n     */\n    //% blockId=setAction\n    //% block=\"activate animation $action=action_enum_shim on $sprite=variables_get(mySprite)\"\n    //% group=\"Legacy\"\n    //% weight=20\n    //% help=animation/set-action\n    export function setAction(sprite: Sprite, action: number) {\n        sprite._action = action;\n    }\n\n}",
            "pxt.json": "{\n  \"weight\": 80,\n  \"name\": \"animation\",\n  \"description\": \"An animation library for sprite\",\n  \"files\": [\n    \"README.md\",\n    \"animation.ts\",\n    \"legacy.ts\",\n    \"targetoverrides.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/8f60e7cc5fe821f515d939fdc1d5a0212bcb30e6/static/libs/animation.png\"\n}",
            "targetoverrides.ts": "// TODO any platform specific overrides",
            "test.ts": "let mySprite: Sprite = sprites.create(img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `, SpriteKind.Player);\nanimation.runImageAnimation(\n    mySprite,\n    [img`\n    1 . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `,\n    img`\n    2 . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `],\n    500\n)\nanimation.runMovementAnimation(\n    mySprite,\n    animation.animationPresets(animation.flyToCenter),\n    500\n)\nanimation.runImageAnimation(\n    mySprite,\n    [img`\n    1 . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `,\n    img`\n    2 . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `],\n    500,\n    true\n)\nanimation.runMovementAnimation(\n    mySprite,\n    animation.animationPresets(animation.flyToCenter),\n    500\n)"
        },
        "accelerometer": {
            "README.md": "# accelerometer\n\nThe accelerometer library.\n\n",
            "accelerometer.cpp": "#include \"pxt.h\"\n#include \"axis.h\"\n#include \"Pin.h\"\n#include \"I2C.h\"\n#include \"CoordinateSystem.h\"\n#include \"Accelerometer.h\"\n\nenum class Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n};\n\nenum class Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n};\n\nenum class AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8\n};\n\nenum class Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = ACCELEROMETER_EVT_SHAKE,\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = ACCELEROMETER_EVT_TILT_UP,\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = ACCELEROMETER_EVT_TILT_DOWN,\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = ACCELEROMETER_EVT_TILT_LEFT,\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = ACCELEROMETER_EVT_TILT_RIGHT,\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = ACCELEROMETER_EVT_FACE_UP,\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = ACCELEROMETER_EVT_FACE_DOWN,\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = ACCELEROMETER_EVT_FREEFALL,\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = ACCELEROMETER_EVT_2G,\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = ACCELEROMETER_EVT_3G,\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = ACCELEROMETER_EVT_6G,\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = ACCELEROMETER_EVT_8G\n};\n\n// defined in accelhw.cpp\nnamespace pxt {\ncodal::Accelerometer *getAccelerometer();\n\nvoid initAccelRandom() {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    for (int i = 0; i < 10; ++i) {\n        acc->requestUpdate();\n        if (acc->getY())\n            break;\n        fiber_sleep(5);\n    }\n    int x = acc->getX(), y = acc->getY(), z = acc->getZ();\n    DMESG(\"random seed from accel %d,%d,%d\", x, y, z);\n    seedAddRandom(x);\n    seedAddRandom(y);\n    seedAddRandom(z);\n}\n\n} // namespace pxt\n\nnamespace input {\n/**\n * Do something when a gesture happens (like shaking the board).\n * @param gesture the type of gesture to track, eg: Gesture.Shake\n * @param body code to run when gesture is raised\n */\n//% help=input/on-gesture\n//% blockId=device_gesture_event block=\"on |%NAME\"\n//% parts=\"accelerometer\"\n//% gesture.fieldEditor=\"gridpicker\"\n//% gesture.fieldOptions.width=220\n//% gesture.fieldOptions.columns=3\n//% weight=92 blockGap=12\nvoid onGesture(Gesture gesture, Action body) {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    acc->requestUpdate();\n    int gi = (int)gesture;\n    if (gi == ACCELEROMETER_EVT_3G && acc->getRange() < 3)\n        acc->setRange(4);\n    else if ((gi == ACCELEROMETER_EVT_6G || gi == ACCELEROMETER_EVT_8G) && acc->getRange() < 6)\n        acc->setRange(8);\n    registerWithDal(DEVICE_ID_GESTURE, gi, body);\n}\n\n/**\n * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n * x=0, y=0 and z=-1023)\n * @param dimension TODO\n */\n//% help=input/acceleration\n//% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n//% parts=\"accelerometer\"\n//% dimension.fieldEditor=\"gridpicker\"\n//% dimension.fieldOptions.width=180\n//% dimension.fieldOptions.columns=2\n//% weight=42 blockGap=8\nint acceleration(Dimension dimension) {\n    auto acc = getAccelerometer();\n    if (!acc) return 0;\n\n    acc->requestUpdate();\n    switch (dimension) {\n    case Dimension::X:\n        return acc->getX();\n    case Dimension::Y:\n        return acc->getY();\n    case Dimension::Z:\n        return acc->getZ();\n    case Dimension::Strength:\n        float x = acc->getX();\n        float y = acc->getY();\n        float z = acc->getZ();\n        return (int)sqrtf(x * x + y * y + z * z);\n    }\n    return 0;\n}\n\n/**\n * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n * @param kind TODO\n */\n//% help=input/rotation\n//% blockId=device_get_rotation block=\"rotation (°)|%NAME\"\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=38\nint rotation(Rotation kind) {\n    auto acc = getAccelerometer();\n    if (!acc) return 0;\n\n    acc->requestUpdate();\n    switch (kind) {\n    case Rotation::Pitch:\n        return acc->getPitch();\n    case Rotation::Roll:\n        return acc->getRoll();\n    }\n    return 0;\n}\n\n/**\n * Sets the accelerometer sample range in gravities.\n * @param range a value describe the maximum strengh of acceleration measured\n */\n//% help=input/set-accelerometer-range\n//% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n//% weight=5\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=15 blockGap=8\nvoid setAccelerometerRange(AcceleratorRange range) {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    acc->setRange((int)range);\n}\n\n} // namespace input\n",
            "accelhw.cpp": "// This supports a few different accelerometers.\n// If desired, overrides PXT_SUPPORT_* in platform.h (note that only LIS3DH is on by default).\n// Then accelerometer can be changed with config.ACCELEROMETER_TYPE in TypeScript.\n// This file can be overridden alltogether by a target if a different accelerometer is desired.\n\n#include \"pxt.h\"\n#include \"axis.h\"\n#include \"Pin.h\"\n#include \"I2C.h\"\n#include \"CoordinateSystem.h\"\n#include \"CodalDmesg.h\"\n\n#ifndef PXT_DEFAULT_ACCELEROMETER\n#define PXT_DEFAULT_ACCELEROMETER -1\n#endif\n\n#ifndef PXT_SUPPORT_LIS3DH\n#define PXT_SUPPORT_LIS3DH 1\n#endif\n#if PXT_SUPPORT_LIS3DH\n#include \"LIS3DH.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MMA8653\n#define PXT_SUPPORT_MMA8653 0\n#endif\n#if PXT_SUPPORT_MMA8653\n#include \"MMA8653.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MMA8453\n#define PXT_SUPPORT_MMA8453 0\n#endif\n#if PXT_SUPPORT_MMA8453\n#include \"MMA8453.h\"\n#endif\n\n#ifndef PXT_SUPPORT_FXOS8700\n#define PXT_SUPPORT_FXOS8700 0\n#endif\n#if PXT_SUPPORT_FXOS8700\n#include \"FXOS8700Accelerometer.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MSA300\n#define PXT_SUPPORT_MSA300 0\n#endif\n#if PXT_SUPPORT_MSA300\n#include \"MSA300.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MPU6050\n#define PXT_SUPPORT_MPU6050 0\n#endif\n#if PXT_SUPPORT_MPU6050\n#include \"MPU6050.h\"\n#endif\n\n#if defined(CODAL_ACCELEROMETER)\n#error \"please define PXT_SUPPORT_*\"\n#endif\n\nnamespace pxt {\n\n    /*\nRAW,                            0x000000\nSIMPLE_CARTESIAN,               0x000001\nNORTH_EAST_DOWN,                0x000002\nNORTH_EAST_UP                   0x000003\n\nCOORDINATE_SPACE_ROTATED_0      0x000000\nCOORDINATE_SPACE_ROTATED_90     0x000010\nCOORDINATE_SPACE_ROTATED_180    0x000020\nCOORDINATE_SPACE_ROTATED_270    0x000030\n\nNOT_UPSIDE_DOWN                 0x000000\nUPSIDE_DOWN                     0x000100\n    */\n\nstatic CoordinateSpace boardCoordinateSpace() {\n    int defaultSpace = ((int)ACC_SYSTEM) | ((int)ACC_ROTATION << 4) | (ACC_UPSIDEDOWN ? 0x100 : 0x000);\n#if defined(STM32F4) && PXT_SUPPORT_MPU6050\n    // meowbit\n    if (getConfig(CFG_ACCELEROMETER_TYPE, -1) == ACCELEROMETER_TYPE_MPU6050)\n        defaultSpace = 0x33;\n#endif\n    int space = getConfig(CFG_ACCELEROMETER_SPACE, defaultSpace);\n    DMESG(\"coordinate space: %d / %d, %s\", space & 0xf, (space >> 4) & 0xf, space & 0x100 ? \"upside\" : \"normal\");\n    return CoordinateSpace((CoordinateSystem)(space & 0xf), !!(space & 0x100), (space >> 4) & 0xf);\n}\n\n// Wrapper classes\nclass WAccel {\n    CoordinateSpace space;\n\t\t\n  public:\n    Accelerometer *acc;\n    WAccel() \n    : space(boardCoordinateSpace())\n    , acc(NULL) {\n        DMESG(\"acc: mounting\");\n        auto sda = LOOKUP_PIN(ACCELEROMETER_SDA);\n        auto scl = LOOKUP_PIN(ACCELEROMETER_SCL);\n        if (NULL == sda || NULL == scl) { // use default i2c instead\n            DMESG(\"acc: using SDA, SCL\");\n            sda = LOOKUP_PIN(SDA);\n            scl = LOOKUP_PIN(SCL);\n        }\n        codal::I2C* i2c = pxt::getI2C(sda, scl);\n        if (NULL == i2c) {\n            DMESG(\"acc: no i2c available\");\n            return;\n        }\n\t\t\n        int accType = getConfig(CFG_ACCELEROMETER_TYPE, PXT_DEFAULT_ACCELEROMETER);\n        acc = instantiateAccelerometer(accType, i2c);\n        if (NULL == acc) {\n            int accDetect = detectAccelerometer(i2c);\n            if (accDetect < 0) {\n                DMESG(\"acc: not detected\");\n            } else {\n                DMESG(\"acc: detected %d\", accDetect);\n                acc = instantiateAccelerometer(accDetect, i2c);\n            }\n        }\n\n        if (NULL == acc) {\n            // the accelerometer might be damaged or incorrectly configured,\n            // in doubt, we just ignore it            \n            if (LOOKUP_PIN(ACCELEROMETER_SDA))\n                DMESG(\"acc: damaged accelereomter or invalid ACCELEROMETER_TYPE\");\n            else\n                DMESG(\"acc: invalid ACCELEROMETER_TYPE\");\n            // acc is already NULL, do nothing\n        }\n        else {\n            // acc->init(); - doesn't do anything\n            acc->configure();\n            acc->requestUpdate();\n            DMESG(\"acc: mounted\");\n        }\n    }\n\nprivate:\n\n\tint detectAccelerometer(codal::I2C* i2c){\n\t\tuint8_t data;\n\t\tint result;\n\n#if PXT_SUPPORT_LIS3DH\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_LIS3DH, LIS3DH_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_LIS3DH;\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_LIS3DH_ALT, LIS3DH_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_LIS3DH_ALT;\n#endif\n\t\t\t\n#if PXT_SUPPORT_MMA8453\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MMA8453, MMA8653_WHOAMI/*MMA8453 is similar to MMA8653*/ , &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MMA8453;\n#endif\n\n#if PXT_SUPPORT_FXOS8700\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_FXOS8700, FXOS8700_WHO_AM_I, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_FXOS8700;\n#endif\n\t\t\n#if PXT_SUPPORT_MMA8653\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MMA8653,  MMA8653_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MMA8653;\t\n#endif\n\t\t\n#if PXT_SUPPORT_MSA300\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MSA300, MSA300_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MSA300;\t\n#endif\n\t\t\t\n#if PXT_SUPPORT_MPU6050\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MPU6050, MPU6050_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MPU6050;\t\n#endif \n\n\t\treturn -1;\n\t}\n\n    codal::Accelerometer* instantiateAccelerometer(int accType, codal::I2C* i2c) {\n        switch (accType) {\n#if PXT_SUPPORT_LIS3DH\n        case ACCELEROMETER_TYPE_LIS3DH:\n        case ACCELEROMETER_TYPE_LIS3DH_ALT:\n            return new LIS3DH(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space, accType);\n#endif\n#if PXT_SUPPORT_MSA300\n        case ACCELEROMETER_TYPE_MSA300:\n            return new MSA300(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_FXOS8700\n        case ACCELEROMETER_TYPE_FXOS8700: {\n            // TODO: singleton when exposing gyro\n            auto fox = new FXOS8700(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT));\n            return new FXOS8700Accelerometer(*fox, space);\n        }\n#endif\n#if PXT_SUPPORT_MMA8653\n        case ACCELEROMETER_TYPE_MMA8653:\n            return new MMA8653(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_MMA8453\n        case ACCELEROMETER_TYPE_MMA8453:\n            return new MMA8453(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_MPU6050\n        case ACCELEROMETER_TYPE_MPU6050:\n            return new MPU6050(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n        default:\n            return NULL;\n        }\n    }\n\n};\n\nSINGLETON_IF_PIN(WAccel, ACCELEROMETER_INT);\n\ncodal::Accelerometer *getAccelerometer() {\n    auto wacc = getWAccel();\n    return wacc ? wacc->acc : NULL;\n}\n\n} // namespace pxt\n",
            "axis.h": "// Override in target to change inversion of axis\n\n#define ACC_SYSTEM NORTH_EAST_UP\n#define ACC_UPSIDEDOWN false\n#define ACC_ROTATION COORDINATE_SPACE_ROTATED_0\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n    }\n\n\n    declare const enum Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n    }\n\n\n    declare const enum AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8,\n    }\n\n\n    declare const enum Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = 11,  // ACCELEROMETER_EVT_SHAKE\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = 1,  // ACCELEROMETER_EVT_TILT_UP\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = 2,  // ACCELEROMETER_EVT_TILT_DOWN\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = 3,  // ACCELEROMETER_EVT_TILT_LEFT\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = 4,  // ACCELEROMETER_EVT_TILT_RIGHT\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = 5,  // ACCELEROMETER_EVT_FACE_UP\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = 6,  // ACCELEROMETER_EVT_FACE_DOWN\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = 7,  // ACCELEROMETER_EVT_FREEFALL\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = 12,  // ACCELEROMETER_EVT_2G\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = 8,  // ACCELEROMETER_EVT_3G\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = 9,  // ACCELEROMETER_EVT_6G\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = 10,  // ACCELEROMETER_EVT_8G\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "gesture.ts": "namespace input {\n    /**\n     * Registers a custom gesture recognizer\n     * @param id \n     * @param update true if gesture detected\n     * @param handler \n     */\n    export function onCustomGesture(\n        id: number, \n        update: () => boolean, \n        handler: () => void) {\n        if (!update || !handler) return;\n\n        input.acceleration(Dimension.X); // turn on accelerometer\n        const evid = DAL.ACCELEROMETER_EVT_2G + 1 + (id | 0);\n        control.onEvent(DAL.DEVICE_ID_GESTURE, evid, handler);\n        let sigma = 0;\n        control.onIdle(function() {\n            if (sigma > 0) {\n                sigma--;\n            } else if(update()) {\n                sigma = 6;\n                control.raiseEvent(DAL.DEVICE_ID_GESTURE, evid);\n            }\n        })\n    }\n}",
            "jacdac.ts": "namespace jacdac {\n    export class AccelerometerService extends jacdac.SensorHost {\n        constructor(name: string) {\n            super(\"acc\", jacdac.ACCELEROMETER_DEVICE_CLASS);\n            // TODO: catch all event\n            input.onGesture(Gesture.Shake, () => this.raiseHostEvent(JDGesture.Shake));\n            input.onGesture(Gesture.TiltUp, () => this.raiseHostEvent(JDGesture.TiltUp));\n            input.onGesture(Gesture.TiltDown, () => this.raiseHostEvent(JDGesture.TiltDown));\n            input.onGesture(Gesture.TiltLeft, () => this.raiseHostEvent(JDGesture.TiltLeft));\n            input.onGesture(Gesture.TiltRight, () => this.raiseHostEvent(JDGesture.TiltRight));\n            input.onGesture(Gesture.FaceUp, () => this.raiseHostEvent(JDGesture.FaceUp));\n            input.onGesture(Gesture.FaceDown, () => this.raiseHostEvent(JDGesture.FaceDown));\n            input.onGesture(Gesture.FreeFall, () => this.raiseHostEvent(JDGesture.FreeFall));\n            input.onGesture(Gesture.ThreeG, () => this.raiseHostEvent(JDGesture.ThreeG));\n            input.onGesture(Gesture.SixG, () => this.raiseHostEvent(JDGesture.SixG));\n            input.onGesture(Gesture.EightG, () => this.raiseHostEvent(JDGesture.EightG));\n            input.onGesture(Gesture.TwoG, () => this.raiseHostEvent(JDGesture.TwoG));\n        }\n\n        raiseCustomGestureEvent(id: number) {\n            this.raiseHostEvent(JDGesture.TwoG + 1 + (id | 0));\n        }\n\n        protected serializeState(): Buffer {\n            const buf = control.createBuffer(6);\n            buf.setNumber(NumberFormat.Int16LE, 0, input.acceleration(Dimension.X));\n            buf.setNumber(NumberFormat.Int16LE, 2, input.acceleration(Dimension.Y));\n            buf.setNumber(NumberFormat.Int16LE, 4, input.acceleration(Dimension.Z));\n            return buf;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"accelerometer service\"\n    export const accelerometerService = new AccelerometerService(\"acc\");\n}",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "part.svg": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   width=\"92.834999\"\n   height=\"48.351559\"\n   y=\"0\"\n   x=\"0\"\n   viewBox=\"0 0 92.834999 48.351559\"\n   id=\"svg4493\"\n   version=\"1.1\"\n   sodipodi:docname=\"part.svg\"\n   inkscape:version=\"0.92.1 r15371\">\n  <metadata\n     id=\"metadata4514\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id=\"defs4512\" />\n  <sodipodi:namedview\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1\"\n     objecttolerance=\"10\"\n     gridtolerance=\"10\"\n     guidetolerance=\"10\"\n     inkscape:pageopacity=\"0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:window-width=\"1600\"\n     inkscape:window-height=\"837\"\n     id=\"namedview4510\"\n     showgrid=\"false\"\n     inkscape:zoom=\"8.2495794\"\n     inkscape:cx=\"42.339269\"\n     inkscape:cy=\"33.871495\"\n     inkscape:window-x=\"-8\"\n     inkscape:window-y=\"-8\"\n     inkscape:window-maximized=\"1\"\n     inkscape:current-layer=\"svg4493\"\n     fit-margin-top=\"0\"\n     fit-margin-left=\"0\"\n     fit-margin-right=\"0\"\n     fit-margin-bottom=\"0\"\n     units=\"px\"\n     inkscape:measure-start=\"-5.21239,56.8514\"\n     inkscape:measure-end=\"23.6376,42.184\" />\n  <rect\n     rx=\"1.1604376\"\n     y=\"0.048351564\"\n     height=\"48.254856\"\n     width=\"92.738297\"\n     id=\"rect5038\"\n     x=\"0.048351564\"\n     style=\"fill:#5a86c2;stroke:#8e8e8e;stroke-width:0.09670313\" />\n  <text\n     id=\"text5094\"\n     y=\"40.50362\"\n     x=\"4.5252295\"\n     style=\"font-weight:400;font-size:13.53218174px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.37589398\"\n     font-weight=\"400\"\n     font-size=\"14.4\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\"\n     transform=\"scale(0.99296988,1.0070799)\">\n    <tspan\n       y=\"40.50362\"\n       x=\"4.5252295\"\n       id=\"tspan5092\"\n       style=\"font-size:10.02383709px;stroke-width:0.37589398\">ACCELEROMETER</tspan>\n  </text>\n  <rect\n     rx=\"0.78499681\"\n     y=\"32.338985\"\n     x=\"77.394577\"\n     height=\"10.968015\"\n     width=\"11.303953\"\n     id=\"rect5096\"\n     style=\"stroke:#000000;stroke-width:0.3893353\" />\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-9.2452202\"\n     id=\"ACCELEROMETER_INT\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-6\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5\"\n     y=\"-7.1094813\"\n     x=\"10.925499\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       y=\"-7.1094813\"\n       x=\"10.925499\"\n       id=\"tspan5098-2-4\"\n       style=\"stroke-width:0.32272473\">INT</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-39.334583\"\n     id=\"SDA\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-3\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4\"\n     y=\"-37.301361\"\n     x=\"11.108133\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156\"\n       y=\"-37.301361\"\n       x=\"11.108133\"\n       style=\"stroke-width:0.32272473\">SDA</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-70.055618\"\n     id=\"VCC\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-1\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-9\"\n     y=\"-68.672005\"\n     x=\"11.428495\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-5\"\n       y=\"-68.672005\"\n       x=\"11.428495\"\n       style=\"stroke-width:0.32272473\">VCC</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-85.100304\"\n     id=\"GND\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-0\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-9-3\"\n     y=\"-83.929306\"\n     x=\"11.242865\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-5-7\"\n       y=\"-83.929306\"\n       x=\"11.242865\"\n       style=\"stroke-width:0.32272473\">GND</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-24.289902\"\n     id=\"SCL\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-6-2\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-47\"\n     y=\"-22.366781\"\n     x=\"11.108133\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       y=\"-22.366781\"\n       x=\"11.108133\"\n       id=\"tspan5098-2-4-5\"\n       style=\"stroke-width:0.32272473\">SCL</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.5968285\"\n     cx=\"-54.547421\"\n     id=\"SDO\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-3\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-4\"\n     y=\"-52.621964\"\n     x=\"10.784061\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-4\"\n       y=\"-52.621964\"\n       x=\"10.784061\"\n       style=\"stroke-width:0.32272473\">SDO</tspan>\n  </text>\n</svg>\n",
            "pxt.json": "{\n  \"yotta\": {\n    \"config\": {\n      \"PXT_SUPPORT_LIS3DH\": 1,\n      \"PXT_SUPPORT_MMA8453\": 1,\n      \"PXT_SUPPORT_MPU6050\": 1\n    }\n  },\n  \"hidden\": true,\n  \"name\": \"accelerometer\",\n  \"description\": \"The accelerometer library\",\n  \"files\": [\n    \"README.md\",\n    \"accelerometer.cpp\",\n    \"accelhw.cpp\",\n    \"axis.h\",\n    \"gesture.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\",\n    \"pxtparts.json\",\n    \"part.svg\",\n    \"jacdac.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n  \"accelerometer\": {\n    \"visual\": {\n      \"image\": \"part.svg\",\n      \"width\": 92.83499908447266,\n      \"height\": 48.351558685302734,\n      \"pinDistance\": 15,\n      \"pinLocations\": [\n        {\n          \"x\": 6.009125520265597,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 36.0982164424424,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 66.81896669097237,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 81.86351733614008,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 21.053670981354,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 51.31091788377569,\n          \"y\": 2.378772674719472\n        }\n      ]\n    },\n    \"numberOfPins\": 6,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ACCELEROMETER_INT\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"SDA\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"SCL\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5\n        ]\n      }\n    ]\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Do something when a gesture happens (like shaking the board).\n     * @param gesture the type of gesture to track, eg: Gesture.Shake\n     * @param body code to run when gesture is raised\n     */\n    //% help=input/on-gesture\n    //% blockId=device_gesture_event block=\"on |%NAME\"\n    //% parts=\"accelerometer\"\n    //% gesture.fieldEditor=\"gridpicker\"\n    //% gesture.fieldOptions.width=220\n    //% gesture.fieldOptions.columns=3\n    //% weight=92 blockGap=12 shim=input::onGesture\n    function onGesture(gesture: Gesture, body: () => void): void;\n\n    /**\n     * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n     * x=0, y=0 and z=-1023)\n     * @param dimension TODO\n     */\n    //% help=input/acceleration\n    //% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% dimension.fieldEditor=\"gridpicker\"\n    //% dimension.fieldOptions.width=180\n    //% dimension.fieldOptions.columns=2\n    //% weight=42 blockGap=8 shim=input::acceleration\n    function acceleration(dimension: Dimension): int32;\n\n    /**\n     * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n     * @param kind TODO\n     */\n    //% help=input/rotation\n    //% blockId=device_get_rotation block=\"rotation (°)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=38 shim=input::rotation\n    function rotation(kind: Rotation): int32;\n\n    /**\n     * Sets the accelerometer sample range in gravities.\n     * @param range a value describe the maximum strengh of acceleration measured\n     */\n    //% help=input/set-accelerometer-range\n    //% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n    //% weight=5\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=15 blockGap=8 shim=input::setAccelerometerRange\n    function setAccelerometerRange(range: AcceleratorRange): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": ""
        },
        "lightsensor": {
            "README.md": "# lightsensor\n\nThe lightsensor library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum LightCondition {\n    //% block=\"dark\"\n    Dark = 1,  // SENSOR_THRESHOLD_LOW\n    //% block=\"bright\"\n    Bright = 2,  // SENSOR_THRESHOLD_HIGH\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "jacdac.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LightSensorService extends jacdac.SensorHost {\n        constructor(name: string) {\n            super(name, jacdac.LIGHT_SENSOR_DEVICE_CLASS);\n            input.onLightConditionChanged(LightCondition.Bright, () => this.raiseHostEvent(LightCondition.Bright));\n            input.onLightConditionChanged(LightCondition.Dark, () => this.raiseHostEvent(LightCondition.Dark));\n        }\n\n        protected serializeState(): Buffer {\n            const buf = control.createBuffer(1);\n            buf.setNumber(NumberFormat.UInt8LE, 0, input.lightLevel());\n            return buf;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"light sensor service\"\n    export const lightSensorService = new LightSensorService(\"lis\");\n}",
            "lightsensor.cpp": "#include \"pxt.h\"\n#include \"AnalogSensor.h\"\n\n#ifdef CODAL_LIGHT_SENSOR_HEADER\n#include CODAL_LIGHT_SENSOR_HEADER\n#endif\n\n\n#ifndef CODAL_LIGHT_SENSOR\n#define CODAL_LIGHT_SENSOR AnalogSensor\n#endif\n\n#ifndef LIGHTSENSOR_SENSITIVITY\n#define LIGHTSENSOR_SENSITIVITY 868 // codal has 912 now\n#endif\n\n#ifndef LIGHTSENSOR_LOW_THRESHOLD\n#define LIGHTSENSOR_LOW_THRESHOLD 128\n#endif\n\n#ifndef LIGHTSENSOR_HIGH_THRESHOLD\n#define LIGHTSENSOR_HIGH_THRESHOLD 896\n#endif\n\nenum class LightCondition {\n    //% block=\"dark\"\n    Dark = SENSOR_THRESHOLD_LOW,\n    //% block=\"bright\"\n    Bright = SENSOR_THRESHOLD_HIGH\n};\n\nnamespace pxt {\n\nclass WLight {\n  public:\n    CODAL_LIGHT_SENSOR sensor;\n    WLight()\n        : sensor(*LOOKUP_PIN(LIGHT), DEVICE_ID_LIGHT_SENSOR) //\n    {\n        sensor.init();\n        sensor.setPeriod(50);\n        sensor.setSensitivity(LIGHTSENSOR_SENSITIVITY); \n        sensor.setLowThreshold(LIGHTSENSOR_LOW_THRESHOLD);\n        sensor.setHighThreshold(LIGHTSENSOR_HIGH_THRESHOLD);\n    }\n};\nSINGLETON_IF_PIN(WLight, LIGHT);\n\n}\n\nnamespace input {\n\n/**\n* Register an event that runs when light conditions (darker or brighter) change.\n* @param condition the condition that event triggers on\n*/\n//% help=input/on-light-condition-changed\n//% blockId=input_on_light_condition_changed block=\"on light %condition\"\n//% parts=\"lightsensor\"\n//% weight=84 blockGap=12\nvoid onLightConditionChanged(LightCondition condition, Action handler) {\n    auto wlight = getWLight();\n    if (NULL == wlight) return;    \n    auto sensor = wlight->sensor;\n\n    sensor.updateSample();\n    registerWithDal(sensor.id, (int)condition, handler);\n}\n\n/**\n * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n */\n//% help=input/light-level\n//% blockId=device_get_light_level block=\"light level\"\n//% parts=\"lightsensor\"\n//% weight=30 blockGap=8\nint lightLevel() {\n    auto wlight = getWLight();\n    if (NULL == wlight) return 127;\n    auto sensor = wlight->sensor;\n    // 0...1023\n    int value = sensor.getValue();\n    return value / 4;\n}\n\n/**\n* Set the threshold value for the light condition event.\n*/\n//% help=input/set-light-threshold\n//% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n//% parts=\"lightsensor\"\n//% value.min=1 value.max=255\n//% group=\"More\" weight=13 blockGap=8\nvoid setLightThreshold(LightCondition condition, int value) {\n    auto wlight = getWLight();\n    if (NULL == wlight) return;\n    auto sensor = wlight->sensor;\n\n    int v = value * 4;\n    if (condition == LightCondition::Dark)\n        sensor.setLowThreshold(v);\n    else\n        sensor.setHighThreshold(v);\n}\n}\n",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"lightsensor\",\n  \"description\": \"Onboard light level sensor\",\n  \"files\": [\n    \"README.md\",\n    \"lightsensor.cpp\",\n    \"jacdac.ts\",\n    \"ns.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Register an event that runs when light conditions (darker or brighter) change.\n     * @param condition the condition that event triggers on\n     */\n    //% help=input/on-light-condition-changed\n    //% blockId=input_on_light_condition_changed block=\"on light %condition\"\n    //% parts=\"lightsensor\"\n    //% weight=84 blockGap=12 shim=input::onLightConditionChanged\n    function onLightConditionChanged(condition: LightCondition, handler: () => void): void;\n\n    /**\n     * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n     */\n    //% help=input/light-level\n    //% blockId=device_get_light_level block=\"light level\"\n    //% parts=\"lightsensor\"\n    //% weight=30 blockGap=8 shim=input::lightLevel\n    function lightLevel(): int32;\n\n    /**\n     * Set the threshold value for the light condition event.\n     */\n    //% help=input/set-light-threshold\n    //% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n    //% parts=\"lightsensor\"\n    //% value.min=1 value.max=255\n    //% group=\"More\" weight=13 blockGap=8 shim=input::setLightThreshold\n    function setLightThreshold(condition: LightCondition, value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "for(let i = 0; i < 100; ++i) {\n    pause(500)\n    console.log(`light=${input.lightLevel()}`);\n}"
        },
        "thermometer": {
            "README.md": "# temperature\n\nThe temperature library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum TemperatureCondition {\n    //% block=\"hot\"\n    Hot = 2,  // SENSOR_THRESHOLD_HIGH\n    //% block=\"cold\"\n    Cold = 1,  // SENSOR_THRESHOLD_LOW\n    }\n\n\n    declare const enum TemperatureUnit {\n    //% block=\"°C\"\n    Celsius = 0,\n    //% block=\"°F\"\n    Fahrenheit = 1,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"thermometer\",\n  \"description\": \"A thermometer cdriver\",\n  \"files\": [\n    \"README.md\",\n    \"temperature.cpp\",\n    \"target_temperature.h\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Run some code when the temperature changes from hot to cold, or from cold to hot.\n     * @param condition the condition, hot or cold, the event triggers on\n     * @param temperature the temperature at which this event happens, eg: 15\n     * @param unit the unit of the temperature\n     */\n    //% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n    //% parts=\"thermometer\"\n    //% help=input/on-temperature-condition-changed blockExternalInputs=0\n    //% group=\"More\" weight=76 shim=input::onTemperatureConditionChanged\n    function onTemperatureConditionChanged(condition: TemperatureCondition, temperature: int32, unit: TemperatureUnit, handler: () => void): void;\n\n    /**\n     * Get the temperature in Celsius or Fahrenheit degrees.\n     */\n    //% help=input/temperature\n    //% blockId=device_temperature block=\"temperature in %unit\"\n    //% parts=\"thermometer\"\n    //% weight=26 shim=input::temperature\n    function temperature(unit: TemperatureUnit): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "target_temperature.h": "#include \"NonLinearAnalogSensor.h\"\n\n/*\n * @param nominalValue The value (in SI units) of a nominal position.\n * @param nominalReading The raw reading from the sensor at the nominal position.\n * @param beta The Steinhart-Hart Beta constant for the device\n * @param seriesResistor The value (in ohms) of the resistor in series with the sensor.\n * @param zeroOffset Optional zero offset applied to all SI units (e.g. 273.15 for temperature\n * sensing in C vs Kelvin).\n */\n\n#ifndef TEMPERATURE_NOMINAL_VALUE\n#define TEMPERATURE_NOMINAL_VALUE 25\n#endif\n\n#ifndef TEMPERATURE_NOMINAL_READING\n#define TEMPERATURE_NOMINAL_READING 10000\n#endif\n\n#ifndef TEMPERATURE_BETA\n#define TEMPERATURE_BETA 3380\n#endif\n\n#ifndef TEMPERATURE_SERIES_RESISTOR\n#define TEMPERATURE_SERIES_RESISTOR 10000\n#endif\n\n#ifndef TEMPERATURE_ZERO_OFFSET\n#define TEMPERATURE_ZERO_OFFSET 273.5\n#endif\n\nnamespace pxt {\nclass WTemp {\n  public:\n    NonLinearAnalogSensor sensor;\n    WTemp()\n        : sensor(*LOOKUP_PIN(TEMPERATURE), DEVICE_ID_THERMOMETER,\n                TEMPERATURE_NOMINAL_VALUE, \n                TEMPERATURE_NOMINAL_READING, \n                TEMPERATURE_BETA, \n                TEMPERATURE_SERIES_RESISTOR,\n                TEMPERATURE_ZERO_OFFSET)\n    {\n        sensor.init();\n    }\n};\n}",
            "temperature.cpp": "#include \"pxt.h\"\n#include \"target_temperature.h\"\n\nenum class TemperatureCondition {\n    //% block=\"hot\"\n    Hot = SENSOR_THRESHOLD_HIGH,\n    //% block=\"cold\"\n    Cold = SENSOR_THRESHOLD_LOW\n};\n\nenum class TemperatureUnit {\n    //% block=\"°C\"\n    Celsius,\n    //% block=\"°F\"\n    Fahrenheit\n};\n\nnamespace pxt {\nSINGLETON_IF_PIN(WTemp, TEMPERATURE);\n}\n\nnamespace input {\n\n/**\n* Run some code when the temperature changes from hot to cold, or from cold to hot.\n* @param condition the condition, hot or cold, the event triggers on\n* @param temperature the temperature at which this event happens, eg: 15\n* @param unit the unit of the temperature\n*/\n//% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n//% parts=\"thermometer\"\n//% help=input/on-temperature-condition-changed blockExternalInputs=0\n//% group=\"More\" weight=76\nvoid onTemperatureConditionChanged(TemperatureCondition condition, int temperature, TemperatureUnit unit, Action handler) {\n    auto thermo = getWTemp();\n    if (!thermo) return;\n\n    auto sensor = &thermo->sensor;\n    sensor->updateSample();\n\n    int t = unit == TemperatureUnit::Celsius ? temperature : ((temperature - 32) * 10) / 18;\n\n    if (condition == TemperatureCondition::Cold)\n        sensor->setLowThreshold(t);\n    else\n        sensor->setHighThreshold(t);\n    registerWithDal(sensor->id, (int)condition, handler);\n}\n\n/**\n * Get the temperature in Celsius or Fahrenheit degrees.\n */\n//% help=input/temperature\n//% blockId=device_temperature block=\"temperature in %unit\"\n//% parts=\"thermometer\"\n//% weight=26\nint temperature(TemperatureUnit unit) {\n    auto thermo = getWTemp();\n    // default to 21 if not present\n    int value = (NULL != thermo) ? thermo->sensor.getValue() : 21;\n    if (unit == TemperatureUnit::Celsius) return value;\n    else return (value * 18) / 10 + 32;\n}\n}\n",
            "test.ts": ""
        },
        "base": {
            "README.md": "# base\n\nThe base library, shared by all C++ targets (not only Codal-based).\n\n\n",
            "advmath.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\nnamespace Math_ {\n\n//%\nTNumber log2(TNumber x){SINGLE(log2)}\n//%\nTNumber exp(TNumber x){SINGLE(exp)}\n//%\nTNumber tanh(TNumber x){SINGLE(tanh)}\n//%\nTNumber sinh(TNumber x){SINGLE(sinh)}\n//%\nTNumber cosh(TNumber x){SINGLE(cosh)}\n//%\nTNumber atanh(TNumber x){SINGLE(atanh)}\n//%\nTNumber asinh(TNumber x){SINGLE(asinh)}\n//%\nTNumber acosh(TNumber x){SINGLE(acosh)}\n\n}",
            "buffer.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n\nusing namespace std;\n\n//% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\nnamespace BufferMethods {\n//%\nuint8_t *getBytes(Buffer buf) {\n    return buf->data;\n}\n\n//%\nint getByte(Buffer buf, int off) {\n    if (buf && 0 <= off && off < buf->length)\n        return buf->data[off];\n    return 0;\n}\n\n//%\nvoid setByte(Buffer buf, int off, int v) {\n    if (buf && 0 <= off && off < buf->length)\n        buf->data[off] = v;\n}\n\n/**\n* Reads an unsigned byte at a particular location\n*/\n//%\nint getUint8(Buffer buf, int off) {\n    return getByte(buf, off);\n}\n\n/**\n* Writes an unsigned byte at a particular location\n*/\n//%\nvoid setUint8(Buffer buf, int off, int v) {\n    setByte(buf, off, v);\n}\n\nint writeBuffer(Buffer buf, int dstOffset, Buffer src, int srcOffset = 0, int length = -1) {\n    if (length < 0)\n        length = src->length;\n\n    if (srcOffset < 0 || dstOffset < 0 || dstOffset > buf->length)\n        return -1;\n\n    length = min(src->length - srcOffset, buf->length - dstOffset);\n\n    if (length < 0)\n        return -1;\n\n    if (buf == src) {\n        memmove(buf->data + dstOffset, src->data + srcOffset, length);\n    } else {\n        memcpy(buf->data + dstOffset, src->data + srcOffset, length);\n    }\n\n    return 0;\n}\n\n/**\n * Write a number in specified format in the buffer.\n */\n//%\nvoid setNumber(Buffer buf, NumberFormat format, int offset, TNumber value) {\n    if (offset < 0)\n        return;\n    setNumberCore(buf->data + offset, buf->length - offset, format, value);\n}\n\n/**\n * Read a number in specified format from the buffer.\n */\n//%\nTNumber getNumber(Buffer buf, NumberFormat format, int offset) {\n    if (offset < 0)\n        return fromInt(0);\n    return getNumberCore(buf->data + offset, buf->length - offset, format);\n}\n\n/** Returns the length of a Buffer object. */\n//% property\nint length(Buffer s) {\n    return s->length;\n}\n\n/**\n * Fill (a fragment) of the buffer with given value.\n */\n//%\nvoid fill(Buffer buf, int value, int offset = 0, int length = -1) {\n    if (offset < 0 || offset > buf->length)\n        return; // DEVICE_INVALID_PARAMETER;\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    memset(buf->data + offset, value, length);\n}\n\n/**\n * Return a copy of a fragment of a buffer.\n */\n//%\nBuffer slice(Buffer buf, int offset = 0, int length = -1) {\n    offset = min((int)buf->length, offset);\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    return mkBuffer(buf->data + offset, length);\n}\n\n/**\n * Shift buffer left in place, with zero padding.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid shift(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n    if (offset <= -length || offset >= length) {\n        fill(buf, 0);\n        return;\n    }\n\n    uint8_t *data = buf->data + start;\n    if (offset < 0) {\n        offset = -offset;\n        memmove(data + offset, data, length - offset);\n        memset(data, 0, offset);\n    } else {\n        length = length - offset;\n        memmove(data, data + offset, length);\n        memset(data + length, 0, offset);\n    }\n}\n\n/**\n * Convert a buffer to string assuming UTF8 encoding\n */\n//%\nString toString(Buffer buf) {\n    return mkString((char *)buf->data, buf->length);\n}\n\n/**\n * Convert a buffer to its hexadecimal representation.\n */\n//%\nString toHex(Buffer buf) {\n    const char *hex = \"0123456789abcdef\";\n    auto res = mkStringCore(NULL, buf->length * 2);\n    for (int i = 0; i < buf->length; ++i) {\n        res->ascii.data[i << 1] = hex[buf->data[i] >> 4];\n        res->ascii.data[(i << 1) + 1] = hex[buf->data[i] & 0xf];\n    }\n    return res;\n}\n\n/**\n * Rotate buffer left in place.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid rotate(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n\n    if (offset < 0)\n        offset += length << 8; // try to make it positive\n    offset %= length;\n    if (offset < 0)\n        offset += length;\n\n    uint8_t *data = buf->data + start;\n\n    uint8_t *n_first = data + offset;\n    uint8_t *first = data;\n    uint8_t *next = n_first;\n    uint8_t *last = data + length;\n\n    while (first != next) {\n        uint8_t tmp = *first;\n        *first++ = *next;\n        *next++ = tmp;\n        if (next == last) {\n            next = n_first;\n        } else if (first == n_first) {\n            n_first = next;\n        }\n    }\n}\n\n/**\n * Write contents of `src` at `dstOffset` in current buffer.\n */\n//%\nvoid write(Buffer buf, int dstOffset, Buffer src) {\n    // srcOff and length not supported, we only do up to 4 args :/\n    writeBuffer(buf, dstOffset, src, 0, -1);\n}\n} // namespace BufferMethods\n\nnamespace control {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n\n/**\n * Create a new buffer with UTF8-encoded string\n * @param str the string to put in the buffer\n */\n//%\nBuffer createBufferFromUTF8(String str) {\n#if PXT_UTF8\n    auto sz = toRealUTF8(str, NULL);\n    auto r = mkBuffer(NULL, sz);\n    toRealUTF8(str, r->data);\n    return r;\n#else\n    return mkBuffer((const uint8_t *)str->getUTF8Data(), str->getUTF8Size());\n#endif\n}\n} // namespace control\n\nnamespace pxt {\nstatic int writeBytes(uint8_t *dst, uint8_t *src, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = dst + length;\n        for (int i = 0; i < length; ++i)\n            *--p = src[i];\n    } else {\n        if (length == 4 && ((uintptr_t)dst & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uintptr_t)dst & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nstatic int readBytes(uint8_t *src, uint8_t *dst, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        memset(dst, 0, length);\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = src + length;\n        for (int i = 0; i < length; ++i)\n            dst[i] = *--p;\n    } else {\n        if (length == 4 && ((uintptr_t)src & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uintptr_t)src & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nvoid setNumberCore(uint8_t *buf, int szLeft, NumberFormat format, TNumber value) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define WRITEBYTES(isz, swap, toInt)                                                               \\\n    isz = toInt(value);                                                                            \\\n    writeBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                   \\\n    break\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        WRITEBYTES(i8, false, toInt);\n    case NumberFormat::UInt8LE:\n        WRITEBYTES(u8, false, toInt);\n    case NumberFormat::Int16LE:\n        WRITEBYTES(i16, false, toInt);\n    case NumberFormat::UInt16LE:\n        WRITEBYTES(u16, false, toInt);\n    case NumberFormat::Int32LE:\n        WRITEBYTES(i32, false, toInt);\n    case NumberFormat::UInt32LE:\n        WRITEBYTES(u32, false, toUInt);\n\n    case NumberFormat::Int8BE:\n        WRITEBYTES(i8, true, toInt);\n    case NumberFormat::UInt8BE:\n        WRITEBYTES(u8, true, toInt);\n    case NumberFormat::Int16BE:\n        WRITEBYTES(i16, true, toInt);\n    case NumberFormat::UInt16BE:\n        WRITEBYTES(u16, true, toInt);\n    case NumberFormat::Int32BE:\n        WRITEBYTES(i32, true, toInt);\n    case NumberFormat::UInt32BE:\n        WRITEBYTES(u32, true, toUInt);\n\n    case NumberFormat::Float32LE:\n        WRITEBYTES(f32, false, toFloat);\n    case NumberFormat::Float32BE:\n        WRITEBYTES(f32, true, toFloat);\n    case NumberFormat::Float64LE:\n        WRITEBYTES(f64, false, toDouble);\n    case NumberFormat::Float64BE:\n        WRITEBYTES(f64, true, toDouble);\n    }\n}\n\nTNumber getNumberCore(uint8_t *buf, int szLeft, NumberFormat format) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define READBYTES(isz, swap, conv)                                                                 \\\n    readBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                    \\\n    return conv(isz)\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        READBYTES(i8, false, fromInt);\n    case NumberFormat::UInt8LE:\n        READBYTES(u8, false, fromInt);\n    case NumberFormat::Int16LE:\n        READBYTES(i16, false, fromInt);\n    case NumberFormat::UInt16LE:\n        READBYTES(u16, false, fromInt);\n    case NumberFormat::Int32LE:\n        READBYTES(i32, false, fromInt);\n    case NumberFormat::UInt32LE:\n        READBYTES(u32, false, fromUInt);\n\n    case NumberFormat::Int8BE:\n        READBYTES(i8, true, fromInt);\n    case NumberFormat::UInt8BE:\n        READBYTES(u8, true, fromInt);\n    case NumberFormat::Int16BE:\n        READBYTES(i16, true, fromInt);\n    case NumberFormat::UInt16BE:\n        READBYTES(u16, true, fromInt);\n    case NumberFormat::Int32BE:\n        READBYTES(i32, true, fromInt);\n    case NumberFormat::UInt32BE:\n        READBYTES(u32, true, fromUInt);\n\n    case NumberFormat::Float32LE:\n        READBYTES(f32, false, fromFloat);\n    case NumberFormat::Float32BE:\n        READBYTES(f32, true, fromFloat);\n    case NumberFormat::Float64LE:\n        READBYTES(f64, false, fromDouble);\n    case NumberFormat::Float64BE:\n        READBYTES(f64, true, fromDouble);\n    }\n\n    return 0;\n}\n} // namespace pxt\n",
            "buffer.ts": "namespace pins {\n    /**\n     * Get the size in bytes of specified number format.\n     */\n    //%\n    export function sizeOf(format: NumberFormat) {\n        switch (format) {\n            case NumberFormat.Int8LE:\n            case NumberFormat.UInt8LE:\n            case NumberFormat.Int8BE:\n            case NumberFormat.UInt8BE:\n                return 1;\n            case NumberFormat.Int16LE:\n            case NumberFormat.UInt16LE:\n            case NumberFormat.Int16BE:\n            case NumberFormat.UInt16BE:\n                return 2;\n            case NumberFormat.Int32LE:\n            case NumberFormat.Int32BE:\n            case NumberFormat.UInt32BE:\n            case NumberFormat.UInt32LE:\n            case NumberFormat.Float32BE:\n            case NumberFormat.Float32LE:\n                return 4;\n            case NumberFormat.Float64BE:\n            case NumberFormat.Float64LE:\n                return 8;\n        }\n        return 0;\n    }\n\n    /**\n     * Create a new buffer initalized to bytes from given array.\n     * @param bytes data to initalize with\n     */\n    //%\n    export function createBufferFromArray(bytes: number[]) {\n        let buf = control.createBuffer(bytes.length)\n        for (let i = 0; i < bytes.length; ++i)\n            buf[i] = bytes[i]\n        return buf\n    }\n\n    function getFormat(pychar: string, isBig: boolean) {\n        switch (pychar) {\n            case 'B':\n                return NumberFormat.UInt8LE\n            case 'b':\n                return NumberFormat.Int8LE\n            case 'H':\n                return isBig ? NumberFormat.UInt16BE : NumberFormat.UInt16LE\n            case 'h':\n                return isBig ? NumberFormat.Int16BE : NumberFormat.Int16LE\n            case 'I':\n            case 'L':\n                return isBig ? NumberFormat.UInt32BE : NumberFormat.UInt32LE\n            case 'i':\n            case 'l':\n                return isBig ? NumberFormat.Int32BE : NumberFormat.Int32LE\n            case 'f':\n                return isBig ? NumberFormat.Float32BE : NumberFormat.Float32LE\n            case 'd':\n                return isBig ? NumberFormat.Float64BE : NumberFormat.Float64LE\n            default:\n                return null as NumberFormat\n        }\n    }\n\n    function packUnpackCore(format: string, nums: number[], buf: Buffer, isPack: boolean, off = 0) {\n        let isBig = false\n        let idx = 0\n        for (let i = 0; i < format.length; ++i) {\n            switch (format[i]) {\n                case ' ':\n                case '<':\n                case '=':\n                    isBig = false\n                    break\n                case '>':\n                case '!':\n                    isBig = true\n                    break\n                case 'x':\n                    off++\n                    break\n                default:\n                    let fmt = getFormat(format[i], isBig)\n                    if (fmt === null) {\n                        control.fail(\"Not supported format character: \" + format[i])\n                    } else {\n                        if (buf) {\n                            if (isPack)\n                                buf.setNumber(fmt, off, nums[idx++])\n                            else\n                                nums.push(buf.getNumber(fmt, off))\n                        }\n\n                        off += pins.sizeOf(fmt)\n                    }\n                    break\n            }\n        }\n        return off\n    }\n\n    export function packedSize(format: string) {\n        return packUnpackCore(format, null, null, true)\n    }\n\n    export function packBuffer(format: string, nums: number[]) {\n        let buf = control.createBuffer(packedSize(format))\n        packUnpackCore(format, nums, buf, true)\n        return buf\n    }\n\n    export function packIntoBuffer(format: string, buf: Buffer, offset: number, nums: number[]) {\n        packUnpackCore(format, nums, buf, true, offset)\n    }\n\n    export function unpackBuffer(format: string, buf: Buffer, offset = 0) {\n        let res: number[] = []\n        packUnpackCore(format, res, buf, false, offset)\n        return res\n    }\n\n    export function concatBuffers(bufs: Buffer[]) {\n        let len = 0\n        for (let b of bufs)\n            len += b.length\n        const r = control.createBuffer(len)\n        len = 0\n        for (let b of bufs) {\n            r.write(len, b)\n            len += b.length\n        }\n        return r\n    }\n}\n\n// see http://msgpack.org/ for the spec\n// it currently only implements numbers and their sequances\n// once we handle any type and typeof expressions we can do more\n\nnamespace msgpack {\n    function tagFormat(tag: number) {\n        switch (tag) {\n            case 0xCB: return NumberFormat.Float64BE\n            case 0xCC: return NumberFormat.UInt8BE\n            case 0xCD: return NumberFormat.UInt16BE\n            case 0xCE: return NumberFormat.UInt32BE\n            case 0xD0: return NumberFormat.Int8BE\n            case 0xD1: return NumberFormat.Int16BE\n            case 0xD2: return NumberFormat.Int32BE\n            default:\n                return null\n        }\n    }\n\n    function packNumberCore(buf: Buffer, offset: number, num: number) {\n        let tag = 0xCB\n        if (num == (num << 0) || num == (num >>> 0)) {\n            if (-31 <= num && num <= 127) {\n                if (buf) buf[offset] = num\n                return 1\n            } else if (0 <= num) {\n                if (num <= 0xff) {\n                    tag = 0xCC\n                } else if (num <= 0xffff) {\n                    tag = 0xCD\n                } else {\n                    tag = 0xCE\n                }\n            } else {\n                if (-0x7f <= num) {\n                    tag = 0xD0\n                } else if (-0x7fff <= num) {\n                    tag = 0xD1\n                } else {\n                    tag = 0xD2\n                }\n            }\n        }\n        let fmt = tagFormat(tag)\n        if (buf) {\n            buf[offset] = tag\n            buf.setNumber(fmt, offset + 1, num)\n        }\n        return pins.sizeOf(fmt) + 1\n    }\n\n    /**\n     * Unpacks a buffer into a number array.\n     */\n    export function unpackNumberArray(buf: Buffer, offset = 0): number[] {\n        let res: number[] = []\n\n        while (offset < buf.length) {\n            let fmt = tagFormat(buf[offset++])\n            if (fmt === null) {\n                let v = buf.getNumber(NumberFormat.Int8BE, offset - 1)\n                if (-31 <= v && v <= 127)\n                    res.push(v)\n                else\n                    return null\n            } else {\n                res.push(buf.getNumber(fmt, offset))\n                offset += pins.sizeOf(fmt)\n            }\n            // padding at the end\n            while (buf[offset] === 0xc1) offset++;\n        }\n\n        return res\n    }\n\n    /**\n     * Pack a number array into a buffer.\n     * @param nums the numbers to be packed\n     */\n    export function packNumberArray(nums: number[]): Buffer {\n        let off = 0\n        for (let n of nums) {\n            off += packNumberCore(null, off, n)\n        }\n        let buf = control.createBuffer(off)\n        off = 0\n        for (let n of nums) {\n            off += packNumberCore(buf, off, n)\n        }\n        return buf\n    }\n}\n\nnamespace helpers {\n    export function bufferConcat(a: Buffer, b: Buffer) {\n        const r = control.createBuffer(a.length + b.length)\n        r.write(0, a)\n        r.write(a.length, b)\n        return r\n    }\n\n    export function bufferIndexOf(a: Buffer, b: Buffer) {\n        for (let i = 0; i <= a.length - b.length; ++i) {\n            if (a[i] == b[0]) {\n                let j = 0\n                while (j < b.length) {\n                    if (a[i + j] != b[j])\n                        break\n                    j++\n                }\n                if (j >= b.length)\n                    return i\n            }\n        }\n        return -1\n    }\n}\n\ninterface Buffer {\n    [index: number]: number;\n\n    /**\n     * Return concatenation of current buffer and the given buffer\n     */\n    //% helper=bufferConcat\n    concat(other: Buffer): Buffer;\n\n    /**\n     * Return position of other buffer in current buffer\n     */\n    //% helper=bufferIndexOf\n    indexOf(other: Buffer): number;\n\n    // rest defined in buffer.cpp\n}",
            "configkeys.h": "#ifndef __PXT_CONFIGKEYS_H\n#define __PXT_CONFIGKEYS_H\n\n// used by pins.cpp to mask off the pin name from any config\n// lower 16 pins of value are the pin name\n#define CFG_PIN_NAME_MSK 0x0000ffff\n// upper 16 bits of value is any configuration of the pin.\n#define CFG_PIN_CONFIG_MSK 0xffff0000\n\n// begin optional pin configurations\n#define CFG_PIN_CONFIG_ACTIVE_LO 0x10000\n\n\n#define CFG_MAGIC0 0x1e9e10f1\n#define CFG_MAGIC1 0x20227a79\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n\n#define CFG_PIN_JACK_TX 60\n#define CFG_PIN_JACK_SENSE 61\n#define CFG_PIN_JACK_HPEN 62\n#define CFG_PIN_JACK_BZEN 63\n#define CFG_PIN_JACK_PWREN 64\n#define CFG_PIN_JACK_SND 65\n#define CFG_PIN_JACK_BUSLED 66\n#define CFG_PIN_JACK_COMMLED 67\n\n#define CFG_PIN_BTN_SOFT_RESET 69\n#define CFG_ACCELEROMETER_TYPE 70\n#define CFG_PIN_BTNMX_LATCH 71\n#define CFG_PIN_BTNMX_CLOCK 72\n#define CFG_PIN_BTNMX_DATA 73\n#define CFG_PIN_BTN_MENU2 74\n#define CFG_PIN_BATTSENSE 75\n#define CFG_PIN_VIBRATION 76\n#define CFG_PIN_PWREN 77\n#define CFG_DISPLAY_TYPE 78\n\n#define CFG_PIN_ROTARY_ENCODER_A 79\n#define CFG_PIN_ROTARY_ENCODER_B 80\n\n#define CFG_ACCELEROMETER_SPACE 81\n\n// default I2C address\n#define ACCELEROMETER_TYPE_LIS3DH 0x32\n#define ACCELEROMETER_TYPE_LIS3DH_ALT 0x30\n#define ACCELEROMETER_TYPE_MMA8453 0x38\n#define ACCELEROMETER_TYPE_FXOS8700 0x3C\n#define ACCELEROMETER_TYPE_MMA8653 0x3A\n#define ACCELEROMETER_TYPE_MSA300 0x4C\n#define ACCELEROMETER_TYPE_MPU6050 0x68\n\n#define DISPLAY_TYPE_ST7735 7735\n#define DISPLAY_TYPE_ILI9341 9341\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n#define CFG_PIN_A16 116\n#define CFG_PIN_A17 117\n#define CFG_PIN_A18 118\n#define CFG_PIN_A19 119\n#define CFG_PIN_A20 120\n#define CFG_PIN_A21 121\n#define CFG_PIN_A22 122\n#define CFG_PIN_A23 123\n#define CFG_PIN_A24 124\n#define CFG_PIN_A25 125\n#define CFG_PIN_A26 126\n#define CFG_PIN_A27 127\n#define CFG_PIN_A28 128\n#define CFG_PIN_A29 129\n#define CFG_PIN_A30 130\n#define CFG_PIN_A31 131\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n#define CFG_PIN_D16 166\n#define CFG_PIN_D17 167\n#define CFG_PIN_D18 168\n#define CFG_PIN_D19 169\n#define CFG_PIN_D20 170\n#define CFG_PIN_D21 171\n#define CFG_PIN_D22 172\n#define CFG_PIN_D23 173\n#define CFG_PIN_D24 174\n#define CFG_PIN_D25 175\n#define CFG_PIN_D26 176\n#define CFG_PIN_D27 177\n#define CFG_PIN_D28 178\n#define CFG_PIN_D29 179\n#define CFG_PIN_D30 180\n#define CFG_PIN_D31 181\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n#define CFG_RAM_BYTES 205\n#define CFG_SYSTEM_HEAP_BYTES 206\n#define CFG_LOW_MEM_SIMULATION_KB 207\n#define CFG_BOOTLOADER_BOARD_ID 208\n#define CFG_UF2_FAMILY 209\n#define CFG_PINS_PORT_SIZE 210\n#define CFG_BOOTLOADER_PROTECTION 211\n#define CFG_POWER_DEEPSLEEP_TIMEOUT 212\n#define CFG_ANALOG_BUTTON_THRESHOLD 213\n#define CFG_CPU_MHZ 214\n#define CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS 215\n\n#define CFG_PIN_B0 300\n#define CFG_PIN_B1 301\n#define CFG_PIN_B2 302\n#define CFG_PIN_B3 303\n#define CFG_PIN_B4 304\n#define CFG_PIN_B5 305\n#define CFG_PIN_B6 306\n#define CFG_PIN_B7 307\n#define CFG_PIN_B8 308\n#define CFG_PIN_B9 309\n#define CFG_PIN_B10 310\n#define CFG_PIN_B11 311\n#define CFG_PIN_B12 312\n#define CFG_PIN_B13 313\n#define CFG_PIN_B14 314\n#define CFG_PIN_B15 315\n#define CFG_PIN_B16 316\n#define CFG_PIN_B17 317\n#define CFG_PIN_B18 318\n#define CFG_PIN_B19 319\n#define CFG_PIN_B20 320\n#define CFG_PIN_B21 321\n#define CFG_PIN_B22 322\n#define CFG_PIN_B23 323\n#define CFG_PIN_B24 324\n#define CFG_PIN_B25 325\n#define CFG_PIN_B26 326\n#define CFG_PIN_B27 327\n#define CFG_PIN_B28 328\n#define CFG_PIN_B29 329\n#define CFG_PIN_B30 330\n#define CFG_PIN_B31 331\n\n#define CFG_PIN_C0 350\n#define CFG_PIN_C1 351\n#define CFG_PIN_C2 352\n#define CFG_PIN_C3 353\n#define CFG_PIN_C4 354\n#define CFG_PIN_C5 355\n#define CFG_PIN_C6 356\n#define CFG_PIN_C7 357\n#define CFG_PIN_C8 358\n#define CFG_PIN_C9 359\n#define CFG_PIN_C10 360\n#define CFG_PIN_C11 361\n#define CFG_PIN_C12 362\n#define CFG_PIN_C13 363\n#define CFG_PIN_C14 364\n#define CFG_PIN_C15 365\n#define CFG_PIN_C16 366\n#define CFG_PIN_C17 367\n#define CFG_PIN_C18 368\n#define CFG_PIN_C19 369\n#define CFG_PIN_C20 370\n#define CFG_PIN_C21 371\n#define CFG_PIN_C22 372\n#define CFG_PIN_C23 373\n#define CFG_PIN_C24 374\n#define CFG_PIN_C25 375\n#define CFG_PIN_C26 376\n#define CFG_PIN_C27 377\n#define CFG_PIN_C28 378\n#define CFG_PIN_C29 379\n#define CFG_PIN_C30 380\n#define CFG_PIN_C31 381\n\n#define CFG_PIN_P0 400\n#define CFG_PIN_P1 401\n#define CFG_PIN_P2 402\n#define CFG_PIN_P3 403\n#define CFG_PIN_P4 404\n#define CFG_PIN_P5 405\n#define CFG_PIN_P6 406\n#define CFG_PIN_P7 407\n#define CFG_PIN_P8 408\n#define CFG_PIN_P9 409\n#define CFG_PIN_P10 410\n#define CFG_PIN_P11 411\n#define CFG_PIN_P12 412\n#define CFG_PIN_P13 413\n#define CFG_PIN_P14 414\n#define CFG_PIN_P15 415\n#define CFG_PIN_P16 416\n#define CFG_PIN_P17 417\n#define CFG_PIN_P18 418\n#define CFG_PIN_P19 419\n#define CFG_PIN_P20 420\n#define CFG_PIN_P21 421\n#define CFG_PIN_P22 422\n#define CFG_PIN_P23 423\n#define CFG_PIN_P24 424\n#define CFG_PIN_P25 425\n#define CFG_PIN_P26 426\n#define CFG_PIN_P27 427\n#define CFG_PIN_P28 428\n#define CFG_PIN_P29 429\n#define CFG_PIN_P30 420\n#define CFG_PIN_P31 421\n\n#define CFG_PIN_LORA_MISO 1001\n#define CFG_PIN_LORA_MOSI 1002\n#define CFG_PIN_LORA_SCK 1003\n#define CFG_PIN_LORA_CS 1004\n#define CFG_PIN_LORA_BOOT 1005\n#define CFG_PIN_LORA_RESET 1006\n#define CFG_PIN_IRRXLED 1007\n#define CFG_PIN_IRTXLED 1008\n#define CFG_PIN_LCD_RESET 1009\n#define CFG_PIN_LCD_ENABLE 1010\n#define CFG_PIN_LCD_DATALINE4 1011\n#define CFG_PIN_LCD_DATALINE5 1012\n#define CFG_PIN_LCD_DATALINE6 1013\n#define CFG_PIN_LCD_DATALINE7 1014\n#define CFG_NUM_LCD_COLUMNS 1015\n#define CFG_NUM_LCD_ROWS 1016\n\n#endif\n",
            "console.ts": "/// <reference no-default-lib=\"true\"/>\n\nenum ConsolePriority {\n    Debug = 0,\n    Log = 1,\n    Warning = 2,\n    Error = 3,\n    Silent = 4\n}\n\n/**\n * Reading and writing data to the console output.\n */\n//% weight=12 color=#002050 icon=\"\\uf120\"\n//% advanced=true\nnamespace console {\n    type Listener = (priority: ConsolePriority, text: string) => void;\n\n    /**\n     * Minimum priority to send messages to listeners\n     */\n    export let minPriority = ConsolePriority.Log;\n\n    //% whenUsed\n    const listeners: Listener[] = [\n        function (priority: ConsolePriority, text: string) { control.__log(priority, text); }\n    ];\n\n    export function add(priority: ConsolePriority, text: string) {\n        if (priority < minPriority) return;\n        // add new line\n        text += \"\\n\";\n        // send to listeners\n        for (let i = 0; i < listeners.length; ++i)\n            listeners[i](priority, text);\n    }\n\n    export function debug(text: string) {\n        add(ConsolePriority.Debug, text);\n    }\n\n    export function warn(text: string) {\n        add(ConsolePriority.Warning, text);\n    }\n\n    export function error(text: string) {\n        add(ConsolePriority.Error, text);\n    }\n\n    /**\n     * Write a line of text to the console output.\n     * @param value to send\n     */\n    //% weight=90\n    //% help=console/log blockGap=8\n    //% blockId=console_log block=\"console log $value\"\n    //% value.shadow=text\n    export function log(value: any): void {\n        add(ConsolePriority.Log, inspect(value));\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the console output.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=console/log-value\n    //% blockId=console_log_value block=\"console|log value %name|= %value\"\n    export function logValue(name: string, value: number): void {\n        log(name ? `${name}: ${value}` : `${value}`)\n    }\n\n    /**\n     * Convert any object or value to a string representation\n     * @param obj value to be converted to a string\n     * @param maxElements [optional] max number values in an object to include in output\n     */\n    export function inspect(obj: any, maxElements = 20): string {\n        if (typeof obj == \"string\") {\n            return obj;\n        } else if (typeof obj == \"number\") {\n            return \"\" + obj;\n        } else if (Array.isArray(obj)) {\n            const asArr = (obj as Array<string>);\n            if (asArr.length <= maxElements) {\n                return asArr.join(\",\");\n            } else {\n                return `${asArr.slice(0, maxElements).join(\",\")}...`;\n            }\n        } else {\n            const asString = obj + \"\";\n            if (asString != \"[object Object]\"\n                && asString != \"[Object]\") { // on arcade at least, default toString is [Object] on hardware instead of standard\n                return asString;\n            }\n\n            let keys = Object.keys(obj);\n            const snipped = keys.length > maxElements;\n            if (snipped) {\n                keys = keys.slice(0, maxElements);\n            }\n\n            return `{${\n                keys.reduce(\n                    (prev, currKey) => prev + `\\n    ${currKey}: ${obj[currKey]}`,\n                    \"\"\n                ) + (snipped ? \"\\n    ...\" : \"\")\n            }\n}`;\n        }\n    }\n\n    /**\n     * Adds a listener for the log messages\n     * @param listener\n     */\n    //%\n    export function addListener(listener: (priority: ConsolePriority, text: string) => void) {\n        if (!listener || listeners.indexOf(listener) > -1) return;\n        listeners.push(listener);\n    }\n\n    /**\n     * Removes a listener\n     * @param listener \n     */\n    //%\n    export function removeListener(listener: (priority: ConsolePriority, text: string) => void) {\n        if (!listener) return;\n        const i = listeners.indexOf(listener);\n        if (i > -1)\n            listeners.splice(i, 1);\n    }\n}",
            "control.cpp": "#include \"pxtbase.h\"\n\n\nnamespace control {\n    /**\n    * Gets the number of milliseconds elapsed since power on.\n    */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\"\n    int millis() {\n        return current_time_ms();\n    }\n\n    /**\n    * Gets current time in microseconds. Overflows every ~18 minutes.\n    */\n    //%\n    int micros() {\n        return current_time_us() & 0x3fffffff;\n    }\n\n    /**\n    * Used internally\n    */\n    //%\n    void internalOnEvent(int src, int value, Action handler, int flags = 16) {\n        registerWithDal(src, value, handler, flags);\n    }\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\"\n    void reset() {\n        target_reset();\n    }\n\n    /**\n    * Block the current fiber for the given microseconds\n    * @param micros number of micro-seconds to wait. eg: 4\n    */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (µs)%micros\"\n    void waitMicros(int micros) {\n        sleep_us(micros);\n    }\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8\n    void runInParallel(Action a) {\n        pxt::runInParallel(a);\n    }\n\n    /**\n    * Blocks the calling thread until the specified event is raised.\n    */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\"\n    void waitForEvent(int src, int value) {\n        pxt::waitForEvent(src, value);\n    }\n\n    /**\n    * Derive a unique, consistent serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number\n    int deviceSerialNumber() {\n        return pxt::getSerialNumber();\n    }\n\n    /**\n    * Derive a unique, consistent 64-bit serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_long_serial_number\" block=\"device long serial number\" weight=9\n    //% help=control/device-long-serial-number\n    Buffer deviceLongSerialNumber() {\n        uint64_t serial_num = pxt::getLongSerialNumber();\n        return mkBuffer((uint8_t*)&serial_num, sizeof(uint64_t));\n    }\n\n    /**\n    *\n    */\n    //%\n    void __log(int prority, String text) {\n        if (NULL == text) return;\n        pxt::sendSerial(text->getUTF8Data(), text->getUTF8Size());\n    }\n\n    /**\n     * Dump internal information about a value.\n     */\n    //%\n    void dmesgValue(TValue v) {\n        anyPrint(v);\n    }\n\n    /**\n     * Force GC and dump basic information about heap.\n     */\n    //%\n    void gc() {\n        pxt::gc(1);\n    }\n\n    /**\n     * Force GC and halt waiting for debugger to do a full heap dump.\n     */\n    //%\n    void heapDump() {\n        pxt::gc(2);\n        target_panic(PANIC_HEAP_DUMPED);\n    }\n\n\n    /**\n     * Set flags used when connecting an external debugger.\n     */\n    //%\n    void setDebugFlags(int flags) {\n        debugFlags = flags;\n    }\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //%\n    bool profilingEnabled() {\n#ifdef PXT_PROFILE\n        return true;\n#else\n        return false;\n#endif\n    }\n}\n",
            "control.ts": "/**\n* Program controls and events.\n*/\n//% weight=10 color=\"#31bca3\" icon=\"\\uf110\" advanced=true\nnamespace control {\n    /**\n     * Deprecated, use ``control.runInParallel`` instead.\n     */\n    //% deprecated=1 hidden=1 help=control/run-in-background blockAllowMultiple=1 afterOnStart=true\n    //% blockId=\"control_run_in_background\" block=\"run in background\" blockGap=8 weight=0\n    export function runInBackground(a: () => void) {\n        control.runInParallel(a);\n    }\n\n    /**\n     * Display an error code and stop the program.\n     * @param code an error number to display. eg: 5\n     */\n    //% help=control/panic weight=29\n    //% blockId=\"control_panic\" block=\"panic %code\"\n    //% shim=pxtrt::panic\n    export function panic(code: number) { }\n\n    /**\n     * Enable profiling for current function.\n     */\n    //% shim=TD_NOOP shimArgument=perfCounter\n    export function enablePerfCounter(name?: string) { }\n\n    /**\n     * Dump values of profiling performance counters.\n     */\n    //% shim=pxt::dumpPerfCounters\n    export function dmesgPerfCounters() { }\n\n    /**\n     * Display an error code and stop the program when the assertion is `false`.\n     */\n    //% help=control/assert weight=30\n    //% blockId=\"control_assert\" block=\"assert %cond|with value %code\"\n    export function assert(cond: boolean, code: number) {\n        if (!cond) {\n            fail(\"Assertion failed, code=\" + code)\n        }\n    }\n\n    export function fail(message: string) {\n        console.log(\"Fatal failure: \")\n        console.log(message)\n        dmesg(message)\n        panic(108)\n    }\n\n    export class AnimationQueue {\n        running: boolean;\n        eventID: number;\n        public interval: number;\n\n        constructor() {\n            this.running = false;\n            this.eventID = control.allocateNotifyEvent();\n            this.interval = 1;\n        }\n\n        /**\n         * Runs 'render' in a loop until it returns false or the 'stop' function is called\n         */\n        runUntilDone(render: () => boolean) {\n            const evid = this.eventID;\n\n            // if other animation, wait for turn\n            if (this.running)\n                control.waitForEvent(DAL.DEVICE_ID_NOTIFY, evid);\n\n            // check if the animation hasn't been cancelled since we've waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // run animation\n            this.running = true;\n            while (this.running\n                && !this.isCancelled(evid)\n                && render()) {\n                pause(this.interval);\n            }\n\n            // check if the animation hasn't been cancelled since we've been waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // we're done\n            this.running = false;\n            // unblock 1 fiber\n            control.raiseEvent(DAL.DEVICE_ID_NOTIFY_ONE, this.eventID);\n        }\n\n        isCancelled(evid: number) {\n            return this.eventID !== evid;\n        }\n\n        /**\n         * Cancels the current running animation and clears the queue\n         */\n        cancel() {\n            if (this.running) {\n                this.running = false;\n                const evid = this.eventID;\n                this.eventID = control.allocateNotifyEvent();\n                // unblock fibers\n                control.raiseEvent(DAL.DEVICE_ID_NOTIFY, evid);\n            }\n        }\n    }\n\n    class PollEvent {\n        public eid: number;\n        public vid: number;\n        public start: number;\n        public timeOut: number;\n        public condition: () => boolean;\n        public once: boolean;\n        constructor(eid: number, vid: number, start: number, timeOut: number, condition: () => boolean, once: boolean) {\n            this.eid = eid;\n            this.vid = vid;\n            this.start = start;\n            this.timeOut = timeOut;\n            this.condition = condition;\n            this.once = once;\n        }\n    }\n\n    let _pollEventQueue: PollEvent[] = undefined;\n\n    function pollEvents() {\n        while (_pollEventQueue.length > 0) {\n            const now = control.millis();\n            for (let i = 0; i < _pollEventQueue.length; ++i) {\n                const ev = _pollEventQueue[i];\n                if (ev.condition() || (ev.timeOut > 0 && now - ev.start > ev.timeOut)) {\n                    control.raiseEvent(ev.eid, ev.vid);\n                    if (ev.once) {\n                        _pollEventQueue.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            pause(50);\n        }\n        // release fiber\n        _pollEventQueue = undefined;\n    }\n\n    export function __queuePollEvent(timeOut: number, condition: () => boolean, handler: () => void) {\n        const ev = new PollEvent(\n            control.allocateNotifyEvent(),\n            1,\n            control.millis(),\n            timeOut,\n            condition,\n            !handler\n        );\n\n        // start polling fiber if needed\n        if (!_pollEventQueue) {\n            _pollEventQueue = [ev];\n            control.runInParallel(pollEvents);\n        }\n        else {\n            // add to the queue\n            _pollEventQueue.push(ev)\n        }\n\n        // register event\n        if (handler)\n            control.onEvent(ev.eid, ev.vid, handler);\n        else // or wait\n            control.waitForEvent(ev.eid, ev.vid);\n    }\n\n    //% shim=pxt::getConfig\n    export declare function getConfigValue(key: int32, defl: int32): number;\n\n    //% shim=pxt::programHash\n    export declare function programHash(): number;\n\n    //% shim=pxt::programName\n    export declare function programName(): string;\n\n    export enum IntervalMode {\n        Interval,\n        Timeout,\n        Immediate\n    }\n\n    let _intervals: Interval[] = undefined;\n    class Interval {\n\n        id: number;\n        func: () => void;\n        delay: number;\n        mode: IntervalMode;\n\n        constructor(func: () => void, delay: number, mode: IntervalMode) {\n            this.id = _intervals.length == 0\n                ? 1 : _intervals[_intervals.length - 1].id + 1;\n            this.func = func;\n            this.delay = delay;\n            this.mode = mode;\n            _intervals.push(this);\n\n            control.runInParallel(() => this.work());\n        }\n\n        work() {\n            // execute\n            switch (this.mode) {\n                case IntervalMode.Immediate:\n                case IntervalMode.Timeout:\n                    if (this.delay > 0)\n                        pause(this.delay); // timeout\n                    if (this.delay >= 0) // immediate, timeout\n                        this.func();\n                    break;\n                case IntervalMode.Interval:\n                    while (this.delay > 0) {\n                        pause(this.delay);\n                        // might have been cancelled during this duration\n                        if (this.delay > 0)\n                            this.func();\n                    }\n                    break;\n            }\n            // remove from interval array\n            _intervals.removeElement(this);\n        }\n\n        cancel() {\n            this.delay = -1;\n        }\n    }\n\n    export function setInterval(func: () => void, delay: number, mode: IntervalMode): number {\n        if (!func || delay < 0) return 0;\n        if (!_intervals) _intervals = [];\n        const interval = new Interval(func, delay, mode);\n        return interval.id;\n    }\n\n    export function clearInterval(intervalId: number, mode: IntervalMode): void {\n        if (!_intervals) return;\n        for (let i = 0; i < _intervals.length; ++i) {\n            const it = _intervals[i];\n            if (it.id == intervalId && it.mode == mode) {\n                it.cancel();\n                break;\n            }\n        }\n    }\n\n    //% shim=control::_ramSize\n    function _ramSize() {\n        return 32 * 1024 * 1024;\n    }\n\n    /** Returns estimated size of memory in bytes. */\n    export function ramSize() {\n        return getConfigValue(DAL.CFG_RAM_BYTES, 0) || _ramSize();\n    }\n\n    /** Runs the function and returns run time in microseconds. */\n    export function benchmark(f: () => void) {\n        const t0 = micros()\n        f()\n        let t = micros() - t0\n        if (t < 0)\n            t += 0x3fffffff\n        return t\n    }\n}\n\n/**\n * Busy wait for a condition to be true\n * @param condition condition to test for\n * @param timeOut if positive, maximum duration to wait for in milliseconds\n */\n//% blockId=\"pxt_pause_until\"\nfunction pauseUntil(condition: () => boolean, timeOut?: number): void {\n    if (!condition || condition()) return; // optimistic path\n    if (!timeOut) timeOut = 0;\n    control.__queuePollEvent(timeOut, condition, undefined);\n}\n\n/**\n * Convert any value to text\n * @param value value to be converted to text\n */\n//% help=text/convert-to-text weight=1\n//% block=\"convert $value=math_number to text\"\n//% blockId=variable_to_text blockNamespace=\"text\"\nfunction convertToText(value: any): string {\n    return \"\" + value;\n}\n",
            "core.cpp": "#include \"pxtbase.h\"\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n#include \"LowLevelTimer.h\"\nusing namespace codal;\n#endif\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#define p10(v) __builtin_powi(10, v)\n\n// try not to create cons-strings shorter than this\n#define SHORT_CONCAT_STRING 50\n\n// bigger value - less memory, but slower\n// 16/20 keeps s.length and s.charCodeAt(i) at about 200 cycles (for actual unicode strings),\n// which is similar to amortized allocation time\n#define SKIP_INCR 16 // needs to be power of 2; needs to be kept in sync with compiler\n#define MIN_SKIP 20  // min. size of string to use skip list; static code has its own limit\n\nnamespace pxt {\n\nPXT_DEF_STRING(emptyString, \"\")\n\nstatic HandlerBinding *handlerBindings;\n\nHandlerBinding *nextBinding(HandlerBinding *curr, int source, int value) {\n    for (auto p = curr; p; p = p->next) {\n        // DEVICE_ID_ANY == DEVICE_EXT_ANY == 0\n        if ((p->source == source || p->source == 0) && (p->value == value || p->value == 0)) {\n            return p;\n        }\n    }\n    return 0;\n}\n\nHandlerBinding *findBinding(int source, int value) {\n    return nextBinding(handlerBindings, source, value);\n}\n\nvoid setBinding(int source, int value, Action act) {\n    HandlerBinding *curr = NULL;\n    for (auto p = handlerBindings; p; p = p->next) {\n        if ((p->source == source) && (p->value == value)) {\n            curr = p;\n            break;\n        }\n    }\n    incr(act);\n    if (curr) {\n        decr(curr->action);\n        curr->action = act;\n        return;\n    }\n    curr = new (app_alloc(sizeof(HandlerBinding))) HandlerBinding();\n    curr->next = handlerBindings;\n    curr->source = source;\n    curr->value = value;\n    curr->action = act;\n    registerGC(&curr->action);\n    handlerBindings = curr;\n}\n\nvoid coreReset() {\n    // these are allocated on GC heap, so they will go away together with the reset\n    handlerBindings = NULL;\n}\n\nstatic const char emptyBuffer[] __attribute__((aligned(4))) = \"@PXT#:\\x00\\x00\\x00\";\n\n#if PXT_UTF8\nint utf8Len(const char *data, int size) {\n    int len = 0;\n    for (int i = 0; i < size; ++i) {\n        char c = data[i];\n        len++;\n        if ((c & 0x80) == 0x00) {\n            // skip\n        } else if ((c & 0xe0) == 0xc0) {\n            i++;\n        } else if ((c & 0xf0) == 0xe0) {\n            i += 2;\n        } else {\n            // error; just skip\n        }\n    }\n    return len;\n}\n\nconst char *utf8Skip(const char *data, int size, int skip) {\n    int len = 0;\n    for (int i = 0; i <= size; ++i) {\n        char c = data[i];\n        len++;\n        if (len > skip)\n            return data + i;\n        if ((c & 0x80) == 0x00) {\n            // skip\n        } else if ((c & 0xe0) == 0xc0) {\n            i++;\n        } else if ((c & 0xf0) == 0xe0) {\n            i += 2;\n        } else {\n            // error; just skip over\n        }\n    }\n    return NULL;\n}\n\nstatic char *write3byte(char *dst, uint32_t charCode) {\n    if (dst) {\n        *dst++ = 0xe0 | (charCode >> 12);\n        *dst++ = 0x80 | (0x3f & (charCode >> 6));\n        *dst++ = 0x80 | (0x3f & (charCode >> 0));\n    }\n    return dst;\n}\n\nstatic char *write2byte(char *dst, uint32_t charCode) {\n    if (dst) {\n        *dst++ = 0xc0 | (charCode >> 6);\n        *dst++ = 0x80 | (0x3f & charCode);\n    }\n    return dst;\n}\n\nstatic int utf8canon(char *dst, const char *data, int size) {\n    int outsz = 0;\n    for (int i = 0; i < size;) {\n        uint8_t c = data[i];\n        uint32_t charCode = c;\n        if ((c & 0x80) == 0x00) {\n            charCode = c;\n            i++;\n        } else if ((c & 0xe0) == 0xc0 && i + 1 < size && (data[i + 1] & 0xc0) == 0x80) {\n            charCode = ((c & 0x1f) << 6) | (data[i + 1] & 0x3f);\n            if (charCode < 0x80)\n                goto error;\n            else\n                i += 2;\n        } else if ((c & 0xf0) == 0xe0 && i + 2 < size && (data[i + 1] & 0xc0) == 0x80 &&\n                   (data[i + 2] & 0xc0) == 0x80) {\n            charCode = ((c & 0x0f) << 12) | (data[i + 1] & 0x3f) << 6 | (data[i + 2] & 0x3f);\n            // don't exclude surrogate pairs, since we're generating them\n            if (charCode < 0x800 /*|| (0xd800 <= charCode && charCode <= 0xdfff)*/)\n                goto error;\n            else\n                i += 3;\n        } else if ((c & 0xf8) == 0xf0 && i + 3 < size && (data[i + 1] & 0xc0) == 0x80 &&\n                   (data[i + 2] & 0xc0) == 0x80 && (data[i + 3] & 0xc0) == 0x80) {\n            charCode = ((c & 0x07) << 18) | (data[i + 1] & 0x3f) << 12 | (data[i + 2] & 0x3f) << 6 |\n                       (data[i + 3] & 0x3f);\n            if (charCode < 0x10000 || charCode > 0x10ffff)\n                goto error;\n            else\n                i += 4;\n        } else {\n            goto error;\n        }\n\n        if (charCode < 0x80) {\n            outsz += 1;\n            if (dst)\n                *dst++ = charCode;\n        } else if (charCode < 0x800) {\n            outsz += 2;\n            dst = write2byte(dst, charCode);\n        } else if (charCode < 0x10000) {\n            outsz += 3;\n            dst = write3byte(dst, charCode);\n        } else {\n            outsz += 6; // a surrogate pair\n            charCode -= 0x10000;\n            dst = write3byte(dst, 0xd800 + (charCode >> 10));\n            dst = write3byte(dst, 0xdc00 + (charCode & 0x3ff));\n        }\n\n        continue;\n\n    error:\n        i++;\n        outsz += 2;\n        dst = write2byte(dst, c);\n    }\n    return outsz;\n}\n\nstatic int utf8CharCode(const char *data) {\n    unsigned char c = *data;\n    if ((c & 0x80) == 0) {\n        return c;\n    } else if ((c & 0xe0) == 0xc0) {\n        return ((c & 0x1f) << 6) | (data[1] & 0x3f);\n    } else if ((c & 0xf0) == 0xe0) {\n        return ((c & 0x0f) << 12) | (data[1] & 0x3f) << 6 | (data[2] & 0x3f);\n    } else {\n        return c; // error\n    }\n}\n\nstatic bool isUTF8(const char *data, int len) {\n    for (int i = 0; i < len; ++i) {\n        if (data[i] & 0x80)\n            return true;\n    }\n    return false;\n}\n\n#define NUM_SKIP_ENTRIES(p) ((p)->skip.length / SKIP_INCR)\n#define SKIP_DATA(p) (const char *)(p->skip.list + NUM_SKIP_ENTRIES(p))\n\nstatic void setupSkipList(String r, const char *data) {\n    char *dst = (char *)SKIP_DATA(r);\n    auto len = r->skip.size;\n    if (data)\n        memcpy(dst, data, len);\n    dst[len] = 0;\n    const char *ptr = dst;\n    auto skipEntries = NUM_SKIP_ENTRIES(r);\n    for (int i = 0; i < skipEntries; ++i) {\n        ptr = utf8Skip(ptr, (int)(len - (ptr - dst)), SKIP_INCR);\n        if (!ptr)\n            oops(80);\n        r->skip.list[i] = ptr - dst;\n    }\n}\n#endif\n\n#ifdef PXT_VM\nString mkInternalString(const char *str) {\n    int len = (int)strlen(str);\n    String r = new (xmalloc(sizeof(void *) + 2 + len + 1)) BoxedString(&string_inline_ascii_vt);\n    r->ascii.length = len;\n    memcpy(r->ascii.data, str, len);\n    r->ascii.data[len] = 0;\n    return r;\n}\n#endif\n\nString mkStringCore(const char *data, int len) {\n    if (len < 0)\n        len = (int)strlen(data);\n    if (len == 0 && !inGCPrealloc())\n        return (String)emptyString;\n\n    auto vt = &string_inline_ascii_vt;\n    String r;\n\n#if PXT_UTF8\n    if (data && isUTF8(data, len)) {\n        vt = len >= MIN_SKIP ? &string_skiplist16_vt : &string_inline_utf8_vt;\n    }\n    if (vt == &string_skiplist16_vt) {\n        r = new (gcAllocate(sizeof(void *) + sizeof(r->skip))) BoxedString(vt);\n        r->skip.list = NULL;\n        registerGCObj(r);\n        r->skip.size = len;\n        r->skip.length = utf8Len(data, len);\n        r->skip.list = NULL; // in case gc triggers below\n        r->skip.list = (uint16_t *)gcAllocateArray(NUM_SKIP_ENTRIES(r) * 2 + len + 1);\n        setupSkipList(r, data);\n        unregisterGCObj(r);\n    } else\n#endif\n    {\n        // for ASCII and UTF8 the layout is the same\n        r = new (gcAllocate(sizeof(void *) + 2 + len + 1)) BoxedString(vt);\n        r->ascii.length = len;\n        if (data)\n            memcpy(r->ascii.data, data, len);\n        r->ascii.data[len] = 0;\n    }\n\n    MEMDBG(\"mkString: len=%d => %p\", len, r);\n    return r;\n}\n\nString mkString(const char *data, int len) {\n#if PXT_UTF8\n    if (len < 0)\n        len = (int)strlen(data);\n    if (len == 0 && !inGCPrealloc())\n        return (String)emptyString;\n\n    int sz = utf8canon(NULL, data, len);\n    if (sz == len)\n        return mkStringCore(data, len);\n    // this could be optimized, but it only kicks in when the string isn't valid utf8\n    // (or we need to introduce surrogate pairs) which is unlikely to be performance critical\n    char *tmp = (char *)app_alloc(sz);\n    utf8canon(tmp, data, len);\n    auto r = mkStringCore(tmp, sz);\n    app_free(tmp);\n    return r;\n#else\n    return mkStringCore(data, len);\n#endif\n}\n\n#if PXT_UTF8\n// This converts surrogate pairs, which are encoded as 2 characters of 3 bytes each\n// into a proper 4 byte utf-8 character.\nuint32_t toRealUTF8(String str, uint8_t *dst) {\n    auto src = str->getUTF8Data();\n    auto len = str->getUTF8Size();\n    auto dlen = 0;\n\n    for (unsigned i = 0; i < len; ++i) {\n        if ((uint8_t)src[i] == 0xED && i + 5 < len) {\n            auto c0 = utf8CharCode(src + i);\n            auto c1 = utf8CharCode(src + i + 3);\n            if (0xd800 <= c0 && c0 < 0xdc00 && 0xdc00 <= c1 && c1 < 0xe000) {\n                i += 5;\n                auto charCode = ((c0 - 0xd800) << 10) + (c1 - 0xdc00) + 0x10000;\n                if (dst) {\n                    dst[dlen] = 0xf0 | (charCode >> 18);\n                    dst[dlen + 1] = 0x80 | (0x3f & (charCode >> 12));\n                    dst[dlen + 2] = 0x80 | (0x3f & (charCode >> 6));\n                    dst[dlen + 3] = 0x80 | (0x3f & (charCode >> 0));\n                }\n                dlen += 4;\n            }\n        } else {\n            if (dst)\n                dst[dlen] = src[i];\n            dlen++;\n        }\n    }\n    return dlen;\n}\n#endif\n\nBuffer mkBuffer(const uint8_t *data, int len) {\n    if (len <= 0 && !inGCPrealloc())\n        return (Buffer)emptyBuffer;\n    Buffer r = new (gcAllocate(sizeof(BoxedBuffer) + len)) BoxedBuffer();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    else\n        memset(r->data, 0, len);\n    MEMDBG(\"mkBuffer: len=%d => %p\", len, r);\n    return r;\n}\n\nstatic unsigned random_value = 0xC0DA1;\n\n//%\nvoid seedRandom(unsigned seed) {\n    random_value = seed;\n}\n\n//%\nvoid seedAddRandom(unsigned seed) {\n    random_value ^= 0xCA2557CB * seed;\n}\n\nunsigned getRandom(unsigned max) {\n    unsigned m, result;\n\n    do {\n        m = (unsigned)max;\n        result = 0;\n\n        do {\n            // Cycle the LFSR (Linear Feedback Shift Register).\n            // We use an optimal sequence with a period of 2^32-1, as defined by Bruce Schneier here\n            // (a true legend in the field!),\n            // For those interested, it's documented in his paper:\n            // \"Pseudo-Random Sequence Generator for 32-Bit CPUs: A fast, machine-independent\n            // generator for 32-bit Microprocessors\"\n            // https://www.schneier.com/paper-pseudorandom-sequence.html\n            unsigned r = random_value;\n\n            r = ((((r >> 31) ^ (r >> 6) ^ (r >> 4) ^ (r >> 2) ^ (r >> 1) ^ r) & 1) << 31) |\n                (r >> 1);\n\n            random_value = r;\n\n            result = ((result << 1) | (r & 0x00000001));\n        } while (m >>= 1);\n    } while (result > (unsigned)max);\n\n    return result;\n}\n\nTNumber BoxedString::charCodeAt(int pos) {\n#if PXT_UTF8\n    auto ptr = this->getUTF8DataAt(pos);\n    if (!ptr)\n        return TAG_NAN;\n    auto code = utf8CharCode(ptr);\n    if (!code && ptr == this->getUTF8Data() + this->getUTF8Size())\n        return TAG_NAN;\n    return fromInt(code);\n#else\n    if (0 <= pos && pos < this->ascii.length) {\n        return fromInt(this->ascii.data[pos]);\n    } else {\n        return TAG_NAN;\n    }\n#endif\n}\n\nPXT_DEF_STRING(sTrue, \"true\")\nPXT_DEF_STRING(sFalse, \"false\")\nPXT_DEF_STRING(sUndefined, \"undefined\")\nPXT_DEF_STRING(sNull, \"null\")\nPXT_DEF_STRING(sObject, \"[Object]\")\nPXT_DEF_STRING(sFunction, \"[Function]\")\nPXT_DEF_STRING(sNaN, \"NaN\")\nPXT_DEF_STRING(sInf, \"Infinity\")\nPXT_DEF_STRING(sMInf, \"-Infinity\")\n} // namespace pxt\n\n#ifndef X86_64\n\nnamespace String_ {\n\n//%\nString mkEmpty() {\n    return (String)emptyString;\n}\n\n// TODO support var-args somehow?\n\n//%\nString fromCharCode(int code) {\n#if PXT_UTF8\n    char buf[3];\n    int len;\n    code &= 0xffff; // JS semantics\n    if (code < 0x80) {\n        buf[0] = code;\n        len = 1;\n    } else if (code < 0x800) {\n        buf[0] = 0xc0 | (code >> 6);\n        buf[1] = 0x80 | ((code >> 0) & 0x3f);\n        len = 2;\n    } else {\n        buf[0] = 0xe0 | (code >> 12);\n        buf[1] = 0x80 | ((code >> 6) & 0x3f);\n        buf[2] = 0x80 | ((code >> 0) & 0x3f);\n        len = 3;\n    }\n    return mkStringCore(buf, len);\n#else\n    char buf[] = {(char)code, 0};\n    return mkStringCore(buf, 1);\n#endif\n}\n\n//%\nTNumber charCodeAt(String s, int pos) {\n    if (!s)\n        return TAG_NAN;\n    return s->charCodeAt(pos);\n}\n\n//%\nString charAt(String s, int pos) {\n    auto v = charCodeAt(s, pos);\n    if (v == TAG_NAN)\n        return mkEmpty();\n    if (!isInt(v))\n        oops(81);\n    return fromCharCode(numValue(v));\n}\n\n#define IS_CONS(s) ((s)->vtable == (uintptr_t)&string_cons_vt)\n#define IS_EMPTY(s) ((s) == (String)emptyString)\n\n//%\nString concat(String s, String other) {\n    if (!s)\n        s = (String)sNull;\n    if (!other)\n        other = (String)sNull;\n    if (IS_EMPTY(s))\n        return (String)incrRC(other);\n    if (IS_EMPTY(other))\n        return (String)incrRC(s);\n\n    uint32_t lenA, lenB;\n\n#if PXT_UTF8\n    if (IS_CONS(s)) {\n        // (s->cons.left + s->cons.right) + other = s->cons.left + (s->cons.right + other)\n        if (IS_CONS(other) || IS_CONS(s->cons.right))\n            goto mkCons;\n        auto lenAR = s->cons.right->getUTF8Size();\n        lenB = other->getUTF8Size();\n        if (lenAR + lenB > SHORT_CONCAT_STRING)\n            goto mkCons;\n        // if (s->cons.right + other) is short enough, use associativity\n        // to construct a shallower tree; this should keep the live set reasonable\n        // when someone decides to construct a long string by concatenating\n        // single characters\n\n        // allocate [r] first, and keep it alive\n        String r = new (gcAllocate(3 * sizeof(void *))) BoxedString(&string_cons_vt);\n        registerGCObj(r);\n        r->cons.left = s->cons.left;\n        // this concat() might trigger GC\n        r->cons.right = concat(s->cons.right, other);\n        unregisterGCObj(r);\n        return r;\n    }\n#endif\n\n    lenA = s->getUTF8Size();\n    lenB = other->getUTF8Size();\n#if PXT_UTF8\n    if (lenA + lenB > SHORT_CONCAT_STRING)\n        goto mkCons;\n#endif\n    String r;\n    {\n        auto dataA = s->getUTF8Data();\n        auto dataB = other->getUTF8Data();\n        r = mkStringCore(NULL, lenA + lenB);\n        auto dst = (char *)r->getUTF8Data();\n        memcpy(dst, dataA, lenA);\n        memcpy(dst + lenA, dataB, lenB);\n#if PXT_UTF8\n        if (isUTF8(dst, lenA + lenB))\n            r->vtable = PXT_VTABLE_TO_INT(&string_inline_utf8_vt);\n#endif\n        return r;\n    }\n\n#if PXT_UTF8\nmkCons:\n    r = new (gcAllocate(3 * sizeof(void *))) BoxedString(&string_cons_vt);\n    r->cons.left = s;\n    r->cons.right = other;\n    return r;\n#endif\n}\n\nint compare(String a, String b) {\n    if (a == b)\n        return 0;\n\n    auto lenA = a->getUTF8Size();\n    auto lenB = b->getUTF8Size();\n    auto dataA = a->getUTF8Data();\n    auto dataB = b->getUTF8Data();\n    auto len = lenA < lenB ? lenA : lenB;\n\n    // this also works for UTF8, provided canonical encoding\n    // which is guaranteed by the constructor\n    for (unsigned i = 0; i <= len; ++i) {\n        unsigned char cA = dataA[i];\n        unsigned char cB = dataB[i];\n        if (cA == cB)\n            continue;\n        return cA < cB ? -1 : 1;\n    }\n    return 0;\n}\n\n//%\nint length(String s) {\n    return s->getLength();\n}\n\n#define isspace(c) ((c) == ' ')\n\nNUMBER mystrtod(const char *p, char **endp) {\n    while (isspace(*p))\n        p++;\n    NUMBER m = 1;\n    NUMBER v = 0;\n    int dot = 0;\n    if (*p == '+')\n        p++;\n    if (*p == '-') {\n        m = -1;\n        p++;\n    }\n    if (*p == '0' && (p[1] | 0x20) == 'x') {\n        return m * strtol(p, endp, 16);\n    }\n    while (*p) {\n        int c = *p - '0';\n        if (0 <= c && c <= 9) {\n            v *= 10;\n            v += c;\n            if (dot)\n                m /= 10;\n        } else if (!dot && *p == '.') {\n            dot = 1;\n        } else if (*p == 'e' || *p == 'E') {\n            break;\n        } else {\n            while (isspace(*p))\n                p++;\n            if (*p)\n                return NAN;\n            break;\n        }\n        p++;\n    }\n\n    v *= m;\n\n    if (*p) {\n        p++;\n        int pw = (int)strtol(p, endp, 10);\n        v *= p10(pw);\n    } else {\n        *endp = (char *)p;\n    }\n\n    return v;\n}\n\n//%\nTNumber toNumber(String s) {\n    // JSCHECK\n    char *endptr;\n    auto data = s->getUTF8Data();\n    NUMBER v = mystrtod(data, &endptr);\n    if (endptr != data + s->getUTF8Size())\n        v = NAN;\n    else if (v == 0.0 || v == -0.0) {\n        // nothing\n    } else if (!isnormal(v))\n        v = NAN;\n    return fromDouble(v);\n}\n\n//%\nString substr(String s, int start, int length) {\n    if (length <= 0)\n        return mkEmpty();\n    auto slen = (int)s->getLength();\n    if (start < 0)\n        start = max(slen + start, 0);\n    length = min(length, slen - start);\n    if (length <= 0)\n        return mkEmpty();\n    auto p = s->getUTF8DataAt(start);\n#if PXT_UTF8\n    auto ep = s->getUTF8DataAt(start + length);\n    if (ep == NULL)\n        oops(82);\n    return mkStringCore(p, (int)(ep - p));\n#else\n    return mkStringCore(p, length);\n#endif\n}\n\n//%\nint indexOf(String s, String searchString, int start) {\n    if (!s || !searchString)\n        return -1;\n\n    if (start < 0)\n        start = 0;\n\n    auto dataA0 = s->getUTF8Data();\n    auto dataA = s->getUTF8DataAt(start);\n    auto offset = dataA - dataA0;\n    auto lenA = s->getUTF8Size() - offset;\n    auto lenB = searchString->getUTF8Size();\n\n    if (dataA == NULL || lenB > lenA)\n        return -1;\n\n    auto dataB = searchString->getUTF8Data();\n    auto firstB = dataB[0];\n    while (lenA >= lenB) {\n        if (*dataA == firstB && !memcmp(dataA, dataB, lenB))\n#if PXT_UTF8\n            return utf8Len(dataA0, (int)(dataA - dataA0));\n#else\n            return dataA - dataA0;\n#endif\n        dataA++;\n        lenA--;\n    }\n    return -1;\n}\n\n//%\nint includes(String s, String searchString, int start) {\n    return -1 != indexOf(s, searchString, start);\n}\n\n} // namespace String_\n\nnamespace Boolean_ {\n//%\nbool bang(bool v) {\n    return v == 0;\n}\n} // namespace Boolean_\n\nnamespace pxt {\n\n// ES5 9.5, 9.6\nunsigned toUInt(TNumber v) {\n    if (isInt(v))\n        return numValue(v);\n    if (isSpecial(v)) {\n        if ((intptr_t)v >> 6)\n            return 1;\n        else\n            return 0;\n    }\n    if (!v)\n        return 0;\n\n    NUMBER num = toDouble(v);\n    if (!isnormal(num))\n        return 0;\n#ifdef PXT_USE_FLOAT\n    float rem = fmodf(truncf(num), 4294967296.0);\n#else\n    double rem = fmod(trunc(num), 4294967296.0);\n#endif\n    if (rem < 0.0)\n        rem += 4294967296.0;\n    return (unsigned)rem;\n}\nint toInt(TNumber v) {\n    return (int)toUInt(v);\n}\n\nNUMBER toDouble(TNumber v) {\n    if (v == TAG_NAN || v == TAG_UNDEFINED)\n        return NAN;\n    if (isTagged(v))\n        return toInt(v);\n\n#ifdef PXT64\n    if (isDouble(v))\n        return doubleVal(v);\n#endif\n\n    ValType t = valType(v);\n\n#ifndef PXT64\n    if (t == ValType::Number) {\n        BoxedNumber *p = (BoxedNumber *)v;\n        return p->num;\n    }\n#endif\n\n    if (t == ValType::String) {\n        // TODO avoid allocation\n        auto tmp = String_::toNumber((String)v);\n        auto r = toDouble(tmp);\n        decr(tmp);\n        return r;\n    } else {\n        return NAN;\n    }\n}\n\nfloat toFloat(TNumber v) {\n    // TODO optimize?\n    return (float)toDouble(v);\n}\n\n#if !defined(PXT_HARD_FLOAT) && !defined(PXT_USE_FLOAT)\nunion NumberConv {\n    double v;\n    struct {\n        uint32_t word0;\n        uint32_t word1;\n    };\n};\n\nstatic inline TValue doubleToInt(double x) {\n    NumberConv cnv;\n    cnv.v = x;\n\n    if (cnv.word1 == 0 && cnv.word0 == 0)\n        return TAG_NUMBER(0);\n\n    auto ex = (int)((cnv.word1 << 1) >> 21) - 1023;\n\n    // DMESG(\"v=%d/1000 %p %p %d\", (int)(x * 1000), cnv.word0, cnv.word1, ex);\n\n    if (ex < 0 || ex > 29) {\n        // the 'MININT' case\n        if (ex == 30 && cnv.word0 == 0 && cnv.word1 == 0xC1D00000)\n            return (TValue)(0x80000001);\n        return NULL;\n    }\n\n    int32_t r;\n\n    if (ex <= 20) {\n        if (cnv.word0)\n            return TAG_UNDEFINED;\n        if (cnv.word1 << (ex + 12))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n    } else {\n        if (cnv.word0 << (ex - 20))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n        r |= cnv.word0 >> (32 - (ex - 20));\n    }\n\n    if (cnv.word1 >> 31)\n        return TAG_NUMBER(-r);\n    else\n        return TAG_NUMBER(r);\n}\n#else\nstatic inline TValue doubleToInt(NUMBER r) {\n#ifdef PXT64\n    if ((int)r == r)\n        return TAG_NUMBER((int)r);\n#else\n    int ri = ((int)r) << 1;\n    if ((ri >> 1) == r)\n        return (TNumber)(uintptr_t)(ri | 1);\n#endif\n    return TAG_UNDEFINED;\n}\n#endif\n\nTNumber fromDouble(NUMBER r) {\n#ifndef PXT_BOX_DEBUG\n    auto i = doubleToInt(r);\n    if (i)\n        return i;\n#endif\n    if (isnan(r))\n        return TAG_NAN;\n#ifdef PXT64\n    return tvalueFromDouble(r);\n#else\n    BoxedNumber *p = NEW_GC(BoxedNumber);\n    p->num = r;\n    MEMDBG(\"mkNum: %d/1000 => %p\", (int)(r * 1000), p);\n    return (TNumber)p;\n#endif\n}\n\nTNumber fromFloat(float r) {\n    // TODO optimize\n    return fromDouble(r);\n}\n\nTNumber fromInt(int v) {\n    if (canBeTagged(v))\n        return TAG_NUMBER(v);\n    return fromDouble(v);\n}\n\nTNumber fromUInt(unsigned v) {\n#ifndef PXT_BOX_DEBUG\n    if (v <= 0x3fffffff)\n        return TAG_NUMBER(v);\n#endif\n    return fromDouble(v);\n}\n\nTValue fromBool(bool v) {\n    if (v)\n        return TAG_TRUE;\n    else\n        return TAG_FALSE;\n}\n\nTNumber eqFixup(TNumber v) {\n    if (v == TAG_NULL)\n        return TAG_UNDEFINED;\n    if (v == TAG_TRUE)\n        return TAG_NUMBER(1);\n    if (v == TAG_FALSE)\n        return TAG_NUMBER(0);\n    return v;\n}\n\nstatic inline bool eq_core(TValue a, TValue b, ValType ta) {\n#ifndef PXT_BOX_DEBUG\n    auto aa = (intptr_t)a;\n    auto bb = (intptr_t)b;\n\n    // if at least one of the values is tagged, they are not equal\n    if ((aa | bb) & 3)\n        return false;\n#endif\n\n    if (ta == ValType::String)\n        return String_::compare((String)a, (String)b) == 0;\n    else if (ta == ValType::Number)\n        return toDouble(a) == toDouble(b);\n    else\n        return a == b;\n}\n\nbool eqq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (a == b)\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\nbool eq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (eqFixup(a) == eqFixup(b))\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if ((ta == ValType::String && tb == ValType::Number) ||\n        (tb == ValType::String && ta == ValType::Number))\n        return toDouble(a) == toDouble(b);\n\n    if (ta == ValType::Boolean) {\n        a = eqFixup(a);\n        ta = ValType::Number;\n    }\n    if (tb == ValType::Boolean) {\n        b = eqFixup(b);\n        tb = ValType::Number;\n    }\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\n// TODO move to assembly\n//%\nbool switch_eq(TValue a, TValue b) {\n    if (eq_bool(a, b)) {\n        decr(b);\n        return true;\n    }\n    return false;\n}\n\n} // namespace pxt\n\n#define NUMOP(op) return fromDouble(toDouble(a) op toDouble(b));\n#define BITOP(op) return fromInt(toInt(a) op toInt(b));\nnamespace numops {\n\nint toBool(TValue v) {\n    if (isTagged(v)) {\n        if (v == TAG_FALSE || v == TAG_UNDEFINED || v == TAG_NAN || v == TAG_NULL ||\n            v == TAG_NUMBER(0))\n            return 0;\n        else\n            return 1;\n    }\n\n    ValType t = valType(v);\n    if (t == ValType::String) {\n        String s = (String)v;\n        if (IS_EMPTY(s))\n            return 0;\n    } else if (t == ValType::Number) {\n        auto x = toDouble(v);\n        if (isnan(x) || x == 0.0 || x == -0.0)\n            return 0;\n        else\n            return 1;\n    }\n\n    return 1;\n}\n\nint toBoolDecr(TValue v) {\n    if (v == TAG_TRUE)\n        return 1;\n    if (v == TAG_FALSE)\n        return 0;\n    int r = toBool(v);\n    decr(v);\n    return r;\n}\n\n// The integer, non-overflow case for add/sub/bit opts is handled in assembly\n\n#ifdef PXT_VM\n#define NUMOP2(op)                                                                                 \\\n    if (bothNumbers(a, b)) {                                                                       \\\n        auto tmp = (int64_t)numValue(a) op(int64_t) numValue(b);                                   \\\n        if ((int)tmp == tmp)                                                                       \\\n            return TAG_NUMBER((int)tmp);                                                           \\\n    }                                                                                              \\\n    NUMOP(op)\n#else\n#define NUMOP2(op) NUMOP(op)\n#endif\n\n//%\nTNumber adds(TNumber a, TNumber b){NUMOP2(+)}\n\n//%\nTNumber subs(TNumber a, TNumber b){NUMOP2(-)}\n\n//%\nTNumber muls(TNumber a, TNumber b) {\n    if (bothNumbers(a, b)) {\n#ifdef PXT64\n        auto tmp = (int64_t)numValue(a) * (int64_t)numValue(b);\n        if ((int)tmp == tmp)\n            return TAG_NUMBER((int)tmp);\n#else\n        int aa = (int)a;\n        int bb = (int)b;\n        // if both operands fit 15 bits, the result will not overflow int\n        if ((aa >> 15 == 0 || aa >> 15 == -1) && (bb >> 15 == 0 || bb >> 15 == -1)) {\n            // it may overflow 31 bit int though - use fromInt to convert properly\n            return fromInt((aa >> 1) * (bb >> 1));\n        }\n#endif\n    }\n    NUMOP(*)\n}\n\n//%\nTNumber div(TNumber a, TNumber b){NUMOP(/)}\n\n//%\nTNumber mod(TNumber a, TNumber b) {\n    if (isInt(a) && isInt(b) && numValue(b))\n        BITOP(%)\n    return fromDouble(fmod(toDouble(a), toDouble(b)));\n}\n\n//%\nTNumber lsls(TNumber a, TNumber b){\n    return fromInt(toInt(a) << (toInt(b) & 0x1f));\n}\n\n//%\nTNumber lsrs(TNumber a, TNumber b) {\n    return fromUInt(toUInt(a) >> (toUInt(b) & 0x1f));\n}\n\n//%\nTNumber asrs(TNumber a, TNumber b){\n    return fromInt(toInt(a) >> (toInt(b) & 0x1f));\n}\n\n//%\nTNumber eors(TNumber a, TNumber b){BITOP (^)}\n\n//%\nTNumber orrs(TNumber a, TNumber b){BITOP(|)}\n\n//%\nTNumber bnot(TNumber a) {\n    return fromInt(~toInt(a));\n}\n\n//%\nTNumber ands(TNumber a, TNumber b) {\n    BITOP(&)\n}\n\n#ifdef PXT64\n#define CMPOP_RAW(op, t, f)                                                                        \\\n    if (bothNumbers(a, b))                                                                         \\\n        return numValue(a) op numValue(b) ? t : f;                                                 \\\n    int cmp = valCompare(a, b);                                                                    \\\n    return cmp != -2 && cmp op 0 ? t : f;\n#else\n#define CMPOP_RAW(op, t, f)                                                                        \\\n    if (bothNumbers(a, b))                                                                         \\\n        return (intptr_t)a op((intptr_t)b) ? t : f;                                                \\\n    int cmp = valCompare(a, b);                                                                    \\\n    return cmp != -2 && cmp op 0 ? t : f;\n#endif\n\n#define CMPOP(op) CMPOP_RAW(op, TAG_TRUE, TAG_FALSE)\n\n// 7.2.13 Abstract Relational Comparison\nstatic int valCompare(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return -2;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta == ValType::String && tb == ValType::String)\n        return String_::compare((String)a, (String)b);\n\n    if (a == b)\n        return 0;\n\n    auto da = toDouble(a);\n    auto db = toDouble(b);\n\n    if (isnan(da) || isnan(db))\n        return -2;\n\n    if (da < db)\n        return -1;\n    else if (da > db)\n        return 1;\n    else\n        return 0;\n}\n\n//%\nbool lt_bool(TNumber a, TNumber b){CMPOP_RAW(<, true, false)}\n\n//%\nTNumber le(TNumber a, TNumber b){CMPOP(<=)}\n\n//%\nTNumber lt(TNumber a, TNumber b){CMPOP(<)}\n\n//%\nTNumber ge(TNumber a, TNumber b){CMPOP(>=)}\n\n//%\nTNumber gt(TNumber a, TNumber b){CMPOP(>)}\n\n//%\nTNumber eq(TNumber a, TNumber b) {\n    return pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neq(TNumber a, TNumber b) {\n    return !pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber eqq(TNumber a, TNumber b) {\n    return pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neqq(TNumber a, TNumber b) {\n    return !pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n\n// How many significant digits mycvt() should output.\n// This cannot be more than 15, as this is the most that can be accurately represented\n// in 64 bit double. Otherwise this code may crash.\n#define DIGITS 15\n\nstatic const uint64_t pows[] = {\n    1LL,\n    10LL,\n    100LL,\n    1000LL,\n    10000LL,\n    100000LL,\n    1000000LL,\n    10000000LL,\n    100000000LL,\n    1000000000LL,\n    10000000000LL,    \n    100000000000LL,\n    1000000000000LL,\n    10000000000000LL,\n    100000000000000LL,\n};\n\n// The basic idea is we convert d to a 64 bit integer with DIGITS\n// digits, and then print it out, putting dot in the right place.\n\nvoid mycvt(NUMBER d, char *buf) {\n    if (d < 0) {\n        *buf++ = '-';\n        d = -d;\n    }\n\n    if (!d) {\n        *buf++ = '0';\n        *buf++ = 0;\n        return;\n    }\n\n    int pw = (int)log10(d);\n    int e = 1;\n\n    // if outside 1e-6 -- 1e21 range, we use the e-notation\n    if (d < 1e-6 || d > 1e21) {\n        // normalize number to 1.XYZ, save e, and reset pw\n        if (pw < 0)\n            d *= p10(-pw);\n        else\n            d /= p10(pw);\n        e = pw;\n        pw = 0;\n    }\n\n    int trailingZ = 0;\n    int dotAfter = pw + 1; // at which position the dot should be in the number\n\n    uint64_t dd;\n\n    // normalize number to be integer with exactly DIGITS digits\n    if (pw >= DIGITS) {\n        // if the number is larger than DIGITS, we need trailing zeroes\n        trailingZ = pw - DIGITS + 1;\n        dd = (uint64_t)(d / p10(trailingZ) + 0.5);\n    } else {\n        dd = (uint64_t)(d * p10(DIGITS - pw - 1) + 0.5);\n    }\n\n    // if number is less than 1, we need 0.00...00 at the beginning\n    if (dotAfter < 1) {\n        *buf++ = '0';\n        *buf++ = '.';\n        int n = -dotAfter;\n        while (n--)\n            *buf++ = '0';\n    }\n\n    // now print out the actual number\n    for (int i = DIGITS - 1; i >= 0; i--) {\n        uint64_t q = pows[i];\n        // this may be faster than fp-division and fmod(); or maybe not\n        // anyways, it works\n        int k = '0';\n        while (dd >= q) {\n            dd -= q;\n            k++;\n        }\n        *buf++ = k;\n        // if we're after dot, and what's left is zeroes, stop\n        if (dd == 0 && (DIGITS - i) >= dotAfter)\n            break;\n        // print the dot, if we arrived at it\n        if ((DIGITS - i) == dotAfter)\n            *buf++ = '.';\n    }\n\n    // print out remaining trailing zeroes if any\n    while (trailingZ-- > 0)\n        *buf++ = '0';\n\n    // if we used e-notation, handle that\n    if (e != 1) {\n        *buf++ = 'e';\n        if (e > 0)\n            *buf++ = '+';\n        itoa(e, buf);\n    } else {\n        *buf = 0;\n    }\n}\n\n#if 0\n//%\nTValue floatAsInt(TValue x) {\n    return doubleToInt(toDouble(x));\n}\n\n//% shim=numops::floatAsInt\nfunction floatAsInt(v: number): number { return 0 }\n\nfunction testInt(i: number) {\n    if (floatAsInt(i) != i)\n        control.panic(101)\n    if (floatAsInt(i + 0.5) != null)\n        control.panic(102)\n    if (floatAsInt(i + 0.00001) != null)\n        control.panic(103)\n}\n\nfunction testFloat(i: number) {\n    if (floatAsInt(i) != null)\n        control.panic(104)\n}\n\nfunction testFloatAsInt() {\n    for (let i = 0; i < 0xffff; ++i) {\n        testInt(i)\n        testInt(-i)\n        testInt(i * 10000)\n        testInt(i << 12)\n        testInt(i + 0x3fff0001)\n        testInt(-i - 0x3fff0002)\n        testFloat(i + 0x3fffffff + 1)\n        testFloat((i + 10000) * 1000000)\n    }\n}\n#endif\n\nString toString(TValue v) {\n    ValType t = valType(v);\n\n    if (t == ValType::String) {\n        return (String)(void *)incr(v);\n    } else if (t == ValType::Number) {\n        char buf[64];\n\n        if (isInt(v)) {\n            itoa(numValue(v), buf);\n            return mkStringCore(buf);\n        }\n\n        if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n\n        auto x = toDouble(v);\n\n#ifdef PXT_BOX_DEBUG\n        if (x == (int)x) {\n            itoa((int)x, buf);\n            return mkStringCore(buf);\n        }\n#endif\n\n        if (isinf(x)) {\n            if (x < 0)\n                return (String)(void *)sMInf;\n            else\n                return (String)(void *)sInf;\n        } else if (isnan(x)) {\n            return (String)(void *)sNaN;\n        }\n        mycvt(x, buf);\n\n        return mkStringCore(buf);\n    } else if (t == ValType::Function) {\n        return (String)(void *)sFunction;\n    } else {\n        if (v == TAG_UNDEFINED)\n            return (String)(void *)sUndefined;\n        else if (v == TAG_FALSE)\n            return (String)(void *)sFalse;\n        else if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n        else if (v == TAG_TRUE)\n            return (String)(void *)sTrue;\n        else if (v == TAG_NULL)\n            return (String)(void *)sNull;\n        return (String)(void *)sObject;\n    }\n}\n\n} // namespace numops\n\nnamespace Math_ {\n//%\nTNumber pow(TNumber x, TNumber y) {\n#ifdef PXT_POWI\n    // regular pow() from math.h is 4k of code\n    return fromDouble(__builtin_powi(toDouble(x), toInt(y)));\n#else\n    return fromDouble(::pow(toDouble(x), toDouble(y)));\n#endif\n}\n\nNUMBER randomDouble() {\n    return getRandom(UINT_MAX) / ((NUMBER)UINT_MAX + 1) +\n           getRandom(0xffffff) / ((NUMBER)UINT_MAX * 0xffffff);\n}\n\n//%\nTNumber random() {\n    return fromDouble(randomDouble());\n}\n\n//%\nTNumber randomRange(TNumber min, TNumber max) {\n    if (isInt(min) && isInt(max)) {\n        int mini = numValue(min);\n        int maxi = numValue(max);\n        if (mini > maxi) {\n            int temp = mini;\n            mini = maxi;\n            maxi = temp;\n        }\n        if (maxi == mini)\n            return fromInt(mini);\n        else\n            return fromInt(mini + getRandom(maxi - mini));\n    } else {\n        auto mind = toDouble(min);\n        auto maxd = toDouble(max);\n        if (mind > maxd) {\n            auto temp = mind;\n            mind = maxd;\n            maxd = temp;\n        }\n        if (maxd == mind)\n            return fromDouble(mind);\n        else {\n            return fromDouble(mind + randomDouble() * (maxd - mind));\n        }\n    }\n}\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber log(TNumber x){SINGLE(log)}\n\n//%\nTNumber log10(TNumber x){SINGLE(log10)}\n\n//%\nTNumber floor(TNumber x){SINGLE(floor)}\n\n//%\nTNumber ceil(TNumber x){SINGLE(ceil)}\n\n//%\nTNumber trunc(TNumber x){SINGLE(trunc)}\n\n//%\nTNumber round(TNumber x) {\n    // In C++, round(-1.5) == -2, while in JS, round(-1.5) == -1. Align to the JS convention for\n    // consistency between simulator and device. The following does rounding with ties (x.5) going\n    // towards positive infinity.\n    return fromDouble(::floor(toDouble(x) + 0.5));\n}\n\n//%\nint imul(int x, int y) {\n    return x * y;\n}\n\n//%\nint idiv(int x, int y) {\n    return x / y;\n}\n} // namespace Math_\n\nnamespace Array_ {\nRefCollection *mk() {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl: => %p\", r);\n    return r;\n}\nint length(RefCollection *c) {\n    return c->length();\n}\nvoid setLength(RefCollection *c, int newLength) {\n    c->setLength(newLength);\n}\nvoid push(RefCollection *c, TValue x) {\n    c->head.push(x);\n}\nTValue pop(RefCollection *c) {\n    return c->head.pop();\n}\nTValue getAt(RefCollection *c, int x) {\n    return c->head.get(x);\n}\nvoid setAt(RefCollection *c, int x, TValue y) {\n    c->head.set(x, y);\n}\nTValue removeAt(RefCollection *c, int x) {\n    return c->head.remove(x);\n}\nvoid insertAt(RefCollection *c, int x, TValue value) {\n    c->head.insert(x, value);\n}\nint indexOf(RefCollection *c, TValue x, int start) {\n    auto data = c->head.getData();\n    auto len = c->head.getLength();\n    for (unsigned i = 0; i < len; i++) {\n        if (pxt::eq_bool(data[i], x)) {\n            return (int)i;\n        }\n    }\n    return -1;\n}\nbool removeElement(RefCollection *c, TValue x) {\n    int idx = indexOf(c, x, 0);\n    if (idx >= 0) {\n        decr(removeAt(c, idx));\n        return 1;\n    }\n    return 0;\n}\n} // namespace Array_\n\nnamespace pxt {\nint debugFlags;\n\n//%\nvoid *ptrOfLiteral(int offset);\n\n#ifdef PXT_VM\nunsigned programSize() {\n    return 0;\n}\n#else\n//%\nunsigned programSize() {\n    return bytecode[17] * 8;\n}\n#endif\n\nvoid deepSleep() __attribute__((weak));\n//%\nvoid deepSleep() {}\n\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer *getJACDACTimer() __attribute__((weak));\nLowLevelTimer *getJACDACTimer() {\n    return NULL;\n}\n#endif\n\nint *getBootloaderConfigData() __attribute__((weak));\nint *getBootloaderConfigData() {\n    return NULL;\n}\n\n//%\nint getConfig(int key, int defl) {\n#ifdef PXT_VM\n    int *cfgData = vmImg->configData;\n#else\n    int *cfgData = bytecode ? *(int **)&bytecode[18] : NULL;\n#endif\n\n    if (cfgData) {\n        for (int i = 0;; i += 2) {\n            if (cfgData[i] == key)\n                return cfgData[i + 1];\n            if (cfgData[i] == 0)\n                break;\n        }\n    }\n\n    cfgData = getBootloaderConfigData();\n\n    if (cfgData) {\n        for (int i = 0;; i += 2) {\n            if (cfgData[i] == key)\n                return cfgData[i + 1];\n            if (cfgData[i] == 0)\n                break;\n        }\n    }\n\n    return defl;\n}\n\n} // namespace pxt\n\nnamespace pxtrt {\n//%\nTValue ldlocRef(RefRefLocal *r) {\n    TValue tmp = r->v;\n    incr(tmp);\n    return tmp;\n}\n\n//%\nvoid stlocRef(RefRefLocal *r, TValue v) {\n    decr(r->v);\n    r->v = v;\n}\n\n//%\nRefRefLocal *mklocRef() {\n    auto r = NEW_GC(RefRefLocal);\n    MEMDBG(\"mklocRef: => %p\", r);\n    return r;\n}\n\n// Store a captured local in a closure. It returns the action, so it can be chained.\n//%\nRefAction *stclo(RefAction *a, int idx, TValue v) {\n    // DBG(\"STCLO \"); a->print(); DBG(\"@%d = %p\\n\", idx, (void*)v);\n    a->stCore(idx, v);\n    return a;\n}\n\n//%\nvoid panic(int code) {\n    soft_panic(code);\n}\n\n//%\nString emptyToNull(String s) {\n    if (!s || IS_EMPTY(s))\n        return NULL;\n    return s;\n}\n\n//%\nint ptrToBool(TValue p) {\n    if (p) {\n        decr(p);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nRefMap *mkMap() {\n    auto r = NEW_GC(RefMap);\n    MEMDBG(\"mkMap: => %p\", r);\n    return r;\n}\n\nTValue mapGetByString(RefMap *map, String key) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        return 0;\n    }\n    TValue r = incr(map->values.get(i));\n    return r;\n}\n\n#ifdef PXT_VM\n#define IFACE_MEMBER_NAMES vmImg->ifaceMemberNames\n#else\n#define IFACE_MEMBER_NAMES *(uintptr_t **)&bytecode[22]\n#endif\n\nint lookupMapKey(String key) {\n    auto arr = IFACE_MEMBER_NAMES;\n    auto len = *arr++;\n    int l = 1U; // skip index 0 - it's invalid\n    int r = (int)len - 1;\n    auto ikey = (uintptr_t)key;\n    if (arr[l] <= ikey && ikey <= arr[r]) {\n        while (l <= r) {\n            auto m = (l + r) >> 1;\n            if (arr[m] == ikey)\n                return m;\n            else if (arr[m] < ikey)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    } else\n    {\n        while (l <= r) {\n            int m = (l + r) >> 1;\n            auto cmp = String_::compare((String)arr[m], key);\n            if (cmp == 0)\n                return m;\n            else if (cmp < 0)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    }\n    return 0;\n}\n\nTValue mapGet(RefMap *map, unsigned key) {\n    auto arr = (String *)IFACE_MEMBER_NAMES;\n    auto r = mapGetByString(map, arr[key + 1]);\n    map->unref();\n    return r;\n}\n\nvoid mapSetByString(RefMap *map, String key, TValue val) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        incrRC(key);\n        map->keys.push((TValue)key);\n        map->values.push(val);\n    } else {\n        map->values.set(i, val);\n    }\n    incr(val);\n}\n\nvoid mapSet(RefMap *map, unsigned key, TValue val) {\n    auto arr = (String *)IFACE_MEMBER_NAMES;\n    mapSetByString(map, arr[key + 1], val);\n    decr(val);\n    map->unref();\n}\n\n//\n// Debugger\n//\n\n// This is only to be called once at the beginning of lambda function\n//%\nvoid *getGlobalsPtr() {\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    return globals;\n}\n\n//%\nvoid runtimeWarning(String s) {\n    // noop for now\n}\n} // namespace pxtrt\n#endif\n\nnamespace pxt {\n\n//%\nValType valType(TValue v) {\n    if (isTagged(v)) {\n        if (!v)\n            return ValType::Undefined;\n\n        if (isInt(v) || v == TAG_NAN)\n            return ValType::Number;\n        if (v == TAG_TRUE || v == TAG_FALSE)\n            return ValType::Boolean;\n        else if (v == TAG_NULL)\n            return ValType::Object;\n        else {\n            oops(1);\n            return ValType::Object;\n        }\n#ifdef PXT64\n    } else if (isDouble(v)) {\n        return ValType::Number;\n#endif\n    } else {\n        auto vt = getVTable((RefObject *)v);\n        if (vt->magic == VTABLE_MAGIC)\n            return vt->objectType;\n        else\n            return ValType::Object;\n    }\n}\n\nPXT_DEF_STRING(sObjectTp, \"object\")\nPXT_DEF_STRING(sBooleanTp, \"boolean\")\nPXT_DEF_STRING(sStringTp, \"string\")\nPXT_DEF_STRING(sNumberTp, \"number\")\nPXT_DEF_STRING(sFunctionTp, \"function\")\nPXT_DEF_STRING(sUndefinedTp, \"undefined\")\n\n//% expose\nString typeOf(TValue v) {\n    switch (valType(v)) {\n    case ValType::Undefined:\n        return (String)sUndefinedTp;\n    case ValType::Boolean:\n        return (String)sBooleanTp;\n    case ValType::Number:\n        return (String)sNumberTp;\n    case ValType::String:\n        return (String)sStringTp;\n    case ValType::Object:\n        return (String)sObjectTp;\n    case ValType::Function:\n        return (String)sFunctionTp;\n    default:\n        oops(2);\n        return 0;\n    }\n}\n\n// Maybe in future we will want separate print methods; for now ignore\nvoid anyPrint(TValue v) {\n    if (valType(v) == ValType::Object) {\n        if (isRefCounted(v)) {\n            auto o = (RefObject *)v;\n            auto vt = getVTable(o);\n            auto meth = ((RefObjectMethod)vt->methods[1]);\n            if ((void *)meth == (void *)&anyPrint)\n                DMESG(\"[RefObject refs=%d vt=%p cl=%d sz=%d]\", REFCNT(o), o->vtable, vt->classNo,\n                      vt->numbytes);\n            else\n                meth(o);\n        } else {\n            DMESG(\"[Native %p]\", v);\n        }\n    } else {\n#ifndef X86_64\n        String s = numops::toString(v);\n        DMESG(\"[%s %p = %s]\", pxt::typeOf(v)->getUTF8Data(), v, s->getUTF8Data());\n        decr((TValue)s);\n#endif\n    }\n}\n\nstatic void dtorDoNothing() {}\n\n#ifdef PXT_GC\n#define PRIM_VTABLE(name, objectTp, tp, szexpr)                                                    \\\n    static uint32_t name##_size(tp *p) { return TOWORDS(sizeof(tp) + szexpr); }                    \\\n    DEF_VTABLE(name##_vt, tp, objectTp, (void *)&dtorDoNothing, (void *)&anyPrint, 0,              \\\n               (void *)&name##_size)\n#else\n#define PRIM_VTABLE(name, objectTp, tp, szexpr)                                                    \\\n    DEF_VTABLE(name##_vt, tp, objectTp, (void *)&dtorDoNothing, (void *)&anyPrint)\n#endif\n\n#define NOOP ((void)0)\n\n#define STRING_VT(name, fix, scan, gcsize, data, utfsize, length, dataAt)                          \\\n    static uint32_t name##_gcsize(BoxedString *p) { return TOWORDS(sizeof(void *) + (gcsize)); }   \\\n    static void name##_gcscan(BoxedString *p) { scan; }                                            \\\n    static const char *name##_data(BoxedString *p) {                                               \\\n        fix;                                                                                       \\\n        return data;                                                                               \\\n    }                                                                                              \\\n    static uint32_t name##_utfsize(BoxedString *p) {                                               \\\n        fix;                                                                                       \\\n        return utfsize;                                                                            \\\n    }                                                                                              \\\n    static uint32_t name##_length(BoxedString *p) {                                                \\\n        fix;                                                                                       \\\n        return length;                                                                             \\\n    }                                                                                              \\\n    static const char *name##_dataAt(BoxedString *p, uint32_t idx) {                               \\\n        fix;                                                                                       \\\n        return dataAt;                                                                             \\\n    }                                                                                              \\\n    DEF_VTABLE(name##_vt, BoxedString, ValType::String, (void *)&dtorDoNothing, (void *)&anyPrint, \\\n               (void *)&name##_gcscan, (void *)&name##_gcsize, (void *)&name##_data,               \\\n               (void *)&name##_utfsize, (void *)&name##_length, (void *)&name##_dataAt)\n\nvoid gcMarkArray(void *data);\nvoid gcScan(TValue v);\n\n#if PXT_UTF8\nstatic const char *skipLookup(BoxedString *p, uint32_t idx) {\n    if (idx > p->skip.length)\n        return NULL;\n    auto ent = idx / SKIP_INCR;\n    auto data = SKIP_DATA(p);\n    auto size = p->skip.size;\n    if (ent) {\n        auto off = p->skip.list[ent - 1];\n        data += off;\n        size -= off;\n        idx &= SKIP_INCR - 1;\n    }\n    return utf8Skip(data, size, idx);\n}\n\nextern LLSegment workQueue;\n\nstatic uint32_t fixSize(BoxedString *p, uint32_t *len) {\n    uint32_t tlen = 0;\n    uint32_t sz = 0;\n    if (workQueue.getLength())\n        oops(81);\n    workQueue.push((TValue)p);\n    while (workQueue.getLength()) {\n        p = (BoxedString *)workQueue.pop();\n        if (IS_CONS(p)) {\n            workQueue.push((TValue)p->cons.right);\n            workQueue.push((TValue)p->cons.left);\n        } else {\n            tlen += p->getLength();\n            sz += p->getUTF8Size();\n        }\n    }\n    *len = tlen;\n    return sz;\n}\n\nstatic void fixCopy(BoxedString *p, char *dst) {\n    if (workQueue.getLength())\n        oops(81);\n\n    workQueue.push((TValue)p);\n    while (workQueue.getLength()) {\n        p = (BoxedString *)workQueue.pop();\n        if (IS_CONS(p)) {\n            workQueue.push((TValue)p->cons.right);\n            workQueue.push((TValue)p->cons.left);\n        } else {\n            auto sz = p->getUTF8Size();\n            memcpy(dst, p->getUTF8Data(), sz);\n            dst += sz;\n        }\n    }\n}\n\n// switches CONS representation into skip list representation\n// does not switch representation of CONS' children\nstatic void fixCons(BoxedString *r) {\n    uint32_t length = 0;\n    auto sz = fixSize(r, &length);\n    auto numSkips = length / SKIP_INCR;\n    // allocate first, while [r] still holds references to its children\n    // because allocation might trigger GC\n    auto data = (uint16_t *)gcAllocateArray(numSkips * 2 + sz + 1);\n    // copy, while [r] is still cons\n    fixCopy(r, (char *)(data + numSkips));\n    // now, set [r] up properly\n    r->vtable = PXT_VTABLE_TO_INT(&string_skiplist16_vt);\n    r->skip.size = sz;\n    r->skip.length = length;\n    r->skip.list = data;\n    setupSkipList(r, NULL);\n}\n#endif\n\nSTRING_VT(string_inline_ascii, NOOP, NOOP, 2 + p->ascii.length + 1, p->ascii.data, p->ascii.length,\n          p->ascii.length, idx <= p->ascii.length ? p->ascii.data + idx : NULL)\n#if PXT_UTF8\nSTRING_VT(string_inline_utf8, NOOP, NOOP, 2 + p->utf8.length + 1, p->utf8.data, p->utf8.length,\n          utf8Len(p->utf8.data, p->utf8.length), utf8Skip(p->utf8.data, p->utf8.length, idx))\nSTRING_VT(string_skiplist16, NOOP, if (p->skip.list) gcMarkArray(p->skip.list), 2 * sizeof(void *),\n          SKIP_DATA(p), p->skip.size, p->skip.length, skipLookup(p, idx))\nSTRING_VT(string_cons, fixCons(p), (gcScan((TValue)p->cons.left), gcScan((TValue)p->cons.right)),\n          2 * sizeof(void *), SKIP_DATA(p), p->skip.size, p->skip.length, skipLookup(p, idx))\n#endif\n\nPRIM_VTABLE(number, ValType::Number, BoxedNumber, 0)\nPRIM_VTABLE(buffer, ValType::Object, BoxedBuffer, p->length)\n// PRIM_VTABLE(action, ValType::Function, RefAction, )\n\nvoid failedCast(TValue v) {\n    DMESG(\"failed type check for %p\", v);\n    auto vt = getAnyVTable(v);\n    if (vt) {\n        DMESG(\"VT %p - objtype %d classNo %d\", vt, vt->objectType, vt->classNo);\n    }\n\n    int code;\n    if (v == TAG_NULL)\n        code = PANIC_CAST_FROM_NULL;\n    else\n        code = PANIC_CAST_FIRST + (int)valType(v);\n    soft_panic(code);\n}\n\nvoid missingProperty(TValue v) {\n    DMESG(\"missing property on %p\", v);\n    soft_panic(PANIC_MISSING_PROPERTY);\n}\n\n#ifdef PXT_PROFILE\nstruct PerfCounter *perfCounters;\n\nstruct PerfCounterInfo {\n    uint32_t numPerfCounters;\n    char *perfCounterNames[0];\n};\n\n#define PERF_INFO ((PerfCounterInfo *)(((uintptr_t *)bytecode)[13]))\n\nvoid initPerfCounters() {\n    auto n = PERF_INFO->numPerfCounters;\n    perfCounters = new PerfCounter[n];\n    memset(perfCounters, 0, n * sizeof(PerfCounter));\n}\n\nvoid dumpPerfCounters() {\n    auto info = PERF_INFO;\n    DMESG(\"calls,us,name\");\n    for (uint32_t i = 0; i < info->numPerfCounters; ++i) {\n        auto c = &perfCounters[i];\n        DMESG(\"%d,%d,%s\", c->numstops, c->value, info->perfCounterNames[i]);\n    }\n}\n\nvoid startPerfCounter(PerfCounters n) {\n    auto c = &perfCounters[(uint32_t)n];\n    if (c->start)\n        oops(50);\n    c->start = PERF_NOW();\n}\n\nvoid stopPerfCounter(PerfCounters n) {\n    auto c = &perfCounters[(uint32_t)n];\n    if (!c->start)\n        oops(51);\n    c->value += PERF_NOW() - c->start;\n    c->start = 0;\n    c->numstops++;\n}\n#endif\n\n// Exceptions\n\n#ifndef PXT_EXN_CTX\n#define PXT_EXN_CTX() getThreadContext()\n#endif\n\ntypedef void (*RestoreStateType)(TryFrame *, ThreadContext *);\n#ifndef pxt_restore_exception_state\n#define pxt_restore_exception_state ((RestoreStateType)(((uintptr_t *)bytecode)[14]))\n#endif\n\n//%\nTryFrame *beginTry() {\n    auto ctx = PXT_EXN_CTX();\n    auto frame = (TryFrame *)app_alloc(sizeof(TryFrame));\n    frame->parent = ctx->tryFrame;\n    ctx->tryFrame = frame;\n    return frame;\n}\n\n//% expose\nvoid endTry() {\n    auto ctx = PXT_EXN_CTX();\n    auto f = ctx->tryFrame;\n    if (!f) oops(51);\n    ctx->tryFrame = f->parent;\n    app_free(f);\n}\n\n//% expose\nvoid throwValue(TValue v) {\n    auto ctx = PXT_EXN_CTX();\n    auto f = ctx->tryFrame;\n    if (!f) target_panic(PANIC_UNHANDLED_EXCEPTION);\n    ctx->tryFrame = f->parent;\n    TryFrame copy = *f;\n    app_free(f);\n    ctx->thrownValue = v;\n    pxt_restore_exception_state(&copy, ctx);\n}\n\n//% expose\nTValue getThrownValue() {\n    auto ctx = PXT_EXN_CTX();\n    auto v = ctx->thrownValue;\n    ctx->thrownValue = TAG_NON_VALUE;\n    if (v == TAG_NON_VALUE)\n        oops(51);\n    return v;\n}\n\n//% expose\nvoid endFinally() {\n    auto ctx = PXT_EXN_CTX();\n    if (ctx->thrownValue == TAG_NON_VALUE)\n        return;\n    throwValue(getThrownValue());\n}\n\n\n} // namespace pxt\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum NumberFormat {\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    }\n\n\n    declare const enum PerfCounters {\n    GC = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "eventcontext.ts": "namespace control {\n    /**\n     * Run code when a registered event happens.\n     * @param id the event compoent id\n     * @param value the event value to match\n     */\n    //% weight=20 blockGap=8 blockId=\"control_on_event\" block=\"on event|from %src|with value %value\"\n    //% blockExternalInputs=1\n    //% help=\"control/on-event\"\n    export function onEvent(src: number, value: number, handler: () => void, flags = 16) { // EVENT_LISTENER_DEFAULT_FLAGS\n        const ctx = control.eventContext();\n        if (!ctx)\n            control.internalOnEvent(src, value, handler, flags);\n        else\n            ctx.registerHandler(src, value, handler, flags);\n    }\n\n    class FrameCallback {\n        order: number\n        handler: () => void\n    }\n\n    class EventHandler {\n        src: number;\n        value: number;\n        handler: () => void;\n        flags: number;\n\n        constructor(src: number, value: number, handler: () => void, flags: number) {\n            this.src = src;\n            this.value = value;\n            this.handler = handler;\n        }\n\n        register() {\n            control.internalOnEvent(this.src, this.value, () => {\n                if (this.handler) this.handler();\n            }, this.flags)\n        }\n\n        unregister() {\n            control.internalOnEvent(this.src, this.value, doNothing, this.flags);\n        }\n    }\n\n    function doNothing() { }\n\n\n\n    export class EventContext {\n        private handlers: EventHandler[];\n        private frameCallbacks: FrameCallback[];\n        private frameWorker: number;\n        private framesInSample: number;\n        private timeInSample: number;\n        public deltaTimeMillis: number;\n        private prevTimeMillis: number;\n        private idleCallbacks: (() => void)[];\n\n        static lastStats: string;\n        static onStats: (stats: string) => void;\n\n        constructor() {\n            this.handlers = [];\n            this.framesInSample = 0;\n            this.timeInSample = 0;\n            this.deltaTimeMillis = 0;\n            this.frameWorker = 0;\n            this.idleCallbacks = undefined;\n        }\n\n        get deltaTime() {\n            return this.deltaTimeMillis / 1000;\n        }\n\n        private runCallbacks() {\n            control.enablePerfCounter(\"all frame callbacks\")\n\n            let loopStart = control.millis()\n            this.deltaTimeMillis = loopStart - this.prevTimeMillis;\n            this.prevTimeMillis = loopStart;\n            for (let f of this.frameCallbacks) {\n                f.handler()\n            }\n            let runtime = control.millis() - loopStart\n            this.timeInSample += runtime\n            this.framesInSample++\n            if (this.timeInSample > 1000 || this.framesInSample > 30) {\n                const fps = this.framesInSample / (this.timeInSample / 1000);\n                EventContext.lastStats = `fps:${Math.round(fps)}`;\n                if (fps < 99)\n                    EventContext.lastStats += \".\" + (Math.round(fps * 10) % 10)\n                if (control.profilingEnabled()) {\n                    control.dmesg(`${(fps * 100) | 0}/100 fps - ${this.framesInSample} frames`)\n                    control.gc()\n                    control.dmesgPerfCounters()\n                }\n                this.timeInSample = 0\n                this.framesInSample = 0\n            }\n            let delay = Math.max(1, 20 - runtime)\n            return delay\n        }\n\n        private registerFrameCallbacks() {\n            if (!this.frameCallbacks) return;\n\n            this.framesInSample = 0;\n            this.timeInSample = 0;\n            this.deltaTimeMillis = 0;\n            this.prevTimeMillis = control.millis();\n            const worker = this.frameWorker;\n            control.runInParallel(() => {\n                while (worker == this.frameWorker) {\n                    let delay = this.runCallbacks()\n                    pause(delay)\n                }\n            })\n        }\n\n        register() {\n            for (const h of this.handlers)\n                h.register();\n            this.registerFrameCallbacks();\n        }\n\n        unregister() {\n            for (const h of this.handlers)\n                h.unregister();\n            this.frameWorker++;\n        }\n\n        registerFrameHandler(order: number, handler: () => void) {\n            if (!this.frameCallbacks) {\n                this.frameCallbacks = [];\n                this.registerFrameCallbacks();\n            }\n\n            const fn = new FrameCallback()\n            fn.order = order\n            fn.handler = handler\n            for (let i = 0; i < this.frameCallbacks.length; ++i) {\n                if (this.frameCallbacks[i].order > order) {\n                    this.frameCallbacks.insertAt(i, fn)\n                    return\n                }\n            }\n            this.frameCallbacks.push(fn)\n        }\n\n        registerHandler(src: number, value: number, handler: () => void, flags: number) {\n            // already there?\n            for (const h of this.handlers) {\n                if (h.src == src && h.value == value) {\n                    h.flags = flags;\n                    h.handler = handler;\n                    return;\n                }\n            }\n            // register and push\n            const hn = new EventHandler(src, value, handler, flags);\n            this.handlers.push(hn);\n            hn.register();\n        }\n\n        addIdleHandler(handler: () => void) {\n            if (!this.idleCallbacks) {\n                this.idleCallbacks = [];\n                this.registerHandler(15/*DAL.DEVICE_ID_SCHEDULER*/, 2/*DAL.DEVICE_SCHEDULER_EVT_IDLE*/, () => this.runIdleHandler(), 16);\n            }\n            this.idleCallbacks.push(handler);\n        }\n\n        removeIdleHandler(handler: () => void) {\n            if (handler && this.idleCallbacks)\n                this.idleCallbacks.removeElement(handler);\n        }\n\n        private runIdleHandler() {\n            if (this.idleCallbacks) {\n                const ics = this.idleCallbacks.slice(0);\n                ics.forEach(ic => ic());\n            }\n        }    \n    }\n    let eventContexts: EventContext[];\n\n    /**\n     * Gets the current event context if any\n     */\n    export function eventContext(): EventContext {\n        return eventContexts ? eventContexts[eventContexts.length - 1] : undefined;\n    }\n\n    /**\n     * Pushes a new event context and clears all handlers\n     */\n    export function pushEventContext(): EventContext {\n        if (!eventContexts)\n            eventContexts = [];\n\n        // unregister previous context\n        const ctx = eventContext();\n        if (ctx) ctx.unregister();\n        // register again\n        const n = new EventContext();\n        eventContexts.push(n);\n        return n;\n    }\n\n    /**\n     * Pops the current event context and restore handlers if any previous context\n     */\n    export function popEventContext() {\n        if (!eventContexts) return;\n\n        // clear current context\n        const ctx = eventContexts.pop();\n        if (!ctx) return;\n        ctx.unregister();\n\n        // register old context again\n        const context = eventContexts[eventContexts.length - 1];\n        if (context)\n            context.register();\n        else\n            eventContexts = undefined;\n    }\n\n    let _idleCallbacks: (() => void)[];\n    /**\n     * Registers a function to run when the device is idling\n     * @param handler \n    */\n    export function onIdle(handler: () => void) {\n        if (!handler) return;\n\n        const ctx = eventContext();\n        if (ctx) ctx.addIdleHandler(handler);\n        else {\n            if (!_idleCallbacks) {\n                _idleCallbacks = [];\n                control.runInBackground(function() {\n                    while(_idleCallbacks) {\n                        _idleCallbacks.slice(0).forEach(cb => cb());\n                        pause(20);\n                    }\n                })\n                /*\n                control.internalOnEvent(\n                    15. // DAL.DEVICE_ID_SCHEDULER\n                    2, // DAL.DEVICE_SCHEDULER_EVT_IDLE\n                    function() {\n                        pins.LED.digitalWrite(on = !on);\n                        if (_idleCallbacks)\n                            _idleCallbacks.slice(0).forEach(cb => cb());\n                    }, 192); // MESSAGE_BUS_LISTENER_IMMEDIATE\n                */\n            }\n            _idleCallbacks.push(handler);\n        }\n    }\n\n    export function removeIdleHandler(handler: () => void) {\n        if (!handler) return;\n        const ctx = eventContext();\n        if (ctx) ctx.removeIdleHandler(handler);\n        else if (_idleCallbacks) _idleCallbacks.removeElement(handler);\n    }\n}",
            "fixed.ts": "interface Fx8 {\n    _dummyFx8: string;\n}\n\nfunction Fx8(v: number) {\n    return ((v * 256) | 0) as any as Fx8\n}\n\nnamespace Fx {\n    export const zeroFx8 = 0 as any as Fx8\n    export const oneHalfFx8 = Fx8(0.5)\n    export const oneFx8 = 1 as any as Fx8\n    export const twoFx8 = 2 as any as Fx8\n\n    export function neg(a: Fx8) {\n        return (-(a as any as number)) as any as Fx8\n    }\n    export function toIntShifted(a: Fx8, n: number) {\n        return (a as any as number) >> (n + 8)\n    }\n    export function add(a: Fx8, b: Fx8) {\n        return ((a as any as number) + (b as any as number)) as any as Fx8\n    }\n    export function iadd(a: number, b: Fx8) {\n        return ((a << 8) + (b as any as number)) as any as Fx8\n    }\n    export function sub(a: Fx8, b: Fx8) {\n        return ((a as any as number) - (b as any as number)) as any as Fx8\n    }\n    export function mul(a: Fx8, b: Fx8) {\n        return (Math.imul((a as any as number), (b as any as number)) >> 8) as any as Fx8\n    }\n    export function div(a: Fx8, b: Fx8) {\n        return Math.idiv((a as any as number) << 8, b as any as number) as any as Fx8\n    }\n    export function idiv(a: Fx8, b: number) {\n        return Math.idiv((a as any as number), b) as any as Fx8\n    }\n    export function compare(a: Fx8, b: Fx8) {\n        return (a as any as number) - (b as any as number)\n    }\n    export function abs(a: Fx8) {\n        if ((a as any as number) < 0)\n            return (-(a as any as number)) as any as Fx8\n        else\n            return a\n    }\n    export function min(a: Fx8, b: Fx8) {\n        if (a < b)\n            return a\n        else\n            return b\n    }\n    export function max(a: Fx8, b: Fx8) {\n        if (a > b)\n            return a\n        else\n            return b\n    }\n    export function leftShift(a: Fx8, n: number) {\n        return (a as any as number << n) as any as Fx8\n    }\n    export function rightShift(a: Fx8, n: number) {\n        return (a as any as number >> n) as any as Fx8\n    }\n    export function toInt(v: Fx8) {\n        return ((v as any as number) + 128) >> 8\n    }\n    export function toFloat(v: Fx8) {\n        return (v as any as number) / 256\n    }\n}",
            "forever.ts": "// implemented in game",
            "gc.cpp": "#include \"pxtbase.h\"\n\n#ifndef GC_BLOCK_SIZE\n#define GC_BLOCK_SIZE (1024 * 16)\n#endif\n\n#ifndef GC_MAX_ALLOC_SIZE\n#define GC_MAX_ALLOC_SIZE (GC_BLOCK_SIZE - 16)\n#endif\n\n#ifndef GC_ALLOC_BLOCK\n#define GC_ALLOC_BLOCK xmalloc\n#endif\n\n#ifdef PXT64\n#define HIGH_SHIFT 48\n#define BYTES_TO_WORDS(x) ((x) >> 3)\n#define WORDS_TO_BYTES(x) ((x) << 3)\n#define ALIGN_TO_WORD(x) (((x) + 7) & (~7ULL))\n#define VAR_BLOCK_WORDS(vt) ((uint32_t)(vt) >> 2)\n#else\n#define HIGH_SHIFT 28\n#define BYTES_TO_WORDS(x) ((x) >> 2)\n#define WORDS_TO_BYTES(x) ((x) << 2)\n#define ALIGN_TO_WORD(x) (((x) + 3) & (~3U))\n#define VAR_BLOCK_WORDS(vt) (((uint32_t)(vt) << 4) >> (4 + 2))\n#endif\n\n#define FREE_MASK (1ULL << (HIGH_SHIFT + 3))\n#define ARRAY_MASK (1ULL << (HIGH_SHIFT + 2))\n#define PERMA_MASK (1ULL << (HIGH_SHIFT + 1))\n#define MARKED_MASK 0x1\n#define ANY_MARKED_MASK 0x3\n\n// the bit operations should be faster than loading large constants\n#define IS_FREE(vt) ((uintptr_t)(vt) >> (HIGH_SHIFT + 3))\n#define IS_ARRAY(vt) (((uintptr_t)(vt) >> (HIGH_SHIFT + 2)) & 1)\n#define IS_PERMA(vt) (((uintptr_t)(vt) >> (HIGH_SHIFT + 1)) & 1)\n#define IS_VAR_BLOCK(vt) ((uintptr_t)(vt) >> (HIGH_SHIFT + 2))\n#define IS_MARKED(vt) ((uintptr_t)(vt)&MARKED_MASK)\n#define IS_LIVE(vt) (IS_MARKED(vt) || (((uintptr_t)(vt) >> (HIGH_SHIFT)) == 0x6))\n\n//#define PXT_GC_DEBUG 1\n#ifndef PXT_GC_CHECKS\n#define PXT_GC_CHECKS 1\n#endif\n//#define PXT_GC_STRESS 1\n\n//#define PXT_GC_CHECKS 1\n\n#define MARK(v)                                                                                    \\\n    do {                                                                                           \\\n        GC_CHECK(inGCArea(v), 42);                                                                 \\\n        *(uintptr_t *)(v) |= MARKED_MASK;                                                          \\\n    } while (0)\n\n#ifdef PXT_GC_DEBUG\n#define LOG DMESG\n#define VLOG DMESG\n#define VVLOG DMESG\n#else\n#define LOG NOLOG\n#define VLOG NOLOG\n#define VVLOG NOLOG\n#endif\n\n#ifdef PXT_GC_CHECKS\n#define GC_CHECK(cond, code)                                                                       \\\n    if (!(cond))                                                                                   \\\n    oops(code)\n#else\n#define GC_CHECK(cond, code) ((void)0)\n#endif\n\nnamespace pxt {\n\n//%\nvoid popThreadContext(ThreadContext *ctx);\n//%\nThreadContext *pushThreadContext(void *sp, void *endSP);\n\nunsigned RefRecord_gcsize(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    return BYTES_TO_WORDS(tbl->numbytes);\n}\n\n#ifndef PXT_GC\n// dummies, to make the linker happy\nvoid popThreadContext(ThreadContext *ctx) {}\nThreadContext *pushThreadContext(void *sp, void *endSP) {\n    return NULL;\n}\nvoid RefRecord_scan(RefRecord *r) {}\n#else\n\n#ifdef PXT_GC_THREAD_LIST\nThreadContext *threadContexts;\n#endif\n\n#define IN_GC_ALLOC 1\n#define IN_GC_COLLECT 2\n#define IN_GC_FREEZE 4\n#define IN_GC_PREALLOC 8\n\n#ifndef PXT_VM\nstatic TValue *tempRoot;\nstatic uint8_t tempRootLen;\n#endif\n\nuint8_t inGC;\n\nvoid popThreadContext(ThreadContext *ctx) {\n#ifndef PXT_VM\n    VLOG(\"pop: %p\", ctx);\n\n    if (!ctx)\n        return;\n\n    auto n = ctx->stack.next;\n    if (n) {\n        VLOG(\"seg %p\", n);\n        ctx->stack.top = n->top;\n        ctx->stack.bottom = n->bottom;\n        ctx->stack.next = n->next;\n        app_free(n);\n    } else {\n#ifdef PXT_GC_THREAD_LIST\n        if (ctx->next)\n            ctx->next->prev = ctx->prev;\n        if (ctx->prev)\n            ctx->prev->next = ctx->next;\n        else {\n            if (threadContexts != ctx)\n                oops(41);\n            threadContexts = ctx->next;\n            if (threadContexts)\n                threadContexts->prev = NULL;\n        }\n#endif\n        app_free(ctx);\n        setThreadContext(NULL);\n    }\n#endif\n}\n\n#define ALLOC(tp) (tp *)app_alloc(sizeof(tp))\n\nThreadContext *pushThreadContext(void *sp, void *endSP) {\n#ifdef PXT_VM\n    return NULL;\n#else\n    if (PXT_IN_ISR())\n        target_panic(PANIC_CALLED_FROM_ISR);\n\n    auto curr = getThreadContext();\n    tempRoot = (TValue *)endSP;\n    tempRootLen = (uintptr_t *)sp - (uintptr_t *)endSP;\n    if (curr) {\n#ifdef PXT_GC_THREAD_LIST\n#ifdef PXT_GC_DEBUG\n        auto ok = false;\n        for (auto p = threadContexts; p; p = p->next)\n            if (p == curr) {\n                ok = true;\n                break;\n            }\n        if (!ok)\n            oops(49);\n#endif\n#endif\n        auto seg = ALLOC(StackSegment);\n        VLOG(\"stack %p / %p\", seg, curr);\n        seg->top = curr->stack.top;\n        seg->bottom = curr->stack.bottom;\n        seg->next = curr->stack.next;\n        curr->stack.next = seg;\n    } else {\n        curr = ALLOC(ThreadContext);\n        LOG(\"push: %p\", curr);\n        curr->globals = globals;\n        curr->stack.next = NULL;\n        curr->thrownValue = TAG_NON_VALUE;\n        curr->tryFrame = NULL;\n\n#ifdef PXT_GC_THREAD_LIST\n        curr->next = threadContexts;\n        curr->prev = NULL;\n        if (curr->next)\n            curr->next->prev = curr;\n        threadContexts = curr;\n#endif\n        setThreadContext(curr);\n    }\n    tempRootLen = 0;\n    curr->stack.bottom = sp;\n    curr->stack.top = NULL;\n    return curr;\n#endif\n}\n\nclass RefBlock : public RefObject {\n  public:\n    RefBlock *nextFree;\n};\n\nstruct GCBlock {\n    GCBlock *next;\n    uint32_t blockSize;\n    RefObject data[0];\n};\n\nstruct PendingArray {\n    PendingArray *next;\n    TValue *data;\n    unsigned len;\n};\n\n#define PENDING_ARRAY_THR 100\n\nstatic PendingArray *pendingArrays;\nstatic LLSegment gcRoots;\nLLSegment workQueue; // (ab)used by consString making\nstatic GCBlock *firstBlock;\nstatic RefBlock *firstFree;\nstatic uint8_t *midPtr;\n\nstatic bool inGCArea(void *ptr) {\n    for (auto block = firstBlock; block; block = block->next) {\n        if ((void *)block->data <= ptr && ptr < (void *)((uint8_t *)block->data + block->blockSize))\n            return true;\n    }\n    return false;\n}\n\n#define NO_MAGIC(vt) ((VTable *)vt)->magic != VTABLE_MAGIC\n#define VT(p) (*(uintptr_t *)(p))\n#define SKIP_PROCESSING(p)                                                                         \\\n    (isReadOnly(p) || (VT(p) & (ANY_MARKED_MASK | ARRAY_MASK)) || NO_MAGIC(VT(p)))\n\nvoid gcMarkArray(void *data) {\n    auto segBl = (uintptr_t *)data - 1;\n    GC_CHECK(!IS_MARKED(VT(segBl)), 47);\n    MARK(segBl);\n}\n\nvoid gcScan(TValue v) {\n    if (SKIP_PROCESSING(v))\n        return;\n    MARK(v);\n    workQueue.push(v);\n}\n\nvoid gcScanMany(TValue *data, unsigned len) {\n    // VLOG(\"scan: %p %d\", data, len);\n    for (unsigned i = 0; i < len; ++i) {\n        auto v = data[i];\n        // VLOG(\"psh: %p %d %d\", v, isReadOnly(v), (*(uint32_t *)v & 1));\n        if (SKIP_PROCESSING(v))\n            continue;\n        MARK(v);\n        workQueue.push(v);\n        if (workQueue.getLength() > PENDING_ARRAY_THR) {\n            i++;\n            // store rest of the work for later, when we have cleared the queue\n            auto pa = (PendingArray *)xmalloc(sizeof(PendingArray));\n            pa->next = pendingArrays;\n            pa->data = data + i;\n            pa->len = len - i;\n            pendingArrays = pa;\n            break;\n        }\n    }\n}\n\nvoid gcScanSegment(Segment &seg) {\n    auto data = seg.getData();\n    if (!data)\n        return;\n    VVLOG(\"seg %p %d\", data, seg.getLength());\n    gcMarkArray(data);\n    gcScanMany(data, seg.getLength());\n}\n\n#define getScanMethod(vt) ((RefObjectMethod)(((VTable *)(vt))->methods[2]))\n#define getSizeMethod(vt) ((RefObjectSizeMethod)(((VTable *)(vt))->methods[3]))\n\nvoid gcProcess(TValue v) {\n    if (SKIP_PROCESSING(v))\n        return;\n    VVLOG(\"gcProcess: %p\", v);\n    MARK(v);\n    auto scan = getScanMethod(VT(v) & ~ANY_MARKED_MASK);\n    if (scan)\n        scan((RefObject *)v);\n    for (;;) {\n        while (workQueue.getLength()) {\n            auto curr = (RefObject *)workQueue.pop();\n            VVLOG(\" - %p\", curr);\n            scan = getScanMethod(curr->vtable & ~ANY_MARKED_MASK);\n            if (scan)\n                scan(curr);\n        }\n        if (pendingArrays) {\n            auto pa = pendingArrays;\n            pendingArrays = pa->next;\n            auto data = pa->data;\n            auto len = pa->len;\n            xfree(pa);\n            gcScanMany(data, len);\n        } else {\n            break;\n        }\n    }\n}\n\nstatic void mark(int flags) {\n#ifdef PXT_GC_DEBUG\n    flags |= 2;\n#endif\n    auto data = gcRoots.getData();\n    auto len = gcRoots.getLength();\n    if (flags & 2) {\n        DMESG(\"--MARK\");\n        DMESG(\"RP:%p/%d\", data, len);\n    }\n    for (unsigned i = 0; i < len; ++i) {\n        auto d = data[i];\n        if ((uintptr_t)d & 1) {\n            d = *(TValue *)((uintptr_t)d & ~1);\n        }\n        gcProcess(d);\n    }\n\n#ifdef PXT_GC_THREAD_LIST\n    for (auto ctx = threadContexts; ctx; ctx = ctx->next) {\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(ctx, seg->top);\n            auto end = (TValue *)threadAddressFor(ctx, seg->bottom);\n            VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n#else\n    gcProcessStacks(flags);\n#endif\n\n    if (globals) {\n#ifdef PXT_VM\n        auto nonPtrs = vmImg->infoHeader->nonPointerGlobals;\n#else\n        auto nonPtrs = bytecode[21];\n#endif\n        len = getNumGlobals() - nonPtrs;\n        data = globals + nonPtrs;\n        if (flags & 2)\n            DMESG(\"RG:%p/%d\", data, len);\n        VLOG(\"globals: %p %d\", data, len);\n        for (unsigned i = 0; i < len; ++i) {\n            gcProcess(*data++);\n        }\n    }\n\n#ifndef PXT_VM\n    data = tempRoot;\n    len = tempRootLen;\n    for (unsigned i = 0; i < len; ++i) {\n        gcProcess(*data++);\n    }\n#endif\n}\n\nstatic uint32_t getObjectSize(RefObject *o) {\n    auto vt = o->vtable & ~ANY_MARKED_MASK;\n    uint32_t r;\n    GC_CHECK(vt != 0, 49);\n    if (IS_VAR_BLOCK(vt)) {\n        r = VAR_BLOCK_WORDS(vt);\n    } else {\n        auto sz = getSizeMethod(vt);\n        // GC_CHECK(0x2000 <= (intptr_t)sz && (intptr_t)sz <= 0x100000, 47);\n        r = sz(o);\n    }\n    GC_CHECK(1 <= r && (r <= BYTES_TO_WORDS(GC_MAX_ALLOC_SIZE) || IS_FREE(vt)), 41);\n    return r;\n}\n\nstatic void setupFreeBlock(GCBlock *curr) {\n    curr->data[0].vtable = FREE_MASK | (TOWORDS(curr->blockSize) << 2);\n    ((RefBlock *)curr->data)[0].nextFree = firstFree;\n    firstFree = (RefBlock *)curr->data;\n    midPtr = (uint8_t *)curr->data + curr->blockSize / 4;\n}\n\nstatic void linkFreeBlock(GCBlock *curr) {\n    // blocks need to be sorted by address for midPtr to work\n    if (!firstBlock || curr < firstBlock) {\n        curr->next = firstBlock;\n        firstBlock = curr;\n    } else {\n        for (auto p = firstBlock; p; p = p->next) {\n            if (!p->next || curr < p->next) {\n                curr->next = p->next;\n                p->next = curr;\n                break;\n            }\n        }\n    }\n}\n\nvoid gcPreAllocateBlock(uint32_t sz) {\n    auto curr = (GCBlock *)GC_ALLOC_BLOCK(sz);\n    curr->blockSize = sz - sizeof(GCBlock);\n    LOG(\"GC pre-alloc: %p\", curr);\n    GC_CHECK((curr->blockSize & 3) == 0, 40);\n    setupFreeBlock(curr);\n    linkFreeBlock(curr);\n}\n\nstatic GCBlock *allocateBlockCore() {\n    int sz = GC_BLOCK_SIZE;\n    void *dummy = NULL;\n#ifdef GC_GET_HEAP_SIZE\n    if (firstBlock) {\n#ifdef GC_STACK_BASE\n        if (!firstBlock->next) {\n            int memSize = getConfig(CFG_RAM_BYTES, 0);\n            int codalEnd = GC_STACK_BASE;\n            // round up to 1k - there is sometimes a few bytes below the stack\n            codalEnd = (codalEnd + 1024) & ~1023;\n            int codalSize = codalEnd & 0xffffff;\n            sz = memSize - codalSize - 4;\n            if (sz > 0) {\n                auto curr = (GCBlock *)codalEnd;\n                curr->blockSize = sz - sizeof(GCBlock);\n                return curr;\n            }\n        }\n#endif\n        gc(2); // dump roots\n        target_panic(PANIC_GC_OOM);\n    }\n    auto lowMem = getConfig(CFG_LOW_MEM_SIMULATION_KB, 0);\n    auto sysHeapSize = getConfig(CFG_SYSTEM_HEAP_BYTES, 4 * 1024);\n    auto heapSize = GC_GET_HEAP_SIZE();\n    sz = heapSize - sysHeapSize;\n    if (lowMem) {\n        auto memIncrement = 32 * 1024;\n        // get the memory size - assume it's increment of 32k,\n        // and we don't statically allocate more than 32k\n        auto memSize = ((heapSize + memIncrement - 1) / memIncrement) * memIncrement;\n        int fillerSize = memSize - lowMem * 1024;\n        if (fillerSize > 0) {\n            dummy = GC_ALLOC_BLOCK(fillerSize);\n            sz -= fillerSize;\n        }\n    }\n#endif\n    auto curr = (GCBlock *)GC_ALLOC_BLOCK(sz);\n    curr->blockSize = sz - sizeof(GCBlock);\n    // make sure reference to allocated block is stored somewhere, otherwise\n    // GCC optimizes out the call to GC_ALLOC_BLOCK\n    curr->data[4].vtable = (uint32_t)(uintptr_t)dummy;\n    return curr;\n}\n\n__attribute__((noinline)) static void allocateBlock() {\n    auto curr = allocateBlockCore();\n    LOG(\"GC alloc: %p\", curr);\n    GC_CHECK((curr->blockSize & 3) == 0, 40);\n    setupFreeBlock(curr);\n    linkFreeBlock(curr);\n}\n\nstatic void sweep(int flags) {\n    RefBlock *prevFreePtr = NULL;\n    uint32_t freeSize = 0;\n    uint32_t totalSize = 0;\n    firstFree = NULL;\n\n    for (auto h = firstBlock; h; h = h->next) {\n        auto d = h->data;\n        auto words = BYTES_TO_WORDS(h->blockSize);\n        auto end = d + words;\n        totalSize += words;\n        VLOG(\"sweep: %p - %p\", d, end);\n        while (d < end) {\n            if (IS_LIVE(d->vtable)) {\n                VVLOG(\"Live %p\", d);\n                d->vtable &= ~MARKED_MASK;\n                d += getObjectSize(d);\n            } else {\n                auto start = (RefBlock *)d;\n                while (d < end) {\n                    if (IS_FREE(d->vtable)) {\n                        VVLOG(\"Free %p\", d);\n                    } else if (IS_LIVE(d->vtable)) {\n                        break;\n                    } else if (IS_ARRAY(d->vtable)) {\n                        VVLOG(\"Dead Arr %p\", d);\n                    } else {\n                        VVLOG(\"Dead Obj %p\", d);\n                        GC_CHECK(((VTable *)d->vtable)->magic == VTABLE_MAGIC, 41);\n                        d->destroyVT();\n                        VVLOG(\"destroyed\");\n                    }\n                    d += getObjectSize(d);\n                }\n                auto sz = d - (RefObject *)start;\n                freeSize += sz;\n#ifdef PXT_GC_CHECKS\n                memset(start, 0xff, WORDS_TO_BYTES(sz));\n#endif\n                start->vtable = (sz << 2) | FREE_MASK;\n                if (sz > 1) {\n                    start->nextFree = NULL;\n                    if (!prevFreePtr) {\n                        firstFree = start;\n                    } else {\n                        prevFreePtr->nextFree = start;\n                    }\n                    prevFreePtr = start;\n                }\n            }\n        }\n    }\n\n    if (midPtr) {\n        uint32_t currFree = 0;\n        auto limit = freeSize >> 2;\n        for (auto p = firstFree; p; p = p->nextFree) {\n            currFree += VAR_BLOCK_WORDS(p->vtable);\n            if (currFree > limit) {\n                midPtr = (uint8_t *)p + ((currFree - limit) << 2);\n                break;\n            }\n        }\n    }\n\n    freeSize = WORDS_TO_BYTES(freeSize);\n    totalSize = WORDS_TO_BYTES(totalSize);\n\n    if (flags & 1)\n        DMESG(\"GC %d/%d free\", freeSize, totalSize);\n    else\n        LOG(\"GC %d/%d free\", freeSize, totalSize);\n\n#ifndef GC_GET_HEAP_SIZE\n    // if the heap is 90% full, allocate a new block\n    if (freeSize * 10 <= totalSize) {\n        allocateBlock();\n    }\n#endif\n}\n\nvoid gc(int flags) {\n    startPerfCounter(PerfCounters::GC);\n    GC_CHECK(!(inGC & IN_GC_COLLECT), 40);\n    inGC |= IN_GC_COLLECT;\n    VLOG(\"GC mark\");\n    mark(flags);\n    VLOG(\"GC sweep\");\n    sweep(flags);\n    VLOG(\"GC done\");\n    stopPerfCounter(PerfCounters::GC);\n    inGC &= ~IN_GC_COLLECT;\n}\n\n#ifdef GC_GET_HEAP_SIZE\nextern \"C\" void free(void *ptr) {\n    if (!ptr)\n        return;\n    if (inGCArea(ptr))\n        app_free(ptr);\n    else\n        xfree(ptr);\n}\n\nextern \"C\" void *malloc(size_t sz) {\n    if (PXT_IN_ISR() || inGC)\n        return xmalloc(sz);\n    else\n        return app_alloc(sz);\n}\n\nextern \"C\" void *realloc(void *ptr, size_t size) {\n    if (inGCArea(ptr)) {\n        void *mem = malloc(size);\n\n        if (ptr != NULL && mem != NULL) {\n            auto r = (uintptr_t *)ptr;\n            GC_CHECK((r[-1] >> (HIGH_SHIFT + 1)) == 3, 41);\n            size_t blockSize = VAR_BLOCK_WORDS(r[-1]);\n            memcpy(mem, ptr, min(blockSize * sizeof(void *), size));\n            free(ptr);\n        }\n\n        return mem;\n    } else {\n        return device_realloc(ptr, size);\n    }\n}\n#endif\n\nvoid *gcAllocateArray(int numbytes) {\n    numbytes = ALIGN_TO_WORD(numbytes);\n    numbytes += sizeof(void *);\n    auto r = (uintptr_t *)gcAllocate(numbytes);\n    *r = ARRAY_MASK | (TOWORDS(numbytes) << 2);\n    return r + 1;\n}\n\nvoid *app_alloc(int numbytes) {\n    if (!numbytes)\n        return NULL;\n\n    // gc(0);\n    auto r = (uintptr_t *)gcAllocateArray(numbytes);\n    r[-1] |= PERMA_MASK;\n    return r;\n}\n\nvoid *app_free(void *ptr) {\n    auto r = (uintptr_t *)ptr;\n    GC_CHECK((r[-1] >> (HIGH_SHIFT + 1)) == 3, 41);\n    r[-1] |= FREE_MASK;\n    return r;\n}\n\nvoid gcFreeze() {\n    inGC |= IN_GC_FREEZE;\n}\n\nvoid gcReset() {\n    inGC &= ~IN_GC_FREEZE;\n\n    gcRoots.setLength(0);\n\n    if (inGC)\n        oops(41);\n\n    if (workQueue.getLength())\n        oops(41);\n\n    firstFree = NULL;\n    for (auto h = firstBlock; h; h = h->next) {\n        setupFreeBlock(h);\n    }\n}\n\n#ifdef PXT_VM\nstatic uint8_t *preallocBlock;\nstatic uint8_t *preallocPointer;\n\n#define PREALLOC_SIZE (1024 * 1024)\n\nvoid gcPreStartup() {\n    xfree(preallocBlock);\n    preallocBlock = (uint8_t *)xmalloc(PREALLOC_SIZE);\n    preallocPointer = preallocBlock;\n    if (!isReadOnly((TValue)preallocBlock))\n        oops(40);\n    inGC |= IN_GC_PREALLOC;\n}\n\nvoid gcStartup() {\n    inGC &= ~IN_GC_PREALLOC;\n    preallocPointer = NULL;\n}\n\nvoid *gcPrealloc(int numbytes) {\n    if (!preallocPointer)\n        oops(49);\n    void *r = preallocPointer;\n    preallocPointer += ALIGN_TO_WORD(numbytes);\n    if (preallocPointer > preallocBlock + PREALLOC_SIZE) {\n        DMESG(\"pre-alloc size exceeded! block=%p ptr=%p sz=%d\", preallocBlock, preallocPointer,\n              (int)PREALLOC_SIZE);\n        oops(48);\n    }\n    return r;\n}\n\nbool inGCPrealloc() {\n    return (inGC & IN_GC_PREALLOC) != 0;\n}\n#endif\n\nvoid *gcAllocate(int numbytes) {\n    size_t numwords = BYTES_TO_WORDS(ALIGN_TO_WORD(numbytes));\n    // VVLOG(\"alloc %d bytes %d words\", numbytes, numwords);\n\n    if (numbytes > GC_MAX_ALLOC_SIZE)\n        target_panic(PANIC_GC_TOO_BIG_ALLOCATION);\n\n    if (PXT_IN_ISR() || (inGC & (IN_GC_ALLOC | IN_GC_COLLECT | IN_GC_FREEZE)))\n        target_panic(PANIC_CALLED_FROM_ISR);\n\n#ifdef PXT_VM\n    if (inGCPrealloc())\n        return gcPrealloc(numbytes);\n#endif\n\n    inGC |= IN_GC_ALLOC;\n\n#if defined(PXT_GC_CHECKS) && !defined(PXT_VM)\n    {\n        auto curr = getThreadContext();\n        if (curr && !curr->stack.top)\n            oops(46);\n    }\n#endif\n\n#ifdef PXT_GC_STRESS\n    gc(0);\n#endif\n\n    for (int i = 0;; ++i) {\n        RefBlock *prev = NULL;\n        for (auto p = firstFree; p; p = p->nextFree) {\n            VVLOG(\"p=%p\", p);\n            if (i == 0 && (uint8_t *)p > midPtr) {\n                VLOG(\"past midptr %p; gc\", midPtr);\n                break;\n            }\n            GC_CHECK(!isReadOnly((TValue)p), 49);\n            auto vt = p->vtable;\n            if (!IS_FREE(vt))\n                oops(43);\n            int left = (int)(VAR_BLOCK_WORDS(vt) - numwords);\n            VVLOG(\"%p %d - %d = %d\", (void *)vt, (int)VAR_BLOCK_WORDS(vt), (int)numwords, left);\n            if (left >= 0) {\n                auto nf = (RefBlock *)((void **)p + numwords);\n                auto nextFree = p->nextFree; // p and nf can overlap when allocating 4 bytes\n                // VVLOG(\"nf=%p nef=%p\", nf, nextFree);\n                if (left)\n                    nf->vtable = (left << 2) | FREE_MASK;\n                if (left >= 2) {\n                    nf->nextFree = nextFree;\n                } else {\n                    nf = nextFree;\n                }\n                if (prev)\n                    prev->nextFree = nf;\n                else\n                    firstFree = nf;\n                p->vtable = 0;\n                VVLOG(\"GC=>%p %d %p -> %p,%p\", p, numwords, nf, nf ? nf->nextFree : 0,\n                      nf ? (void *)nf->vtable : 0);\n                GC_CHECK(!nf || !nf->nextFree || !isReadOnly((TValue)nf->nextFree), 48);\n                inGC &= ~IN_GC_ALLOC;\n                return p;\n            }\n            prev = p;\n        }\n\n        // we didn't find anything, try GC\n        if (i == 0)\n            gc(0);\n        // GC didn't help, try new block\n        else if (i == 1)\n            allocateBlock();\n        else\n            oops(44);\n    }\n}\n\nstatic void removePtr(TValue v) {\n    int len = gcRoots.getLength();\n    auto data = gcRoots.getData();\n    // scan from the back, as this is often used as a stack\n    for (int i = len - 1; i >= 0; --i) {\n        if (data[i] == v) {\n            if (i == len - 1) {\n                gcRoots.pop();\n            } else {\n                data[i] = gcRoots.pop();\n            }\n            return;\n        }\n    }\n    oops(40);\n}\n\nvoid registerGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            registerGC(root++, 1);\n        }\n        return;\n    }\n\n    gcRoots.push((TValue)((uintptr_t)root | 1));\n}\n\nvoid unregisterGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            unregisterGC(root++, 1);\n        }\n        return;\n    }\n\n    removePtr((TValue)((uintptr_t)root | 1));\n}\n\nvoid registerGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    gcRoots.push(ptr);\n}\n\nvoid unregisterGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    removePtr(ptr);\n}\n\nvoid RefImage::scan(RefImage *t) {\n    gcScan((TValue)t->buffer);\n}\n\nvoid RefCollection::scan(RefCollection *t) {\n    gcScanSegment(t->head);\n}\n\nvoid RefAction::scan(RefAction *t) {\n    gcScanMany(t->fields, t->len);\n}\n\nvoid RefRefLocal::scan(RefRefLocal *t) {\n    gcScan(t->v);\n}\n\nvoid RefMap::scan(RefMap *t) {\n    gcScanSegment(t->keys);\n    gcScanSegment(t->values);\n}\n\nvoid RefRecord_scan(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    gcScanMany(r->fields, BYTES_TO_WORDS(tbl->numbytes - sizeof(RefRecord)));\n}\n\n#define SIZE(off) TOWORDS(sizeof(*t) + (off))\n\nunsigned RefImage::gcsize(RefImage *t) {\n    return SIZE(0);\n}\n\nunsigned RefCollection::gcsize(RefCollection *t) {\n    return SIZE(0);\n}\n\nunsigned RefAction::gcsize(RefAction *t) {\n    return SIZE(WORDS_TO_BYTES(t->len));\n}\n\nunsigned RefRefLocal::gcsize(RefRefLocal *t) {\n    return SIZE(0);\n}\n\nunsigned RefMap::gcsize(RefMap *t) {\n    return SIZE(0);\n}\n\n#endif\n\n} // namespace pxt\n",
            "json.ts": "namespace JSON {\n    export function parseIntRadix(s: string, base?: number) {\n        if (base == null || base == 10) {\n            return parseFloat(s) | 0\n        }\n\n        let m = false\n        let r = 0\n        for (let i = 0; i < s.length; ++i) {\n            let c = s.charCodeAt(i)\n            if (c == 0x20 || c == 10 || c == 13 || c == 9)\n                continue\n            if (r == 0 && !m && c == 0x2d) {\n                m = true\n                continue\n            }\n\n            let v = -1\n            if (0x30 <= c && c <= 0x39)\n                v = c - 0x30\n            else {\n                c |= 0x20\n                if (0x61 <= c && c <= 0x7a)\n                    v = c - 0x61 + 10\n            }\n\n            if (0 <= v && v < base) {\n                r *= base\n                r += v\n            } else {\n                return undefined\n            }\n        }\n\n        return m ? -r : r\n    }\n\n\n    class Parser {\n        ptr: number\n        s: string\n        errorMsg: string\n\n        error(msg: string) {\n            if (!this.errorMsg) {\n                this.errorMsg = msg + \" at position \" + this.ptr\n                this.ptr = this.s.length\n            }\n        }\n\n        skipWS() {\n            for (; ;) {\n                const c = this.nextChar()\n                if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {\n                    // OK\n                } else {\n                    this.ptr--\n                    return c\n                }\n            }\n        }\n\n        nextChar() {\n            if (this.ptr < this.s.length)\n                return this.s.charCodeAt(this.ptr++)\n            return 0\n        }\n\n        doString() {\n            let r = \"\"\n            this.ptr++\n            for (; ;) {\n                const c = this.s.charAt(this.ptr++)\n                if (c == \"\\\"\")\n                    return r\n                if (c == \"\\\\\") {\n                    let q = this.s.charAt(this.ptr++)\n                    if (q == \"b\") q = \"\\b\"\n                    else if (q == \"n\") q = \"\\n\"\n                    else if (q == \"r\") q = \"\\r\"\n                    else if (q == \"t\") q = \"\\t\"\n                    else if (q == \"u\") {\n                        q = String.fromCharCode(parseIntRadix(this.s.slice(this.ptr, this.ptr + 4), 16))\n                        this.ptr += 4\n                    }\n                    r += q\n                } else {\n                    r += c\n                }\n            }\n        }\n\n        doArray(): any[] {\n            const r = []\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x5d) {\n                    this.ptr++\n                    return r\n                }\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r.push(v)\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x5d)\n                    continue\n                this.error(\"expecting comma\")\n            }\n        }\n\n        doObject() {\n            const r: any = {}\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x7d) {\n                    this.ptr++\n                    return r\n                }\n                if (c != 0x22) {\n                    this.error(\"expecting key\")\n                    return r\n                }\n                const k = this.doString()\n                c = this.skipWS()\n                if (c != 0x3a) {\n                    this.error(\"expecting colon\")\n                    return r\n                }\n                this.ptr++\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r[k] = v\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x7d)\n                    continue\n                this.error(\"expecting comma, got \" + String.fromCharCode(c))\n            }\n        }\n\n        doNumber() {\n            const beg = this.ptr\n            for (; ;) {\n                const c = this.nextChar()\n                if ((0x30 <= c && c <= 0x39) || c == 0x2b || c == 0x2d || c == 0x2e || c == 0x45 || c == 0x65) {\n                    // one more\n                } else {\n                    this.ptr--\n                    break\n                }\n            }\n            const ss = this.s.slice(beg, this.ptr)\n            if (ss.length == 0) {\n                this.error(\"expecting number\")\n                return 0\n            }\n            return parseFloat(ss)\n        }\n\n        checkKw(k: string) {\n            if (this.s.slice(this.ptr, this.ptr + k.length) == k) {\n                this.ptr += k.length\n                return true\n            }\n            return false\n        }\n\n        value() {\n            if (this.errorMsg)\n                return null\n\n            const c = this.skipWS()\n            if (c == 0x7b)\n                return this.doObject()\n            else if (c == 0x5b)\n                return this.doArray()\n            else if ((0x30 <= c && c <= 0x39) || c == 0x2d)\n                return this.doNumber()\n            else if (c == 0x22)\n                return this.doString()\n            else if (c == 0x74 && this.checkKw(\"true\"))\n                return true\n            else if (c == 0x66 && this.checkKw(\"false\"))\n                return false\n            else if (c == 0x6e && this.checkKw(\"null\"))\n                return null\n\n            this.error(\"unexpected token\")\n            return null\n        }\n    }\n\n    class Stringifier {\n        currIndent: string\n        indentStep: string\n        indent: number\n\n        doString(s: string) {\n            let r = \"\\\"\"\n            for (let i = 0; i < s.length; ++i) {\n                let c = s[i]\n                if (c == \"\\n\") c = \"\\\\n\"\n                else if (c == \"\\r\") c = \"\\\\r\"\n                else if (c == \"\\t\") c = \"\\\\t\"\n                else if (c == \"\\b\") c = \"\\\\b\"\n                else if (c == \"\\\\\") c = \"\\\\\\\\\"\n                else if (c == \"\\\"\") c = \"\\\\\\\"\"\n                r += c\n            }\n            return r + \"\\\"\"\n        }\n\n        go(v: any) {\n            const t = typeof v\n            if (t == \"string\")\n                return this.doString(v)\n            else if (t == \"boolean\" || t == \"number\" || v == null)\n                return \"\" + v\n            else if (Array.isArray(v)) {\n                const arr = v as any[]\n                if (arr.length == 0)\n                    return \"[]\"\n                else {\n                    let r = \"[\"\n                    if (this.indent) {\n                        this.currIndent += this.indentStep\n                        r += \"\\n\"\n                    }\n                    for (let i = 0; i < arr.length; ++i) {\n                        r += this.currIndent + this.go(arr[i])\n                        if (i != arr.length - 1)\n                            r += \",\"\n                        if (this.indent)\n                            r += \"\\n\"\n                    }\n                    if (this.indent)\n                        this.currIndent = this.currIndent.slice(this.indent)\n                    r += this.currIndent + \"]\"\n                    return r\n                }\n            } else {\n                const keys = Object.keys(v)\n                if (keys.length == 0)\n                    return \"{}\"\n\n                let r = \"{\"\n                if (this.indent) {\n                    this.currIndent += this.indentStep\n                    r += \"\\n\"\n                }\n                for (let i = 0; i < keys.length; ++i) {\n                    const k = keys[i]\n                    r += this.currIndent + this.doString(k)\n                    if (this.indent)\n                        r += \": \"\n                    else\n                        r += \":\"\n                    r += this.go(v[k])\n                    if (i != keys.length - 1)\n                        r += \",\"\n                    if (this.indent)\n                        r += \"\\n\"\n                }\n                if (this.indent)\n                    this.currIndent = this.currIndent.slice(this.indent)\n                r += this.currIndent + \"}\"\n                return r\n            }\n        }\n    }\n\n    /**\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n     * @param value A JavaScript value, usually an object or array, to be converted.\n     * @param replacer Not supported; use null.\n     * @param indent Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    export function stringify(value: any, replacer: any = null, indent: number = 0) {\n        const ss = new Stringifier()\n        ss.currIndent = \"\"\n        indent |= 0\n        if (indent < 0) indent = 0\n        if (indent > 10) indent = 10\n        ss.indentStep = \"\"\n        ss.currIndent = \"\"\n        ss.indent = indent\n        while (indent-- > 0)\n            ss.indentStep += \" \"\n        return ss.go(value)\n    }\n\n\n    /**\n     * Converts a JavaScript Object Notation (JSON) string into an object.\n     * @param text A valid JSON string.\n     */\n    export function parse(s: string) {\n        const p = new Parser()\n        p.ptr = 0\n        p.s = s\n        const r = p.value()\n        if (p.skipWS()) {\n            p.error(\"excessive input\")\n        }\n        if (p.errorMsg) {\n            control.dmesg(\"Invalid JSON: \" + p.errorMsg)\n            return undefined\n        }\n        return r\n    }\n}\n",
            "loops.cpp": "#include \"pxtbase.h\"\n\nnamespace loops {\n\n/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true deprecated=true\n//% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1\nvoid forever(Action a) {\n    runForever(a);\n}\n\n/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99 deprecated=true\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause_deprecated\nvoid pause(int ms) {\n    if (ms < 0) return;\n    sleep_ms(ms);\n}\n\n}",
            "math.ts": "namespace Math {\n\n    export const E = 2.718281828459045;\n    export const LN2 = 0.6931471805599453;\n    export const LN10 = 2.302585092994046;\n    export const LOG2E = 1.4426950408889634;\n    export const LOG10E = 0.4342944819032518;\n    export const PI = 3.141592653589793;\n    export const SQRT1_2 = 0.7071067811865476;\n    export const SQRT2 = 1.4142135623730951;\n\n    /**\n     * Re-maps a number from one range to another. That is, a value of ``from low`` would get mapped to ``to low``, a value of ``from high`` to ``to high``, values in-between to values in-between, etc.\n     * @param value value to map in ranges\n     * @param fromLow the lower bound of the value's current range\n     * @param fromHigh the upper bound of the value's current range, eg: 1023\n     * @param toLow the lower bound of the value's target range\n     * @param toHigh the upper bound of the value's target range, eg: 4\n     */\n    //% help=math/map weight=10 blockGap=8\n    //% blockId=math_map block=\"map %value|from low %fromLow|high %fromHigh|to low %toLow|high %toHigh\"\n    //% inlineInputMode=inline\n    export function map(value: number, fromLow: number, fromHigh: number, toLow: number, toHigh: number): number {\n        return ((value - fromLow) * (toHigh - toLow)) / (fromHigh - fromLow) + toLow;\n    }    \n\n    /**\n     * Constrains a number to be within a range\n     * @param x the number to constrain, all data types\n     * @param y the lower end of the range, all data types\n     * @param z the upper end of the range, all data types\n     */\n    //% help=math/constrain weight=11 blockGap=8\n    //% blockId=\"math_constrain_value\" block=\"constrain %value|between %low|and %high\"\n    export function constrain(value: number, low: number, high: number): number {\n        return value < low ? low : value > high ? high : value;\n    }\n\n    const b_m16: number[] = [0, 49, 49, 41, 90, 27, 117, 10]\n    /**\n     * Returns the sine of an input angle. This is an 8-bit approximation.\n     * @param theta input angle from 0-255\n     */\n    //% help=math/isin weight=11 advanced=true blockGap=8\n    export function isin(theta: number) {\n        //reference: based on FASTLed's sin approximation method: [https://github.com/FastLED/FastLED](MIT)\n        let offset = theta;\n        if( theta & 0x40 ) {\n            offset = 255 - offset;\n        }\n        offset &= 0x3F; // 0..63\n\n        let secoffset  = offset & 0x0F; // 0..15\n        if( theta & 0x40) secoffset++;\n\n        let section = offset >> 4; // 0..3\n        let s2 = section * 2;\n\n        let b = b_m16[s2];\n        let m16 = b_m16[s2+1];\n        let mx = (m16 * secoffset) >> 4;\n        \n        let y = mx + b;\n        if( theta & 0x80 ) y = -y;\n\n        y += 128;\n\n        return y;\n    }\n\n    /**\n     * Returns the cosine of an input angle. This is an 8-bit approximation. \n     * @param theta input angle from 0-255\n     */\n    //% help=math/icos weight=10 advanced=true blockGap=8\n    export function icos(theta: number) {\n        return isin(theta + 16384);\n    }\n}\n\nnamespace Number {\n    export const EPSILON = 2.220446049250313e-16;\n}",
            "ns.ts": "\n/**\n * Respond to and read data from buttons and sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}\n",
            "pause.ts": "/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause blockNamespace=\"loops\"\nfunction pause(ms: number): void {\n    loops.pause(ms);\n}\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function pause(millis: number) {\n        loops.pause(millis);\n    }\n}",
            "pxt-core.d.ts": "/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n      * Get or set the length of an array. This number is one more than the index of the last element the array.\n      */\n    //% shim=Array_::length weight=84\n    //% blockId=\"lists_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"arrays\"\n    length: number;\n\n    /**\n      * Append a new element to an array.\n      * @param items New elements of the Array.\n      */\n    //% help=arrays/push\n    //% shim=Array_::push weight=50\n    //% blockId=\"array_push\" block=\"%list| add value %value| to end\" blockNamespace=\"arrays\"\n    push(item: T): void;\n\n    /**\n      * Concatenates the values with another array.\n      * @param arr The other array that is being concatenated with\n      */\n    //% helper=arrayConcat weight=40\n    concat(arr: T[]): T[];\n\n    /**\n      * Remove the last element from an array and return it.\n      */\n    //% help=arrays/pop\n    //% shim=Array_::pop weight=45\n    //% blockId=\"array_pop\" block=\"get and remove last value from %list\" blockNamespace=\"arrays\"\n    //% blockGap=64\n    pop(): T;\n\n    /**\n      * Reverse the elements in an array. The first array element becomes the last, and the last array element becomes the first.\n      */\n    //% help=arrays/reverse\n    //% helper=arrayReverse weight=10\n    //% blockId=\"array_reverse\" block=\"reverse %list\" blockNamespace=\"arrays\"\n    reverse(): void;\n\n    /**\n      * Remove the first element from an array and return it. This method changes the length of the array.\n      */\n    //% help=arrays/shift\n    //% helper=arrayShift weight=30\n    //% blockId=\"array_shift\" block=\"get and remove first value from %list\" blockNamespace=\"arrays\"\n    shift(): T;\n\n    /**\n      * Add one element to the beginning of an array and return the new length of the array.\n      * @param element to insert at the start of the Array.\n      */\n    //% help=arrays/unshift\n    //% helper=arrayUnshift weight=25\n    //% blockId=\"array_unshift\" block=\"%list| insert %value| at beginning\" blockNamespace=\"arrays\"\n    //unshift(...values:T[]): number; //rest is not supported in our compiler yet.\n    unshift(value: T): number;\n\n    /**\n      * Return a section of an array.\n      * @param start The beginning of the specified portion of the array. eg: 0\n      * @param end The end of the specified portion of the array. eg: 0\n      */\n    //% help=arrays/slice\n    //% helper=arraySlice weight=41 blockNamespace=\"arrays\"\n    slice(start?: number, end?: number): T[];\n\n    /**\n      * Remove elements from an array.\n      * @param start The zero-based location in the array from which to start removing elements. eg: 0\n      * @param deleteCount The number of elements to remove. eg: 0\n      */\n    //% helper=arraySplice weight=40\n    splice(start: number, deleteCount: number): void;\n\n    /**\n      * joins all elements of an array into a string and returns this string.\n      * @param sep the string separator\n      */\n    //% helper=arrayJoin weight=40\n    join(sep?: string): string;\n    \n    /**\n      * Tests whether at least one element in the array passes the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arraySome weight=40\n    some(callbackfn: (value: T, index: number) => boolean): boolean;\n\n    /**\n      * Tests whether all elements in the array pass the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayEvery weight=40\n    every(callbackfn: (value: T, index: number) => boolean): boolean;\n    \n    /**\n      * Sort the elements of an array in place and returns the array. The sort is not necessarily stable.\n      * @param specifies a function that defines the sort order. If omitted, the array is sorted according to the prmitive type\n      */\n    //% helper=arraySort weight=40\n    sort(callbackfn?: (value1: T, value2: T) => number): T[];\n\n    /**\n      * Call a defined callback function on each element of an array, and return an array containing the results.\n      * @param callbackfn A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayMap weight=40\n    map<U>(callbackfn: (value: T, index: number) => U): U[];\n\n    /**\n      * Call a defined callback function on each element of an array.\n      * @param callbackfn A function that accepts up to two arguments. The forEach method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayForEach weight=40\n    forEach(callbackfn: (value: T, index: number) => void): void;\n    \n    /**\n      * Return the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayFilter weight=40\n    filter(callbackfn: (value: T, index: number) => boolean): T[];\n\n    /**\n      * Fills all the elements of an array from a start index to an end index with a static value. The end index is not included.\n      */\n    //% helper=arrayFill weight=39\n    fill(value: T, start?: number, end?: number): T[];\n    \n    /**\n     * Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.\n     * @param callbackfn \n     */\n    //% helper=arrayFind weight=40\n    find(callbackfn: (value: T, index: number) => boolean): T;\n\n    /**\n      * Call the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    //% helper=arrayReduce weight=40\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U;\n\n\n    /** Remove the first occurence of an object. Returns true if removed. */\n    //% shim=Array_::removeElement weight=48\n    removeElement(element: T): boolean;\n\n    /** Remove the element at a certain index. */\n    //% help=arrays/remove-at\n    //% shim=Array_::removeAt weight=15\n    //% blockId=\"array_removeat\" block=\"%list| remove value at %index\" blockNamespace=\"arrays\"\n    removeAt(index: number): T;\n\n    /**\n     * Insert the value at a particular index, increases length by 1\n     * @param index the zero-based position in the list to insert the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/insert-at\n    //% shim=Array_::insertAt weight=20\n    //% blockId=\"array_insertAt\" block=\"%list| insert at %index| value %value\" blockNamespace=\"arrays\"\n    insertAt(index: number, value: T): void;\n\n    /**\n      * Return the index of the first occurrence of a value in an array.\n      * @param item The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    //% help=arrays/index-of\n    //% shim=Array_::indexOf weight=40\n    //% blockId=\"array_indexof\" block=\"%list| find index of %value\" blockNamespace=\"arrays\"\n    indexOf(item: T, fromIndex?: number): number;\n\n    /**\n     * Get the value at a particular index\n     * @param index the zero-based position in the list of the item, eg: 0\n     */\n    //% help=arrays/get\n    //% shim=Array_::getAt weight=85\n    get(index: number): T;\n\n    /**\n     * Store a value at a particular index\n     * @param index the zero-based position in the list to store the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/set\n    //% shim=Array_::setAt weight=84\n    set(index: number, value: T): void;\n\n    [n: number]: T;\n}\n\ndeclare interface String {\n    // This block is currently disabled in favor of the built-in Blockly \"Create text with\" block, which compiles to \"\" + \"\"\n    // Add % sign back to the block annotation to re-enable\n    /**\n     * Returns a string that contains the concatenation of two or more strings.\n     * @param other The string to append to the end of the string.\n     */\n    //% shim=String_::concat weight=49\n    //% blockId=\"string_concat\" blockNamespace=\"text\"\n    // block=\"join %list=text|%other\"\n    concat(other: string): string;\n\n    /**\n     * Return the character at the specified index.\n     * @param index The zero-based index of the desired character.\n     */\n    //% shim=String_::charAt weight=48\n    //% help=text/char-at\n    //% blockId=\"string_get\" block=\"char from %this=text|at %pos\" blockNamespace=\"text\"\n    charAt(index: number): string;\n\n    /** Returns the length of a String object. */\n    //% property shim=String_::length weight=47\n    //% blockId=\"text_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"text\"\n    length: number;\n\n    /**\n     * Return the Unicode value of the character at the specified location.\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n     */\n    //% shim=String_::charCodeAt\n    charCodeAt(index: number): number;\n\n    /**\n     * See how the order of characters in two strings is different (in ASCII encoding).\n     * @param that String to compare to target string\n     */\n    //% shim=String_::compare\n    //% help=text/compare\n    //% blockId=\"string_compare\" block=\"compare %this=text| to %that\" blockNamespace=\"text\"\n    compare(that: string): number;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param length number of characters to extract\n     */\n    //% shim=String_::substr length.defl=10\n    //% help=text/substr\n    //% blockId=\"string_substr\" block=\"substring of %this=text|from %start|of length %length\" blockNamespace=\"text\"\n    substr(start: number, length?: number): string;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param end one-past-last character index\n     */\n    //% helper=stringSlice\n    slice(start: number, end?: number): string;\n\n    /** Returns a value indicating if the string is empty */\n    //% helper=stringEmpty\n    //% blockId=\"string_isempty\" blockNamespace=\"text\"\n    //% block=\"%this=text| is empty\"\n    isEmpty(): boolean;\n\n    /**\n     * Returns the position of the first occurrence of a specified value in a string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::indexOf\n    //% help=text/index-of\n    //% blockId=\"string_indexof\" blockNamespace=\"text\"\n    //% block=\"%this=text|find index of %searchValue\"\n    indexOf(searchValue: string, start?: number): number;\n\n    /**\n     * Determines whether a string contains the characters of a specified string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::includes\n    //% help=text/includes\n    //% blockId=\"string_includes\" blockNamespace=\"text\"\n    //% block=\"%this=text|includes %searchValue\"\n    includes(searchValue: string, start?: number): boolean;\n\n    /**\n     * Splits the string according to the separators\n     * @param separator \n     * @param limit \n     */\n    //% helper=stringSplit\n    //% help=text/split\n    //% blockId=\"string_split\" blockNamespace=\"text\"\n    //% block=\"split %this=text|at %separator\"\n    split(separator?: string, limit?: number): string[];\n\n    /**\n     * Converts the string to lower case characters.\n     */\n    //% helper=stringToLowerCase\n    //% help=text/to-lower-case\n    toLowerCase(): string;\n\n    [index: number]: string;\n}\n\n/**\n  * Convert a string to a number.\n  * @param s A string to convert into a number. eg: 123\n  */\n//% shim=String_::toNumber\n//% help=text/parse-float\n//% blockId=\"string_parsefloat\" block=\"parse to number %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\ndeclare function parseFloat(text: string): number;\n\ninterface Object { }\ninterface Function { }\ninterface IArguments { }\ninterface RegExp { }\ntype TemplateStringsArray = Array<string>;\n\ntype uint8 = number;\ntype uint16 = number;\ntype uint32 = number;\ntype int8 = number;\ntype int16 = number;\ntype int32 = number;\n\n\ndeclare interface Boolean {\n    /**\n     * Returns a string representation of an object.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Combine, split, and search text strings.\n*/\n//% blockNamespace=\"text\"\ndeclare namespace String {\n\n    /**\n     * Make a string from the given ASCII character code.\n     */\n    //% help=math/from-char-code\n    //% shim=String_::fromCharCode weight=1\n    //% blockNamespace=\"text\" blockId=\"stringFromCharCode\" block=\"text from char code %code\"\n    function fromCharCode(code: number): string;\n}\n\ndeclare interface Number {\n    /**\n     * Returns a string representation of a number.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Add, remove, and replace items in lists.\n*/\n//% blockNamespace=\"Arrays\"\ndeclare namespace Array {\n    /**\n     * Check if a given object is an array.\n     */\n    //% shim=Array_::isArray\n    function isArray(obj: any): boolean;\n}\n\ndeclare namespace Object {\n    /**\n     * Return the field names in an object.\n     */\n    //% shim=pxtrt::keysOf\n    function keys(obj: any): string[];\n}\n\n/**\n * More complex operations with numbers.\n*/\ndeclare namespace Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    //% shim=Math_::pow\n    function pow(x: number, y: number): number;\n\n    /**\n     * Returns a pseudorandom number between 0 and 1.\n     */\n    //% shim=Math_::random\n    //% help=math/random\n    function random(): number;\n\n    /**\n     * Returns a pseudorandom number between min and max included.\n     * If both numbers are integral, the result is integral.\n     * @param min the lower inclusive bound, eg: 0\n     * @param max the upper inclusive bound, eg: 10\n     */\n    //% blockId=\"device_random\" block=\"pick random %min|to %limit\"\n    //% help=math/random-range\n    //% shim=Math_::randomRange\n    function randomRange(min: number, max: number): number;\n\n    /**\n     * Returns the natural logarithm (base e) of a number.\n     * @param x A number\n     */\n    //% shim=Math_::log\n    function log(x: number): number;\n\n    /**\n     * Returns returns ``e^x``.\n     * @param x A number\n     */\n    //% shim=Math_::exp\n    function exp(x: number): number;\n\n    /**\n     * Returns the sine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::sin\n    function sin(x: number): number;\n\n    /**\n     * Returns the cosine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::cos\n    function cos(x: number): number;\n\n    /**\n     * Returns the tangent of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::tan\n    function tan(x: number): number;\n\n    /**\n     * Returns the arcsine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::asin\n    function asin(x: number): number;\n\n    /**\n     * Returns the arccosine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::acos\n    function acos(x: number): number;\n\n    /**\n     * Returns the arctangent (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::atan\n    function atan(x: number): number;\n\n    /**\n     * Returns the arctangent of the quotient of its arguments.\n     * @param y A number\n     * @param x A number\n     */\n    //% shim=Math_::atan2\n    function atan2(y: number, x: number): number;\n\n    /**\n     * Returns the square root of a number.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::sqrt\n    function sqrt(x: number): number;\n\n    /**\n     * Returns the smallest number greater than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::ceil\n    function ceil(x: number): number;\n\n    /**\n      * Returns the greatest number less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::floor\n    function floor(x: number): number;\n\n    /**\n      * Returns the number with the decimal part truncated.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::trunc\n    function trunc(x: number): number;\n\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    //% shim=Math_::round\n    function round(x: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit multiplication of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::imul\n    function imul(x: number, y: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit division of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::idiv\n    function idiv(x: number, y: number): number;\n}\n",
            "pxt-helpers.ts": "type Action = () => void;\n\n/**\n * A dictionary from string key to string values\n */\ninterface StringMap {\n    [index: string]: string;\n}\n\n/**\n  * Convert a string to an integer.\n  * @param s A string to convert into an integral number. eg: 123\n  */\n//% help=text/parse-int\n//% blockId=\"string_parseint\" block=\"parse to integer %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\n//% blockHidden=1\nfunction parseInt(text: string): number {\n    return parseFloat(text) >> 0;\n}\n\nnamespace helpers {\n    export function arrayFill<T>(O: T[], value: T, start?: number, end?: number) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\n        // Steps 3-5.\n        const len = O.length >>> 0;\n\n        // Steps 6-7.\n        const relativeStart = start === undefined ? 0 : start >> 0;\n\n        // Step 8.\n        let k = relativeStart < 0 ?\n            Math.max(len + relativeStart, 0) :\n            Math.min(relativeStart, len);\n\n        // Steps 9-10.\n        const relativeEnd = end === undefined ? len : end >> 0;\n\n        // Step 11.\n        const final = relativeEnd < 0 ?\n            Math.max(len + relativeEnd, 0) :\n            Math.min(relativeEnd, len);\n\n        // Step 12.\n        while (k < final) {\n            O[k] = value;\n            k++;\n        }\n\n        // Step 13.\n        return O;\n    }\n\n    export function arraySplice<T>(arr: T[], start: number, len: number) {\n        if (start < 0) {\n            return;\n        }\n        for (let i = 0; i < len; ++i) {\n            arr.removeAt(start)\n        }\n    }\n\n    export function arrayReverse<T>(arr: T[]): void {\n        let len = arr.length;\n        for (let i = 0; i < len / 2; i++) {\n            swap(arr, i, len - i - 1);\n        }\n    }\n\n    export function arrayShift<T>(arr: T[]): T {\n        return arr.removeAt(0);\n    }\n\n    export function arrayJoin<T>(arr: T[], sep?: string): string {\n        if (sep === undefined || sep === null) {\n            sep = \",\";\n        }\n\n        let r = \"\";\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            if (i > 0 && sep)\n                r += sep;\n            r += (arr[i] === undefined || arr[i] === null) ? \"\" : arr[i];\n        }\n        return r;\n    }\n\n    /*TODO: Enable this multiple value unshift, after rest is enabled in our compiler.\n        export function arrayUnshift<T>(arr: T[], ...values: T[]) : number {\n            for(let i = values.length; i > 0; --i) {\n                arr.insertAt(0, values[i - 1]);\n            }\n            return arr.length;\n        }\n    */\n    export function arrayUnshift<T>(arr: T[], value: T): number {\n        arr.insertAt(0, value);\n        return arr.length;\n    }\n\n    function swap<T>(arr: T[], i: number, j: number): void {\n        let temp: T = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    function sortHelper<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (arr.length <= 0 || !callbackfn) {\n            return arr;\n        }\n        let len = arr.length;\n        // simple selection sort.\n        for (let i = 0; i < len - 1; ++i) {\n            for (let j = i + 1; j < len; ++j) {\n                if (callbackfn(arr[i], arr[j]) > 0) {\n                    swap(arr, i, j);\n                }\n            }\n        }\n        return arr;\n    }\n\n    export function arraySort<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (!callbackfn && arr.length > 1) {\n            callbackfn = (a, b) => {\n                // default is sort as if the element were a string, with null < undefined\n                const aIsUndef = a === undefined;\n                const bIsUndef = b === undefined;\n                if (aIsUndef && bIsUndef) return 0;\n                else if (aIsUndef) return 1;\n                else if (bIsUndef) return -1;\n\n                const aIsNull = a === null;\n                const bIsNull = b === null;\n                if (aIsNull && bIsNull) return 0;\n                else if (aIsNull) return 1;\n                else if (bIsNull) return -1;\n\n                return (a + \"\").compare(b + \"\");\n            }\n        }\n        return sortHelper(arr, callbackfn);\n    }\n\n    export function arrayMap<T, U>(arr: T[], callbackfn: (value: T, index: number) => U): U[] {\n        let res: U[] = []\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            res.push(callbackfn(arr[i], i))\n        }\n        return res\n    }\n\n    export function arraySome<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (callbackfn(arr[i], i))\n                return true;\n        return false;\n    }\n\n    export function arrayEvery<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (!callbackfn(arr[i], i))\n                return false;\n        return true;\n    }\n\n    export function arrayForEach<T>(arr: T[], callbackfn: (value: T, index: number) => void): void {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            callbackfn(arr[i], i);\n        }\n    }\n\n    export function arrayFilter<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T[] {\n        let res: T[] = []\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) res.push(v)\n        }\n        return res\n    }\n\n    export function arrayFind<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) return v;\n        }\n        return undefined;\n    }\n\n    export function arrayReduce<T, U>(arr: T[], callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            initialValue = callbackfn(initialValue, arr[i], i)\n        }\n        return initialValue\n    }\n\n    export function arrayConcat<T>(arr: T[], otherArr: T[]): T[] {\n        let out: T[] = [];\n        for (let value of arr) {\n            out.push(value);\n        }\n        for (let value of otherArr) {\n            out.push(value);\n        }\n        return out;\n    }\n\n    export function arraySlice<T>(arr: T[], start?: number, end?: number): T[] {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n        const res: T[] = [];\n        const len = arr.length;\n\n        if (start === undefined)\n            start = 0;\n        else if (start < 0)\n            start = Math.max(len + start, 0);\n\n        if (start > len)\n            return res;\n\n        if (end === undefined)\n            end = len;\n        else if (end < 0)\n            end = len + end;\n\n        if (end > len)\n            end = len;\n\n        for (let i = start; i < end; ++i) {\n            res.push(arr[i]);\n        }\n        return res;\n    }\n\n    export function stringSlice(s: string, start: number, end?: number): string {\n        const len = s.length;\n\n        if (start < 0) {\n            start = Math.max(len + start, 0);\n        }\n\n        if (end == null) {\n            end = len;\n        }\n\n        if (end < 0) {\n            end = len + end;\n        }\n\n        return s.substr(start, end - start);\n    }\n\n    // TODO move to PXT\n    // also note this doesn't handle unicode, but neither does JS (there's toLocaleLowerCase())\n    export function stringToLowerCase(s: string): string {\n        let r = \"\"\n        let prev = 0\n        for (let i = 0; i < s.length; i++) {\n            const c = s.charCodeAt(i)\n            if (65 <= c && c <= 90) {\n                r += s.slice(prev, i) + String.fromCharCode(c + 32)\n                prev = i + 1\n            }\n        }\n        r += s.slice(prev)\n        return r\n    }\n\n    export function stringSplit(S: string, separator?: string, limit?: number): string[] {\n        // https://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype.split\n        const A: string[] = [];\n        let lim = 0;\n        if (limit === undefined)\n            lim = (1 << 29) - 1; // spec says 1 << 53, leaving it at 29 for constant folding\n        else if (limit < 0)\n            lim = 0;\n        else\n            lim = limit | 0;\n        const s = S.length;\n        let p = 0;\n        const R = separator;\n        if (lim == 0)\n            return A;\n        if (separator === undefined) {\n            A[0] = S;\n            return A;\n        }\n        if (s == 0) {\n            let z = splitMatch(S, 0, R);\n            if (z > -1) return A;\n            A[0] = S;\n            return A;\n        }\n        let T: string;\n        let q = p;\n        while (q != s) {\n            let e = splitMatch(S, q, R);\n            if (e < 0) q++;\n            else {\n                if (e == p) q++;\n                else {\n                    T = stringSlice(S, p, q);\n                    A.push(T);\n                    if (A.length == lim) return A;\n                    p = e;\n                    q = p;\n                }\n            }\n        }\n        T = stringSlice(S, p, q);\n        A.push(T);\n        return A;\n    }\n\n    function splitMatch(S: string, q: number, R: string): number {\n        const r = R.length;\n        const s = S.length;\n        if (q + r > s) return -1;\n        for (let i = 0; i < r; ++i) {\n            if (S[q + i] != R[i])\n                return -1;\n        }\n        return q + r;\n    }\n\n    export function stringEmpty(S: string): boolean {\n        return !S;\n    }\n}\n\nnamespace Math {\n    export function clamp(min: number, max: number, value: number): number {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    export function abs(x: number): number {\n        return x < 0 ? -x : x;\n    }\n\n    /**\n      * Returns the sign of the x, indicating whether x is positive, negative or zero.\n      * @param x The numeric expression to test\n      */\n    export function sign(x: number): number {\n        if (x == 0) return 0;\n        if (x > 0) return 1;\n        return -1;\n    }\n\n    /**\n      * Returns the larger of two supplied numeric expressions.\n      */\n    export function max(a: number, b: number): number {\n        if (a >= b) return a;\n        return b;\n    }\n\n    /**\n      * Returns the smaller of two supplied numeric expressions.\n      */\n    export function min(a: number, b: number): number {\n        if (a <= b) return a;\n        return b;\n    }\n\n    /**\n     * Rounds ``x`` to a number with the given number of ``digits``\n     * @param x the number to round\n     * @param digits the number of resulting digits\n     */\n    //%\n    export function roundWithPrecision(x: number, digits: number): number {\n        digits = digits | 0;\n        // invalid digits input\n        if (digits <= 0) return Math.round(x);\n        if (x == 0) return 0;\n        let r = 0;\n        do {\n            const d = Math.pow(10, digits);\n            r = Math.round(x * d) / d;\n            digits++;\n        } while (r == 0 && digits < 21);\n        return r;\n    }\n}\n\n\n//% blockHidden=1\nnamespace __internal {\n    /**\n     * A shim to render a boolean as a down/up toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleDownUp block=\"%down\"\n    //% down.fieldEditor=toggledownup\n    //% down.fieldOptions.decompileLiterals=true\n    export function __downUp(down: boolean): boolean {\n        return down;\n    }\n\n    /**\n     * A shim to render a boolean as a up/down toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleUpDown block=\"%up\"\n    //% up.fieldEditor=toggleupdown\n    //% up.fieldOptions.decompileLiterals=true\n    export function __upDown(up: boolean): boolean {\n        return up;\n    }\n\n    /**\n     * A shim to render a boolean as a high/low toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleHighLow block=\"%high\"\n    //% high.fieldEditor=togglehighlow\n    //% high.fieldOptions.decompileLiterals=true\n    export function __highLow(high: boolean): boolean {\n        return high;\n    }\n\n    /**\n     * A shim to render a boolean as a on/off toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleOnOff block=\"%on\"\n    //% on.fieldEditor=toggleonoff\n    //% on.fieldOptions.decompileLiterals=true\n    export function __onOff(on: boolean): boolean {\n        return on;\n    }\n\n    /**\n     * A shim to render a boolean as a yes/no toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleYesNo block=\"%yes\"\n    //% yes.fieldEditor=toggleyesno\n    //% yes.fieldOptions.decompileLiterals=true\n    export function __yesNo(yes: boolean): boolean {\n        return yes;\n    }\n\n    /**\n     * A shim to render a boolean as a win/lose toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleWinLose block=\"%win\"\n    //% win.fieldEditor=togglewinlose\n    //% win.fieldOptions.decompileLiterals=true\n    export function __winLose(win: boolean): boolean {\n        return win;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param color color, eg: #ff0000\n     */\n    //% blockId=colorNumberPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.defl='#ff0000'\n    //% value.fieldOptions.colours='[\"#ff0000\",\"#ff8000\",\"#ffff00\",\"#ff9da5\",\"#00ff00\",\"#b09eff\",\"#00ffff\",\"#007fff\",\"#65471f\",\"#0000ff\",\"#7f00ff\",\"#ff0080\",\"#ff00ff\",\"#ffffff\",\"#999999\",\"#000000\"]'\n    //% value.fieldOptions.columns=4 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param value value between 0 to 255 to get a color value, eg: 10\n     */\n    //% blockId=colorWheelPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    export function __colorWheelPicker(value: number) {\n        return value;\n    }\n\n    /**\n    * Get the color wheel field editor using HSV values\n    * @param value value between 0 to 255 to get a color value, eg: 10\n    */\n    //% blockId=colorWheelHsvPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    //% value.fieldOptions.channel=hsvfast\n    export function __colorWheelHsvPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * A speed picker\n     * @param speed the speed, eg: 50\n     */\n    //% blockId=speedPicker block=\"%speed\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 speed.fieldOptions.decompileLiterals=1\n    export function __speedPicker(speed: number): number {\n        return speed;\n    }\n\n    /**\n     * A turn ratio picker\n     * @param turnratio the turn ratio, eg: 0\n     */\n    //% blockId=turnRatioPicker block=\"%turnratio\" shim=TD_ID\n    //% turnratio.fieldEditor=\"turnratio\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 turnRatio.fieldOptions.decompileLiterals=1\n    export function __turnRatioPicker(turnratio: number): number {\n        return turnratio;\n    }\n\n    /**\n     * A field editor that displays a protractor\n     */\n    //% blockId=protractorPicker block=\"%angle\"\n    //% shim=TD_ID\n    //% angle.fieldEditor=protractor\n    //% angle.fieldOptions.decompileLiterals=1    \n    //% colorSecondary=\"#FFFFFF\"\n    //% blockHidden=1\n    export function __protractor(angle: number) {\n        return angle;\n    }\n\n    /**\n      * Get the time field editor\n      * @param ms time duration in milliseconds, eg: 500, 1000\n      */\n    //% blockId=timePicker block=\"%ms\"\n    //% blockHidden=true shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% ms.fieldEditor=\"numberdropdown\" ms.fieldOptions.decompileLiterals=true\n    //% ms.fieldOptions.data='[[\"100 ms\", 100], [\"200 ms\", 200], [\"500 ms\", 500], [\"1 second\", 1000], [\"2 seconds\", 2000]]'\n    export function __timePicker(ms: number): number {\n        return ms;\n    }\n}",
            "pxt.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\nnamespace pxt {\n\n#ifndef PXT_GC\nTValue incr(TValue e) {\n    if (isRefCounted(e)) {\n        getVTable((RefObject *)e);\n        ((RefObject *)e)->ref();\n    }\n    return e;\n}\n\nvoid decr(TValue e) {\n    if (isRefCounted(e)) {\n        ((RefObject *)e)->unref();\n    }\n}\n#endif\n\nAction mkAction(int totallen, RefAction *act) {\n    check(getVTable(act)->classNo == BuiltInType::RefAction, PANIC_INVALID_BINARY_HEADER, 1);\n#ifdef PXT_VM\n    check(act->initialLen == totallen, PANIC_INVALID_BINARY_HEADER, 13);\n#endif\n\n    if (totallen == 0) {\n        return (TValue)act; // no closure needed\n    }\n\n    void *ptr = gcAllocate(sizeof(RefAction) + totallen * sizeof(void *));\n    RefAction *r = new (ptr) RefAction();\n    r->len = totallen;\n#ifdef PXT_VM\n    r->numArgs = act->numArgs;\n    r->initialLen = act->initialLen;\n    r->reserved = act->reserved;\n#endif\n    r->func = act->func;\n    memset(r->fields, 0, r->len * sizeof(void *));\n\n    MEMDBG(\"mkAction: start=%p => %p\", act, r);\n\n    return (Action)r;\n}\n\nRefRecord *mkClassInstance(VTable *vtable) {\n    intcheck(vtable->methods[0] == &RefRecord_destroy, PANIC_SIZE, 3);\n    // intcheck(vtable->methods[1] == &RefRecord_print, PANIC_SIZE, 4);\n\n    void *ptr = gcAllocate(vtable->numbytes);\n    RefRecord *r = new (ptr) RefRecord(vtable);\n    memset(r->fields, 0, vtable->numbytes - sizeof(RefRecord));\n    MEMDBG(\"mkClass: vt=%p => %p\", vtable, r);\n    return r;\n}\n\nTValue RefRecord::ld(int idx) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 1);\n    return fields[idx];\n}\n\nTValue RefRecord::ldref(int idx) {\n    // DMESG(\"LD %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 2);\n    TValue tmp = fields[idx];\n    incr(tmp);\n    return tmp;\n}\n\nvoid RefRecord::st(int idx, TValue v) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 3);\n    fields[idx] = v;\n}\n\nvoid RefRecord::stref(int idx, TValue v) {\n    // DMESG(\"ST %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 4);\n    decr(fields[idx]);\n    fields[idx] = v;\n}\n\nvoid RefObject::destroyVT() {\n    ((RefObjectMethod)getVTable(this)->methods[0])(this);\n#ifndef PXT_GC\n    free(this);\n#endif\n}\n\n//%\nvoid deleteRefObject(RefObject *obj) {\n    obj->destroyVT();\n}\n\nvoid RefObject::printVT() {\n    ((RefObjectMethod)getVTable(this)->methods[1])(this);\n}\n\nvoid RefRecord_destroy(RefRecord *r) {\n#ifndef PXT_GC\n    VTable *tbl = getVTable(r);\n    int len = (tbl->numbytes - sizeof(RefRecord)) >> 2;\n    for (int i = 0; i < len; ++i) {\n        decr(r->fields[i]);\n        r->fields[i] = 0;\n    }\n#endif\n}\n\nvoid RefRecord_print(RefRecord *r) {\n    DMESG(\"RefRecord %p r=%d size=%d bytes\", r, REFCNT(r), getVTable(r)->numbytes);\n}\n\nvoid Segment::set(unsigned i, TValue value) {\n    if (i < size) {\n        data[i] = value;\n    } else if (i < Segment::MaxSize) {\n        growByMin(i + 1);\n        data[i] = value;\n    } else {\n        return;\n    }\n    if (length <= i) {\n        length = i + 1;\n    }\n\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::set\");\n    this->print();\n#endif\n\n    return;\n}\n\nstatic inline int growthFactor(int size) {\n    if (size == 0) {\n        return 4;\n    }\n    if (size < 64) {\n        return size * 2; // Double\n    }\n    if (size < 512) {\n        return size * 5 / 3; // Grow by 1.66 rate\n    }\n    // Grow by constant rate\n    if ((unsigned)size + 256 < Segment::MaxSize)\n        return size + 256;\n    else\n        return Segment::MaxSize;\n}\n\nvoid LLSegment::setLength(unsigned newLen) {\n    if (newLen > Segment::MaxSize)\n        return;\n\n    if (newLen > size) {\n        int newSize = growthFactor(size);\n        if (newSize < (int)newLen)\n            newSize = newLen;\n\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(xmalloc(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size) {\n            memcpy(tmp, data, size * sizeof(TValue));\n        }\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        // free older segment;\n        xfree(data);\n\n        data = tmp;\n        size = newSize;\n    } else if (newLen < length) {\n        memset(data + newLen, 0, (length - newLen) * sizeof(TValue));\n    }\n\n    length = newLen;\n}\n\nvoid LLSegment::set(unsigned idx, TValue v) {\n    if (idx >= Segment::MaxSize)\n        return;\n    if (idx >= length)\n        setLength(idx + 1);\n    data[idx] = v;\n}\n\nTValue LLSegment::pop() {\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = 0;\n        return value;\n    }\n    return 0;\n}\n\nvoid LLSegment::destroy() {\n    length = size = 0;\n    xfree(data);\n    data = nullptr;\n}\n\nvoid Segment::growByMin(ramint_t minSize) {\n    ramint_t newSize = max(minSize, (ramint_t)growthFactor(size));\n\n    if (size < newSize) {\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(gcAllocateArray(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size)\n            memcpy(tmp, data, size * sizeof(TValue));\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        data = tmp;\n        size = newSize;\n\n#ifdef DEBUG_BUILD\n        DMESG(\"growBy - after reallocation\");\n        this->print();\n#endif\n    }\n    // else { no shrinking yet; }\n    return;\n}\n\nvoid Segment::ensure(ramint_t newSize) {\n    if (newSize < size) {\n        return;\n    }\n    growByMin(newSize);\n}\n\nvoid Segment::setLength(unsigned newLength) {\n    if (newLength > size) {\n        ensure(newLength);\n    }\n    length = newLength;\n    return;\n}\n\nTValue Segment::pop() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::pop\");\n    this->print();\n#endif\n\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = Segment::DefaultValue;\n        return value;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function removes an element at index i and shifts the rest of the elements to\n// left to fill the gap\nTValue Segment::remove(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::remove index:%d\", i);\n    this->print();\n#endif\n    if (i < length) {\n        // value to return\n        TValue ret = data[i];\n        if (i + 1 < length) {\n            // Move the rest of the elements to fill in the gap.\n            memmove(data + i, data + i + 1, (length - i - 1) * sizeof(void *));\n        }\n        length--;\n        data[length] = Segment::DefaultValue;\n#ifdef DEBUG_BUILD\n        DMESG(\"After Segment::remove index:%d\", i);\n        this->print();\n#endif\n        return ret;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function inserts element value at index i by shifting the rest of the elements right.\nvoid Segment::insert(unsigned i, TValue value) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::insert index:%d value:%d\", i, value);\n    this->print();\n#endif\n\n    if (i < length) {\n        ensure(length + 1);\n\n        // Move the rest of the elements to fill in the gap.\n        memmove(data + i + 1, data + i, (length - i) * sizeof(void *));\n\n        data[i] = value;\n        length++;\n    } else {\n        // This is insert beyond the length, just call set which will adjust the length\n        set(i, value);\n    }\n#ifdef DEBUG_BUILD\n    DMESG(\"After Segment::insert index:%d\", i);\n    this->print();\n#endif\n}\n\nvoid Segment::print() {\n    DMESG(\"Segment: %p, length: %d, size: %d\", data, (unsigned)length, (unsigned)size);\n    for (unsigned i = 0; i < size; i++) {\n        DMESG(\"-> %d\", (unsigned)(uintptr_t)data[i]);\n    }\n}\n\nvoid Segment::destroy() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::destroy\");\n    this->print();\n#endif\n    length = size = 0;\n    data = nullptr;\n}\n\nPXT_VTABLE_CTOR(RefCollection) {}\n\nvoid RefCollection::destroy(RefCollection *t) {\n#ifndef PXT_GC\n    auto data = t->head.getData();\n    auto len = t->head.getLength();\n    for (unsigned i = 0; i < len; i++) {\n        decr(data[i]);\n    }\n#endif\n    t->head.destroy();\n}\n\nvoid RefCollection::print(RefCollection *t) {\n    DMESG(\"RefCollection %p r=%d size=%d\", t, REFCNT(t), t->head.getLength());\n    t->head.print();\n}\n\nPXT_VTABLE(RefAction, ValType::Function)\nRefAction::RefAction() : PXT_VTABLE_INIT(RefAction) {}\n\n// fields[] contain captured locals\nvoid RefAction::destroy(RefAction *t) {\n#ifndef PXT_GC\n    for (int i = 0; i < t->len; ++i) {\n        decr(t->fields[i]);\n        t->fields[i] = 0;\n    }\n#endif\n}\n\nvoid RefAction::print(RefAction *t) {\n#ifdef PXT_VM\n    DMESG(\"RefAction %p pc=%X size=%d\", t,\n          (const uint8_t *)t->func - (const uint8_t *)vmImg->dataStart, t->len);\n#else\n    DMESG(\"RefAction %p r=%d pc=%X size=%d\", t, REFCNT(t),\n          (const uint8_t *)t->func - (const uint8_t *)bytecode, t->len);\n#endif\n}\n\nPXT_VTABLE_CTOR(RefRefLocal) {\n    v = 0;\n}\n\nvoid RefRefLocal::print(RefRefLocal *t) {\n    DMESG(\"RefRefLocal %p r=%d v=%p\", t, REFCNT(t), (void *)t->v);\n}\n\nvoid RefRefLocal::destroy(RefRefLocal *t) {\n    decr(t->v);\n}\n\nPXT_VTABLE_CTOR(RefMap) {}\n\nvoid RefMap::destroy(RefMap *t) {\n#ifndef PXT_GC\n    auto len = t->values.getLength();\n    auto values = t->values.getData();\n    auto keys = t->keys.getData();\n    intcheck(t->keys.getLength() == len, PANIC_SIZE, 101);\n    for (unsigned i = 0; i < len; ++i) {\n        decr(values[i]);\n        values[i] = nullptr;\n        decr(keys[i]);\n        keys[i] = nullptr;\n    }\n#endif\n    t->keys.destroy();\n    t->values.destroy();\n}\n\nint RefMap::findIdx(String key) {\n    auto len = keys.getLength();\n    auto data = (String *)keys.getData();\n\n    // fast path\n    for (unsigned i = 0; i < len; ++i) {\n        if (data[i] == key)\n            return i;\n    }\n\n    // slow path\n    auto keylen = key->getUTF8Size();\n    auto keydata = key->getUTF8Data();\n    for (unsigned i = 0; i < len; ++i) {\n        auto s = data[i];\n        if (s->getUTF8Size() == keylen && memcmp(keydata, s->getUTF8Data(), keylen) == 0)\n            return i;\n    }\n\n    return -1;\n}\n\nvoid RefMap::print(RefMap *t) {\n    DMESG(\"RefMap %p r=%d size=%d\", t, REFCNT(t), t->keys.getLength());\n}\n\nvoid debugMemLeaks() {}\n\nvoid error(PXT_PANIC code, int subcode) {\n    DMESG(\"Error: %d [%d]\", code, subcode);\n    target_panic(code);\n}\n\n#ifndef PXT_VM\nuint16_t *bytecode;\n#endif\nTValue *globals;\n\nvoid checkStr(bool cond, const char *msg) {\n    if (!cond) {\n        while (true) {\n            // uBit.display.scroll(msg, 100);\n            // uBit.sleep(100);\n        }\n    }\n}\n\n#ifdef PXT_VM\nint templateHash() {\n    return (int)vmImg->infoHeader->hexHash;\n}\n\nint programHash() {\n    return (int)vmImg->infoHeader->programHash;\n}\n\nint getNumGlobals() {\n    return (int)vmImg->infoHeader->allocGlobals;\n}\n\nString programName() {\n    return mkString((char*)vmImg->infoHeader->name);\n}\n#else\nint templateHash() {\n    return ((int *)bytecode)[4];\n}\n\nint programHash() {\n    return ((int *)bytecode)[6];\n}\n\nint getNumGlobals() {\n    return bytecode[16];\n}\n\nString programName() {\n    return ((String *)bytecode)[15];\n}\n#endif\n\n#ifndef PXT_VM\nvoid exec_binary(unsigned *pc) {\n    // XXX re-enable once the calibration code is fixed and [editor/embedded.ts]\n    // properly prepends a call to [internal_main].\n    // ::touch_develop::internal_main();\n\n    // unique group for radio based on source hash\n    // ::touch_develop::micro_bit::radioDefaultGroup = programHash();\n\n    unsigned ver = *pc++;\n    checkStr(ver == 0x4210, \":( Bad runtime version\");\n\n    bytecode = *((uint16_t **)pc++); // the actual bytecode is here\n    globals = (TValue *)app_alloc(sizeof(TValue) * getNumGlobals());\n    memset(globals, 0, sizeof(TValue) * getNumGlobals());\n\n    // can be any valid address, best in RAM for speed\n    globals[0] = (TValue)&globals;\n\n    // just compare the first word\n    // TODO\n    checkStr(((uint32_t *)bytecode)[0] == 0x923B8E70 && (unsigned)templateHash() == *pc,\n             \":( Failed partial flash\");\n\n    uintptr_t startptr = (uintptr_t)bytecode;\n\n    startptr += 64; // header\n\n    initPerfCounters();\n\n    initRuntime();\n\n    runAction0((Action)startptr);\n\n    pxt::releaseFiber();\n}\n\nvoid start() {\n    exec_binary((unsigned *)functionsAndBytecode);\n}\n#endif\n\n} // namespace pxt\n\nnamespace Array_ {\n//%\nbool isArray(TValue arr) {\n    auto vt = getAnyVTable(arr);\n    return vt && vt->classNo == BuiltInType::RefCollection;\n}\n} // namespace Array_\n\nnamespace pxtrt {\n//% expose\nRefCollection *keysOf(TValue v) {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl[keys]: => %p\", r);\n    if (getAnyVTable(v) != &RefMap_vtable)\n        return r;\n    auto rm = (RefMap *)v;\n    auto len = rm->keys.getLength();\n    if (!len)\n        return r;\n    registerGCObj(r);\n    r->setLength(len);\n    auto dst = r->getData();\n    memcpy(dst, rm->keys.getData(), len * sizeof(TValue));\n    for (unsigned i = 0; i < len; ++i)\n        incr(dst[i]);\n    unregisterGCObj(r);\n    return r;\n}\n} // namespace pxtrt\n",
            "pxt.json": "{\n  \"name\": \"base\",\n  \"description\": \"The base library\",\n  \"files\": [\n    \"README.md\",\n    \"pxt-core.d.ts\",\n    \"pxt.cpp\",\n    \"gc.cpp\",\n    \"configkeys.h\",\n    \"pxtbase.h\",\n    \"core.cpp\",\n    \"advmath.cpp\",\n    \"trig.cpp\",\n    \"pxt-helpers.ts\",\n    \"fixed.ts\",\n    \"buffer.cpp\",\n    \"buffer.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"loops.cpp\",\n    \"math.ts\",\n    \"ns.ts\",\n    \"control.cpp\",\n    \"control.ts\",\n    \"console.ts\",\n    \"json.ts\",\n    \"templates.ts\",\n    \"eventcontext.ts\",\n    \"pause.ts\",\n    \"forever.ts\",\n    \"utfdecoder.ts\",\n    \"scheduling.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {},\n  \"yotta\": {\n    \"optionalConfig\": {\n      \"PXT_GC_CHECKS\": 0\n    },\n    \"userConfigs\": [\n      {\n        \"description\": \"(Diagnostics) Garbage Collection checks.\",\n        \"config\": {\n          \"PXT_GC_CHECKS\": 1\n        }\n      }\n    ]\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtbase.h": "#ifndef __PXTBASE_H\n#define __PXTBASE_H\n\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wformat\"\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n\n// needed for gcc6; not sure why\n#undef min\n#undef max\n\n#define NOLOG(...)                                                                                 \\\n    do {                                                                                           \\\n    } while (0)\n\n#define MEMDBG NOLOG\n//#define MEMDBG DMESG\n#define MEMDBG2 NOLOG\n\n#include \"pxtconfig.h\"\n#include \"configkeys.h\"\n\n#ifndef PXT_UTF8\n#define PXT_UTF8 0\n#endif\n\n#if defined(PXT_VM)\n#include <stdint.h>\n#if UINTPTR_MAX == 0xffffffff\n#define PXT32 1\n#elif UINTPTR_MAX == 0xffffffffffffffff\n#define PXT64 1\n#else\n#error \"UINTPTR_MAX has invalid value\"\n#endif\n#endif\n\n#define intcheck(...) check(__VA_ARGS__)\n//#define intcheck(...) do {} while (0)\n\n#ifdef PXT_USE_FLOAT\n#define NUMBER float\n#else\n#define NUMBER double\n#endif\n\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n\n#ifdef POKY\nvoid *operator new(size_t size, void *ptr);\nvoid *operator new(size_t size);\n#else\n#include <new>\n#endif\n\n#include \"platform.h\"\n#include \"pxtcore.h\"\n\n#ifndef PXT_REGISTER_RESET\n#define PXT_REGISTER_RESET(fn) ((void)0)\n#endif\n\n#ifndef PXT_VTABLE_SHIFT\n#define PXT_VTABLE_SHIFT 2\n#endif\n\n#define PXT_REFCNT_FLASH 0xfffe\n\n#define CONCAT_1(a, b) a##b\n#define CONCAT_0(a, b) CONCAT_1(a, b)\n#define STATIC_ASSERT(e) enum { CONCAT_0(_static_assert_, __LINE__) = 1 / ((e) ? 1 : 0) };\n\n#ifndef ramint_t\n// this type limits size of arrays\n#if defined(__linux__) || defined(PXT_VM)\n// TODO fix the inline array accesses to take note of this!\n#define ramint_t uint32_t\n#else\n#define ramint_t uint16_t\n#endif\n#endif\n\n#ifndef PXT_IN_ISR\n#define PXT_IN_ISR() (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk)\n#endif\n\n#ifdef POKY\ninline void *operator new(size_t, void *p) {\n    return p;\n}\ninline void *operator new[](size_t, void *p) {\n    return p;\n}\n#endif\n\nnamespace pxt {\n\ntemplate <typename T> inline const T &max(const T &a, const T &b) {\n    if (a < b)\n        return b;\n    return a;\n}\n\ntemplate <typename T> inline const T &min(const T &a, const T &b) {\n    if (a < b)\n        return a;\n    return b;\n}\n\ntemplate <typename T> inline void swap(T &a, T &b) {\n    T tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//\n// Tagged values (assume 4 bytes for now, Cortex-M0)\n//\nstruct TValueStruct {};\ntypedef TValueStruct *TValue;\n\ntypedef TValue TNumber;\ntypedef TValue Action;\ntypedef TValue ImageLiteral;\n\n// To be implemented by the target\nextern \"C\" void target_panic(int error_code);\nextern \"C\" void target_reset();\nvoid sleep_ms(unsigned ms);\nvoid sleep_us(uint64_t us);\nvoid releaseFiber();\nuint64_t current_time_us();\nint current_time_ms();\nvoid initRuntime();\nvoid sendSerial(const char *data, int len);\nvoid setSendToUART(void (*f)(const char *, int));\nint getSerialNumber();\nuint64_t getLongSerialNumber();\nvoid registerWithDal(int id, int event, Action a, int flags = 16); // EVENT_LISTENER_DEFAULT_FLAGS\nvoid runInParallel(Action a);\nvoid runForever(Action a);\nvoid waitForEvent(int id, int event);\n//%\nunsigned afterProgramPage();\n//%\nvoid dumpDmesg();\n\n// also defined DMESG macro\n// end\n\n#define TAGGED_SPECIAL(n) (TValue)(void *)((n << 2) | 2)\n#define TAG_FALSE TAGGED_SPECIAL(2) // 10\n#define TAG_TRUE TAGGED_SPECIAL(16) // 66\n#define TAG_UNDEFINED (TValue)0\n#define TAG_NULL TAGGED_SPECIAL(1) // 6\n#define TAG_NAN TAGGED_SPECIAL(3)  // 14\n#define TAG_NUMBER(n) (TNumber)(void *)(((uintptr_t)(uint32_t)(n) << 1) | 1)\n#define TAG_NON_VALUE TAGGED_SPECIAL(4) // 18; doesn't represent any JS value\n\n#ifdef PXT_VM\ninline bool isEncodedDouble(uint64_t v) {\n    return (v >> 48) != 0;\n}\n#endif\n\ninline bool isDouble(TValue v) {\n#ifdef PXT64\n    return ((uintptr_t)v >> 48) != 0;\n#else\n    (void)v;\n    return false;\n#endif\n}\n\ninline bool isPointer(TValue v) {\n    return !isDouble(v) && v != 0 && ((intptr_t)v & 3) == 0;\n}\n\ninline bool isTagged(TValue v) {\n    return (!isDouble(v) && ((intptr_t)v & 3)) || !v;\n}\n\ninline bool isInt(TValue v) {\n    return !isDouble(v) && ((intptr_t)v & 1);\n}\n\ninline bool isSpecial(TValue v) {\n    return !isDouble(v) && ((intptr_t)v & 2);\n}\n\ninline bool bothNumbers(TValue a, TValue b) {\n    return !isDouble(a) && !isDouble(b) && ((intptr_t)a & (intptr_t)b & 1);\n}\n\ninline int numValue(TValue n) {\n    return (int)((intptr_t)n >> 1);\n}\n\ninline bool canBeTagged(int v) {\n    (void)v;\n#ifdef PXT_BOX_DEBUG\n    return false;\n#elif defined(PXT64)\n    return true;\n#else\n    return (v << 1) >> 1 == v;\n#endif\n}\n\n// see https://anniecherkaev.com/the-secret-life-of-nan\n\n#define NanBoxingOffset 0x1000000000000LL\n\ntemplate <typename TO, typename FROM> TO bitwise_cast(FROM in) {\n    STATIC_ASSERT(sizeof(TO) == sizeof(FROM));\n    union {\n        FROM from;\n        TO to;\n    } u;\n    u.from = in;\n    return u.to;\n}\n\ninline double decodeDouble(uint64_t v) {\n    return bitwise_cast<double>(v - NanBoxingOffset);\n}\n\n#ifdef PXT64\nSTATIC_ASSERT(sizeof(void *) == 8);\ninline double doubleVal(TValue v) {\n    return bitwise_cast<double>((uint64_t)v - NanBoxingOffset);\n}\n\ninline TValue tvalueFromDouble(double d) {\n    return (TValue)(bitwise_cast<uint64_t>(d) + NanBoxingOffset);\n}\n#else\nSTATIC_ASSERT(sizeof(void *) == 4);\n#endif\n\n// keep in sym with sim/control.ts\ntypedef enum {\n    PANIC_CODAL_OOM = 20,\n    PANIC_GC_OOM = 21,\n    PANIC_GC_TOO_BIG_ALLOCATION = 22,\n    PANIC_CODAL_HEAP_ERROR = 30,\n    PANIC_CODAL_NULL_DEREFERENCE = 40,\n    PANIC_CODAL_USB_ERROR = 50,\n    PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR = 90,\n\n    PANIC_INVALID_BINARY_HEADER = 901,\n    PANIC_OUT_OF_BOUNDS = 902,\n    PANIC_REF_DELETED = 903,\n    PANIC_SIZE = 904,\n    PANIC_INVALID_VTABLE = 905,\n    PANIC_INTERNAL_ERROR = 906,\n    PANIC_NO_SUCH_CONFIG = 907,\n    PANIC_NO_SUCH_PIN = 908,\n    PANIC_INVALID_ARGUMENT = 909,\n    PANIC_MEMORY_LIMIT_EXCEEDED = 910,\n    PANIC_SCREEN_ERROR = 911,\n    PANIC_MISSING_PROPERTY = 912,\n    PANIC_INVALID_IMAGE = 913,\n    PANIC_CALLED_FROM_ISR = 914,\n    PANIC_HEAP_DUMPED = 915,\n    PANIC_STACK_OVERFLOW = 916,\n    PANIC_BLOCKING_TO_STRING = 917,\n    PANIC_VM_ERROR = 918,\n    PANIC_SETTINGS_CLEARED = 920,\n    PANIC_SETTINGS_OVERLOAD = 921,\n\n    PANIC_CAST_FIRST = 980,\n    PANIC_CAST_FROM_UNDEFINED = 980,\n    PANIC_CAST_FROM_BOOLEAN = 981,\n    PANIC_CAST_FROM_NUMBER = 982,\n    PANIC_CAST_FROM_STRING = 983,\n    PANIC_CAST_FROM_OBJECT = 984,\n    PANIC_CAST_FROM_FUNCTION = 985,\n    PANIC_CAST_FROM_NULL = 989,\n\n    PANIC_UNHANDLED_EXCEPTION = 999,\n\n} PXT_PANIC;\n\nextern const uintptr_t functionsAndBytecode[];\nextern TValue *globals;\nextern uint16_t *bytecode;\nclass RefRecord;\n\n// Utility functions\n\ntypedef TValue (*RunActionType)(Action a, TValue arg0, TValue arg1, TValue arg2);\n\n#define asmRunAction3 ((RunActionType)(((uintptr_t *)bytecode)[12]))\n\nstatic inline TValue runAction3(Action a, TValue arg0, TValue arg1, TValue arg2) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction2(Action a, TValue arg0, TValue arg1) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction1(Action a, TValue arg0) {\n    return asmRunAction3(a, arg0, 0, 0);\n}\nstatic inline TValue runAction0(Action a) {\n    return asmRunAction3(a, 0, 0, 0);\n}\n\nclass RefAction;\nclass BoxedString;\nstruct VTable;\n\n//%\nAction mkAction(int totallen, RefAction *act);\n//% expose\nint templateHash();\n//% expose\nint programHash();\n//% expose\nBoxedString *programName();\n//% expose\nunsigned programSize();\n//%\nint getNumGlobals();\n//%\nRefRecord *mkClassInstance(VTable *vt);\n//%\nvoid debugMemLeaks();\n//%\nvoid anyPrint(TValue v);\n\n//%\nint getConfig(int key, int defl = -1);\n\n//%\nint toInt(TNumber v);\n//%\nunsigned toUInt(TNumber v);\n//%\nNUMBER toDouble(TNumber v);\n//%\nfloat toFloat(TNumber v);\n//%\nTNumber fromDouble(NUMBER r);\n//%\nTNumber fromFloat(float r);\n\n//%\nTNumber fromInt(int v);\n//%\nTNumber fromUInt(unsigned v);\n//%\nTValue fromBool(bool v);\n//%\nbool eq_bool(TValue a, TValue b);\n//%\nbool eqq_bool(TValue a, TValue b);\n\n//%\nvoid failedCast(TValue v);\n//%\nvoid missingProperty(TValue v);\n\nvoid error(PXT_PANIC code, int subcode = 0);\nvoid exec_binary(unsigned *pc);\nvoid start();\n\nstruct HandlerBinding {\n    HandlerBinding *next;\n    int source;\n    int value;\n    Action action;\n};\nHandlerBinding *findBinding(int source, int value);\nHandlerBinding *nextBinding(HandlerBinding *curr, int source, int value);\nvoid setBinding(int source, int value, Action act);\n\n// The standard calling convention is:\n//   - when a pointer is loaded from a local/global/field etc, and incr()ed\n//     (in other words, its presence on stack counts as a reference)\n//   - after a function call, all pointers are popped off the stack and decr()ed\n// This does not apply to the RefRecord and st/ld(ref) methods - they unref()\n// the RefRecord* this.\n//%\nTValue incr(TValue e);\n//%\nvoid decr(TValue e);\n\n#ifdef PXT_GC\ninline TValue incr(TValue e) {\n    return e;\n}\ninline void decr(TValue e) {}\n#endif\n\nclass RefObject;\n\nstatic inline RefObject *incrRC(RefObject *r) {\n    return (RefObject *)incr((TValue)r);\n}\nstatic inline void decrRC(RefObject *r) {\n    decr((TValue)r);\n}\n\ninline void *ptrOfLiteral(int offset) {\n    return &bytecode[offset];\n}\n\n// Checks if object is ref-counted, and has a custom PXT vtable in front\n// TODO\ninline bool isRefCounted(TValue e) {\n#ifdef PXT_GC\n    return isPointer(e);\n#else\n    return !isTagged(e) && (*((uint16_t *)e) & 1) == 1;\n#endif\n}\n\ninline void check(int cond, PXT_PANIC code, int subcode = 0) {\n    if (!cond)\n        error(code, subcode);\n}\n\ninline void oops(int subcode = 0) {\n    target_panic(800 + subcode);\n}\n\nclass RefObject;\n\ntypedef void (*RefObjectMethod)(RefObject *self);\ntypedef unsigned (*RefObjectSizeMethod)(RefObject *self);\ntypedef void *PVoid;\ntypedef void **PPVoid;\n\ntypedef void *Object_;\n\n#define VTABLE_MAGIC 0xF9\n\nenum class ValType : uint8_t {\n    Undefined,\n    Boolean,\n    Number,\n    String,\n    Object,\n    Function,\n};\n\n// keep in sync with pxt-core (search for the type name)\nenum class BuiltInType : uint16_t {\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n};\n\nstruct VTable {\n    uint16_t numbytes;\n    ValType objectType;\n    uint8_t magic;\n#ifdef PXT_VM\n    uint16_t ifaceHashEntries;\n    BuiltInType lastClassNo;\n#else\n    PVoid *ifaceTable;\n#endif\n    BuiltInType classNo;\n    uint16_t reserved;\n    uint32_t ifaceHashMult;\n\n    // we only use the first few methods here; pxt will generate more\n#ifdef PXT_GC\n    PVoid methods[8];\n#else\n    PVoid methods[3];\n#endif\n};\n\n//%\nextern const VTable string_inline_ascii_vt;\n#if PXT_UTF8\n//%\nextern const VTable string_inline_utf8_vt;\n//%\nextern const VTable string_cons_vt;\n//%\nextern const VTable string_skiplist16_vt;\n#endif\n//%\nextern const VTable buffer_vt;\n//%\nextern const VTable number_vt;\n//%\nextern const VTable RefAction_vtable;\n\n#ifdef PXT_GC\n#define PXT_VTABLE_TO_INT(vt) ((uintptr_t)(vt))\n#else\n#define PXT_VTABLE_TO_INT(vt) ((uintptr_t)(vt) >> PXT_VTABLE_SHIFT)\n#endif\n\n// allocate 1M of heap on iOS\n#define PXT_IOS_HEAP_ALLOC_BITS 20\n\n#ifdef PXT_GC\n#ifdef PXT_IOS\nextern uint8_t *gcBase;\n#endif\ninline bool isReadOnly(TValue v) {\n#ifdef PXT64\n#ifdef PXT_IOS\n    return !isPointer(v) || (((uintptr_t)v - (uintptr_t)gcBase) >> PXT_IOS_HEAP_ALLOC_BITS) != 0;\n#else\n    return !isPointer(v) || !((uintptr_t)v >> 37);\n#endif\n#else\n    return isTagged(v) || !((uintptr_t)v >> 28);\n#endif\n}\n#endif\n\n#ifdef PXT_GC\n#define REFCNT(x) 0\n#else\n#define REFCNT(x) ((x)->refcnt)\n#endif\n\n// A base abstract class for ref-counted objects.\nclass RefObject {\n  public:\n#ifdef PXT_GC\n    uintptr_t vtable;\n\n    RefObject(const VTable *vt) {\n#if defined(PXT32) && defined(PXT_VM)\n        if ((uint32_t)vt & 0xf0000000)\n            target_panic(PANIC_INVALID_VTABLE);\n#endif\n        vtable = PXT_VTABLE_TO_INT(vt);\n    }\n#else\n    uint16_t refcnt;\n    uint16_t vtable;\n\n    RefObject(const VTable *vt) {\n        refcnt = 3;\n        vtable = PXT_VTABLE_TO_INT(vt);\n    }\n#endif\n\n    void destroyVT();\n    void printVT();\n\n#ifdef PXT_GC\n    inline void ref() {}\n    inline void unref() {}\n    inline bool isReadOnly() { return pxt::isReadOnly((TValue)this); }\n#else\n    inline bool isReadOnly() { return refcnt == PXT_REFCNT_FLASH; }\n\n    // Increment/decrement the ref-count. Decrementing to zero deletes the current object.\n    inline void ref() {\n        if (isReadOnly())\n            return;\n        MEMDBG2(\"INCR: %p refs=%d\", this, this->refcnt);\n        check(refcnt > 1, PANIC_REF_DELETED);\n        refcnt += 2;\n    }\n\n    inline void unref() {\n        if (isReadOnly())\n            return;\n        MEMDBG2(\"DECR: %p refs=%d\", this, this->refcnt);\n        check(refcnt > 1, PANIC_REF_DELETED);\n        check((refcnt & 1), PANIC_REF_DELETED);\n        refcnt -= 2;\n        if (refcnt == 1) {\n            MEMDBG(\"DEL: %p\", this);\n            destroyVT();\n        }\n    }\n#endif\n};\n\nclass Segment {\n  private:\n    TValue *data;\n    ramint_t length;\n    ramint_t size;\n\n    // this just gives max value of ramint_t\n    void growByMin(ramint_t minSize);\n    void ensure(ramint_t newSize);\n\n  public:\n    static constexpr ramint_t MaxSize = (((1U << (8 * sizeof(ramint_t) - 1)) - 1) << 1) + 1;\n    static constexpr TValue DefaultValue = TAG_UNDEFINED; // == NULL\n\n    Segment() : data(nullptr), length(0), size(0) {}\n\n    TValue get(unsigned i) { return i < length ? data[i] : NULL; }\n    void set(unsigned i, TValue value);\n\n    unsigned getLength() { return length; };\n    void setLength(unsigned newLength);\n\n    void push(TValue value) { set(length, value); }\n    TValue pop();\n\n    TValue remove(unsigned i);\n    void insert(unsigned i, TValue value);\n\n    void destroy();\n\n    void print();\n\n    TValue *getData() { return data; }\n};\n\n// Low-Level segment using system malloc\nclass LLSegment {\n  private:\n    TValue *data;\n    ramint_t length;\n    ramint_t size;\n\n  public:\n    LLSegment() : data(nullptr), length(0), size(0) {}\n\n    void set(unsigned idx, TValue v);\n    void push(TValue value) { set(length, value); }\n    TValue pop();\n    void destroy();\n    void setLength(unsigned newLen);\n\n    TValue get(unsigned i) { return i < length ? data[i] : NULL; }\n    unsigned getLength() { return length; };\n    TValue *getData() { return data; }\n};\n\n// A ref-counted collection of either primitive or ref-counted objects (String, Image,\n// user-defined record, another collection)\nclass RefCollection : public RefObject {\n  public:\n    Segment head;\n\n    RefCollection();\n\n    static void destroy(RefCollection *coll);\n    static void scan(RefCollection *coll);\n    static unsigned gcsize(RefCollection *coll);\n    static void print(RefCollection *coll);\n\n    unsigned length() { return head.getLength(); }\n    void setLength(unsigned newLength) { head.setLength(newLength); }\n    TValue getAt(int i) { return head.get(i); }\n    TValue *getData() { return head.getData(); }\n};\n\nclass RefMap : public RefObject {\n  public:\n    Segment keys;\n    Segment values;\n\n    RefMap();\n    static void destroy(RefMap *map);\n    static void scan(RefMap *map);\n    static unsigned gcsize(RefMap *coll);\n    static void print(RefMap *map);\n    int findIdx(BoxedString *key);\n};\n\n// A ref-counted, user-defined JS object.\nclass RefRecord : public RefObject {\n  public:\n    // The object is allocated, so that there is space at the end for the fields.\n    TValue fields[];\n\n    RefRecord(VTable *v) : RefObject(v) {}\n\n    TValue ld(int idx);\n    TValue ldref(int idx);\n    void st(int idx, TValue v);\n    void stref(int idx, TValue v);\n};\n\nstatic inline VTable *getVTable(RefObject *r) {\n#ifdef PXT_GC\n    return (VTable *)(r->vtable & ~1);\n#else\n    return (VTable *)((uintptr_t)r->vtable << PXT_VTABLE_SHIFT);\n#endif\n}\n\nstatic inline VTable *getAnyVTable(TValue v) {\n    if (!isRefCounted(v))\n        return NULL;\n    auto vt = getVTable((RefObject *)v);\n    if (vt->magic == VTABLE_MAGIC)\n        return vt;\n    return NULL;\n}\n\n// these are needed when constructing vtables for user-defined classes\n//%\nvoid RefRecord_destroy(RefRecord *r);\n//%\nvoid RefRecord_print(RefRecord *r);\n//%\nvoid RefRecord_scan(RefRecord *r);\n//%\nunsigned RefRecord_gcsize(RefRecord *r);\n\ntypedef TValue (*ActionCB)(TValue *captured, TValue arg0, TValue arg1, TValue arg2);\n\n// Ref-counted function pointer.\nclass RefAction : public RefObject {\n  public:\n#if defined(PXT_VM) && defined(PXT32)\n    uint32_t _padding; // match binary format in .pxt64 files\n#endif\n    uint16_t len;\n    uint16_t numArgs;\n#ifdef PXT_VM\n    uint16_t initialLen;\n    uint16_t reserved;\n#endif\n    ActionCB func; // The function pointer\n    // fields[] contain captured locals\n    TValue fields[];\n\n    static void destroy(RefAction *act);\n    static void scan(RefAction *act);\n    static unsigned gcsize(RefAction *coll);\n    static void print(RefAction *act);\n\n    RefAction();\n\n    inline void stCore(int idx, TValue v) {\n        // DMESG(\"ST [%d] = %d \", idx, v); this->print();\n        intcheck(0 <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 10);\n        intcheck(fields[idx] == 0, PANIC_OUT_OF_BOUNDS, 11); // only one assignment permitted\n        fields[idx] = v;\n    }\n};\n\n// These two are used to represent locals written from inside inline functions\nclass RefRefLocal : public RefObject {\n  public:\n    TValue v;\n    static void destroy(RefRefLocal *l);\n    static void scan(RefRefLocal *l);\n    static unsigned gcsize(RefRefLocal *l);\n    static void print(RefRefLocal *l);\n    RefRefLocal();\n};\n\ntypedef int color;\n\n// note: this is hardcoded in PXT (hexfile.ts)\n\nclass BoxedNumber : public RefObject {\n  public:\n    NUMBER num;\n    BoxedNumber() : RefObject(&number_vt) {}\n} __attribute__((packed));\n\nclass BoxedString : public RefObject {\n  public:\n    union {\n        struct {\n            uint16_t length;\n            char data[0];\n        } ascii;\n#if PXT_UTF8\n        struct {\n            uint16_t length;\n            char data[0];\n        } utf8;\n        struct {\n            BoxedString *left;\n            BoxedString *right;\n        } cons;\n        struct {\n            uint16_t size;\n            uint16_t length;\n            uint16_t *list;\n        } skip;\n#endif\n    };\n\n#if PXT_UTF8\n    uintptr_t runMethod(int idx) {\n        return ((uintptr_t(*)(BoxedString *))((VTable *)this->vtable)->methods[idx])(this);\n    }\n    const char *getUTF8Data() { return (const char *)runMethod(4); }\n    uint32_t getUTF8Size() { return (uint32_t)runMethod(5); }\n    // in characters\n    uint32_t getLength() { return (uint32_t)runMethod(6); }\n    const char *getUTF8DataAt(uint32_t pos) {\n        auto meth =\n            ((const char *(*)(BoxedString *, uint32_t))((VTable *)this->vtable)->methods[7]);\n        return meth(this, pos);\n    }\n#else\n    const char *getUTF8Data() { return ascii.data; }\n    uint32_t getUTF8Size() { return ascii.length; }\n    uint32_t getLength() { return ascii.length; }\n    const char *getUTF8DataAt(uint32_t pos) { return pos < ascii.length ? ascii.data + pos : NULL; }\n#endif\n\n    TNumber charCodeAt(int pos);\n\n    BoxedString(const VTable *vt) : RefObject(vt) {}\n};\n\n// cross version compatible way of accessing string data\n#ifndef PXT_STRING_DATA\n#define PXT_STRING_DATA(str) str->getUTF8Data()\n#endif\n\n// cross version compatible way of accessing string length\n#ifndef PXT_STRING_DATA_LENGTH\n#define PXT_STRING_DATA_LENGTH(str) str->getUTF8Size()\n#endif\n\nclass BoxedBuffer : public RefObject {\n  public:\n    // data needs to be word-aligned, so we use 32 bits for length\n    int length;\n#ifdef PXT_VM\n    // VM can be 64 bit and it compiles as such\n    int32_t _padding;\n#endif\n    uint8_t data[0];\n    BoxedBuffer() : RefObject(&buffer_vt) {}\n};\n\n// cross version compatible way of access data field\n#ifndef PXT_BUFFER_DATA\n#define PXT_BUFFER_DATA(buffer) buffer->data\n#endif\n\n// cross version compatible way of access data length\n#ifndef PXT_BUFFER_LENGTH\n#define PXT_BUFFER_LENGTH(buffer) buffer->length\n#endif\n\n#ifndef PXT_CREATE_BUFFER\n#define PXT_CREATE_BUFFER(data, len) pxt::mkBuffer(data, len)\n#endif\n\n// Legacy format:\n// the first byte of data indicates the format - currently 0xE1 or 0xE4 to 1 or 4 bit bitmaps\n// second byte indicates width in pixels\n// third byte indicates the height (which should also match the size of the buffer)\n// just like ordinary buffers, these can be layed out in flash\n\n// Current format:\n// 87 BB WW WW HH HH 00 00 DATA\n// that is: 0x87, 0x01 or 0x04 - bpp, width in little endian, height, 0x00, 0x00 followed by data\n// for 4 bpp images, rows are word-aligned (as in legacy)\n\n#define IMAGE_HEADER_MAGIC 0x87\n\nstruct ImageHeader {\n    uint8_t magic;\n    uint8_t bpp;\n    uint16_t width;\n    uint16_t height;\n    uint16_t padding;\n    uint8_t pixels[0];\n};\n\nclass RefImage : public RefObject {\n  public:\n    BoxedBuffer *buffer;\n\n    RefImage(BoxedBuffer *buf);\n    RefImage(uint32_t sz);\n\n    void setBuffer(BoxedBuffer *b);\n\n    uint8_t *data() { return buffer->data; }\n    int length() { return (int)buffer->length; }\n\n    ImageHeader *header() { return (ImageHeader *)buffer->data; }\n    int pixLength() { return length() - sizeof(ImageHeader); }\n\n    int width() { return header()->width; }\n    int height() { return header()->height; }\n    int wordHeight();\n    int bpp() { return header()->bpp; }\n\n    bool hasPadding() { return (height() & 0x7) != 0; }\n\n    uint8_t *pix() { return header()->pixels; }\n\n    int byteHeight() {\n        if (bpp() == 1)\n            return (height() + 7) >> 3;\n        else if (bpp() == 4)\n            return ((height() * 4 + 31) >> 5) << 2;\n        else {\n            oops(21);\n            return -1;\n        }\n    }\n\n    uint8_t *pix(int x, int y) {\n        uint8_t *d = &pix()[byteHeight() * x];\n        if (y) {\n            if (bpp() == 1)\n                d += y >> 3;\n            else if (bpp() == 4)\n                d += y >> 1;\n        }\n        return d;\n    }\n\n    uint8_t fillMask(color c);\n    bool inRange(int x, int y);\n    void clamp(int *x, int *y);\n    void makeWritable();\n\n    static void destroy(RefImage *t);\n    static void scan(RefImage *t);\n    static unsigned gcsize(RefImage *t);\n    static void print(RefImage *t);\n};\n\nRefImage *mkImage(int w, int h, int bpp);\n\ntypedef BoxedBuffer *Buffer;\ntypedef BoxedString *String;\ntypedef RefImage *Image_;\n\nuint32_t toRealUTF8(String str, uint8_t *dst);\n\n// keep in sync with github/pxt/pxtsim/libgeneric.ts\nenum class NumberFormat {\n    Int8LE = 1,\n    UInt8LE,\n    Int16LE,\n    UInt16LE,\n    Int32LE,\n    Int8BE,\n    UInt8BE,\n    Int16BE,\n    UInt16BE,\n    Int32BE,\n\n    UInt32LE,\n    UInt32BE,\n    Float32LE,\n    Float64LE,\n    Float32BE,\n    Float64BE,\n};\n\n// this will, unlike mkStringCore, UTF8-canonicalize the data\nString mkString(const char *data, int len = -1);\n// data can be NULL in both cases\nBuffer mkBuffer(const uint8_t *data, int len);\nString mkStringCore(const char *data, int len = -1);\n\nTNumber getNumberCore(uint8_t *buf, int size, NumberFormat format);\nvoid setNumberCore(uint8_t *buf, int size, NumberFormat format, TNumber value);\n\nvoid seedRandom(unsigned seed);\nvoid seedAddRandom(unsigned seed);\n// max is inclusive\nunsigned getRandom(unsigned max);\n\nValType valType(TValue v);\n\n// this is equivalent to JS `throw v`; it will leave\n// the current function(s), all the way until the nearest try block and\n// ignore all destructors (think longjmp())\nvoid throwValue(TValue v);\n\n#ifdef PXT_GC\nvoid registerGC(TValue *root, int numwords = 1);\nvoid unregisterGC(TValue *root, int numwords = 1);\nvoid registerGCPtr(TValue ptr);\nvoid unregisterGCPtr(TValue ptr);\nstatic inline void registerGCObj(RefObject *ptr) {\n    registerGCPtr((TValue)ptr);\n}\nstatic inline void unregisterGCObj(RefObject *ptr) {\n    unregisterGCPtr((TValue)ptr);\n}\nvoid gc(int flags);\n#else\ninline void registerGC(TValue *root, int numwords = 1) {}\ninline void unregisterGC(TValue *root, int numwords = 1) {}\ninline void registerGCPtr(TValue ptr) {}\ninline void unregisterGCPtr(TValue ptr) {}\ninline void gc(int) {}\n#endif\n\nstruct StackSegment {\n    void *top;\n    void *bottom;\n    StackSegment *next;\n};\n\n#define NUM_TRY_FRAME_REGS 3\nstruct TryFrame {\n    TryFrame *parent;\n    uintptr_t registers[NUM_TRY_FRAME_REGS];\n};\n\nstruct ThreadContext {\n    TValue *globals;\n    StackSegment stack;\n    TryFrame *tryFrame;\n    TValue thrownValue;\n#ifdef PXT_GC_THREAD_LIST\n    ThreadContext *next;\n    ThreadContext *prev;\n#endif\n};\n\n#ifdef PXT_GC_THREAD_LIST\nextern ThreadContext *threadContexts;\nvoid *threadAddressFor(ThreadContext *, void *sp);\n#endif\n\nvoid releaseThreadContext(ThreadContext *ctx);\nThreadContext *getThreadContext();\nvoid setThreadContext(ThreadContext *ctx);\n\n#ifndef PXT_GC_THREAD_LIST\nvoid gcProcessStacks(int flags);\n#endif\n\nvoid gcProcess(TValue v);\nvoid gcFreeze();\n#ifdef PXT_VM\nvoid gcStartup();\nvoid gcPreStartup();\nvoid *gcPrealloc(int numbytes);\nbool inGCPrealloc();\n#else\nstatic inline bool inGCPrealloc() {\n    return false;\n}\n#endif\n\nvoid coreReset();\nvoid gcReset();\nvoid systemReset();\n\nvoid *gcAllocate(int numbytes);\nvoid *gcAllocateArray(int numbytes);\nextern \"C\" void *app_alloc(int numbytes);\nextern \"C\" void *app_free(void *ptr);\nvoid gcPreAllocateBlock(uint32_t sz);\n#ifndef PXT_GC\ninline void *gcAllocate(int numbytes) {\n    return xmalloc(numbytes);\n}\n#endif\n\n#ifdef PXT64\n#define TOWORDS(bytes) (((bytes) + 7) >> 3)\n#else\n#define TOWORDS(bytes) (((bytes) + 3) >> 2)\n#endif\n\n#ifndef PXT_VM\n#define soft_panic target_panic\n#endif\n\nextern int debugFlags;\n\nenum class PerfCounters {\n    GC,\n};\n\n#ifdef PXT_PROFILE\n#ifndef PERF_NOW\n#error \"missing platform timer support\"\n#endif\n\nstruct PerfCounter {\n    uint32_t value;\n    uint32_t numstops;\n    uint32_t start;\n};\n\nextern struct PerfCounter *perfCounters;\n\nvoid initPerfCounters();\n//%\nvoid dumpPerfCounters();\n//%\nvoid startPerfCounter(PerfCounters n);\n//%\nvoid stopPerfCounter(PerfCounters n);\n#else\ninline void startPerfCounter(PerfCounters n) {}\ninline void stopPerfCounter(PerfCounters n) {}\ninline void initPerfCounters() {}\ninline void dumpPerfCounters() {}\n#endif\n\n#ifdef PXT_VM\nString mkInternalString(const char *str);\n#define PXT_DEF_STRING(name, val) String name = mkInternalString(val);\n#else\n#define PXT_DEF_STRING(name, val)                                                                  \\\n    static const char name[] __attribute__((aligned(4))) = \"@PXT@:\" val;\n#endif\n\n} // namespace pxt\n\nusing namespace pxt;\n\nnamespace numops {\n//%\nString toString(TValue v);\n//%\nint toBool(TValue v);\n//%\nint toBoolDecr(TValue v);\n} // namespace numops\n\nnamespace pxt {\ninline bool toBoolQuick(TValue v) {\n    if (v == TAG_TRUE)\n        return true;\n    if (v == TAG_FALSE || v == TAG_UNDEFINED || v == TAG_NULL)\n        return false;\n    return numops::toBool(v);\n}\n} // namespace pxt\n\nnamespace pxtrt {\n//%\nRefMap *mkMap();\n//%\nTValue mapGetByString(RefMap *map, String key);\n//%\nint lookupMapKey(String key);\n//%\nTValue mapGet(RefMap *map, unsigned key);\n//%\nvoid mapSetByString(RefMap *map, String key, TValue val);\n//%\nvoid mapSet(RefMap *map, unsigned key, TValue val);\n} // namespace pxtrt\n\nnamespace pins {\nBuffer createBuffer(int size);\n}\n\nnamespace String_ {\n//%\nint compare(String a, String b);\n} // namespace String_\n\nnamespace Array_ {\n//%\nRefCollection *mk();\n//%\nint length(RefCollection *c);\n//%\nvoid setLength(RefCollection *c, int newLength);\n//%\nvoid push(RefCollection *c, TValue x);\n//%\nTValue pop(RefCollection *c);\n//%\nTValue getAt(RefCollection *c, int x);\n//%\nvoid setAt(RefCollection *c, int x, TValue y);\n//%\nTValue removeAt(RefCollection *c, int x);\n//%\nvoid insertAt(RefCollection *c, int x, TValue value);\n//%\nint indexOf(RefCollection *c, TValue x, int start);\n//%\nbool removeElement(RefCollection *c, TValue x);\n} // namespace Array_\n\n#define NEW_GC(T, ...) new (gcAllocate(sizeof(T))) T(__VA_ARGS__)\n\n// The ARM Thumb generator in the JavaScript code is parsing\n// the hex file and looks for the magic numbers as present here.\n//\n// Then it fetches function pointer addresses from there.\n//\n// The vtable pointers are there, so that the ::emptyData for various types\n// can be patched with the right vtable.\n//\n#define PXT_SHIMS_BEGIN                                                                            \\\n    namespace pxt {                                                                                \\\n    const uintptr_t functionsAndBytecode[]                                                         \\\n        __attribute__((aligned(0x20))) = {0x08010801, 0x42424242, 0x08010801, 0x8de9d83e,\n\n#define PXT_SHIMS_END                                                                              \\\n    }                                                                                              \\\n    ;                                                                                              \\\n    }\n\n#if !defined(X86_64) && !defined(PXT_VM)\n#pragma GCC diagnostic ignored \"-Wpmf-conversions\"\n#endif\n\n#ifdef PXT_VM\n#define DEF_VTABLE(name, tp, valtype, ...)                                                         \\\n    const VTable name __attribute__((aligned(1 << PXT_VTABLE_SHIFT))) = {                          \\\n        sizeof(tp), valtype, VTABLE_MAGIC, 0, BuiltInType::tp, BuiltInType::tp,                    \\\n        0,          0,       {__VA_ARGS__}};\n#else\n#define DEF_VTABLE(name, tp, valtype, ...)                                                         \\\n    const VTable name __attribute__((aligned(1 << PXT_VTABLE_SHIFT))) = {                          \\\n        sizeof(tp), valtype, VTABLE_MAGIC, 0, BuiltInType::tp, 0, 0, {__VA_ARGS__}};\n#endif\n\n#ifdef PXT_GC\n#define PXT_VTABLE(classname, valtp)                                                               \\\n    DEF_VTABLE(classname##_vtable, classname, valtp, (void *)&classname::destroy,                  \\\n               (void *)&classname::print, (void *)&classname::scan, (void *)&classname::gcsize)\n#else\n#define PXT_VTABLE(classname, valtp)                                                               \\\n    DEF_VTABLE(classname##_vtable, classname, valtp, (void *)&classname::destroy,                  \\\n               (void *)&classname::print)\n#endif\n\n#define PXT_VTABLE_INIT(classname) RefObject(&classname##_vtable)\n\n#define PXT_VTABLE_CTOR(classname)                                                                 \\\n    PXT_VTABLE(classname, ValType::Object)                                                         \\\n    classname::classname() : PXT_VTABLE_INIT(classname)\n\n#define PXT_MAIN                                                                                   \\\n    int main() {                                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#define PXT_FNPTR(x) (uintptr_t)(void *)(x)\n\n#define PXT_ABI(...)\n\n#define JOIN(a, b) a##b\n/// Defines getClassName() function to fetch the singleton\n#define SINGLETON(ClassName)                                                                       \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName))                                                                \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n/// Defines getClassName() function to fetch the singleton if PIN present\n#define SINGLETON_IF_PIN(ClassName, pin)                                                           \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName) && LOOKUP_PIN(pin))                                             \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n#ifdef PXT_VM\n#include \"vm.h\"\n#endif\n\n#endif\n",
            "scheduling.ts": "/**\n * Calls a function with a fixed time delay between each call to that function.\n * @param func \n * @param delay \n */\n//%\nfunction setInterval(func: () => void, delay: number): number {\n    delay = Math.max(10, delay | 0);\n    return control.setInterval(func, delay, control.IntervalMode.Interval);\n}\n\n/**\n * Cancels repeated action which was set up using setInterval().\n * @param intervalId \n */\n//%\nfunction clearInterval(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Interval);\n}\n\n/**\n * Calls a function after specified delay.\n * @param func \n * @param delay \n */\n//%\nfunction setTimeout(func: () => void, delay: number): number {\n    return control.setInterval(func, delay, control.IntervalMode.Timeout);\n}\n\n/**\n * Clears the delay set by setTimeout().\n * @param intervalId \n */\n//%\nfunction clearTimeout(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Timeout);\n}\n\n/**\n * Calls a function as soon as possible.\n * @param func \n */\n//%\nfunction setImmediate(func: () => void): number {\n    return control.setInterval(func, 0, control.IntervalMode.Immediate);\n}\n\n/**\n * Cancels the immediate actions.\n * @param intervalId \n */\n//%\nfunction clearImmediate(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Immediate);\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n\n    //% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\ndeclare interface Buffer {\n    /**\n     * Reads an unsigned byte at a particular location\n     */\n    //% shim=BufferMethods::getUint8\n    getUint8(off: int32): int32;\n\n    /**\n     * Writes an unsigned byte at a particular location\n     */\n    //% shim=BufferMethods::setUint8\n    setUint8(off: int32, v: int32): void;\n\n    /**\n     * Write a number in specified format in the buffer.\n     */\n    //% shim=BufferMethods::setNumber\n    setNumber(format: NumberFormat, offset: int32, value: number): void;\n\n    /**\n     * Read a number in specified format from the buffer.\n     */\n    //% shim=BufferMethods::getNumber\n    getNumber(format: NumberFormat, offset: int32): number;\n\n    /** Returns the length of a Buffer object. */\n    //% property shim=BufferMethods::length\n    length: int32;\n\n    /**\n     * Fill (a fragment) of the buffer with given value.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::fill\n    fill(value: int32, offset?: int32, length?: int32): void;\n\n    /**\n     * Return a copy of a fragment of a buffer.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::slice\n    slice(offset?: int32, length?: int32): Buffer;\n\n    /**\n     * Shift buffer left in place, with zero padding.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::shift\n    shift(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Convert a buffer to string assuming UTF8 encoding\n     */\n    //% shim=BufferMethods::toString\n    toString(): string;\n\n    /**\n     * Convert a buffer to its hexadecimal representation.\n     */\n    //% shim=BufferMethods::toHex\n    toHex(): string;\n\n    /**\n     * Rotate buffer left in place.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::rotate\n    rotate(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Write contents of `src` at `dstOffset` in current buffer.\n     */\n    //% shim=BufferMethods::write\n    write(dstOffset: int32, src: Buffer): void;\n}\ndeclare namespace control {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=control::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Create a new buffer with UTF8-encoded string\n     * @param str the string to put in the buffer\n     */\n    //% shim=control::createBufferFromUTF8\n    function createBufferFromUTF8(str: string): Buffer;\n}\ndeclare namespace loops {\n\n    /**\n     * Repeats the code forever in the background. On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    //% help=loops/forever weight=100 afterOnStart=true deprecated=true\n    //% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1 shim=loops::forever\n    function forever(a: () => void): void;\n\n    /**\n     * Pause for the specified time in milliseconds\n     * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n     */\n    //% help=loops/pause weight=99 deprecated=true\n    //% async block=\"pause %pause=timePicker|ms\"\n    //% blockId=device_pause_deprecated shim=loops::pause\n    function pause(ms: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Gets the number of milliseconds elapsed since power on.\n     */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\" shim=control::millis\n    function millis(): int32;\n\n    /**\n     * Gets current time in microseconds. Overflows every ~18 minutes.\n     */\n    //% shim=control::micros\n    function micros(): int32;\n\n    /**\n     * Used internally\n     */\n    //% flags.defl=16 shim=control::internalOnEvent\n    function internalOnEvent(src: int32, value: int32, handler: () => void, flags?: int32): void;\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\" shim=control::reset\n    function reset(): void;\n\n    /**\n     * Block the current fiber for the given microseconds\n     * @param micros number of micro-seconds to wait. eg: 4\n     */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (µs)%micros\" shim=control::waitMicros\n    function waitMicros(micros: int32): void;\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8 shim=control::runInParallel\n    function runInParallel(a: () => void): void;\n\n    /**\n     * Blocks the calling thread until the specified event is raised.\n     */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\" shim=control::waitForEvent\n    function waitForEvent(src: int32, value: int32): void;\n\n    /**\n     * Derive a unique, consistent serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number shim=control::deviceSerialNumber\n    function deviceSerialNumber(): int32;\n\n    /**\n     * Derive a unique, consistent 64-bit serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_long_serial_number\" block=\"device long serial number\" weight=9\n    //% help=control/device-long-serial-number shim=control::deviceLongSerialNumber\n    function deviceLongSerialNumber(): Buffer;\n\n    /**\n     *\n     */\n    //% shim=control::__log\n    function __log(prority: int32, text: string): void;\n\n    /**\n     * Dump internal information about a value.\n     */\n    //% shim=control::dmesgValue\n    function dmesgValue(v: any): void;\n\n    /**\n     * Force GC and dump basic information about heap.\n     */\n    //% shim=control::gc\n    function gc(): void;\n\n    /**\n     * Force GC and halt waiting for debugger to do a full heap dump.\n     */\n    //% shim=control::heapDump\n    function heapDump(): void;\n\n    /**\n     * Set flags used when connecting an external debugger.\n     */\n    //% shim=control::setDebugFlags\n    function setDebugFlags(flags: int32): void;\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //% shim=control::profilingEnabled\n    function profilingEnabled(): boolean;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "templates.ts": "/**\n * Tagged hex literal converter\n */\n//% shim=@hex\nfunction hex(lits: any, ...args: any[]): Buffer { return null }\n",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "trig.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nnamespace Math_ {\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber atan2(TNumber y, TNumber x) {\n    return fromDouble(::atan2(toDouble(y), toDouble(x)));\n}\n\n//%\nTNumber tan(TNumber x){SINGLE(tan)}\n\n//%\nTNumber sin(TNumber x){SINGLE(sin)}\n\n//%\nTNumber cos(TNumber x){SINGLE(cos)}\n\n//%\nTNumber atan(TNumber x){SINGLE(atan)}\n\n//%\nTNumber asin(TNumber x){SINGLE(asin)}\n\n//%\nTNumber acos(TNumber x){SINGLE(acos)}\n\n//%\nTNumber sqrt(TNumber x){SINGLE(sqrt)}\n\n}",
            "utfdecoder.ts": "class UTF8Decoder {\n    private buf: Buffer;\n\n    constructor() {\n        this.buf = undefined;\n    }\n\n    add(buf: Buffer) {\n        if (!buf || !buf.length) return;\n\n        if (!this.buf)\n            this.buf = buf;\n        else {\n            const b = control.createBuffer(this.buf.length + buf.length);\n            b.write(0, this.buf);\n            b.write(this.buf.length, buf);\n            this.buf = b;\n        }\n    }\n\n    decodeUntil(delimiter: number): string {\n        if (!this.buf) return undefined;\n        delimiter = delimiter | 0;\n        let i = 0;\n        for (; i < this.buf.length; ++i) {\n            const c = this.buf[i];\n            // skip multi-chars\n            if ((c & 0xe0) == 0xc0)\n                i += 1;\n            else if ((c & 0xf0) == 0xe0)\n                i += 2;\n            else if (c == delimiter) {\n                // found it\n                break;\n            }\n        }\n\n        if (i >= this.buf.length)\n            return undefined;\n        else {\n            const s = this.buf.slice(0, i).toString();\n            if (i + 1 == this.buf.length)\n                this.buf = undefined;\n            else\n                this.buf = this.buf.slice(i + 1);\n            return s;\n        }\n    }\n\n    decode(): string {\n        if (!this.buf) return \"\";\n\n        // scan the end of the buffer for partial characters\n        let length = 0;\n        for (let i = this.buf.length - 1; i >= 0; i--) {\n            const c = this.buf[i];\n            if ((c & 0x80) == 0) {\n                length = i + 1;\n                break;\n            }\n            else if ((c & 0xe0) == 0xc0) {\n                length = i + 2;\n                break;\n            }\n            else if ((c & 0xf0) == 0xe0) {\n                length = i + 3;\n                break;\n            }\n        }\n        // is last beyond the end?\n        if (length == this.buf.length) {\n            const s = this.buf.toString();\n            this.buf = undefined;\n            return s;\n        } else if (length == 0) { // data yet\n            return \"\";\n        } else {\n            const s = this.buf.slice(0, length).toString();\n            this.buf = this.buf.slice(length);\n            return s;\n        }\n    }\n}"
        },
        "core": {
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile uintptr_t hp = (uintptr_t)p;\n        if (hp & 4) {\n            xfree(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            xfree(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        xfree(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n\n    auto led = LOOKUP_PIN(LED);\n    if (led) {\n        led->setDigitalValue(0);\n    }\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    while (curr) {\n        runAction1(curr->action, value);\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nuint64_t getLongSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\nuint64_t current_time_us() {\n    return system_timer_current_time_us();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    if (!currentFiber)\n        return NULL;\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n\nstatic void *threadAddressFor(codal::Fiber *fib, void *sp) {\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\nvoid gcProcessStacks(int flags) {\n    // check scheduler is initialized\n    if (!currentFiber) {\n        // make sure we allocate something to at least initalize the memory allocator\n        void * volatile p = xmalloc(1);\n        xfree(p);\n        return;\n    }\n\n    int numFibers = codal::list_fibers(NULL);\n    codal::Fiber **fibers = (codal::Fiber **)xmalloc(sizeof(codal::Fiber *) * numFibers);\n    int num2 = codal::list_fibers(fibers);\n    if (numFibers != num2)\n        oops(12);\n    int cnt = 0;\n\n    for (int i = 0; i < numFibers; ++i) {\n        auto fib = fibers[i];\n        auto ctx = (ThreadContext *)fib->user_data;\n        if (!ctx)\n            continue;\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(fib, seg->top);\n            auto end = (TValue *)threadAddressFor(fib, seg->bottom);\n            if (flags & 2)\n                DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n            // VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n    xfree(fibers);\n}\n#endif\n\n} // namespace pxt\n",
            "control.cpp": "#include \"pxt.h\"\n\n#ifdef NRF52 \n#define _estack __StackTop \n#endif\nextern uint32_t _estack;\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->getUTF8Data(), ptr);\n}\n\n//%\nuint32_t _ramSize()\n{\n    return (uint32_t)&_estack & 0x1fffffff;\n}\n\n}\n",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // /libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_VERSION = 5,\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_BUS_RISE = 16,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_EVT_RX_TIMEOUT = 4,\n    JD_SERIAL_EVT_BUS_CONNECTED = 5,\n    JD_SERIAL_EVT_BUS_DISCONNECTED = 6,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_SERIAL_MAX_BAUD = 1000000,\n    JD_SERIAL_TX_MAX_BACKOFF = 4000,\n    JD_SERIAL_TX_MIN_BACKOFF = 1000,\n    Receiving = 0,\n    Transmitting = 1,\n    High = 2,\n    Low = 3,\n    Baud1M = 1,\n    Baud500K = 2,\n    Baud250K = 4,\n    Baud125K = 8,\n    // /libraries/codal-core/inc/JACDAC/JDAccelerometerDriver.h\n    JD_ACCEL_EVT_SEND_DATA = 1,\n    // /libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // /libraries/codal-core/inc/JACDAC/JDClasses.h\n    STATIC_CLASS_START = 0,\n    STATIC_CLASS_END = 16777215,\n    DYNAMIC_CLASS_END = 4294967295,\n    JD_DRIVER_CLASS_CODAL_START = 0,\n    JD_DRIVER_CLASS_CODAL_END = 2000,\n    JD_DRIVER_CLASS_MAKECODE_START = 2000,\n    JD_DRIVER_CLASS_MAKECODE_END = 4000,\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_JOYSTICK = 1,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 2,\n    JD_DRIVER_CLASS_BRIDGE = 3,\n    JD_DRIVER_CLASS_BUTTON = 4,\n    JD_DRIVER_CLASS_PIN = 5,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 6,\n    JD_DRIVER_CLASS_ACCELEROMETER = 7,\n    JD_DRIVER_CLASS_CAPTOUCH_BUTTON = 8,\n    // /libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // /libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // /libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 65520,\n    JD_DRIVER_EVT_DISCONNECTED = 65521,\n    JD_DRIVER_EVT_PAIRED = 65522,\n    JD_DRIVER_EVT_UNPAIRED = 65523,\n    JD_DRIVER_EVT_PAIR_REJECTED = 65524,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 65525,\n    JD_DRIVER_EVT_ERROR = 65526,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_ERROR_MSK = 15,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    JD_LOGIC_DRIVER_EVT_CHANGED = 2,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    CONTROL_JD_TYPE_ERROR = 3,\n    CONTROL_JD_TYPE_PANIC = 255,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    CONTROL_PACKET_ERROR_NAME_LENGTH = 6,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    DRIVER_OK = 0,\n    DRIVER_CALIBRATION_IN_PROGRESS = 1,\n    DRIVER_CALIBRATION_REQUIRED = 2,\n    DRIVER_NO_RESOURCES = 3,\n    DRIVER_BUSY = 4,\n    DRIVER_COMMS_ERROR = 5,\n    DRIVER_INVALID_STATE = 6,\n    DRIVER_PERIPHERAL_MALFUNCTION = 7,\n    // /libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // /libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // /libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // /libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // /libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    DEVICE_HARDWARE_CONFIGURATION_ERROR = 90,\n    // /libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // /libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // /libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_EVT_2G = 12,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_2G_TOLERANCE = 2048,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // /libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // /libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // /libraries/codal-core/inc/driver-models/LowLevelTimer.h\n    TimerModeTimer = 0,\n    TimerModeCounter = 1,\n    TimerModeAlternateFunction = 2,\n    BitMode8 = 0,\n    BitMode16 = 1,\n    BitMode24 = 2,\n    BitMode32 = 3,\n    // /libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // /libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // /libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // /libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // /libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // /libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // /libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // /libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // /libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // /libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // /libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // /libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // /libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // /libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // /libraries/codal-core/inc/drivers/MMA8453.h\n    MMA8453_DEFAULT_ADDR = 56,\n    MMA8453_WHOAMI_VAL = 58,\n    // /libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // /libraries/codal-core/inc/drivers/MPU6050.h\n    MPU6050_DEFAULT_ADDR = 104,\n    MPU6050_WHOAMI = 117,\n    MPU6050_WHOAMI_VAL = 52,\n    // /libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // /libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // /libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // /libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // /libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // /libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // /libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // /libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // /libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // /libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // /libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // /libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // /pxtapp/accelerometer/axis.h\n    ACC_SYSTEM = 3,\n    ACC_ROTATION = 0,\n    // /pxtapp/configkeys.h\n    CFG_PIN_NAME_MSK = 65535,\n    CFG_PIN_CONFIG_MSK = 4294901760,\n    CFG_PIN_CONFIG_ACTIVE_LO = 65536,\n    CFG_MAGIC0 = 513675505,\n    CFG_MAGIC1 = 539130489,\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACK_TX = 60,\n    CFG_PIN_JACK_SENSE = 61,\n    CFG_PIN_JACK_HPEN = 62,\n    CFG_PIN_JACK_BZEN = 63,\n    CFG_PIN_JACK_PWREN = 64,\n    CFG_PIN_JACK_SND = 65,\n    CFG_PIN_JACK_BUSLED = 66,\n    CFG_PIN_JACK_COMMLED = 67,\n    CFG_PIN_BTN_SOFT_RESET = 69,\n    CFG_ACCELEROMETER_TYPE = 70,\n    CFG_PIN_BTNMX_LATCH = 71,\n    CFG_PIN_BTNMX_CLOCK = 72,\n    CFG_PIN_BTNMX_DATA = 73,\n    CFG_PIN_BTN_MENU2 = 74,\n    CFG_PIN_BATTSENSE = 75,\n    CFG_PIN_VIBRATION = 76,\n    CFG_PIN_PWREN = 77,\n    CFG_PIN_ROTARY_ENCODER_A = 79,\n    CFG_PIN_ROTARY_ENCODER_B = 80,\n    ACCELEROMETER_TYPE_LIS3DH = 50,\n    ACCELEROMETER_TYPE_MMA8453 = 56,\n    ACCELEROMETER_TYPE_FXOS8700 = 60,\n    ACCELEROMETER_TYPE_MMA8653 = 58,\n    ACCELEROMETER_TYPE_MSA300 = 76,\n    ACCELEROMETER_TYPE_MPU6050 = 104,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_A16 = 116,\n    CFG_PIN_A17 = 117,\n    CFG_PIN_A18 = 118,\n    CFG_PIN_A19 = 119,\n    CFG_PIN_A20 = 120,\n    CFG_PIN_A21 = 121,\n    CFG_PIN_A22 = 122,\n    CFG_PIN_A23 = 123,\n    CFG_PIN_A24 = 124,\n    CFG_PIN_A25 = 125,\n    CFG_PIN_A26 = 126,\n    CFG_PIN_A27 = 127,\n    CFG_PIN_A28 = 128,\n    CFG_PIN_A29 = 129,\n    CFG_PIN_A30 = 130,\n    CFG_PIN_A31 = 131,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_PIN_D16 = 166,\n    CFG_PIN_D17 = 167,\n    CFG_PIN_D18 = 168,\n    CFG_PIN_D19 = 169,\n    CFG_PIN_D20 = 170,\n    CFG_PIN_D21 = 171,\n    CFG_PIN_D22 = 172,\n    CFG_PIN_D23 = 173,\n    CFG_PIN_D24 = 174,\n    CFG_PIN_D25 = 175,\n    CFG_PIN_D26 = 176,\n    CFG_PIN_D27 = 177,\n    CFG_PIN_D28 = 178,\n    CFG_PIN_D29 = 179,\n    CFG_PIN_D30 = 180,\n    CFG_PIN_D31 = 181,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_SYSTEM_HEAP_BYTES = 206,\n    CFG_LOW_MEM_SIMULATION_KB = 207,\n    CFG_BOOTLOADER_BOARD_ID = 208,\n    CFG_UF2_FAMILY = 209,\n    CFG_PINS_PORT_SIZE = 210,\n    CFG_BOOTLOADER_PROTECTION = 211,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    CFG_ANALOG_BUTTON_THRESHOLD = 213,\n    CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS = 215,\n    CFG_PIN_B0 = 300,\n    CFG_PIN_B1 = 301,\n    CFG_PIN_B2 = 302,\n    CFG_PIN_B3 = 303,\n    CFG_PIN_B4 = 304,\n    CFG_PIN_B5 = 305,\n    CFG_PIN_B6 = 306,\n    CFG_PIN_B7 = 307,\n    CFG_PIN_B8 = 308,\n    CFG_PIN_B9 = 309,\n    CFG_PIN_B10 = 310,\n    CFG_PIN_B11 = 311,\n    CFG_PIN_B12 = 312,\n    CFG_PIN_B13 = 313,\n    CFG_PIN_B14 = 314,\n    CFG_PIN_B15 = 315,\n    CFG_PIN_B16 = 316,\n    CFG_PIN_B17 = 317,\n    CFG_PIN_B18 = 318,\n    CFG_PIN_B19 = 319,\n    CFG_PIN_B20 = 320,\n    CFG_PIN_B21 = 321,\n    CFG_PIN_B22 = 322,\n    CFG_PIN_B23 = 323,\n    CFG_PIN_B24 = 324,\n    CFG_PIN_B25 = 325,\n    CFG_PIN_B26 = 326,\n    CFG_PIN_B27 = 327,\n    CFG_PIN_B28 = 328,\n    CFG_PIN_B29 = 329,\n    CFG_PIN_B30 = 330,\n    CFG_PIN_B31 = 331,\n    CFG_PIN_C0 = 350,\n    CFG_PIN_C1 = 351,\n    CFG_PIN_C2 = 352,\n    CFG_PIN_C3 = 353,\n    CFG_PIN_C4 = 354,\n    CFG_PIN_C5 = 355,\n    CFG_PIN_C6 = 356,\n    CFG_PIN_C7 = 357,\n    CFG_PIN_C8 = 358,\n    CFG_PIN_C9 = 359,\n    CFG_PIN_C10 = 360,\n    CFG_PIN_C11 = 361,\n    CFG_PIN_C12 = 362,\n    CFG_PIN_C13 = 363,\n    CFG_PIN_C14 = 364,\n    CFG_PIN_C15 = 365,\n    CFG_PIN_C16 = 366,\n    CFG_PIN_C17 = 367,\n    CFG_PIN_C18 = 368,\n    CFG_PIN_C19 = 369,\n    CFG_PIN_C20 = 370,\n    CFG_PIN_C21 = 371,\n    CFG_PIN_C22 = 372,\n    CFG_PIN_C23 = 373,\n    CFG_PIN_C24 = 374,\n    CFG_PIN_C25 = 375,\n    CFG_PIN_C26 = 376,\n    CFG_PIN_C27 = 377,\n    CFG_PIN_C28 = 378,\n    CFG_PIN_C29 = 379,\n    CFG_PIN_C30 = 380,\n    CFG_PIN_C31 = 381,\n    CFG_PIN_P0 = 400,\n    CFG_PIN_P1 = 401,\n    CFG_PIN_P2 = 402,\n    CFG_PIN_P3 = 403,\n    CFG_PIN_P4 = 404,\n    CFG_PIN_P5 = 405,\n    CFG_PIN_P6 = 406,\n    CFG_PIN_P7 = 407,\n    CFG_PIN_P8 = 408,\n    CFG_PIN_P9 = 409,\n    CFG_PIN_P10 = 410,\n    CFG_PIN_P11 = 411,\n    CFG_PIN_P12 = 412,\n    CFG_PIN_P13 = 413,\n    CFG_PIN_P14 = 414,\n    CFG_PIN_P15 = 415,\n    CFG_PIN_P16 = 416,\n    CFG_PIN_P17 = 417,\n    CFG_PIN_P18 = 418,\n    CFG_PIN_P19 = 419,\n    CFG_PIN_P20 = 420,\n    CFG_PIN_LORA_MISO = 1001,\n    CFG_PIN_LORA_MOSI = 1002,\n    CFG_PIN_LORA_SCK = 1003,\n    CFG_PIN_LORA_CS = 1004,\n    CFG_PIN_LORA_BOOT = 1005,\n    CFG_PIN_LORA_RESET = 1006,\n    CFG_PIN_IRRXLED = 1007,\n    CFG_PIN_IRTXLED = 1008,\n    CFG_PIN_LCD_RESET = 1009,\n    CFG_PIN_LCD_ENABLE = 1010,\n    CFG_PIN_LCD_DATALINE4 = 1011,\n    CFG_PIN_LCD_DATALINE5 = 1012,\n    CFG_PIN_LCD_DATALINE6 = 1013,\n    CFG_PIN_LCD_DATALINE7 = 1014,\n    CFG_NUM_LCD_COLUMNS = 1015,\n    CFG_NUM_LCD_ROWS = 1016,\n    // /pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // /pxtapp/mixer---samd/melody.h\n    SW_TRIANGLE = 1,\n    SW_SAWTOOTH = 2,\n    SW_SINE = 3,\n    SW_NOISE = 4,\n    SW_REAL_NOISE = 5,\n    SW_SQUARE_10 = 11,\n    SW_SQUARE_50 = 15,\n    CODAL = 1,\n    MAX_SOUNDS = 5,\n    Waiting = 0,\n    Playing = 1,\n    Done = 2,\n    // /pxtapp/pins.h\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // /pxtapp/platform.h\n    PAGE_SIZE = 512,\n    DEV_NUM_PINS = 64,\n    PXT_74HC165 = 1,\n    IMAGE_BITS = 4,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // /pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // /pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // /pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    PXT_UF2_FAMILY = 1760373640,\n    // /pxtapp/storage/SNORFS.h\n    DEVICE_FLASH_ERROR = 950,\n    // /pxtapp/thermometer/target_temperature.h\n    TEMPERATURE_NOMINAL_VALUE = 25,\n    TEMPERATURE_NOMINAL_READING = 10000,\n    TEMPERATURE_BETA = 3380,\n    TEMPERATURE_SERIES_RESISTOR = 10000,\n    // /pxtapp/uf2format.h\n    BOOTLOADER_START = 0,\n    // /pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
            "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
            "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nclass WDMAC {\n  public:\n    CODAL_DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "hf2.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#ifndef USB_HANDOVER\n#define USB_HANDOVER 1\n#endif\n\n#if USB_HANDOVER\n#define UF2_DEFINE_HANDOVER 1\n#endif\n\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\n#ifdef HF2_HID\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfoHID = {\n   &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n#endif\n\nstatic const InterfaceInfo ifaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\nstatic const InterfaceInfo ifaceInfoEP = {\n    NULL,\n    0,\n    2,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_BULK, 0},\n    {USB_EP_TYPE_BULK, 0},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n#ifdef HF2_HID\n    if (!useHID)\n        return DEVICE_NOT_SUPPORTED;\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n#endif\n    return DEVICE_NOT_SUPPORTED;\n}\n\n// same as in microbit\n#define CTRL_GET_REPORT 0x01\n#define CTRL_SET_REPORT 0x09\n#define CTRL_OUT_REPORT_H 0x2\n#define CTRL_IN_REPORT_H 0x1\n\nvoid HF2::prepBuffer(uint8_t *buf) {\n    memset(buf, 0, 64);\n    target_disable_irq();\n    if (dataToSendLength) {\n        if (dataToSendPrepend) {\n            dataToSendPrepend = false;\n            buf[0] = HF2_FLAG_CMDPKT_BODY | 4;\n            memcpy(buf + 1, pkt.buf, 4);\n        } else {\n            int flag = dataToSendFlag;\n            int s = 63;\n            if (dataToSendLength <= 63) {\n                s = dataToSendLength;\n            } else {\n                if (flag == HF2_FLAG_CMDPKT_LAST)\n                    flag = HF2_FLAG_CMDPKT_BODY;\n            }\n\n            buf[0] = flag | s;\n            memcpy(buf + 1, dataToSend, s);\n            dataToSend += s;\n            dataToSendLength -= s;\n        }\n    }\n    target_enable_irq();\n}\n\nvoid HF2::pokeSend() {\n    if (!allocateEP || !CodalUSB::usbInstance->isInitialised())\n        return;\n\n    uint8_t buf[64];\n    for (;;) {\n        prepBuffer(buf);\n        if (!buf[0])\n            break;\n        in->write(buf, sizeof(buf));\n    }\n}\n\nint HF2::classRequest(UsbEndpointIn &ctrl, USBSetup &setup) {\n    if (allocateEP)\n        return DEVICE_NOT_SUPPORTED;\n\n    if ((setup.bmRequestType & USB_REQ_DIRECTION) == USB_REQ_HOSTTODEVICE) {\n        if (setup.bRequest != CTRL_SET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_OUT_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength > 64)\n            return DEVICE_NOT_SUPPORTED;\n        ctrlWaiting = true;\n        CodalUSB::usbInstance->ctrlOut->startRead();\n        ctrl.wLength = 0; // pretend we're done\n    } else {\n        if (setup.bRequest != CTRL_GET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_IN_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength != 64)\n            return DEVICE_NOT_SUPPORTED;\n\n        uint8_t buf[64];\n        prepBuffer(buf);\n        ctrl.write(buf, sizeof(buf));\n    }\n\n    return DEVICE_OK;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo() {\n#ifdef HF2_HID\n    if (useHID)\n        return &ifaceInfoHID;\n#endif\n    return allocateEP ? &ifaceInfoEP : &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError) {\n    if (!gotSomePacket)\n        return DEVICE_OK;\n\n    for (;;) {\n        pokeSend();\n\n        while (dataToSendLength) {\n            fiber_sleep(5);\n            pokeSend();\n        }\n\n        if (size < 0)\n            break;\n\n        target_disable_irq();\n        // there could be a race\n        if (!dataToSendLength) {\n            dataToSend = (const uint8_t *)data;\n            dataToSendPrepend = false;\n            dataToSendFlag = isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT;\n            dataToSendLength = size;\n            size = -1;\n        }\n        target_enable_irq();\n    }\n\n    return 0;\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len;\n\n    if (allocateEP)\n        len = out->read(buf, sizeof(buf));\n    else\n        len = CodalUSB::usbInstance->ctrlOut->read(buf, sizeof(buf));\n    // DMESG(\"HF2 read: %d\", len);\n\n    if (len <= 0)\n        return len;\n\n    if (!allocateEP)\n        CodalUSB::usbInstance->ctrlIn->write(\"\", 0);\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    dataToSend = pkt.buf;\n    dataToSendPrepend = false;\n    dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n    dataToSendLength = 4 + size;\n    pokeSend();\n    return 0;\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    if (dataToSendLength)\n        oops(90);\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        memcpy(pkt.resp.data8, data, size);\n        return sendResponse(size);\n    } else {\n        dataToSend = (const uint8_t *)data;\n        dataToSendPrepend = true;\n        dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n        dataToSendLength = size;\n        pokeSend();\n        return 0;\n    }\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#ifndef QUICK_BOOT\n#ifdef SAMD21\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#endif\n#ifdef SAMD51\n#define DBL_TAP_PTR ((volatile uint32_t *)(HSRAM_ADDR + HSRAM_SIZE - 4))\n#endif\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n#define QUICK_BOOT(v) *DBL_TAP_PTR = v ? DBL_TAP_MAGIC_QUICK_BOOT : 0\n#endif\n\nint HF2::endpointRequest() {\n    if (!allocateEP && !ctrlWaiting)\n        return 0;\n\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        resp->bininfo.uf2_family = PXT_UF2_FAMILY;\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        QUICK_BOOT(1);\n        NVIC_SystemReset();\n        break;\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        QUICK_BOOT(0);\n        NVIC_SystemReset();\n        break;\n\n#if USB_HANDOVER\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n#endif\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : gotSomePacket(false), ctrlWaiting(false), pkt(p), allocateEP(true), useHID(false) {}\n\n\nstatic const InterfaceInfo dummyIfaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        0xff,   // subclass\n        0xff,    // protocol\n        0x00, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\n\nconst InterfaceInfo *DummyIface::getInterfaceInfo() {\n    return &dummyIfaceInfo;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n\n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        xfree(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            xfree(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
            "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct {\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public CodalUSBInterface {\n    void prepBuffer(uint8_t *buf);\n    void pokeSend();\n\n    const uint8_t *dataToSend;\n    volatile uint32_t dataToSendLength;\n    bool dataToSendPrepend;\n    uint8_t dataToSendFlag;\n\n    bool gotSomePacket;\n    bool ctrlWaiting;\n\n  public:\n    HF2_Buffer &pkt;\n\n    bool allocateEP;\n    bool useHID;\n\n    int sendResponse(int size);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int classRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n\n    virtual bool enableWebUSB() { return !useHID; }\n};\n\nclass DummyIface : public CodalUSBInterface {\n  public:\n    virtual const InterfaceInfo *getInterfaceInfo();\n};\n\n#endif\n\n#endif\n",
            "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
            "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n#include \"CodalDmesg.h\"\n#include \"configkeys.h\"\n\n#ifdef CODAL_I2C\n\nnamespace pins {\n\nclass CodalI2CProxy {\nprivate:\n  DevicePin* sda;\n  DevicePin* scl;\n  CODAL_I2C i2c;\npublic:\n  CodalI2CProxy* next;\npublic:\n  CodalI2CProxy(DevicePin* _sda, DevicePin* _scl)\n    : sda(_sda)\n    , scl(_scl)\n    , i2c(*_sda, *_scl) \n    , next(NULL)\n  {\n\n  }\n\n  CODAL_I2C* getI2C() {\n    return &(this->i2c);\n  }\n  \n  bool matchPins(DevicePin* sda, DevicePin* scl) {\n      return this->sda == sda && this->scl == scl;\n  }\n\n  Buffer readBuffer(int address, int size, bool repeat = false)\n  {\n    Buffer buf = mkBuffer(NULL, size);\n    int status = this->i2c.read(address << 1, buf->data, size, repeat);\n    if (status != ErrorCode::DEVICE_OK) {\n      decrRC(buf);\n      buf = 0;\n    }\n    return buf;\n  }\n\n  int writeBuffer(int address, Buffer buf, bool repeat = false)\n  {\n    return this->i2c.write(address << 1, buf->data, buf->length, repeat);\n  }\n};\n\n}\n\nnamespace I2CMethods {\n/**\n  * Read `size` bytes from a 7-bit I2C `address`.\n  */\n//%\nBuffer readBuffer(I2C_ i2c, int address, int size, bool repeat = false)\n{\n  return i2c->readBuffer(address, size, repeat);\n}\n\n/**\n  * Write bytes to a 7-bit I2C `address`.\n  */\n//%\nint writeBuffer(I2C_ i2c, int address, Buffer buf, bool repeat = false)\n{\n  return i2c->writeBuffer(address, buf, repeat);\n}\n\n}\n\nnamespace pins {\n\nstatic I2C_ i2cs(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//% help=pins/create-i2c\n//% parts=i2c\nI2C_ createI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n  // pick up defaults\n  if (!sda || !scl) {\n    DMESG(\"i2c: lookup default pins\");\n    sda = LOOKUP_PIN(SDA);\n    scl = LOOKUP_PIN(SCL);\n  }\n\n  // lookup existing devices\n  auto dev = i2cs;\n  while(dev) {\n    if (dev->matchPins(sda, scl)) {\n      DMESG(\"i2c: found existing i2c\");\n      return dev;\n    }\n    dev = dev->next;\n  }\n\n  // allocate new one\n  DMESG(\"i2c: mounting on new device\");\n  auto ser = new CodalI2CProxy(sda, scl);\n  // push in list\n  ser->next = i2cs;\n  i2cs = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n  CODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n    auto i2c = pins::createI2C(sda, scl);\n    return i2c->getI2C();\n  }\n}\n\n#endif",
            "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        const buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        if (!buf)\n            return undefined\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format?: NumberFormat, repeated?: boolean): void {\n        if (format == undefined)\n            format = NumberFormat.UInt8LE;\n        const buf = control.createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    /**\n     * Write a value in a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param value value to write\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-write-register\n    //% blockId=i2c_writereg block=\"i2c write register|at address $address|at register $register|value $value\"\n    export function i2cWriteRegister(address: number, register: number, value: number, valueFormat?: NumberFormat): void {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        const valueSize = pins.sizeOf(valueFormat);\n        const buf = control.createBuffer(1 + valueSize);\n        buf.setNumber(NumberFormat.UInt8LE, 0, register);\n        buf.setNumber(valueFormat, 1, value);\n        pins.i2cWriteBuffer(address, buf);\n    }\n\n    /**\n     * Read the value from a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-read-register\n    //% blockId=i2c_readreg block=\"i2c read register|at address $address|at register $register\"\n    export function i2cReadRegister(address: number, register: number, valueFormat?: NumberFormat): number {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        pins.i2cWriteNumber(address, register, NumberFormat.UInt8LE);\n        return pins.i2cReadNumber(address, valueFormat);\n    }\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cReadBuffer(address: number, size: number, repeat: boolean = false): Buffer {\n        return pins.i2c().readBuffer(address, size, repeat);\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cWriteBuffer(address: number, buf: Buffer, repeat: boolean = false): number {\n        return pins.i2c().writeBuffer(address, buf, repeat);\n    }\n\n    let _i2c: I2C;\n    /**\n     * Gets the default I2C bus\n     */\n    //%\n    export function i2c() {\n        if (!_i2c) {\n            const sda = pins.pinByCfg(DAL.CFG_PIN_SDA);\n            const scl = pins.pinByCfg(DAL.CFG_PIN_SCL);\n            _i2c = pins.createI2C(sda, scl);    \n        }\n        return _i2c;        \n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}\n",
            "keyvaluestorage.cpp": "#include \"pxt.h\"\n#include \"KeyValueStorage.h\"\n\nnamespace pxt {\n\nclass WKeyValueStorage {\n#ifdef CODAL_NVMCONTROLLER\n    CODAL_NVMCONTROLLER controller;\n#else\n    NVMController controller;\n#endif\n    KeyValueStorage storage;\n  public:\n\n    WKeyValueStorage()\n    : controller()\n    , storage(controller) {\n    }\n\n    bool isSupported() {\n#ifdef CODAL_NVMCONTROLLER\n      return true;\n#else\n      return false;\n#endif\n    }\n\n    int put(String key, Buffer data) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        return storage.put(mkey, data->data, data->length);\n#else\n        return -1;\n#endif\n    }\n\n    Buffer get(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        Buffer buf = NULL;\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        auto entry = storage.get(mkey);\n        if (entry) {\n          buf = mkBuffer(entry->value, sizeof(entry->value));\n          free(entry);\n        }\n        return buf;\n#else\n        return NULL;\n#endif\n    }\n\n    void remove(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        storage.remove(mkey);\n#endif\n    }\n\n    void clear() {\n#ifdef CODAL_NVMCONTROLLER\n        storage.wipe();\n#endif\n    }\n};\nSINGLETON(WKeyValueStorage);\n\n}\n\nnamespace configStorage {\n  /**\n  * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  * @param value the data (max 32 characters)\n  */\n  //%\n  void setBuffer(String key, Buffer value) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->put(key, value);\n  }\n\n  /**\n  * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  Buffer getBuffer(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    return kvm->get(key);\n  }\n\n  /**\n  * Removes the key from local storage\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  void removeItem(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->remove(key);\n  }\n\n  /**\n  * Clears the local storage\n  */\n  //%\n  void clear() {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->clear();\n  }\n}\n",
            "keyvaluestorage.ts": "namespace configStorage {\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     * @param value identifier of the value (max 32 characters)\n     */\n    export function setItem(key: string, value: string) {\n        if (value == null)\n            configStorage.removeItem(key);\n        else\n        {\n            let idx = 0;\n            let buf = control.createBuffer(value.length + 1);\n            buf[idx++] = value.length;\n            let valBuf = control.createBufferFromUTF8(value);\n\n            for (let i = 0; i < valBuf.length; i++)\n                buf[idx++] = valBuf[i];\n\n            configStorage.setBuffer(key, buf);\n        }\n    }\n\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     */\n    export function getItem(key: string): string {\n        const buf = configStorage.getBuffer(key);\n\n        if (!buf)\n            return undefined;\n\n        let idx = 0;\n        let count = buf[idx++];\n        const retBuf = control.createBuffer(count);\n\n        for (let i = 0; i < count; i++)\n            retBuf[i] = buf[idx++];\n\n        return retBuf.toString();\n    }\n}\n",
            "leveldetector.ts": "namespace pins {\n    export class LevelDetector {\n        public id: number;\n        public min: number;\n        public max: number;\n        public lowThreshold: number;\n        public highThreshold: number;\n        private transition: number;\n        private _level: number;\n        private _state: number;\n        public onHigh: () => void;\n        public onLow: () => void;\n        public transitionWindow: number;\n\n        constructor(id: number,\n            min: number, max: number,\n            lowThreshold: number, highThreshold: number) {\n            this.id = id;\n            this.min = min;\n            this.max = max;\n            this.lowThreshold = lowThreshold;\n            this.highThreshold = highThreshold;\n            this._level = Math.ceil((max - min) / 2);\n            this._state = 0;\n            this.transitionWindow = 4;\n            this.transition = 0;\n\n            this.onHigh = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_HIGH);\n            this.onLow = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_LOW);\n        }\n\n        get level(): number {\n            return this._level;\n        }\n\n        set level(level: number) {\n            control.dmesg(\"LEVEL: \");\n            control.dmesg(level.toString());\n\n            this._level = this.clampValue(level);\n\n            if (this._level >= this.highThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_HIGH);\n            }\n            else if (this._level <= this.lowThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_LOW);\n            }\n            else {\n                this.setState(0);\n            }\n        }\n\n        public setLowThreshold(value: number) {\n            this.lowThreshold = this.clampValue(value);\n            this.highThreshold = Math.max(this.lowThreshold + 1, this.highThreshold);\n        }\n\n        public setHighThreshold(value: number) {\n            this.highThreshold = this.clampValue(value);\n            this.lowThreshold = Math.min(this.highThreshold - 1, this.lowThreshold);\n        }\n\n        private clampValue(value: number) {\n            if (value < this.min) {\n                return this.min;\n            }\n            else if (value > this.max) {\n                return this.max;\n            }\n            return value;\n        }\n\n        private setState(state: number) {\n                                        // not enough samples to change\n            if (this._state === state || this.transition++ < this.transitionWindow) {\n                return;\n            }\n\n            this.transition = 0;\n            this._state = state;\n            switch (state) {\n                case DAL.LEVEL_THRESHOLD_HIGH:\n                    if (this.onHigh) this.onHigh();\n                    break;\n                case DAL.LEVEL_THRESHOLD_LOW:\n                    if (this.onLow) this.onLow();\n                    break;\n            }\n        }\n    }\n}",
            "light.cpp": "#include \"light.h\"\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n#include \"neopixel.h\"\n#endif\n\n#define NEOPIXEL_MIN_LENGTH_FOR_SPI 24\n#define DOTSTAR_MIN_LENGTH_FOR_SPI 24\n\n#define LIGHTMODE_RGB 1\n#define LIGHTMODE_RGBW 2\n#define LIGHTMODE_RGB_RGB 3\n#define LIGHTMODE_DOTSTAR 4\n\nnamespace light {\nbool isValidMOSIPin(DigitalInOutPin pin) {\n    if (!pin)\n        return false;\n\n#if SAMD51\n    return ZSPI::isValidMOSIPin(*pin);\n#else\n    // TODO: support for SPI neopixels\n    // default SPI pins supported for now\n    return pin == LOOKUP_PIN(MOSI);\n#endif\n\n}\n\n// SPI\nvoid spiNeopixelSendBuffer(DevicePin* pin, const uint8_t *data, unsigned size) {\n    int32_t iptr = 0, optr = 100;\n    uint32_t len = optr + size * 3 + optr;\n    uint8_t *expBuf = new uint8_t[len];\n    memset(expBuf, 0, len);\n    uint8_t imask = 0x80;\n    uint8_t omask = 0x80;\n\n#define WR(k)                                                                                      \\\n    if (k)                                                                                         \\\n        expBuf[optr] |= omask;                                                                     \\\n    omask >>= 1;                                                                                   \\\n    if (!omask) {                                                                                  \\\n        omask = 0x80;                                                                              \\\n        optr++;                                                                                    \\\n    }\n\n    while (iptr < (int)size) {\n        WR(1);\n        WR(data[iptr] & imask);\n        imask >>= 1;\n        if (!imask) {\n            imask = 0x80;\n            iptr++;\n        }\n        WR(0);\n    }\n\n    auto spi = pxt::getSPI(pin, NULL, NULL);\n    spi->setFrequency(2400000);\n    spi->transfer(expBuf, len, NULL, 0);\n    delete expBuf;\n}\n\nvoid neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length) {\n    if (!pin || !length) return;\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n    if (length > NEOPIXEL_MIN_LENGTH_FOR_SPI && isValidMOSIPin(pin))\n        spiNeopixelSendBuffer(pin, data, length);\n    else\n        neopixel_send_buffer(*pin, data, length);\n #else\n     if (isValidMOSIPin(pin)) {\n         spiNeopixelSendBuffer(pin, data, length);\n     }\n #endif\n}\n\nvoid bitBangDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    // first frame of zeroes\n    data->setDigitalValue(0);\n    for (unsigned i = 0; i < 32; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n\n    // data stream\n    for (unsigned i = 0; i < length; ++i) {\n        auto x = buf[i];\n        for (uint8_t j = 0x80; j != 0; j >>= 1) {\n            data->setDigitalValue(x & j ? 1 : 0);\n            clk->setDigitalValue(1);\n            clk->setDigitalValue(0);\n        }\n    }\n    // https://cpldcpu.wordpress.com/2016/12/13/sk9822-a-clone-of-the-apa102/\n    // reset frame\n    //data->setDigitalValue(0);\n    //for (unsigned i = 0; i < 32 ; ++i) {\n    //    clk->setDigitalValue(1);\n    //    clk->setDigitalValue(0);\n    //}\n\n    // https://cpldcpu.wordpress.com/2014/11/30/understanding-the-apa102-superled/\n    data->setDigitalValue(1);\n    unsigned n = 32;\n    for (unsigned i = 0; i < n; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n}\n\nstatic uint8_t ZERO_FRAME[4];\nstatic uint8_t ONE_FRAME[] = {1,1,1,1};\nvoid spiDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    auto spi = pxt::getSPI(data, NULL, clk);\n\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // initial frame\n    spi->transfer(buf, length, NULL, 0);\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // reset frame\n    for(unsigned i = 0; i < length >> 3; i += 32)\n        spi->transfer(ONE_FRAME, sizeof(ONE_FRAME), NULL, 0); // final frame\n}\n\nvoid dotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    if (!data || !clk || !buf || !length) return;\n\n    if (length > DOTSTAR_MIN_LENGTH_FOR_SPI && isValidMOSIPin(data))\n        spiDotStarSendData(data, clk, mode, buf, length);\n    else\n        bitBangDotStarSendData(data, clk, mode, buf, length);\n}\n\nvoid sendBuffer(DevicePin* data, DevicePin* clk, int mode, Buffer buf) {\n    if (!data || !buf || !buf->length) return;\n\n    if (mode == LIGHTMODE_DOTSTAR)\n        light::dotStarSendData(data, clk, mode, buf->data, buf->length);\n    else\n        light::neopixelSendData(data, mode, buf->data, buf->length);\n}\n\n\nvoid clear() {\n    auto neopix = LOOKUP_PIN(NEOPIXEL);\n    auto neonum = getConfig(CFG_NUM_NEOPIXELS, 0);\n    if (neopix && neonum >= 0) {\n        auto n = 3 * neonum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        light::neopixelSendData(neopix, 0x100, off, sizeof(off));\n    }\n\n    auto data = LOOKUP_PIN(DOTSTAR_DATA);\n    auto clk = LOOKUP_PIN(DOTSTAR_CLOCK);\n    auto dsnum = getConfig(CFG_NUM_DOTSTARS, 0);\n    if (data && clk && dsnum > 0) {\n        auto n = 4 * dsnum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        for(int i = 0; i < n; i += 4)\n            off[i] = 0xe0;\n        bitBangDotStarSendData(data, clk, 0x100, off, sizeof(off));\n    }\n}\n\n} // namespace pxt\n",
            "light.h": "#ifndef __PXT_LIGHT_H\n#define __PXT_LIGHT_H\n\n#include \"pxt.h\"\n\nnamespace light {\n    /**\n    * Clear onboard neopixels\n    */\n    void clear();\n\n    /**\n    * Send a programmable light buffer to the specified digital pin\n    * @param data The pin that the light are connected to\n    * @param clk the clock line if nay\n    * @param mode the color encoding mode\n    * @param buf The buffer to send to the pin\n    */\n    //%\n    void sendBuffer(DigitalInOutPin data, DigitalInOutPin clk, int mode, Buffer buf);\n\n    void neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length);\n}\n\n#endif",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n\n    id &= CFG_PIN_NAME_MSK;\n\n    if (id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0 || pinName == 0xff)\n        return NULL;\n    pinName &= CFG_PIN_NAME_MSK;\n    return getPin(pinName);\n}\n\n//%\nDevicePin *lookupPinCfg(int key) {\n    return lookupPin(getConfig(key));\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n* Get a pin by configuration id (DAL.CFG_PIN...)\n*/\n//%\nDigitalInOutPin pinByCfg(int key) {\n    return pxt::lookupPinCfg(key);\n}\n\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n}",
            "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
            "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
            "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
            "pinscompat.ts": "// filled in by microbit",
            "platform.cpp": "#include \"pxt.h\"\n#include \"light.h\"\n\nnamespace pxt {\n\nCODAL_TIMER devTimer;\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    auto pinTemp = LOOKUP_PIN(TEMPERATURE);\n    if (pinTemp)\n        seed *= pinTemp->getAnalogValue();\n    auto pinLight = LOOKUP_PIN(LIGHT);\n    if (pinLight)\n        seed *= pinLight->getAnalogValue();\n    seedRandom(seed);\n}\n\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n    remapSwdPin(CFG_PIN_SPEAKER_AMP, PIN(D2));\n}\n\nvoid platform_init() {\n    initSwdPins();\n    initRandomSeed();\n    light::clear();\n\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n}\n\n} // namespace pxt\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n// This is specific for SAMD21, to be replaced in other Codal targets.\n\n#include \"CapTouchButton.h\"\n#include \"Image.h\"\n#include \"MbedTimer.h\"\n#include \"MbedI2C.h\"\n#include \"MbedPin.h\"\n#include \"MbedSPI.h\"\n#include \"MbedSerial.h\"\n#include \"MultiButton.h\"\n#include \"CPlayI2C.h\"\n\n#include \"SAMD21DMAC.h\"\n\n// Analog Pins, all SAMD21: PA02-PA11 PB00-PB09 (some pins not connected)\n// 2 ports times 32 pins in each\n#define DEV_NUM_PINS 64\n// pins marked with AIN and PTC in the data sheet\n#define DEV_ANALOG_PINS 0x3ff00000ffcULL\n\n#define PAGE_SIZE 256\n\n#define CODAL_DMAC SAMD21DMAC\n\n// this is codal::_mbed for both mbed and mbedos now\n#define CODAL_MBED codal::_mbed\n\n#define CODAL_I2C codal::CPlayI2C\n\n#ifndef IMAGE_BITS\n#define IMAGE_BITS 1\n#endif\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#endif\n\n#endif\n",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n#include \"USBJACDAC.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nextern USBJACDAC jacdacDebug;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n\nvoid set_usb_strings(const char *uf2_info);\n\n} // namespace pxt\n\nnamespace pins {\nclass CodalSPIProxy;\nclass CodalI2CProxy;\n} // namespace pins\n\ntypedef pins::CodalI2CProxy* I2C_;\ntypedef pins::CodalSPIProxy* SPI_;\n\nnamespace pxt {\n#ifdef CODAL_I2C\nCODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl);\n#endif\nCODAL_SPI* getSPI(DigitalInOutPin mosi, DigitalInOutPin miso, DigitalInOutPin sck);\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer* getJACDACTimer();\n#endif\n}\n\nnamespace serial {\nclass CodalSerialDeviceProxy;\n}\n\ntypedef serial::CodalSerialDeviceProxy* SerialDevice;\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
            "pxt.json": "{\n  \"name\": \"core\",\n  \"description\": \"The core library for Codal-based targets\",\n  \"files\": [\n    \"README.md\",\n    \"dal.d.ts\",\n    \"codal.cpp\",\n    \"usb.cpp\",\n    \"pxt.h\",\n    \"platform.h\",\n    \"platform.cpp\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"pins.cpp\",\n    \"pinsAnalog.cpp\",\n    \"pinsDigital.cpp\",\n    \"pinsPWM.cpp\",\n    \"pins.ts\",\n    \"pinscompat.ts\",\n    \"control.cpp\",\n    \"i2c.cpp\",\n    \"i2c.ts\",\n    \"spi.cpp\",\n    \"spi.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"hf2.cpp\",\n    \"hf2.h\",\n    \"hf2dbg.h\",\n    \"uf2format.h\",\n    \"uf2hid.h\",\n    \"ns.ts\",\n    \"dmac.cpp\",\n    \"dmac.h\",\n    \"timer.ts\",\n    \"light.cpp\",\n    \"light.h\",\n    \"keyvaluestorage.cpp\",\n    \"keyvaluestorage.ts\",\n    \"leveldetector.ts\",\n    \"pxtparts.json\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 1024\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\",\n      \"MS_\",\n      \"SCSI_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n#include \"CodalHeapAllocator.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#define GC_GET_HEAP_SIZE() device_heap_size(0)\n#define GC_STACK_BASE DEVICE_STACK_BASE\n#define xmalloc device_malloc\n#define xfree device_free\n\n#define GC_MAX_ALLOC_SIZE (16 * 1024)\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace pins {\n\n    /**\n     * Get a pin by configuration id (DAL.CFG_PIN...)\n     */\n    //% shim=pins::pinByCfg\n    function pinByCfg(key: int32): DigitalInOutPin;\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\n\n\ndeclare interface I2C {\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::readBuffer\n    readBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::writeBuffer\n    writeBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% help=pins/create-i2c\n    //% parts=i2c shim=pins::createI2C\n    function createI2C(sda: DigitalInOutPin, scl: DigitalInOutPin): I2C;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a SPI driver\n     */\n    //% help=pins/create-spi\n    //% parts=spi shim=pins::createSPI\n    function createSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin): SPI;\n}\n\n\ndeclare interface SPI {\n    /**\n     * Write to the SPI bus\n     */\n    //% shim=SPIMethods::write\n    write(value: int32): int32;\n\n    /**\n     * Transfer buffers over the SPI bus\n     */\n    //% argsNullable shim=SPIMethods::transfer\n    transfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI clock frequency\n     */\n    //% shim=SPIMethods::setFrequency\n    setFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI bus mode\n     */\n    //% shim=SPIMethods::setMode\n    setMode(mode: int32): void;\n}\ndeclare namespace light {\n\n    /**\n     * Send a programmable light buffer to the specified digital pin\n     * @param data The pin that the light are connected to\n     * @param clk the clock line if nay\n     * @param mode the color encoding mode\n     * @param buf The buffer to send to the pin\n     */\n    //% shim=light::sendBuffer\n    function sendBuffer(data: DigitalInOutPin, clk: DigitalInOutPin, mode: int32, buf: Buffer): void;\n}\ndeclare namespace configStorage {\n\n    /**\n     * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     * @param value the data (max 32 characters)\n     */\n    //% shim=configStorage::setBuffer\n    function setBuffer(key: string, value: Buffer): void;\n\n    /**\n     * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::getBuffer\n    function getBuffer(key: string): Buffer;\n\n    /**\n     * Removes the key from local storage\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::removeItem\n    function removeItem(key: string): void;\n\n    /**\n     * Clears the local storage\n     */\n    //% shim=configStorage::clear\n    function clear(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n\nclass CodalSPIProxy {\nprivate:\n    DevicePin* mosi; \n    DevicePin* miso; \n    DevicePin* sck;\n    CODAL_SPI spi;\npublic:\n    CodalSPIProxy* next;\n\npublic:\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck) \n        , next(NULL)\n    {\n    }\n\n    CODAL_SPI* getSPI() {\n        return &spi;\n    }\n\n    bool matchPins(DevicePin* mosi, DevicePin* miso, DevicePin* sck) {\n        return this->mosi == mosi && this->miso == miso && this->sck == sck;\n    }\n\n    int write(int value) {\n        return spi.write(value);\n    }\n\n    void transfer(Buffer command, Buffer response) {\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi.transfer(cdata, clength, rdata, rlength);\n    }\n\n    void setFrequency(int frequency) {\n        spi.setFrequency(frequency);\n    }\n\n    void setMode(int mode) {\n        spi.setMode(mode);\n    }\n};\n\nSPI_ spis(NULL);\n\n/**\n* Opens a SPI driver\n*/\n//% help=pins/create-spi\n//% parts=spi\nSPI_ createSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n  auto dev = spis;\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n\nCODAL_SPI* getSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n    auto spi = pins::createSPI(mosiPin, misoPin, sckPin);\n    return spi->getSPI();\n}\n\n}\n\nnamespace SPIMethods {\n\n/**\n* Write to the SPI bus\n*/\n//%\nint write(SPI_ device, int value) {\n    return device->write(value);\n}\n\n/**\n* Transfer buffers over the SPI bus\n*/\n//% argsNullable\nvoid transfer(SPI_ device, Buffer command, Buffer response) {\n    if (!device)\n        target_panic(PANIC_CAST_FROM_NULL);\n    if (!command && !response)\n        return;\n    device->transfer(command, response);\n}\n\n/**\n* Sets the SPI clock frequency\n*/\n//%\nvoid setFrequency(SPI_ device, int frequency) {\n    device->setFrequency(frequency);\n}\n\n/**\n* Sets the SPI bus mode\n*/\n//%\nvoid setMode(SPI_ device, int mode) {\n    device->setMode(mode);\n}\n\n}\n",
            "spi.ts": "namespace pins {\n\n    let _spi: SPI;\n    /**\n    * Gets the default SPI driver\n    */\n    //%\n    export function spi() {\n        if (!_spi) {\n            const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n            const miso = pins.pinByCfg(DAL.CFG_PIN_MISO);\n            const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n            _spi = pins.createSPI(mosi, miso, sck);\n        }\n        return _spi;\n    }\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    export function spiWrite(value: number) {\n        return spi().write(value);\n    }\n\n    /**\n     * Write a given command to SPI bus, and afterwards read the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    export function spiTransfer(command: Buffer, response: Buffer) {\n        spi().transfer(command, response);\n    }\n\n    /**\n     * Set the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    export function spiFrequency(frequency: number) {\n        spi().setFrequency(frequency);\n    }\n\n    /**\n     * Set the SPI signal mode\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    export function spiMode(mode: number) {\n        spi().setMode(mode);\n    }\n}",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n#ifndef BOOTLOADER_START\n#define BOOTLOADER_START 0x0\n#endif\n\n#ifndef BOOTLOADER_END\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifndef UF2_BINFO\n#define UF2_BINFO ((UF2_BInfo *)(BOOTLOADER_END - sizeof(UF2_BInfo)))\n#endif\n\n#ifndef UF2_INFO_TXT\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#endif\n\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return (BOOTLOADER_START + 0x100) <= (uint32_t)addr && (uint32_t)addr < (BOOTLOADER_END);\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_INFO_TXT))\n        return UF2_INFO_TXT;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
            "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n    uint32_t uf2_family;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
            "usb.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nnamespace pxt {\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\n#ifdef HF2_HID\nHF2 hf2hid(hf2buf);\n#endif\nDummyIface dummyIface;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nUSBJACDAC jacdacDebug;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,   // bLength\n    0x01,   // bDescriptorType\n    0x0210, // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40, // bMaxPacketSize0\n    USB_DEFAULT_VID, USB_DEFAULT_PID,\n    0x4202, // bcdDevice - leave unchanged for the HF2 to work\n    0x01,   // iManufacturer\n    0x02,   // iProduct\n    0x03,   // SerialNumber\n    0x01    // bNumConfigs\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid platform_usb_init() __attribute__((weak));\nvoid platform_usb_init() {}\n\nvoid set_usb_strings(const char *uf2_info) {\n    static const char *string_descriptors[3];\n    static char serial[12];\n    itoa(target_get_serial() & 0x7fffffff, serial);\n\n    auto model = strstr(uf2_info, \"Model: \");\n    if (model) {\n        model += 7;\n        auto end = model;\n        while (*end && *end != '\\n' && *end != '\\r')\n            end++;\n        auto len = end - model;\n        auto dev = (char *)app_alloc(len + 10);\n        memcpy(dev, model, len);\n        strcpy(dev + len, \" (app)\");\n        // try to split into manufacturer and\n        auto sep = strstr(dev, \" / \");\n        if (sep) {\n            *sep = '\\0';\n            string_descriptors[0] = dev;\n            string_descriptors[1] = sep + 3;\n        } else {\n            string_descriptors[0] = dev;\n            string_descriptors[1] = dev;\n        }\n    }\n\n    string_descriptors[2] = serial;\n    usb.stringDescriptors = string_descriptors;\n}\n\nvoid usb_init() {\n    usb.deviceDescriptor = &device_desc;\n    set_usb_strings(UF2_INFO_TXT);\n\n    platform_usb_init();\n\n#ifdef STM32F4\n    // let's not waste EPs on the HF2 - it will run on CONTROL pipe instead\n    // this doesn't seem to currently work on SAMD, so only do it on STM, which\n    // has very few EPs\n    hf2.allocateEP = false;\n#endif\n    usb.add(hf2);\n\n#ifdef HF2_HID\n    hf2hid.useHID = true;\n    usb.add(hf2hid);\n#else\n    // the WINUSB descriptors don't seem to work if there's only one interface\n    // so we add a dummy interface\n    usb.add(dummyIface);\n#endif\n\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n    usb.add(jacdacDebug);\n#endif\n\n    create_fiber(start_usb);\n}\n\n} // namespace pxt\n\n#else\nnamespace pxt {\nvoid usb_init() {}\n} // namespace pxt\n#endif\n\nnamespace control {\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    return pxt::usb.isInitialised();\n#else\n    return false;\n#endif\n}\n}\n\nnamespace pxt {\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n#if HF2_HID\n    hf2hid.sendSerial(data, len);\n#endif\n#endif\n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n} // namespace pxt\n"
        },
        "core---samd": {
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile uintptr_t hp = (uintptr_t)p;\n        if (hp & 4) {\n            xfree(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            xfree(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        xfree(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n\n    auto led = LOOKUP_PIN(LED);\n    if (led) {\n        led->setDigitalValue(0);\n    }\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    while (curr) {\n        runAction1(curr->action, value);\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nuint64_t getLongSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\nuint64_t current_time_us() {\n    return system_timer_current_time_us();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    if (!currentFiber)\n        return NULL;\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n\nstatic void *threadAddressFor(codal::Fiber *fib, void *sp) {\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\nvoid gcProcessStacks(int flags) {\n    // check scheduler is initialized\n    if (!currentFiber) {\n        // make sure we allocate something to at least initalize the memory allocator\n        void * volatile p = xmalloc(1);\n        xfree(p);\n        return;\n    }\n\n    int numFibers = codal::list_fibers(NULL);\n    codal::Fiber **fibers = (codal::Fiber **)xmalloc(sizeof(codal::Fiber *) * numFibers);\n    int num2 = codal::list_fibers(fibers);\n    if (numFibers != num2)\n        oops(12);\n    int cnt = 0;\n\n    for (int i = 0; i < numFibers; ++i) {\n        auto fib = fibers[i];\n        auto ctx = (ThreadContext *)fib->user_data;\n        if (!ctx)\n            continue;\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(fib, seg->top);\n            auto end = (TValue *)threadAddressFor(fib, seg->bottom);\n            if (flags & 2)\n                DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n            // VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n    xfree(fibers);\n}\n#endif\n\n} // namespace pxt\n",
            "control.cpp": "#include \"pxt.h\"\n\n#ifdef NRF52 \n#define _estack __StackTop \n#endif\nextern uint32_t _estack;\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->getUTF8Data(), ptr);\n}\n\n//%\nuint32_t _ramSize()\n{\n    return (uint32_t)&_estack & 0x1fffffff;\n}\n\n}\n",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // /libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_VERSION = 5,\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_BUS_RISE = 16,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_EVT_RX_TIMEOUT = 4,\n    JD_SERIAL_EVT_BUS_CONNECTED = 5,\n    JD_SERIAL_EVT_BUS_DISCONNECTED = 6,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_SERIAL_MAX_BAUD = 1000000,\n    JD_SERIAL_TX_MAX_BACKOFF = 4000,\n    JD_SERIAL_TX_MIN_BACKOFF = 1000,\n    Receiving = 0,\n    Transmitting = 1,\n    High = 2,\n    Low = 3,\n    Baud1M = 1,\n    Baud500K = 2,\n    Baud250K = 4,\n    Baud125K = 8,\n    // /libraries/codal-core/inc/JACDAC/JDAccelerometerDriver.h\n    JD_ACCEL_EVT_SEND_DATA = 1,\n    // /libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // /libraries/codal-core/inc/JACDAC/JDClasses.h\n    STATIC_CLASS_START = 0,\n    STATIC_CLASS_END = 16777215,\n    DYNAMIC_CLASS_END = 4294967295,\n    JD_DRIVER_CLASS_CODAL_START = 0,\n    JD_DRIVER_CLASS_CODAL_END = 2000,\n    JD_DRIVER_CLASS_MAKECODE_START = 2000,\n    JD_DRIVER_CLASS_MAKECODE_END = 4000,\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_JOYSTICK = 1,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 2,\n    JD_DRIVER_CLASS_BRIDGE = 3,\n    JD_DRIVER_CLASS_BUTTON = 4,\n    JD_DRIVER_CLASS_PIN = 5,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 6,\n    JD_DRIVER_CLASS_ACCELEROMETER = 7,\n    JD_DRIVER_CLASS_CAPTOUCH_BUTTON = 8,\n    // /libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // /libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // /libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 65520,\n    JD_DRIVER_EVT_DISCONNECTED = 65521,\n    JD_DRIVER_EVT_PAIRED = 65522,\n    JD_DRIVER_EVT_UNPAIRED = 65523,\n    JD_DRIVER_EVT_PAIR_REJECTED = 65524,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 65525,\n    JD_DRIVER_EVT_ERROR = 65526,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_ERROR_MSK = 15,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    JD_LOGIC_DRIVER_EVT_CHANGED = 2,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    CONTROL_JD_TYPE_ERROR = 3,\n    CONTROL_JD_TYPE_PANIC = 255,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    CONTROL_PACKET_ERROR_NAME_LENGTH = 6,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    DRIVER_OK = 0,\n    DRIVER_CALIBRATION_IN_PROGRESS = 1,\n    DRIVER_CALIBRATION_REQUIRED = 2,\n    DRIVER_NO_RESOURCES = 3,\n    DRIVER_BUSY = 4,\n    DRIVER_COMMS_ERROR = 5,\n    DRIVER_INVALID_STATE = 6,\n    DRIVER_PERIPHERAL_MALFUNCTION = 7,\n    // /libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // /libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // /libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // /libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // /libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    DEVICE_HARDWARE_CONFIGURATION_ERROR = 90,\n    // /libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // /libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // /libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_EVT_2G = 12,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_2G_TOLERANCE = 2048,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // /libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // /libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // /libraries/codal-core/inc/driver-models/LowLevelTimer.h\n    TimerModeTimer = 0,\n    TimerModeCounter = 1,\n    TimerModeAlternateFunction = 2,\n    BitMode8 = 0,\n    BitMode16 = 1,\n    BitMode24 = 2,\n    BitMode32 = 3,\n    // /libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // /libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // /libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // /libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // /libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // /libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // /libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // /libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // /libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // /libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // /libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // /libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // /libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // /libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // /libraries/codal-core/inc/drivers/MMA8453.h\n    MMA8453_DEFAULT_ADDR = 56,\n    MMA8453_WHOAMI_VAL = 58,\n    // /libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // /libraries/codal-core/inc/drivers/MPU6050.h\n    MPU6050_DEFAULT_ADDR = 104,\n    MPU6050_WHOAMI = 117,\n    MPU6050_WHOAMI_VAL = 52,\n    // /libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // /libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // /libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // /libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // /libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // /libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // /libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // /libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // /libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // /libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // /libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // /libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // /pxtapp/accelerometer/axis.h\n    ACC_SYSTEM = 3,\n    ACC_ROTATION = 0,\n    // /pxtapp/configkeys.h\n    CFG_PIN_NAME_MSK = 65535,\n    CFG_PIN_CONFIG_MSK = 4294901760,\n    CFG_PIN_CONFIG_ACTIVE_LO = 65536,\n    CFG_MAGIC0 = 513675505,\n    CFG_MAGIC1 = 539130489,\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACK_TX = 60,\n    CFG_PIN_JACK_SENSE = 61,\n    CFG_PIN_JACK_HPEN = 62,\n    CFG_PIN_JACK_BZEN = 63,\n    CFG_PIN_JACK_PWREN = 64,\n    CFG_PIN_JACK_SND = 65,\n    CFG_PIN_JACK_BUSLED = 66,\n    CFG_PIN_JACK_COMMLED = 67,\n    CFG_PIN_BTN_SOFT_RESET = 69,\n    CFG_ACCELEROMETER_TYPE = 70,\n    CFG_PIN_BTNMX_LATCH = 71,\n    CFG_PIN_BTNMX_CLOCK = 72,\n    CFG_PIN_BTNMX_DATA = 73,\n    CFG_PIN_BTN_MENU2 = 74,\n    CFG_PIN_BATTSENSE = 75,\n    CFG_PIN_VIBRATION = 76,\n    CFG_PIN_PWREN = 77,\n    CFG_PIN_ROTARY_ENCODER_A = 79,\n    CFG_PIN_ROTARY_ENCODER_B = 80,\n    ACCELEROMETER_TYPE_LIS3DH = 50,\n    ACCELEROMETER_TYPE_MMA8453 = 56,\n    ACCELEROMETER_TYPE_FXOS8700 = 60,\n    ACCELEROMETER_TYPE_MMA8653 = 58,\n    ACCELEROMETER_TYPE_MSA300 = 76,\n    ACCELEROMETER_TYPE_MPU6050 = 104,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_A16 = 116,\n    CFG_PIN_A17 = 117,\n    CFG_PIN_A18 = 118,\n    CFG_PIN_A19 = 119,\n    CFG_PIN_A20 = 120,\n    CFG_PIN_A21 = 121,\n    CFG_PIN_A22 = 122,\n    CFG_PIN_A23 = 123,\n    CFG_PIN_A24 = 124,\n    CFG_PIN_A25 = 125,\n    CFG_PIN_A26 = 126,\n    CFG_PIN_A27 = 127,\n    CFG_PIN_A28 = 128,\n    CFG_PIN_A29 = 129,\n    CFG_PIN_A30 = 130,\n    CFG_PIN_A31 = 131,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_PIN_D16 = 166,\n    CFG_PIN_D17 = 167,\n    CFG_PIN_D18 = 168,\n    CFG_PIN_D19 = 169,\n    CFG_PIN_D20 = 170,\n    CFG_PIN_D21 = 171,\n    CFG_PIN_D22 = 172,\n    CFG_PIN_D23 = 173,\n    CFG_PIN_D24 = 174,\n    CFG_PIN_D25 = 175,\n    CFG_PIN_D26 = 176,\n    CFG_PIN_D27 = 177,\n    CFG_PIN_D28 = 178,\n    CFG_PIN_D29 = 179,\n    CFG_PIN_D30 = 180,\n    CFG_PIN_D31 = 181,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_SYSTEM_HEAP_BYTES = 206,\n    CFG_LOW_MEM_SIMULATION_KB = 207,\n    CFG_BOOTLOADER_BOARD_ID = 208,\n    CFG_UF2_FAMILY = 209,\n    CFG_PINS_PORT_SIZE = 210,\n    CFG_BOOTLOADER_PROTECTION = 211,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    CFG_ANALOG_BUTTON_THRESHOLD = 213,\n    CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS = 215,\n    CFG_PIN_B0 = 300,\n    CFG_PIN_B1 = 301,\n    CFG_PIN_B2 = 302,\n    CFG_PIN_B3 = 303,\n    CFG_PIN_B4 = 304,\n    CFG_PIN_B5 = 305,\n    CFG_PIN_B6 = 306,\n    CFG_PIN_B7 = 307,\n    CFG_PIN_B8 = 308,\n    CFG_PIN_B9 = 309,\n    CFG_PIN_B10 = 310,\n    CFG_PIN_B11 = 311,\n    CFG_PIN_B12 = 312,\n    CFG_PIN_B13 = 313,\n    CFG_PIN_B14 = 314,\n    CFG_PIN_B15 = 315,\n    CFG_PIN_B16 = 316,\n    CFG_PIN_B17 = 317,\n    CFG_PIN_B18 = 318,\n    CFG_PIN_B19 = 319,\n    CFG_PIN_B20 = 320,\n    CFG_PIN_B21 = 321,\n    CFG_PIN_B22 = 322,\n    CFG_PIN_B23 = 323,\n    CFG_PIN_B24 = 324,\n    CFG_PIN_B25 = 325,\n    CFG_PIN_B26 = 326,\n    CFG_PIN_B27 = 327,\n    CFG_PIN_B28 = 328,\n    CFG_PIN_B29 = 329,\n    CFG_PIN_B30 = 330,\n    CFG_PIN_B31 = 331,\n    CFG_PIN_C0 = 350,\n    CFG_PIN_C1 = 351,\n    CFG_PIN_C2 = 352,\n    CFG_PIN_C3 = 353,\n    CFG_PIN_C4 = 354,\n    CFG_PIN_C5 = 355,\n    CFG_PIN_C6 = 356,\n    CFG_PIN_C7 = 357,\n    CFG_PIN_C8 = 358,\n    CFG_PIN_C9 = 359,\n    CFG_PIN_C10 = 360,\n    CFG_PIN_C11 = 361,\n    CFG_PIN_C12 = 362,\n    CFG_PIN_C13 = 363,\n    CFG_PIN_C14 = 364,\n    CFG_PIN_C15 = 365,\n    CFG_PIN_C16 = 366,\n    CFG_PIN_C17 = 367,\n    CFG_PIN_C18 = 368,\n    CFG_PIN_C19 = 369,\n    CFG_PIN_C20 = 370,\n    CFG_PIN_C21 = 371,\n    CFG_PIN_C22 = 372,\n    CFG_PIN_C23 = 373,\n    CFG_PIN_C24 = 374,\n    CFG_PIN_C25 = 375,\n    CFG_PIN_C26 = 376,\n    CFG_PIN_C27 = 377,\n    CFG_PIN_C28 = 378,\n    CFG_PIN_C29 = 379,\n    CFG_PIN_C30 = 380,\n    CFG_PIN_C31 = 381,\n    CFG_PIN_P0 = 400,\n    CFG_PIN_P1 = 401,\n    CFG_PIN_P2 = 402,\n    CFG_PIN_P3 = 403,\n    CFG_PIN_P4 = 404,\n    CFG_PIN_P5 = 405,\n    CFG_PIN_P6 = 406,\n    CFG_PIN_P7 = 407,\n    CFG_PIN_P8 = 408,\n    CFG_PIN_P9 = 409,\n    CFG_PIN_P10 = 410,\n    CFG_PIN_P11 = 411,\n    CFG_PIN_P12 = 412,\n    CFG_PIN_P13 = 413,\n    CFG_PIN_P14 = 414,\n    CFG_PIN_P15 = 415,\n    CFG_PIN_P16 = 416,\n    CFG_PIN_P17 = 417,\n    CFG_PIN_P18 = 418,\n    CFG_PIN_P19 = 419,\n    CFG_PIN_P20 = 420,\n    CFG_PIN_LORA_MISO = 1001,\n    CFG_PIN_LORA_MOSI = 1002,\n    CFG_PIN_LORA_SCK = 1003,\n    CFG_PIN_LORA_CS = 1004,\n    CFG_PIN_LORA_BOOT = 1005,\n    CFG_PIN_LORA_RESET = 1006,\n    CFG_PIN_IRRXLED = 1007,\n    CFG_PIN_IRTXLED = 1008,\n    CFG_PIN_LCD_RESET = 1009,\n    CFG_PIN_LCD_ENABLE = 1010,\n    CFG_PIN_LCD_DATALINE4 = 1011,\n    CFG_PIN_LCD_DATALINE5 = 1012,\n    CFG_PIN_LCD_DATALINE6 = 1013,\n    CFG_PIN_LCD_DATALINE7 = 1014,\n    CFG_NUM_LCD_COLUMNS = 1015,\n    CFG_NUM_LCD_ROWS = 1016,\n    // /pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // /pxtapp/mixer---samd/melody.h\n    SW_TRIANGLE = 1,\n    SW_SAWTOOTH = 2,\n    SW_SINE = 3,\n    SW_NOISE = 4,\n    SW_REAL_NOISE = 5,\n    SW_SQUARE_10 = 11,\n    SW_SQUARE_50 = 15,\n    CODAL = 1,\n    MAX_SOUNDS = 5,\n    Waiting = 0,\n    Playing = 1,\n    Done = 2,\n    // /pxtapp/pins.h\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // /pxtapp/platform.h\n    PAGE_SIZE = 512,\n    DEV_NUM_PINS = 64,\n    PXT_74HC165 = 1,\n    IMAGE_BITS = 4,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // /pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // /pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // /pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    PXT_UF2_FAMILY = 1760373640,\n    // /pxtapp/storage/SNORFS.h\n    DEVICE_FLASH_ERROR = 950,\n    // /pxtapp/thermometer/target_temperature.h\n    TEMPERATURE_NOMINAL_VALUE = 25,\n    TEMPERATURE_NOMINAL_READING = 10000,\n    TEMPERATURE_BETA = 3380,\n    TEMPERATURE_SERIES_RESISTOR = 10000,\n    // /pxtapp/uf2format.h\n    BOOTLOADER_START = 0,\n    // /pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
            "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
            "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nclass WDMAC {\n  public:\n    CODAL_DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "hf2.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#ifndef USB_HANDOVER\n#define USB_HANDOVER 1\n#endif\n\n#if USB_HANDOVER\n#define UF2_DEFINE_HANDOVER 1\n#endif\n\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\n#ifdef HF2_HID\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfoHID = {\n   &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n#endif\n\nstatic const InterfaceInfo ifaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\nstatic const InterfaceInfo ifaceInfoEP = {\n    NULL,\n    0,\n    2,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_BULK, 0},\n    {USB_EP_TYPE_BULK, 0},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n#ifdef HF2_HID\n    if (!useHID)\n        return DEVICE_NOT_SUPPORTED;\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n#endif\n    return DEVICE_NOT_SUPPORTED;\n}\n\n// same as in microbit\n#define CTRL_GET_REPORT 0x01\n#define CTRL_SET_REPORT 0x09\n#define CTRL_OUT_REPORT_H 0x2\n#define CTRL_IN_REPORT_H 0x1\n\nvoid HF2::prepBuffer(uint8_t *buf) {\n    memset(buf, 0, 64);\n    target_disable_irq();\n    if (dataToSendLength) {\n        if (dataToSendPrepend) {\n            dataToSendPrepend = false;\n            buf[0] = HF2_FLAG_CMDPKT_BODY | 4;\n            memcpy(buf + 1, pkt.buf, 4);\n        } else {\n            int flag = dataToSendFlag;\n            int s = 63;\n            if (dataToSendLength <= 63) {\n                s = dataToSendLength;\n            } else {\n                if (flag == HF2_FLAG_CMDPKT_LAST)\n                    flag = HF2_FLAG_CMDPKT_BODY;\n            }\n\n            buf[0] = flag | s;\n            memcpy(buf + 1, dataToSend, s);\n            dataToSend += s;\n            dataToSendLength -= s;\n        }\n    }\n    target_enable_irq();\n}\n\nvoid HF2::pokeSend() {\n    if (!allocateEP || !CodalUSB::usbInstance->isInitialised())\n        return;\n\n    uint8_t buf[64];\n    for (;;) {\n        prepBuffer(buf);\n        if (!buf[0])\n            break;\n        in->write(buf, sizeof(buf));\n    }\n}\n\nint HF2::classRequest(UsbEndpointIn &ctrl, USBSetup &setup) {\n    if (allocateEP)\n        return DEVICE_NOT_SUPPORTED;\n\n    if ((setup.bmRequestType & USB_REQ_DIRECTION) == USB_REQ_HOSTTODEVICE) {\n        if (setup.bRequest != CTRL_SET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_OUT_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength > 64)\n            return DEVICE_NOT_SUPPORTED;\n        ctrlWaiting = true;\n        CodalUSB::usbInstance->ctrlOut->startRead();\n        ctrl.wLength = 0; // pretend we're done\n    } else {\n        if (setup.bRequest != CTRL_GET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_IN_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength != 64)\n            return DEVICE_NOT_SUPPORTED;\n\n        uint8_t buf[64];\n        prepBuffer(buf);\n        ctrl.write(buf, sizeof(buf));\n    }\n\n    return DEVICE_OK;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo() {\n#ifdef HF2_HID\n    if (useHID)\n        return &ifaceInfoHID;\n#endif\n    return allocateEP ? &ifaceInfoEP : &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError) {\n    if (!gotSomePacket)\n        return DEVICE_OK;\n\n    for (;;) {\n        pokeSend();\n\n        while (dataToSendLength) {\n            fiber_sleep(5);\n            pokeSend();\n        }\n\n        if (size < 0)\n            break;\n\n        target_disable_irq();\n        // there could be a race\n        if (!dataToSendLength) {\n            dataToSend = (const uint8_t *)data;\n            dataToSendPrepend = false;\n            dataToSendFlag = isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT;\n            dataToSendLength = size;\n            size = -1;\n        }\n        target_enable_irq();\n    }\n\n    return 0;\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len;\n\n    if (allocateEP)\n        len = out->read(buf, sizeof(buf));\n    else\n        len = CodalUSB::usbInstance->ctrlOut->read(buf, sizeof(buf));\n    // DMESG(\"HF2 read: %d\", len);\n\n    if (len <= 0)\n        return len;\n\n    if (!allocateEP)\n        CodalUSB::usbInstance->ctrlIn->write(\"\", 0);\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    dataToSend = pkt.buf;\n    dataToSendPrepend = false;\n    dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n    dataToSendLength = 4 + size;\n    pokeSend();\n    return 0;\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    if (dataToSendLength)\n        oops(90);\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        memcpy(pkt.resp.data8, data, size);\n        return sendResponse(size);\n    } else {\n        dataToSend = (const uint8_t *)data;\n        dataToSendPrepend = true;\n        dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n        dataToSendLength = size;\n        pokeSend();\n        return 0;\n    }\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#ifndef QUICK_BOOT\n#ifdef SAMD21\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#endif\n#ifdef SAMD51\n#define DBL_TAP_PTR ((volatile uint32_t *)(HSRAM_ADDR + HSRAM_SIZE - 4))\n#endif\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n#define QUICK_BOOT(v) *DBL_TAP_PTR = v ? DBL_TAP_MAGIC_QUICK_BOOT : 0\n#endif\n\nint HF2::endpointRequest() {\n    if (!allocateEP && !ctrlWaiting)\n        return 0;\n\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        resp->bininfo.uf2_family = PXT_UF2_FAMILY;\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        QUICK_BOOT(1);\n        NVIC_SystemReset();\n        break;\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        QUICK_BOOT(0);\n        NVIC_SystemReset();\n        break;\n\n#if USB_HANDOVER\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n#endif\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : gotSomePacket(false), ctrlWaiting(false), pkt(p), allocateEP(true), useHID(false) {}\n\n\nstatic const InterfaceInfo dummyIfaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        0xff,   // subclass\n        0xff,    // protocol\n        0x00, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\n\nconst InterfaceInfo *DummyIface::getInterfaceInfo() {\n    return &dummyIfaceInfo;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n\n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        xfree(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            xfree(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
            "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct {\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public CodalUSBInterface {\n    void prepBuffer(uint8_t *buf);\n    void pokeSend();\n\n    const uint8_t *dataToSend;\n    volatile uint32_t dataToSendLength;\n    bool dataToSendPrepend;\n    uint8_t dataToSendFlag;\n\n    bool gotSomePacket;\n    bool ctrlWaiting;\n\n  public:\n    HF2_Buffer &pkt;\n\n    bool allocateEP;\n    bool useHID;\n\n    int sendResponse(int size);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int classRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n\n    virtual bool enableWebUSB() { return !useHID; }\n};\n\nclass DummyIface : public CodalUSBInterface {\n  public:\n    virtual const InterfaceInfo *getInterfaceInfo();\n};\n\n#endif\n\n#endif\n",
            "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
            "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n#include \"CodalDmesg.h\"\n#include \"configkeys.h\"\n\n#ifdef CODAL_I2C\n\nnamespace pins {\n\nclass CodalI2CProxy {\nprivate:\n  DevicePin* sda;\n  DevicePin* scl;\n  CODAL_I2C i2c;\npublic:\n  CodalI2CProxy* next;\npublic:\n  CodalI2CProxy(DevicePin* _sda, DevicePin* _scl)\n    : sda(_sda)\n    , scl(_scl)\n    , i2c(*_sda, *_scl) \n    , next(NULL)\n  {\n\n  }\n\n  CODAL_I2C* getI2C() {\n    return &(this->i2c);\n  }\n  \n  bool matchPins(DevicePin* sda, DevicePin* scl) {\n      return this->sda == sda && this->scl == scl;\n  }\n\n  Buffer readBuffer(int address, int size, bool repeat = false)\n  {\n    Buffer buf = mkBuffer(NULL, size);\n    int status = this->i2c.read(address << 1, buf->data, size, repeat);\n    if (status != ErrorCode::DEVICE_OK) {\n      decrRC(buf);\n      buf = 0;\n    }\n    return buf;\n  }\n\n  int writeBuffer(int address, Buffer buf, bool repeat = false)\n  {\n    return this->i2c.write(address << 1, buf->data, buf->length, repeat);\n  }\n};\n\n}\n\nnamespace I2CMethods {\n/**\n  * Read `size` bytes from a 7-bit I2C `address`.\n  */\n//%\nBuffer readBuffer(I2C_ i2c, int address, int size, bool repeat = false)\n{\n  return i2c->readBuffer(address, size, repeat);\n}\n\n/**\n  * Write bytes to a 7-bit I2C `address`.\n  */\n//%\nint writeBuffer(I2C_ i2c, int address, Buffer buf, bool repeat = false)\n{\n  return i2c->writeBuffer(address, buf, repeat);\n}\n\n}\n\nnamespace pins {\n\nstatic I2C_ i2cs(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//% help=pins/create-i2c\n//% parts=i2c\nI2C_ createI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n  // pick up defaults\n  if (!sda || !scl) {\n    DMESG(\"i2c: lookup default pins\");\n    sda = LOOKUP_PIN(SDA);\n    scl = LOOKUP_PIN(SCL);\n  }\n\n  // lookup existing devices\n  auto dev = i2cs;\n  while(dev) {\n    if (dev->matchPins(sda, scl)) {\n      DMESG(\"i2c: found existing i2c\");\n      return dev;\n    }\n    dev = dev->next;\n  }\n\n  // allocate new one\n  DMESG(\"i2c: mounting on new device\");\n  auto ser = new CodalI2CProxy(sda, scl);\n  // push in list\n  ser->next = i2cs;\n  i2cs = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n  CODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n    auto i2c = pins::createI2C(sda, scl);\n    return i2c->getI2C();\n  }\n}\n\n#endif",
            "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        const buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        if (!buf)\n            return undefined\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format?: NumberFormat, repeated?: boolean): void {\n        if (format == undefined)\n            format = NumberFormat.UInt8LE;\n        const buf = control.createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    /**\n     * Write a value in a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param value value to write\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-write-register\n    //% blockId=i2c_writereg block=\"i2c write register|at address $address|at register $register|value $value\"\n    export function i2cWriteRegister(address: number, register: number, value: number, valueFormat?: NumberFormat): void {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        const valueSize = pins.sizeOf(valueFormat);\n        const buf = control.createBuffer(1 + valueSize);\n        buf.setNumber(NumberFormat.UInt8LE, 0, register);\n        buf.setNumber(valueFormat, 1, value);\n        pins.i2cWriteBuffer(address, buf);\n    }\n\n    /**\n     * Read the value from a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-read-register\n    //% blockId=i2c_readreg block=\"i2c read register|at address $address|at register $register\"\n    export function i2cReadRegister(address: number, register: number, valueFormat?: NumberFormat): number {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        pins.i2cWriteNumber(address, register, NumberFormat.UInt8LE);\n        return pins.i2cReadNumber(address, valueFormat);\n    }\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cReadBuffer(address: number, size: number, repeat: boolean = false): Buffer {\n        return pins.i2c().readBuffer(address, size, repeat);\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cWriteBuffer(address: number, buf: Buffer, repeat: boolean = false): number {\n        return pins.i2c().writeBuffer(address, buf, repeat);\n    }\n\n    let _i2c: I2C;\n    /**\n     * Gets the default I2C bus\n     */\n    //%\n    export function i2c() {\n        if (!_i2c) {\n            const sda = pins.pinByCfg(DAL.CFG_PIN_SDA);\n            const scl = pins.pinByCfg(DAL.CFG_PIN_SCL);\n            _i2c = pins.createI2C(sda, scl);    \n        }\n        return _i2c;        \n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}\n",
            "keyvaluestorage.cpp": "#include \"pxt.h\"\n#include \"KeyValueStorage.h\"\n\nnamespace pxt {\n\nclass WKeyValueStorage {\n#ifdef CODAL_NVMCONTROLLER\n    CODAL_NVMCONTROLLER controller;\n#else\n    NVMController controller;\n#endif\n    KeyValueStorage storage;\n  public:\n\n    WKeyValueStorage()\n    : controller()\n    , storage(controller) {\n    }\n\n    bool isSupported() {\n#ifdef CODAL_NVMCONTROLLER\n      return true;\n#else\n      return false;\n#endif\n    }\n\n    int put(String key, Buffer data) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        return storage.put(mkey, data->data, data->length);\n#else\n        return -1;\n#endif\n    }\n\n    Buffer get(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        Buffer buf = NULL;\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        auto entry = storage.get(mkey);\n        if (entry) {\n          buf = mkBuffer(entry->value, sizeof(entry->value));\n          free(entry);\n        }\n        return buf;\n#else\n        return NULL;\n#endif\n    }\n\n    void remove(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        storage.remove(mkey);\n#endif\n    }\n\n    void clear() {\n#ifdef CODAL_NVMCONTROLLER\n        storage.wipe();\n#endif\n    }\n};\nSINGLETON(WKeyValueStorage);\n\n}\n\nnamespace configStorage {\n  /**\n  * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  * @param value the data (max 32 characters)\n  */\n  //%\n  void setBuffer(String key, Buffer value) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->put(key, value);\n  }\n\n  /**\n  * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  Buffer getBuffer(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    return kvm->get(key);\n  }\n\n  /**\n  * Removes the key from local storage\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  void removeItem(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->remove(key);\n  }\n\n  /**\n  * Clears the local storage\n  */\n  //%\n  void clear() {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->clear();\n  }\n}\n",
            "keyvaluestorage.ts": "namespace configStorage {\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     * @param value identifier of the value (max 32 characters)\n     */\n    export function setItem(key: string, value: string) {\n        if (value == null)\n            configStorage.removeItem(key);\n        else\n        {\n            let idx = 0;\n            let buf = control.createBuffer(value.length + 1);\n            buf[idx++] = value.length;\n            let valBuf = control.createBufferFromUTF8(value);\n\n            for (let i = 0; i < valBuf.length; i++)\n                buf[idx++] = valBuf[i];\n\n            configStorage.setBuffer(key, buf);\n        }\n    }\n\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     */\n    export function getItem(key: string): string {\n        const buf = configStorage.getBuffer(key);\n\n        if (!buf)\n            return undefined;\n\n        let idx = 0;\n        let count = buf[idx++];\n        const retBuf = control.createBuffer(count);\n\n        for (let i = 0; i < count; i++)\n            retBuf[i] = buf[idx++];\n\n        return retBuf.toString();\n    }\n}\n",
            "leveldetector.ts": "namespace pins {\n    export class LevelDetector {\n        public id: number;\n        public min: number;\n        public max: number;\n        public lowThreshold: number;\n        public highThreshold: number;\n        private transition: number;\n        private _level: number;\n        private _state: number;\n        public onHigh: () => void;\n        public onLow: () => void;\n        public transitionWindow: number;\n\n        constructor(id: number,\n            min: number, max: number,\n            lowThreshold: number, highThreshold: number) {\n            this.id = id;\n            this.min = min;\n            this.max = max;\n            this.lowThreshold = lowThreshold;\n            this.highThreshold = highThreshold;\n            this._level = Math.ceil((max - min) / 2);\n            this._state = 0;\n            this.transitionWindow = 4;\n            this.transition = 0;\n\n            this.onHigh = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_HIGH);\n            this.onLow = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_LOW);\n        }\n\n        get level(): number {\n            return this._level;\n        }\n\n        set level(level: number) {\n            control.dmesg(\"LEVEL: \");\n            control.dmesg(level.toString());\n\n            this._level = this.clampValue(level);\n\n            if (this._level >= this.highThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_HIGH);\n            }\n            else if (this._level <= this.lowThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_LOW);\n            }\n            else {\n                this.setState(0);\n            }\n        }\n\n        public setLowThreshold(value: number) {\n            this.lowThreshold = this.clampValue(value);\n            this.highThreshold = Math.max(this.lowThreshold + 1, this.highThreshold);\n        }\n\n        public setHighThreshold(value: number) {\n            this.highThreshold = this.clampValue(value);\n            this.lowThreshold = Math.min(this.highThreshold - 1, this.lowThreshold);\n        }\n\n        private clampValue(value: number) {\n            if (value < this.min) {\n                return this.min;\n            }\n            else if (value > this.max) {\n                return this.max;\n            }\n            return value;\n        }\n\n        private setState(state: number) {\n                                        // not enough samples to change\n            if (this._state === state || this.transition++ < this.transitionWindow) {\n                return;\n            }\n\n            this.transition = 0;\n            this._state = state;\n            switch (state) {\n                case DAL.LEVEL_THRESHOLD_HIGH:\n                    if (this.onHigh) this.onHigh();\n                    break;\n                case DAL.LEVEL_THRESHOLD_LOW:\n                    if (this.onLow) this.onLow();\n                    break;\n            }\n        }\n    }\n}",
            "light.cpp": "#include \"light.h\"\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n#include \"neopixel.h\"\n#endif\n\n#define NEOPIXEL_MIN_LENGTH_FOR_SPI 24\n#define DOTSTAR_MIN_LENGTH_FOR_SPI 24\n\n#define LIGHTMODE_RGB 1\n#define LIGHTMODE_RGBW 2\n#define LIGHTMODE_RGB_RGB 3\n#define LIGHTMODE_DOTSTAR 4\n\nnamespace light {\nbool isValidMOSIPin(DigitalInOutPin pin) {\n    if (!pin)\n        return false;\n\n#if SAMD51\n    return ZSPI::isValidMOSIPin(*pin);\n#else\n    // TODO: support for SPI neopixels\n    // default SPI pins supported for now\n    return pin == LOOKUP_PIN(MOSI);\n#endif\n\n}\n\n// SPI\nvoid spiNeopixelSendBuffer(DevicePin* pin, const uint8_t *data, unsigned size) {\n    int32_t iptr = 0, optr = 100;\n    uint32_t len = optr + size * 3 + optr;\n    uint8_t *expBuf = new uint8_t[len];\n    memset(expBuf, 0, len);\n    uint8_t imask = 0x80;\n    uint8_t omask = 0x80;\n\n#define WR(k)                                                                                      \\\n    if (k)                                                                                         \\\n        expBuf[optr] |= omask;                                                                     \\\n    omask >>= 1;                                                                                   \\\n    if (!omask) {                                                                                  \\\n        omask = 0x80;                                                                              \\\n        optr++;                                                                                    \\\n    }\n\n    while (iptr < (int)size) {\n        WR(1);\n        WR(data[iptr] & imask);\n        imask >>= 1;\n        if (!imask) {\n            imask = 0x80;\n            iptr++;\n        }\n        WR(0);\n    }\n\n    auto spi = pxt::getSPI(pin, NULL, NULL);\n    spi->setFrequency(2400000);\n    spi->transfer(expBuf, len, NULL, 0);\n    delete expBuf;\n}\n\nvoid neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length) {\n    if (!pin || !length) return;\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n    if (length > NEOPIXEL_MIN_LENGTH_FOR_SPI && isValidMOSIPin(pin))\n        spiNeopixelSendBuffer(pin, data, length);\n    else\n        neopixel_send_buffer(*pin, data, length);\n #else\n     if (isValidMOSIPin(pin)) {\n         spiNeopixelSendBuffer(pin, data, length);\n     }\n #endif\n}\n\nvoid bitBangDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    // first frame of zeroes\n    data->setDigitalValue(0);\n    for (unsigned i = 0; i < 32; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n\n    // data stream\n    for (unsigned i = 0; i < length; ++i) {\n        auto x = buf[i];\n        for (uint8_t j = 0x80; j != 0; j >>= 1) {\n            data->setDigitalValue(x & j ? 1 : 0);\n            clk->setDigitalValue(1);\n            clk->setDigitalValue(0);\n        }\n    }\n    // https://cpldcpu.wordpress.com/2016/12/13/sk9822-a-clone-of-the-apa102/\n    // reset frame\n    //data->setDigitalValue(0);\n    //for (unsigned i = 0; i < 32 ; ++i) {\n    //    clk->setDigitalValue(1);\n    //    clk->setDigitalValue(0);\n    //}\n\n    // https://cpldcpu.wordpress.com/2014/11/30/understanding-the-apa102-superled/\n    data->setDigitalValue(1);\n    unsigned n = 32;\n    for (unsigned i = 0; i < n; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n}\n\nstatic uint8_t ZERO_FRAME[4];\nstatic uint8_t ONE_FRAME[] = {1,1,1,1};\nvoid spiDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    auto spi = pxt::getSPI(data, NULL, clk);\n\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // initial frame\n    spi->transfer(buf, length, NULL, 0);\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // reset frame\n    for(unsigned i = 0; i < length >> 3; i += 32)\n        spi->transfer(ONE_FRAME, sizeof(ONE_FRAME), NULL, 0); // final frame\n}\n\nvoid dotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    if (!data || !clk || !buf || !length) return;\n\n    if (length > DOTSTAR_MIN_LENGTH_FOR_SPI && isValidMOSIPin(data))\n        spiDotStarSendData(data, clk, mode, buf, length);\n    else\n        bitBangDotStarSendData(data, clk, mode, buf, length);\n}\n\nvoid sendBuffer(DevicePin* data, DevicePin* clk, int mode, Buffer buf) {\n    if (!data || !buf || !buf->length) return;\n\n    if (mode == LIGHTMODE_DOTSTAR)\n        light::dotStarSendData(data, clk, mode, buf->data, buf->length);\n    else\n        light::neopixelSendData(data, mode, buf->data, buf->length);\n}\n\n\nvoid clear() {\n    auto neopix = LOOKUP_PIN(NEOPIXEL);\n    auto neonum = getConfig(CFG_NUM_NEOPIXELS, 0);\n    if (neopix && neonum >= 0) {\n        auto n = 3 * neonum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        light::neopixelSendData(neopix, 0x100, off, sizeof(off));\n    }\n\n    auto data = LOOKUP_PIN(DOTSTAR_DATA);\n    auto clk = LOOKUP_PIN(DOTSTAR_CLOCK);\n    auto dsnum = getConfig(CFG_NUM_DOTSTARS, 0);\n    if (data && clk && dsnum > 0) {\n        auto n = 4 * dsnum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        for(int i = 0; i < n; i += 4)\n            off[i] = 0xe0;\n        bitBangDotStarSendData(data, clk, 0x100, off, sizeof(off));\n    }\n}\n\n} // namespace pxt\n",
            "light.h": "#ifndef __PXT_LIGHT_H\n#define __PXT_LIGHT_H\n\n#include \"pxt.h\"\n\nnamespace light {\n    /**\n    * Clear onboard neopixels\n    */\n    void clear();\n\n    /**\n    * Send a programmable light buffer to the specified digital pin\n    * @param data The pin that the light are connected to\n    * @param clk the clock line if nay\n    * @param mode the color encoding mode\n    * @param buf The buffer to send to the pin\n    */\n    //%\n    void sendBuffer(DigitalInOutPin data, DigitalInOutPin clk, int mode, Buffer buf);\n\n    void neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length);\n}\n\n#endif",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n\n    id &= CFG_PIN_NAME_MSK;\n\n    if (id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0 || pinName == 0xff)\n        return NULL;\n    pinName &= CFG_PIN_NAME_MSK;\n    return getPin(pinName);\n}\n\n//%\nDevicePin *lookupPinCfg(int key) {\n    return lookupPin(getConfig(key));\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n* Get a pin by configuration id (DAL.CFG_PIN...)\n*/\n//%\nDigitalInOutPin pinByCfg(int key) {\n    return pxt::lookupPinCfg(key);\n}\n\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n}",
            "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
            "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
            "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
            "pinscompat.ts": "// filled in by microbit",
            "platform.cpp": "#include \"pxt.h\"\n\n#include \"SAMDTCTimer.h\"\n#include \"SAMDTCCTimer.h\"\n#include \"light.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n// TC3 is used by DAC on both D21 and D51\n// TCC0 and TC4 is used by IR\n// TCC0, TCC1, TC4 is used by PWM on CPX\n#ifdef SAMD21\nSAMDTCCTimer jacdacTimer(TCC2, TCC2_IRQn);\nSAMDTCTimer lowTimer(TC5, TC5_IRQn);\n\nLowLevelTimer *getJACDACTimer() {\n    jacdacTimer.setIRQPriority(1);\n    return &jacdacTimer;\n}\n\n#endif\n#ifdef SAMD51\nSAMDTCTimer jacdacTimer(TC0, TC0_IRQn);\nSAMDTCTimer lowTimer(TC2, TC2_IRQn);\n\nLowLevelTimer *getJACDACTimer() {\n    jacdacTimer.setIRQPriority(1);\n    return &jacdacTimer;\n}\n#endif\n#endif // CODAL_JACDAC_WIRE_SERIAL\n\n__attribute__((used)) CODAL_TIMER devTimer(lowTimer);\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    // TODO use TRNG\n    seedRandom(seed);\n}\n\nvoid platformSendSerial(const char *data, int len) {}\n\n#ifdef SAMD21\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n    remapSwdPin(CFG_PIN_SPEAKER_AMP, PIN(A2));\n}\n#else\nstatic void initSwdPins() {}\n#endif\n\nvoid platform_init() {\n    initSwdPins();\n    initRandomSeed();\n    setSendToUART(platformSendSerial);\n    light::clear();\n\n    /*\n        if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n            *HF2_DBG_MAGIC_PTR = 0;\n            // this will cause alignment fault at the first breakpoint\n            globals[0] = (TValue)1;\n        }\n    */\n}\n\nint *getBootloaderConfigData() {\n#ifdef SAMD51\n    auto config_data = *(uint32_t *)(BOOTLOADER_END - 4 * 4);\n    if (config_data && (config_data & 3) == 0 && config_data < BOOTLOADER_END) {\n        auto p = (uint32_t *)config_data;\n        if (p[0] == CFG_MAGIC0 && p[1] == CFG_MAGIC1)\n            return (int *)p + 4;\n    }\n#endif\n    return NULL;\n}\n\n} // namespace pxt\n\nvoid cpu_clock_init() {}\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#include \"Image.h\"\n#include \"MultiButton.h\"\n#include \"ZPin.h\"\n#include \"Timer.h\"\n#include \"SAMDDAC.h\"\n#include \"ZSPI.h\"\n#include \"ZI2C.h\"\n#include \"ZSingleWireSerial.h\"\n#include \"SAMDNVM.h\"\n\n#include \"SAMDSerial.h\"\n\n// cap touch not available on 51 yet\n#ifdef SAMD21\n#include \"CapTouchButton.h\"\n#endif\n\n#ifdef SAMD21\n#define OUTPUT_BITS 10\n#else\n#define OUTPUT_BITS 12\n#endif\n\n#include \"pinmap.h\"\n\n#undef min\n#undef max\n\ntypedef int PinName;\n\n#define PAGE_SIZE 512\n\n#define BOOTLOADER_START 0x0\n\n#ifdef SAMD21\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifdef SAMD51\n#define BOOTLOADER_END 0x4000\n#endif\n\n#define USB_HANDOVER 0\n\n// if we ever want to support 100+ pin packages, need to add PC,PD ports and increase this to 128\n#define DEV_NUM_PINS 64\n\n#define IS_ANALOG_PIN(id) 1\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER Timer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n#define CODAL_JACDAC_WIRE_SERIAL codal::ZSingleWireSerial\n#define CODAL_SERIAL codal::SAMDSerial\n#define CODAL_DAC SAMDDAC\n\n#ifdef SAMD21\n#define CODAL_NVMCONTROLLER codal::SAMDNVM\n#endif\n\n#define PXT_74HC165 1\n\n#define IMAGE_BITS 4\n\n// The parameters below needs tuning!\n\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n\n#endif",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n#include \"USBJACDAC.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nextern USBJACDAC jacdacDebug;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n\nvoid set_usb_strings(const char *uf2_info);\n\n} // namespace pxt\n\nnamespace pins {\nclass CodalSPIProxy;\nclass CodalI2CProxy;\n} // namespace pins\n\ntypedef pins::CodalI2CProxy* I2C_;\ntypedef pins::CodalSPIProxy* SPI_;\n\nnamespace pxt {\n#ifdef CODAL_I2C\nCODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl);\n#endif\nCODAL_SPI* getSPI(DigitalInOutPin mosi, DigitalInOutPin miso, DigitalInOutPin sck);\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer* getJACDACTimer();\n#endif\n}\n\nnamespace serial {\nclass CodalSerialDeviceProxy;\n}\n\ntypedef serial::CodalSerialDeviceProxy* SerialDevice;\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
            "pxt.json": "{\n  \"name\": \"core---samd\",\n  \"description\": \"The core library for Codal-based targets\",\n  \"files\": [\n    \"README.md\",\n    \"dal.d.ts\",\n    \"codal.cpp\",\n    \"usb.cpp\",\n    \"pxt.h\",\n    \"platform.h\",\n    \"platform.cpp\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"pins.cpp\",\n    \"pinsAnalog.cpp\",\n    \"pinsDigital.cpp\",\n    \"pinsPWM.cpp\",\n    \"pins.ts\",\n    \"pinscompat.ts\",\n    \"control.cpp\",\n    \"i2c.cpp\",\n    \"i2c.ts\",\n    \"spi.cpp\",\n    \"spi.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"hf2.cpp\",\n    \"hf2.h\",\n    \"hf2dbg.h\",\n    \"uf2format.h\",\n    \"uf2hid.h\",\n    \"ns.ts\",\n    \"dmac.cpp\",\n    \"dmac.h\",\n    \"timer.ts\",\n    \"light.cpp\",\n    \"light.h\",\n    \"keyvaluestorage.cpp\",\n    \"keyvaluestorage.ts\",\n    \"leveldetector.ts\",\n    \"pxtparts.json\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 1024\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\",\n      \"MS_\",\n      \"SCSI_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n#include \"CodalHeapAllocator.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#define GC_GET_HEAP_SIZE() device_heap_size(0)\n#define GC_STACK_BASE DEVICE_STACK_BASE\n#define xmalloc device_malloc\n#define xfree device_free\n\n#define GC_MAX_ALLOC_SIZE (16 * 1024)\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace pins {\n\n    /**\n     * Get a pin by configuration id (DAL.CFG_PIN...)\n     */\n    //% shim=pins::pinByCfg\n    function pinByCfg(key: int32): DigitalInOutPin;\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\n\n\ndeclare interface I2C {\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::readBuffer\n    readBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::writeBuffer\n    writeBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% help=pins/create-i2c\n    //% parts=i2c shim=pins::createI2C\n    function createI2C(sda: DigitalInOutPin, scl: DigitalInOutPin): I2C;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a SPI driver\n     */\n    //% help=pins/create-spi\n    //% parts=spi shim=pins::createSPI\n    function createSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin): SPI;\n}\n\n\ndeclare interface SPI {\n    /**\n     * Write to the SPI bus\n     */\n    //% shim=SPIMethods::write\n    write(value: int32): int32;\n\n    /**\n     * Transfer buffers over the SPI bus\n     */\n    //% argsNullable shim=SPIMethods::transfer\n    transfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI clock frequency\n     */\n    //% shim=SPIMethods::setFrequency\n    setFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI bus mode\n     */\n    //% shim=SPIMethods::setMode\n    setMode(mode: int32): void;\n}\ndeclare namespace light {\n\n    /**\n     * Send a programmable light buffer to the specified digital pin\n     * @param data The pin that the light are connected to\n     * @param clk the clock line if nay\n     * @param mode the color encoding mode\n     * @param buf The buffer to send to the pin\n     */\n    //% shim=light::sendBuffer\n    function sendBuffer(data: DigitalInOutPin, clk: DigitalInOutPin, mode: int32, buf: Buffer): void;\n}\ndeclare namespace configStorage {\n\n    /**\n     * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     * @param value the data (max 32 characters)\n     */\n    //% shim=configStorage::setBuffer\n    function setBuffer(key: string, value: Buffer): void;\n\n    /**\n     * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::getBuffer\n    function getBuffer(key: string): Buffer;\n\n    /**\n     * Removes the key from local storage\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::removeItem\n    function removeItem(key: string): void;\n\n    /**\n     * Clears the local storage\n     */\n    //% shim=configStorage::clear\n    function clear(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n\nclass CodalSPIProxy {\nprivate:\n    DevicePin* mosi; \n    DevicePin* miso; \n    DevicePin* sck;\n    CODAL_SPI spi;\npublic:\n    CodalSPIProxy* next;\n\npublic:\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck) \n        , next(NULL)\n    {\n    }\n\n    CODAL_SPI* getSPI() {\n        return &spi;\n    }\n\n    bool matchPins(DevicePin* mosi, DevicePin* miso, DevicePin* sck) {\n        return this->mosi == mosi && this->miso == miso && this->sck == sck;\n    }\n\n    int write(int value) {\n        return spi.write(value);\n    }\n\n    void transfer(Buffer command, Buffer response) {\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi.transfer(cdata, clength, rdata, rlength);\n    }\n\n    void setFrequency(int frequency) {\n        spi.setFrequency(frequency);\n    }\n\n    void setMode(int mode) {\n        spi.setMode(mode);\n    }\n};\n\nSPI_ spis(NULL);\n\n/**\n* Opens a SPI driver\n*/\n//% help=pins/create-spi\n//% parts=spi\nSPI_ createSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n  auto dev = spis;\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n\nCODAL_SPI* getSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n    auto spi = pins::createSPI(mosiPin, misoPin, sckPin);\n    return spi->getSPI();\n}\n\n}\n\nnamespace SPIMethods {\n\n/**\n* Write to the SPI bus\n*/\n//%\nint write(SPI_ device, int value) {\n    return device->write(value);\n}\n\n/**\n* Transfer buffers over the SPI bus\n*/\n//% argsNullable\nvoid transfer(SPI_ device, Buffer command, Buffer response) {\n    if (!device)\n        target_panic(PANIC_CAST_FROM_NULL);\n    if (!command && !response)\n        return;\n    device->transfer(command, response);\n}\n\n/**\n* Sets the SPI clock frequency\n*/\n//%\nvoid setFrequency(SPI_ device, int frequency) {\n    device->setFrequency(frequency);\n}\n\n/**\n* Sets the SPI bus mode\n*/\n//%\nvoid setMode(SPI_ device, int mode) {\n    device->setMode(mode);\n}\n\n}\n",
            "spi.ts": "namespace pins {\n\n    let _spi: SPI;\n    /**\n    * Gets the default SPI driver\n    */\n    //%\n    export function spi() {\n        if (!_spi) {\n            const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n            const miso = pins.pinByCfg(DAL.CFG_PIN_MISO);\n            const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n            _spi = pins.createSPI(mosi, miso, sck);\n        }\n        return _spi;\n    }\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    export function spiWrite(value: number) {\n        return spi().write(value);\n    }\n\n    /**\n     * Write a given command to SPI bus, and afterwards read the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    export function spiTransfer(command: Buffer, response: Buffer) {\n        spi().transfer(command, response);\n    }\n\n    /**\n     * Set the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    export function spiFrequency(frequency: number) {\n        spi().setFrequency(frequency);\n    }\n\n    /**\n     * Set the SPI signal mode\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    export function spiMode(mode: number) {\n        spi().setMode(mode);\n    }\n}",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n#ifndef BOOTLOADER_START\n#define BOOTLOADER_START 0x0\n#endif\n\n#ifndef BOOTLOADER_END\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifndef UF2_BINFO\n#define UF2_BINFO ((UF2_BInfo *)(BOOTLOADER_END - sizeof(UF2_BInfo)))\n#endif\n\n#ifndef UF2_INFO_TXT\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#endif\n\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return (BOOTLOADER_START + 0x100) <= (uint32_t)addr && (uint32_t)addr < (BOOTLOADER_END);\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_INFO_TXT))\n        return UF2_INFO_TXT;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
            "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n    uint32_t uf2_family;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
            "usb.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nnamespace pxt {\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\n#ifdef HF2_HID\nHF2 hf2hid(hf2buf);\n#endif\nDummyIface dummyIface;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nUSBJACDAC jacdacDebug;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,   // bLength\n    0x01,   // bDescriptorType\n    0x0210, // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40, // bMaxPacketSize0\n    USB_DEFAULT_VID, USB_DEFAULT_PID,\n    0x4202, // bcdDevice - leave unchanged for the HF2 to work\n    0x01,   // iManufacturer\n    0x02,   // iProduct\n    0x03,   // SerialNumber\n    0x01    // bNumConfigs\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid platform_usb_init() __attribute__((weak));\nvoid platform_usb_init() {}\n\nvoid set_usb_strings(const char *uf2_info) {\n    static const char *string_descriptors[3];\n    static char serial[12];\n    itoa(target_get_serial() & 0x7fffffff, serial);\n\n    auto model = strstr(uf2_info, \"Model: \");\n    if (model) {\n        model += 7;\n        auto end = model;\n        while (*end && *end != '\\n' && *end != '\\r')\n            end++;\n        auto len = end - model;\n        auto dev = (char *)app_alloc(len + 10);\n        memcpy(dev, model, len);\n        strcpy(dev + len, \" (app)\");\n        // try to split into manufacturer and\n        auto sep = strstr(dev, \" / \");\n        if (sep) {\n            *sep = '\\0';\n            string_descriptors[0] = dev;\n            string_descriptors[1] = sep + 3;\n        } else {\n            string_descriptors[0] = dev;\n            string_descriptors[1] = dev;\n        }\n    }\n\n    string_descriptors[2] = serial;\n    usb.stringDescriptors = string_descriptors;\n}\n\nvoid usb_init() {\n    usb.deviceDescriptor = &device_desc;\n    set_usb_strings(UF2_INFO_TXT);\n\n    platform_usb_init();\n\n#ifdef STM32F4\n    // let's not waste EPs on the HF2 - it will run on CONTROL pipe instead\n    // this doesn't seem to currently work on SAMD, so only do it on STM, which\n    // has very few EPs\n    hf2.allocateEP = false;\n#endif\n    usb.add(hf2);\n\n#ifdef HF2_HID\n    hf2hid.useHID = true;\n    usb.add(hf2hid);\n#else\n    // the WINUSB descriptors don't seem to work if there's only one interface\n    // so we add a dummy interface\n    usb.add(dummyIface);\n#endif\n\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n    usb.add(jacdacDebug);\n#endif\n\n    create_fiber(start_usb);\n}\n\n} // namespace pxt\n\n#else\nnamespace pxt {\nvoid usb_init() {}\n} // namespace pxt\n#endif\n\nnamespace control {\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    return pxt::usb.isInitialised();\n#else\n    return false;\n#endif\n}\n}\n\nnamespace pxt {\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n#if HF2_HID\n    hf2hid.sendSerial(data, len);\n#endif\n#endif\n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n} // namespace pxt\n"
        },
        "core---stm32": {
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile uintptr_t hp = (uintptr_t)p;\n        if (hp & 4) {\n            xfree(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            xfree(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        xfree(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n\n    auto led = LOOKUP_PIN(LED);\n    if (led) {\n        led->setDigitalValue(0);\n    }\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    while (curr) {\n        runAction1(curr->action, value);\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nuint64_t getLongSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\nuint64_t current_time_us() {\n    return system_timer_current_time_us();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    if (!currentFiber)\n        return NULL;\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n\nstatic void *threadAddressFor(codal::Fiber *fib, void *sp) {\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\nvoid gcProcessStacks(int flags) {\n    // check scheduler is initialized\n    if (!currentFiber) {\n        // make sure we allocate something to at least initalize the memory allocator\n        void * volatile p = xmalloc(1);\n        xfree(p);\n        return;\n    }\n\n    int numFibers = codal::list_fibers(NULL);\n    codal::Fiber **fibers = (codal::Fiber **)xmalloc(sizeof(codal::Fiber *) * numFibers);\n    int num2 = codal::list_fibers(fibers);\n    if (numFibers != num2)\n        oops(12);\n    int cnt = 0;\n\n    for (int i = 0; i < numFibers; ++i) {\n        auto fib = fibers[i];\n        auto ctx = (ThreadContext *)fib->user_data;\n        if (!ctx)\n            continue;\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(fib, seg->top);\n            auto end = (TValue *)threadAddressFor(fib, seg->bottom);\n            if (flags & 2)\n                DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n            // VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n    xfree(fibers);\n}\n#endif\n\n} // namespace pxt\n",
            "control.cpp": "#include \"pxt.h\"\n\n#ifdef NRF52 \n#define _estack __StackTop \n#endif\nextern uint32_t _estack;\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->getUTF8Data(), ptr);\n}\n\n//%\nuint32_t _ramSize()\n{\n    return (uint32_t)&_estack & 0x1fffffff;\n}\n\n}\n",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // /libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_VERSION = 5,\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_BUS_RISE = 16,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_EVT_RX_TIMEOUT = 4,\n    JD_SERIAL_EVT_BUS_CONNECTED = 5,\n    JD_SERIAL_EVT_BUS_DISCONNECTED = 6,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_SERIAL_MAX_BAUD = 1000000,\n    JD_SERIAL_TX_MAX_BACKOFF = 4000,\n    JD_SERIAL_TX_MIN_BACKOFF = 1000,\n    Receiving = 0,\n    Transmitting = 1,\n    High = 2,\n    Low = 3,\n    Baud1M = 1,\n    Baud500K = 2,\n    Baud250K = 4,\n    Baud125K = 8,\n    // /libraries/codal-core/inc/JACDAC/JDAccelerometerDriver.h\n    JD_ACCEL_EVT_SEND_DATA = 1,\n    // /libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // /libraries/codal-core/inc/JACDAC/JDClasses.h\n    STATIC_CLASS_START = 0,\n    STATIC_CLASS_END = 16777215,\n    DYNAMIC_CLASS_END = 4294967295,\n    JD_DRIVER_CLASS_CODAL_START = 0,\n    JD_DRIVER_CLASS_CODAL_END = 2000,\n    JD_DRIVER_CLASS_MAKECODE_START = 2000,\n    JD_DRIVER_CLASS_MAKECODE_END = 4000,\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_JOYSTICK = 1,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 2,\n    JD_DRIVER_CLASS_BRIDGE = 3,\n    JD_DRIVER_CLASS_BUTTON = 4,\n    JD_DRIVER_CLASS_PIN = 5,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 6,\n    JD_DRIVER_CLASS_ACCELEROMETER = 7,\n    JD_DRIVER_CLASS_CAPTOUCH_BUTTON = 8,\n    // /libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // /libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // /libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 65520,\n    JD_DRIVER_EVT_DISCONNECTED = 65521,\n    JD_DRIVER_EVT_PAIRED = 65522,\n    JD_DRIVER_EVT_UNPAIRED = 65523,\n    JD_DRIVER_EVT_PAIR_REJECTED = 65524,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 65525,\n    JD_DRIVER_EVT_ERROR = 65526,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_ERROR_MSK = 15,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    JD_LOGIC_DRIVER_EVT_CHANGED = 2,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    CONTROL_JD_TYPE_ERROR = 3,\n    CONTROL_JD_TYPE_PANIC = 255,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    CONTROL_PACKET_ERROR_NAME_LENGTH = 6,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    DRIVER_OK = 0,\n    DRIVER_CALIBRATION_IN_PROGRESS = 1,\n    DRIVER_CALIBRATION_REQUIRED = 2,\n    DRIVER_NO_RESOURCES = 3,\n    DRIVER_BUSY = 4,\n    DRIVER_COMMS_ERROR = 5,\n    DRIVER_INVALID_STATE = 6,\n    DRIVER_PERIPHERAL_MALFUNCTION = 7,\n    // /libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // /libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // /libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // /libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // /libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    DEVICE_HARDWARE_CONFIGURATION_ERROR = 90,\n    // /libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // /libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // /libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_EVT_2G = 12,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_2G_TOLERANCE = 2048,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // /libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // /libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // /libraries/codal-core/inc/driver-models/LowLevelTimer.h\n    TimerModeTimer = 0,\n    TimerModeCounter = 1,\n    TimerModeAlternateFunction = 2,\n    BitMode8 = 0,\n    BitMode16 = 1,\n    BitMode24 = 2,\n    BitMode32 = 3,\n    // /libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // /libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // /libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // /libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // /libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // /libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // /libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // /libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // /libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // /libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // /libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // /libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // /libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // /libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // /libraries/codal-core/inc/drivers/MMA8453.h\n    MMA8453_DEFAULT_ADDR = 56,\n    MMA8453_WHOAMI_VAL = 58,\n    // /libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // /libraries/codal-core/inc/drivers/MPU6050.h\n    MPU6050_DEFAULT_ADDR = 104,\n    MPU6050_WHOAMI = 117,\n    MPU6050_WHOAMI_VAL = 52,\n    // /libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // /libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // /libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // /libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // /libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // /libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // /libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // /libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // /libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // /libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // /libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // /libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // /pxtapp/configkeys.h\n    CFG_PIN_NAME_MSK = 65535,\n    CFG_PIN_CONFIG_MSK = 4294901760,\n    CFG_PIN_CONFIG_ACTIVE_LO = 65536,\n    CFG_MAGIC0 = 513675505,\n    CFG_MAGIC1 = 539130489,\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACK_TX = 60,\n    CFG_PIN_JACK_SENSE = 61,\n    CFG_PIN_JACK_HPEN = 62,\n    CFG_PIN_JACK_BZEN = 63,\n    CFG_PIN_JACK_PWREN = 64,\n    CFG_PIN_JACK_SND = 65,\n    CFG_PIN_JACK_BUSLED = 66,\n    CFG_PIN_JACK_COMMLED = 67,\n    CFG_PIN_BTN_SOFT_RESET = 69,\n    CFG_ACCELEROMETER_TYPE = 70,\n    CFG_PIN_BTNMX_LATCH = 71,\n    CFG_PIN_BTNMX_CLOCK = 72,\n    CFG_PIN_BTNMX_DATA = 73,\n    CFG_PIN_BTN_MENU2 = 74,\n    CFG_PIN_BATTSENSE = 75,\n    CFG_PIN_VIBRATION = 76,\n    CFG_PIN_PWREN = 77,\n    CFG_PIN_ROTARY_ENCODER_A = 79,\n    CFG_PIN_ROTARY_ENCODER_B = 80,\n    ACCELEROMETER_TYPE_LIS3DH = 50,\n    ACCELEROMETER_TYPE_MMA8453 = 56,\n    ACCELEROMETER_TYPE_FXOS8700 = 60,\n    ACCELEROMETER_TYPE_MMA8653 = 58,\n    ACCELEROMETER_TYPE_MSA300 = 76,\n    ACCELEROMETER_TYPE_MPU6050 = 104,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_A16 = 116,\n    CFG_PIN_A17 = 117,\n    CFG_PIN_A18 = 118,\n    CFG_PIN_A19 = 119,\n    CFG_PIN_A20 = 120,\n    CFG_PIN_A21 = 121,\n    CFG_PIN_A22 = 122,\n    CFG_PIN_A23 = 123,\n    CFG_PIN_A24 = 124,\n    CFG_PIN_A25 = 125,\n    CFG_PIN_A26 = 126,\n    CFG_PIN_A27 = 127,\n    CFG_PIN_A28 = 128,\n    CFG_PIN_A29 = 129,\n    CFG_PIN_A30 = 130,\n    CFG_PIN_A31 = 131,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_PIN_D16 = 166,\n    CFG_PIN_D17 = 167,\n    CFG_PIN_D18 = 168,\n    CFG_PIN_D19 = 169,\n    CFG_PIN_D20 = 170,\n    CFG_PIN_D21 = 171,\n    CFG_PIN_D22 = 172,\n    CFG_PIN_D23 = 173,\n    CFG_PIN_D24 = 174,\n    CFG_PIN_D25 = 175,\n    CFG_PIN_D26 = 176,\n    CFG_PIN_D27 = 177,\n    CFG_PIN_D28 = 178,\n    CFG_PIN_D29 = 179,\n    CFG_PIN_D30 = 180,\n    CFG_PIN_D31 = 181,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_SYSTEM_HEAP_BYTES = 206,\n    CFG_LOW_MEM_SIMULATION_KB = 207,\n    CFG_BOOTLOADER_BOARD_ID = 208,\n    CFG_UF2_FAMILY = 209,\n    CFG_PINS_PORT_SIZE = 210,\n    CFG_BOOTLOADER_PROTECTION = 211,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    CFG_ANALOG_BUTTON_THRESHOLD = 213,\n    CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS = 215,\n    CFG_PIN_B0 = 300,\n    CFG_PIN_B1 = 301,\n    CFG_PIN_B2 = 302,\n    CFG_PIN_B3 = 303,\n    CFG_PIN_B4 = 304,\n    CFG_PIN_B5 = 305,\n    CFG_PIN_B6 = 306,\n    CFG_PIN_B7 = 307,\n    CFG_PIN_B8 = 308,\n    CFG_PIN_B9 = 309,\n    CFG_PIN_B10 = 310,\n    CFG_PIN_B11 = 311,\n    CFG_PIN_B12 = 312,\n    CFG_PIN_B13 = 313,\n    CFG_PIN_B14 = 314,\n    CFG_PIN_B15 = 315,\n    CFG_PIN_B16 = 316,\n    CFG_PIN_B17 = 317,\n    CFG_PIN_B18 = 318,\n    CFG_PIN_B19 = 319,\n    CFG_PIN_B20 = 320,\n    CFG_PIN_B21 = 321,\n    CFG_PIN_B22 = 322,\n    CFG_PIN_B23 = 323,\n    CFG_PIN_B24 = 324,\n    CFG_PIN_B25 = 325,\n    CFG_PIN_B26 = 326,\n    CFG_PIN_B27 = 327,\n    CFG_PIN_B28 = 328,\n    CFG_PIN_B29 = 329,\n    CFG_PIN_B30 = 330,\n    CFG_PIN_B31 = 331,\n    CFG_PIN_C0 = 350,\n    CFG_PIN_C1 = 351,\n    CFG_PIN_C2 = 352,\n    CFG_PIN_C3 = 353,\n    CFG_PIN_C4 = 354,\n    CFG_PIN_C5 = 355,\n    CFG_PIN_C6 = 356,\n    CFG_PIN_C7 = 357,\n    CFG_PIN_C8 = 358,\n    CFG_PIN_C9 = 359,\n    CFG_PIN_C10 = 360,\n    CFG_PIN_C11 = 361,\n    CFG_PIN_C12 = 362,\n    CFG_PIN_C13 = 363,\n    CFG_PIN_C14 = 364,\n    CFG_PIN_C15 = 365,\n    CFG_PIN_C16 = 366,\n    CFG_PIN_C17 = 367,\n    CFG_PIN_C18 = 368,\n    CFG_PIN_C19 = 369,\n    CFG_PIN_C20 = 370,\n    CFG_PIN_C21 = 371,\n    CFG_PIN_C22 = 372,\n    CFG_PIN_C23 = 373,\n    CFG_PIN_C24 = 374,\n    CFG_PIN_C25 = 375,\n    CFG_PIN_C26 = 376,\n    CFG_PIN_C27 = 377,\n    CFG_PIN_C28 = 378,\n    CFG_PIN_C29 = 379,\n    CFG_PIN_C30 = 380,\n    CFG_PIN_C31 = 381,\n    CFG_PIN_P0 = 400,\n    CFG_PIN_P1 = 401,\n    CFG_PIN_P2 = 402,\n    CFG_PIN_P3 = 403,\n    CFG_PIN_P4 = 404,\n    CFG_PIN_P5 = 405,\n    CFG_PIN_P6 = 406,\n    CFG_PIN_P7 = 407,\n    CFG_PIN_P8 = 408,\n    CFG_PIN_P9 = 409,\n    CFG_PIN_P10 = 410,\n    CFG_PIN_P11 = 411,\n    CFG_PIN_P12 = 412,\n    CFG_PIN_P13 = 413,\n    CFG_PIN_P14 = 414,\n    CFG_PIN_P15 = 415,\n    CFG_PIN_P16 = 416,\n    CFG_PIN_P17 = 417,\n    CFG_PIN_P18 = 418,\n    CFG_PIN_P19 = 419,\n    CFG_PIN_P20 = 420,\n    CFG_PIN_LORA_MISO = 1001,\n    CFG_PIN_LORA_MOSI = 1002,\n    CFG_PIN_LORA_SCK = 1003,\n    CFG_PIN_LORA_CS = 1004,\n    CFG_PIN_LORA_BOOT = 1005,\n    CFG_PIN_LORA_RESET = 1006,\n    CFG_PIN_IRRXLED = 1007,\n    CFG_PIN_IRTXLED = 1008,\n    CFG_PIN_LCD_RESET = 1009,\n    CFG_PIN_LCD_ENABLE = 1010,\n    CFG_PIN_LCD_DATALINE4 = 1011,\n    CFG_PIN_LCD_DATALINE5 = 1012,\n    CFG_PIN_LCD_DATALINE6 = 1013,\n    CFG_PIN_LCD_DATALINE7 = 1014,\n    CFG_NUM_LCD_COLUMNS = 1015,\n    CFG_NUM_LCD_ROWS = 1016,\n    // /pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // /pxtapp/pins.h\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // /pxtapp/platform.h\n    SETTINGS_MAGIC_0 = 273114691,\n    SETTINGS_MAGIC_1 = 781864998,\n    BOOT_RTC_SIGNATURE = 1906448503,\n    APP_RTC_SIGNATURE = 614608146,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    PD_0 = 48,\n    PD_1 = 49,\n    PD_2 = 50,\n    PD_3 = 51,\n    PD_4 = 52,\n    PD_5 = 53,\n    PD_6 = 54,\n    PD_7 = 55,\n    PD_8 = 56,\n    PD_9 = 57,\n    PD_10 = 58,\n    PD_11 = 59,\n    PD_12 = 60,\n    PD_13 = 61,\n    PD_14 = 62,\n    PD_15 = 63,\n    // /pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // /pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // /pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    PXT_UF2_FAMILY = 1591873650,\n    // /pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
            "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
            "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nclass WDMAC {\n  public:\n    CODAL_DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "hf2.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#ifndef USB_HANDOVER\n#define USB_HANDOVER 1\n#endif\n\n#if USB_HANDOVER\n#define UF2_DEFINE_HANDOVER 1\n#endif\n\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\n#ifdef HF2_HID\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfoHID = {\n   &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n#endif\n\nstatic const InterfaceInfo ifaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\nstatic const InterfaceInfo ifaceInfoEP = {\n    NULL,\n    0,\n    2,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_BULK, 0},\n    {USB_EP_TYPE_BULK, 0},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n#ifdef HF2_HID\n    if (!useHID)\n        return DEVICE_NOT_SUPPORTED;\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n#endif\n    return DEVICE_NOT_SUPPORTED;\n}\n\n// same as in microbit\n#define CTRL_GET_REPORT 0x01\n#define CTRL_SET_REPORT 0x09\n#define CTRL_OUT_REPORT_H 0x2\n#define CTRL_IN_REPORT_H 0x1\n\nvoid HF2::prepBuffer(uint8_t *buf) {\n    memset(buf, 0, 64);\n    target_disable_irq();\n    if (dataToSendLength) {\n        if (dataToSendPrepend) {\n            dataToSendPrepend = false;\n            buf[0] = HF2_FLAG_CMDPKT_BODY | 4;\n            memcpy(buf + 1, pkt.buf, 4);\n        } else {\n            int flag = dataToSendFlag;\n            int s = 63;\n            if (dataToSendLength <= 63) {\n                s = dataToSendLength;\n            } else {\n                if (flag == HF2_FLAG_CMDPKT_LAST)\n                    flag = HF2_FLAG_CMDPKT_BODY;\n            }\n\n            buf[0] = flag | s;\n            memcpy(buf + 1, dataToSend, s);\n            dataToSend += s;\n            dataToSendLength -= s;\n        }\n    }\n    target_enable_irq();\n}\n\nvoid HF2::pokeSend() {\n    if (!allocateEP || !CodalUSB::usbInstance->isInitialised())\n        return;\n\n    uint8_t buf[64];\n    for (;;) {\n        prepBuffer(buf);\n        if (!buf[0])\n            break;\n        in->write(buf, sizeof(buf));\n    }\n}\n\nint HF2::classRequest(UsbEndpointIn &ctrl, USBSetup &setup) {\n    if (allocateEP)\n        return DEVICE_NOT_SUPPORTED;\n\n    if ((setup.bmRequestType & USB_REQ_DIRECTION) == USB_REQ_HOSTTODEVICE) {\n        if (setup.bRequest != CTRL_SET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_OUT_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength > 64)\n            return DEVICE_NOT_SUPPORTED;\n        ctrlWaiting = true;\n        CodalUSB::usbInstance->ctrlOut->startRead();\n        ctrl.wLength = 0; // pretend we're done\n    } else {\n        if (setup.bRequest != CTRL_GET_REPORT || setup.wValueL != 0 ||\n            setup.wValueH != CTRL_IN_REPORT_H)\n            return DEVICE_NOT_SUPPORTED;\n        if (setup.wLength != 64)\n            return DEVICE_NOT_SUPPORTED;\n\n        uint8_t buf[64];\n        prepBuffer(buf);\n        ctrl.write(buf, sizeof(buf));\n    }\n\n    return DEVICE_OK;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo() {\n#ifdef HF2_HID\n    if (useHID)\n        return &ifaceInfoHID;\n#endif\n    return allocateEP ? &ifaceInfoEP : &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError) {\n    if (!gotSomePacket)\n        return DEVICE_OK;\n\n    for (;;) {\n        pokeSend();\n\n        while (dataToSendLength) {\n            fiber_sleep(5);\n            pokeSend();\n        }\n\n        if (size < 0)\n            break;\n\n        target_disable_irq();\n        // there could be a race\n        if (!dataToSendLength) {\n            dataToSend = (const uint8_t *)data;\n            dataToSendPrepend = false;\n            dataToSendFlag = isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT;\n            dataToSendLength = size;\n            size = -1;\n        }\n        target_enable_irq();\n    }\n\n    return 0;\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len;\n\n    if (allocateEP)\n        len = out->read(buf, sizeof(buf));\n    else\n        len = CodalUSB::usbInstance->ctrlOut->read(buf, sizeof(buf));\n    // DMESG(\"HF2 read: %d\", len);\n\n    if (len <= 0)\n        return len;\n\n    if (!allocateEP)\n        CodalUSB::usbInstance->ctrlIn->write(\"\", 0);\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    dataToSend = pkt.buf;\n    dataToSendPrepend = false;\n    dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n    dataToSendLength = 4 + size;\n    pokeSend();\n    return 0;\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    if (dataToSendLength)\n        oops(90);\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        memcpy(pkt.resp.data8, data, size);\n        return sendResponse(size);\n    } else {\n        dataToSend = (const uint8_t *)data;\n        dataToSendPrepend = true;\n        dataToSendFlag = HF2_FLAG_CMDPKT_LAST;\n        dataToSendLength = size;\n        pokeSend();\n        return 0;\n    }\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#ifndef QUICK_BOOT\n#ifdef SAMD21\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#endif\n#ifdef SAMD51\n#define DBL_TAP_PTR ((volatile uint32_t *)(HSRAM_ADDR + HSRAM_SIZE - 4))\n#endif\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n#define QUICK_BOOT(v) *DBL_TAP_PTR = v ? DBL_TAP_MAGIC_QUICK_BOOT : 0\n#endif\n\nint HF2::endpointRequest() {\n    if (!allocateEP && !ctrlWaiting)\n        return 0;\n\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        resp->bininfo.uf2_family = PXT_UF2_FAMILY;\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        QUICK_BOOT(1);\n        NVIC_SystemReset();\n        break;\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        QUICK_BOOT(0);\n        NVIC_SystemReset();\n        break;\n\n#if USB_HANDOVER\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n#endif\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : gotSomePacket(false), ctrlWaiting(false), pkt(p), allocateEP(true), useHID(false) {}\n\n\nstatic const InterfaceInfo dummyIfaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        0xff,   // subclass\n        0xff,    // protocol\n        0x00, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\n\nconst InterfaceInfo *DummyIface::getInterfaceInfo() {\n    return &dummyIfaceInfo;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n\n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        xfree(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            xfree(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
            "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct {\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public CodalUSBInterface {\n    void prepBuffer(uint8_t *buf);\n    void pokeSend();\n\n    const uint8_t *dataToSend;\n    volatile uint32_t dataToSendLength;\n    bool dataToSendPrepend;\n    uint8_t dataToSendFlag;\n\n    bool gotSomePacket;\n    bool ctrlWaiting;\n\n  public:\n    HF2_Buffer &pkt;\n\n    bool allocateEP;\n    bool useHID;\n\n    int sendResponse(int size);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int classRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n\n    virtual bool enableWebUSB() { return !useHID; }\n};\n\nclass DummyIface : public CodalUSBInterface {\n  public:\n    virtual const InterfaceInfo *getInterfaceInfo();\n};\n\n#endif\n\n#endif\n",
            "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
            "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n#include \"CodalDmesg.h\"\n#include \"configkeys.h\"\n\n#ifdef CODAL_I2C\n\nnamespace pins {\n\nclass CodalI2CProxy {\nprivate:\n  DevicePin* sda;\n  DevicePin* scl;\n  CODAL_I2C i2c;\npublic:\n  CodalI2CProxy* next;\npublic:\n  CodalI2CProxy(DevicePin* _sda, DevicePin* _scl)\n    : sda(_sda)\n    , scl(_scl)\n    , i2c(*_sda, *_scl) \n    , next(NULL)\n  {\n\n  }\n\n  CODAL_I2C* getI2C() {\n    return &(this->i2c);\n  }\n  \n  bool matchPins(DevicePin* sda, DevicePin* scl) {\n      return this->sda == sda && this->scl == scl;\n  }\n\n  Buffer readBuffer(int address, int size, bool repeat = false)\n  {\n    Buffer buf = mkBuffer(NULL, size);\n    int status = this->i2c.read(address << 1, buf->data, size, repeat);\n    if (status != ErrorCode::DEVICE_OK) {\n      decrRC(buf);\n      buf = 0;\n    }\n    return buf;\n  }\n\n  int writeBuffer(int address, Buffer buf, bool repeat = false)\n  {\n    return this->i2c.write(address << 1, buf->data, buf->length, repeat);\n  }\n};\n\n}\n\nnamespace I2CMethods {\n/**\n  * Read `size` bytes from a 7-bit I2C `address`.\n  */\n//%\nBuffer readBuffer(I2C_ i2c, int address, int size, bool repeat = false)\n{\n  return i2c->readBuffer(address, size, repeat);\n}\n\n/**\n  * Write bytes to a 7-bit I2C `address`.\n  */\n//%\nint writeBuffer(I2C_ i2c, int address, Buffer buf, bool repeat = false)\n{\n  return i2c->writeBuffer(address, buf, repeat);\n}\n\n}\n\nnamespace pins {\n\nstatic I2C_ i2cs(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//% help=pins/create-i2c\n//% parts=i2c\nI2C_ createI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n  // pick up defaults\n  if (!sda || !scl) {\n    DMESG(\"i2c: lookup default pins\");\n    sda = LOOKUP_PIN(SDA);\n    scl = LOOKUP_PIN(SCL);\n  }\n\n  // lookup existing devices\n  auto dev = i2cs;\n  while(dev) {\n    if (dev->matchPins(sda, scl)) {\n      DMESG(\"i2c: found existing i2c\");\n      return dev;\n    }\n    dev = dev->next;\n  }\n\n  // allocate new one\n  DMESG(\"i2c: mounting on new device\");\n  auto ser = new CodalI2CProxy(sda, scl);\n  // push in list\n  ser->next = i2cs;\n  i2cs = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n  CODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n    auto i2c = pins::createI2C(sda, scl);\n    return i2c->getI2C();\n  }\n}\n\n#endif",
            "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        const buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        if (!buf)\n            return undefined\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format?: NumberFormat, repeated?: boolean): void {\n        if (format == undefined)\n            format = NumberFormat.UInt8LE;\n        const buf = control.createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    /**\n     * Write a value in a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param value value to write\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-write-register\n    //% blockId=i2c_writereg block=\"i2c write register|at address $address|at register $register|value $value\"\n    export function i2cWriteRegister(address: number, register: number, value: number, valueFormat?: NumberFormat): void {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        const valueSize = pins.sizeOf(valueFormat);\n        const buf = control.createBuffer(1 + valueSize);\n        buf.setNumber(NumberFormat.UInt8LE, 0, register);\n        buf.setNumber(valueFormat, 1, value);\n        pins.i2cWriteBuffer(address, buf);\n    }\n\n    /**\n     * Read the value from a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-read-register\n    //% blockId=i2c_readreg block=\"i2c read register|at address $address|at register $register\"\n    export function i2cReadRegister(address: number, register: number, valueFormat?: NumberFormat): number {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        pins.i2cWriteNumber(address, register, NumberFormat.UInt8LE);\n        return pins.i2cReadNumber(address, valueFormat);\n    }\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cReadBuffer(address: number, size: number, repeat: boolean = false): Buffer {\n        return pins.i2c().readBuffer(address, size, repeat);\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cWriteBuffer(address: number, buf: Buffer, repeat: boolean = false): number {\n        return pins.i2c().writeBuffer(address, buf, repeat);\n    }\n\n    let _i2c: I2C;\n    /**\n     * Gets the default I2C bus\n     */\n    //%\n    export function i2c() {\n        if (!_i2c) {\n            const sda = pins.pinByCfg(DAL.CFG_PIN_SDA);\n            const scl = pins.pinByCfg(DAL.CFG_PIN_SCL);\n            _i2c = pins.createI2C(sda, scl);    \n        }\n        return _i2c;        \n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}\n",
            "keyvaluestorage.cpp": "#include \"pxt.h\"\n#include \"KeyValueStorage.h\"\n\nnamespace pxt {\n\nclass WKeyValueStorage {\n#ifdef CODAL_NVMCONTROLLER\n    CODAL_NVMCONTROLLER controller;\n#else\n    NVMController controller;\n#endif\n    KeyValueStorage storage;\n  public:\n\n    WKeyValueStorage()\n    : controller()\n    , storage(controller) {\n    }\n\n    bool isSupported() {\n#ifdef CODAL_NVMCONTROLLER\n      return true;\n#else\n      return false;\n#endif\n    }\n\n    int put(String key, Buffer data) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        return storage.put(mkey, data->data, data->length);\n#else\n        return -1;\n#endif\n    }\n\n    Buffer get(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        Buffer buf = NULL;\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        auto entry = storage.get(mkey);\n        if (entry) {\n          buf = mkBuffer(entry->value, sizeof(entry->value));\n          free(entry);\n        }\n        return buf;\n#else\n        return NULL;\n#endif\n    }\n\n    void remove(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        storage.remove(mkey);\n#endif\n    }\n\n    void clear() {\n#ifdef CODAL_NVMCONTROLLER\n        storage.wipe();\n#endif\n    }\n};\nSINGLETON(WKeyValueStorage);\n\n}\n\nnamespace configStorage {\n  /**\n  * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  * @param value the data (max 32 characters)\n  */\n  //%\n  void setBuffer(String key, Buffer value) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->put(key, value);\n  }\n\n  /**\n  * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  Buffer getBuffer(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    return kvm->get(key);\n  }\n\n  /**\n  * Removes the key from local storage\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  void removeItem(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->remove(key);\n  }\n\n  /**\n  * Clears the local storage\n  */\n  //%\n  void clear() {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->clear();\n  }\n}\n",
            "keyvaluestorage.ts": "namespace configStorage {\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     * @param value identifier of the value (max 32 characters)\n     */\n    export function setItem(key: string, value: string) {\n        if (value == null)\n            configStorage.removeItem(key);\n        else\n        {\n            let idx = 0;\n            let buf = control.createBuffer(value.length + 1);\n            buf[idx++] = value.length;\n            let valBuf = control.createBufferFromUTF8(value);\n\n            for (let i = 0; i < valBuf.length; i++)\n                buf[idx++] = valBuf[i];\n\n            configStorage.setBuffer(key, buf);\n        }\n    }\n\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     */\n    export function getItem(key: string): string {\n        const buf = configStorage.getBuffer(key);\n\n        if (!buf)\n            return undefined;\n\n        let idx = 0;\n        let count = buf[idx++];\n        const retBuf = control.createBuffer(count);\n\n        for (let i = 0; i < count; i++)\n            retBuf[i] = buf[idx++];\n\n        return retBuf.toString();\n    }\n}\n",
            "leveldetector.ts": "namespace pins {\n    export class LevelDetector {\n        public id: number;\n        public min: number;\n        public max: number;\n        public lowThreshold: number;\n        public highThreshold: number;\n        private transition: number;\n        private _level: number;\n        private _state: number;\n        public onHigh: () => void;\n        public onLow: () => void;\n        public transitionWindow: number;\n\n        constructor(id: number,\n            min: number, max: number,\n            lowThreshold: number, highThreshold: number) {\n            this.id = id;\n            this.min = min;\n            this.max = max;\n            this.lowThreshold = lowThreshold;\n            this.highThreshold = highThreshold;\n            this._level = Math.ceil((max - min) / 2);\n            this._state = 0;\n            this.transitionWindow = 4;\n            this.transition = 0;\n\n            this.onHigh = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_HIGH);\n            this.onLow = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_LOW);\n        }\n\n        get level(): number {\n            return this._level;\n        }\n\n        set level(level: number) {\n            control.dmesg(\"LEVEL: \");\n            control.dmesg(level.toString());\n\n            this._level = this.clampValue(level);\n\n            if (this._level >= this.highThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_HIGH);\n            }\n            else if (this._level <= this.lowThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_LOW);\n            }\n            else {\n                this.setState(0);\n            }\n        }\n\n        public setLowThreshold(value: number) {\n            this.lowThreshold = this.clampValue(value);\n            this.highThreshold = Math.max(this.lowThreshold + 1, this.highThreshold);\n        }\n\n        public setHighThreshold(value: number) {\n            this.highThreshold = this.clampValue(value);\n            this.lowThreshold = Math.min(this.highThreshold - 1, this.lowThreshold);\n        }\n\n        private clampValue(value: number) {\n            if (value < this.min) {\n                return this.min;\n            }\n            else if (value > this.max) {\n                return this.max;\n            }\n            return value;\n        }\n\n        private setState(state: number) {\n                                        // not enough samples to change\n            if (this._state === state || this.transition++ < this.transitionWindow) {\n                return;\n            }\n\n            this.transition = 0;\n            this._state = state;\n            switch (state) {\n                case DAL.LEVEL_THRESHOLD_HIGH:\n                    if (this.onHigh) this.onHigh();\n                    break;\n                case DAL.LEVEL_THRESHOLD_LOW:\n                    if (this.onLow) this.onLow();\n                    break;\n            }\n        }\n    }\n}",
            "light.cpp": "#include \"light.h\"\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n#include \"neopixel.h\"\n#endif\n\n#define NEOPIXEL_MIN_LENGTH_FOR_SPI 24\n#define DOTSTAR_MIN_LENGTH_FOR_SPI 24\n\n#define LIGHTMODE_RGB 1\n#define LIGHTMODE_RGBW 2\n#define LIGHTMODE_RGB_RGB 3\n#define LIGHTMODE_DOTSTAR 4\n\nnamespace light {\nbool isValidMOSIPin(DigitalInOutPin pin) {\n    if (!pin)\n        return false;\n\n#if SAMD51\n    return ZSPI::isValidMOSIPin(*pin);\n#else\n    // TODO: support for SPI neopixels\n    // default SPI pins supported for now\n    return pin == LOOKUP_PIN(MOSI);\n#endif\n\n}\n\n// SPI\nvoid spiNeopixelSendBuffer(DevicePin* pin, const uint8_t *data, unsigned size) {\n    int32_t iptr = 0, optr = 100;\n    uint32_t len = optr + size * 3 + optr;\n    uint8_t *expBuf = new uint8_t[len];\n    memset(expBuf, 0, len);\n    uint8_t imask = 0x80;\n    uint8_t omask = 0x80;\n\n#define WR(k)                                                                                      \\\n    if (k)                                                                                         \\\n        expBuf[optr] |= omask;                                                                     \\\n    omask >>= 1;                                                                                   \\\n    if (!omask) {                                                                                  \\\n        omask = 0x80;                                                                              \\\n        optr++;                                                                                    \\\n    }\n\n    while (iptr < (int)size) {\n        WR(1);\n        WR(data[iptr] & imask);\n        imask >>= 1;\n        if (!imask) {\n            imask = 0x80;\n            iptr++;\n        }\n        WR(0);\n    }\n\n    auto spi = pxt::getSPI(pin, NULL, NULL);\n    spi->setFrequency(2400000);\n    spi->transfer(expBuf, len, NULL, 0);\n    delete expBuf;\n}\n\nvoid neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length) {\n    if (!pin || !length) return;\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4)\n    if (length > NEOPIXEL_MIN_LENGTH_FOR_SPI && isValidMOSIPin(pin))\n        spiNeopixelSendBuffer(pin, data, length);\n    else\n        neopixel_send_buffer(*pin, data, length);\n #else\n     if (isValidMOSIPin(pin)) {\n         spiNeopixelSendBuffer(pin, data, length);\n     }\n #endif\n}\n\nvoid bitBangDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    // first frame of zeroes\n    data->setDigitalValue(0);\n    for (unsigned i = 0; i < 32; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n\n    // data stream\n    for (unsigned i = 0; i < length; ++i) {\n        auto x = buf[i];\n        for (uint8_t j = 0x80; j != 0; j >>= 1) {\n            data->setDigitalValue(x & j ? 1 : 0);\n            clk->setDigitalValue(1);\n            clk->setDigitalValue(0);\n        }\n    }\n    // https://cpldcpu.wordpress.com/2016/12/13/sk9822-a-clone-of-the-apa102/\n    // reset frame\n    //data->setDigitalValue(0);\n    //for (unsigned i = 0; i < 32 ; ++i) {\n    //    clk->setDigitalValue(1);\n    //    clk->setDigitalValue(0);\n    //}\n\n    // https://cpldcpu.wordpress.com/2014/11/30/understanding-the-apa102-superled/\n    data->setDigitalValue(1);\n    unsigned n = 32;\n    for (unsigned i = 0; i < n; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n}\n\nstatic uint8_t ZERO_FRAME[4];\nstatic uint8_t ONE_FRAME[] = {1,1,1,1};\nvoid spiDotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    auto spi = pxt::getSPI(data, NULL, clk);\n\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // initial frame\n    spi->transfer(buf, length, NULL, 0);\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // reset frame\n    for(unsigned i = 0; i < length >> 3; i += 32)\n        spi->transfer(ONE_FRAME, sizeof(ONE_FRAME), NULL, 0); // final frame\n}\n\nvoid dotStarSendData(DevicePin* data, DevicePin* clk, int mode, const uint8_t* buf, unsigned length) {\n    if (!data || !clk || !buf || !length) return;\n\n    if (length > DOTSTAR_MIN_LENGTH_FOR_SPI && isValidMOSIPin(data))\n        spiDotStarSendData(data, clk, mode, buf, length);\n    else\n        bitBangDotStarSendData(data, clk, mode, buf, length);\n}\n\nvoid sendBuffer(DevicePin* data, DevicePin* clk, int mode, Buffer buf) {\n    if (!data || !buf || !buf->length) return;\n\n    if (mode == LIGHTMODE_DOTSTAR)\n        light::dotStarSendData(data, clk, mode, buf->data, buf->length);\n    else\n        light::neopixelSendData(data, mode, buf->data, buf->length);\n}\n\n\nvoid clear() {\n    auto neopix = LOOKUP_PIN(NEOPIXEL);\n    auto neonum = getConfig(CFG_NUM_NEOPIXELS, 0);\n    if (neopix && neonum >= 0) {\n        auto n = 3 * neonum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        light::neopixelSendData(neopix, 0x100, off, sizeof(off));\n    }\n\n    auto data = LOOKUP_PIN(DOTSTAR_DATA);\n    auto clk = LOOKUP_PIN(DOTSTAR_CLOCK);\n    auto dsnum = getConfig(CFG_NUM_DOTSTARS, 0);\n    if (data && clk && dsnum > 0) {\n        auto n = 4 * dsnum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        for(int i = 0; i < n; i += 4)\n            off[i] = 0xe0;\n        bitBangDotStarSendData(data, clk, 0x100, off, sizeof(off));\n    }\n}\n\n} // namespace pxt\n",
            "light.h": "#ifndef __PXT_LIGHT_H\n#define __PXT_LIGHT_H\n\n#include \"pxt.h\"\n\nnamespace light {\n    /**\n    * Clear onboard neopixels\n    */\n    void clear();\n\n    /**\n    * Send a programmable light buffer to the specified digital pin\n    * @param data The pin that the light are connected to\n    * @param clk the clock line if nay\n    * @param mode the color encoding mode\n    * @param buf The buffer to send to the pin\n    */\n    //%\n    void sendBuffer(DigitalInOutPin data, DigitalInOutPin clk, int mode, Buffer buf);\n\n    void neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length);\n}\n\n#endif",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n\n    id &= CFG_PIN_NAME_MSK;\n\n    if (id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0 || pinName == 0xff)\n        return NULL;\n    pinName &= CFG_PIN_NAME_MSK;\n    return getPin(pinName);\n}\n\n//%\nDevicePin *lookupPinCfg(int key) {\n    return lookupPin(getConfig(key));\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n* Get a pin by configuration id (DAL.CFG_PIN...)\n*/\n//%\nDigitalInOutPin pinByCfg(int key) {\n    return pxt::lookupPinCfg(key);\n}\n\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n}",
            "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
            "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
            "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
            "pinscompat.ts": "// filled in by microbit",
            "platform.cpp": "#include \"pxt.h\"\n#include \"STMLowLevelTimer.h\"\n#include \"Accelerometer.h\"\n#include \"light.h\"\n\nnamespace pxt {\n\n#ifdef STM32F1\nSTMLowLevelTimer lowTimer(TIM4, TIM4_IRQn);\n#else\nSTMLowLevelTimer lowTimer(TIM5, TIM5_IRQn);\n#endif\nSTMLowLevelTimer jacdacTimer(TIM2, TIM2_IRQn);\nLowLevelTimer* getJACDACTimer()\n{\n    return &jacdacTimer;\n}\nCODAL_TIMER devTimer(lowTimer);\n\nvoid initAccelRandom();\n#ifdef STM32F4\nextern \"C\" void apply_clock_init(RCC_OscInitTypeDef *oscInit, RCC_ClkInitTypeDef *clkConfig,\n                                 uint32_t flashLatency) {\n\n    int mhz = getConfig(CFG_CPU_MHZ, 84);\n\n    if (mhz >= 216) {\n        oscInit->PLL.PLLN = 432;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV2;\n        oscInit->PLL.PLLQ = 9;\n        flashLatency = FLASH_LATENCY_6;\n    } else if (mhz >= 192) {\n        oscInit->PLL.PLLN = 384;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV2;\n        oscInit->PLL.PLLQ = 8;\n        flashLatency = FLASH_LATENCY_6;\n    } else if (mhz >= 168) {\n        oscInit->PLL.PLLN = 336;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV2;\n        oscInit->PLL.PLLQ = 7;\n        flashLatency = FLASH_LATENCY_5;\n    } else if (mhz >= 144) {\n        oscInit->PLL.PLLN = 288;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV2;\n        oscInit->PLL.PLLQ = 6;\n        flashLatency = FLASH_LATENCY_5;\n    } else if (mhz >= 108) {\n        oscInit->PLL.PLLN = 432;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV4;\n        oscInit->PLL.PLLQ = 9;\n        flashLatency = FLASH_LATENCY_4;\n    } else if (mhz >= 96) {\n        oscInit->PLL.PLLN = 384;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV4;\n        oscInit->PLL.PLLQ = 8;\n        flashLatency = FLASH_LATENCY_3;\n    } else if (mhz >= 84) {\n        // this is the default from codal\n        oscInit->PLL.PLLN = 336;\n        oscInit->PLL.PLLP = RCC_PLLP_DIV4;\n        oscInit->PLL.PLLQ = 7;\n        flashLatency = FLASH_LATENCY_2;\n    } else {\n        target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n    }\n\n    DMESG(\"CPU clock: %dMHz -> %dMHz\", mhz,\n          oscInit->PLL.PLLN / (oscInit->PLL.PLLP == RCC_PLLP_DIV4 ? 4 : 2));\n\n    if (mhz > 108) {\n        clkConfig->APB1CLKDivider = RCC_HCLK_DIV4;\n        clkConfig->APB2CLKDivider = RCC_HCLK_DIV2;\n    } else {\n        clkConfig->APB1CLKDivider = RCC_HCLK_DIV2;\n        clkConfig->APB2CLKDivider = RCC_HCLK_DIV1;\n    }\n\n    HAL_RCC_OscConfig(oscInit);\n    HAL_RCC_ClockConfig(clkConfig, flashLatency);\n}\n#endif\n\n// Disable seeding random from accelerometer. We now store random\n// seed in internal flash, so it's different on every reset, and\n// accelerometer sometimes have bugs, so better not enable them unless\n// requested.\nstatic void initRandomSeed() {\n#if 0\n    if (getConfig(CFG_ACCELEROMETER_TYPE, -1) != -1) {\n        initAccelRandom();\n    }\n#endif\n}\n\nstatic void set_if_present(int cfg, int val) {\n    auto snd = pxt::lookupPinCfg(cfg);\n    if (snd)\n        snd->setDigitalValue(val);\n}\n\n//%\nvoid deepSleep() {\n    // this in particular puts accelerometer to sleep, which the bootloader\n    // doesn't do\n    CodalComponent::setAllSleep(true);\n\n#ifdef STM32F4\n    // ask bootloader to do the deep sleeping\n    QUICK_BOOT(1);\n    RTC->BKP1R = 0x10b37889;\n    NVIC_SystemReset();\n#endif\n}\n\nvoid platformSendSerial(const char *data, int len) {\n    /*\n    if (!serial) {\n        serial = new codal::_mbed::Serial(USBTX, NC);\n        serial->baud(9600);\n    }\n    serial->send((uint8_t*)data, len);\n    */\n}\n\nvoid platform_init() {\n    initRandomSeed();\n    setSendToUART(platformSendSerial);\n    light::clear();\n\n    // make sure sound doesn't draw power before enabled\n    set_if_present(CFG_PIN_JACK_SND, 0);\n    set_if_present(CFG_PIN_JACK_HPEN, 0);\n    set_if_present(CFG_PIN_JACK_BZEN, 1);\n\n    /*\n        if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n            *HF2_DBG_MAGIC_PTR = 0;\n            // this will cause alignment fault at the first breakpoint\n            globals[0] = (TValue)1;\n        }\n    */\n}\n\nint *getBootloaderConfigData() {\n#ifdef STM32F4\n    auto config_data = (uint32_t)(UF2_BINFO->configValues);\n    if (config_data && (config_data & 3) == 0) {\n        auto p = (uint32_t *)config_data - 4;\n        if (p[0] == CFG_MAGIC0 && p[1] == CFG_MAGIC1)\n            return (int *)p + 4;\n    }\n#endif\n\n    return NULL;\n}\n\n#define STM32_UUID ((uint32_t *)0x1FFF7A10)\n\nstatic void writeHex(char *buf, uint32_t n) {\n    int i = 0;\n    int sh = 28;\n    while (sh >= 0) {\n        int d = (n >> sh) & 0xf;\n        buf[i++] = d > 9 ? 'A' + d - 10 : '0' + d;\n        sh -= 4;\n    }\n    buf[i] = 0;\n}\n\nvoid platform_usb_init() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    static char serial_number[25];\n\n    writeHex(serial_number, STM32_UUID[0]);\n    writeHex(serial_number + 8, STM32_UUID[1]);\n    writeHex(serial_number + 16, STM32_UUID[2]);\n\n    usb.stringDescriptors[2] = serial_number;\n#endif\n}\n\n} // namespace pxt\n\nvoid cpu_clock_init() {}\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#include \"Image.h\"\n#include \"MultiButton.h\"\n#include \"ZPin.h\"\n#include \"Timer.h\"\n#include \"ZSPI.h\"\n#include \"ZI2C.h\"\n#include \"ZSingleWireSerial.h\"\n\n#include \"pinmap.h\"\n\n#define BOOTLOADER_START 0x08000000\n#define BOOTLOADER_END 0x08008000\n\n#ifdef STM32F4\n#define SETTINGS_MAGIC_0 0x10476643\n#define SETTINGS_MAGIC_1 0x2e9a5026\n\nstruct F4_Settings {\n    uint32_t magic0;\n    uint32_t magic1;\n    int *configValues;\n    uint32_t hseValue;\n    const char *info_uf2;\n    const char *manufacturer;\n    const char *device;\n    uint32_t reserved[16 - 7];\n};\n\n#define UF2_BINFO ((F4_Settings *)(BOOTLOADER_END - sizeof(F4_Settings)))\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#define USB_HANDOVER 0\n\n#define BOOT_RTC_SIGNATURE 0x71a21877\n#define APP_RTC_SIGNATURE 0x24a22d12\n#define HF2_RTC_SIGNATURE 0x39a63a78\n#define QUICK_BOOT(v)                                                                              \\\n    do {                                                                                           \\\n        RTC->BKP0R = v ? APP_RTC_SIGNATURE : HF2_RTC_SIGNATURE;                                    \\\n    } while (0)\n#else\n#define QUICK_BOOT(v) ((void)0)\n#endif\n\n#define PAGE_SIZE 1024 // not really\n\n#define DEV_NUM_PINS 64\n\n#ifdef STM32F1\n#define DEV_PWM_PINS 0b111100000011101100001110111000111111001110LL\n#else\n#define DEV_PWM_PINS 0b111100000011100111111110111000111111101111LL\n#endif\n\n//               CCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA\n//               fedcba9876543210fedcba9876543210fedcba9876543210\n#define DEV_AIN_PINS 0b000011111100000000000000110000000011111111LL\n\n// Codal doesn't yet distinguish between PWM and AIN\n#define DEV_ANALOG_PINS (DEV_PWM_PINS | DEV_AIN_PINS)\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER Timer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n#define CODAL_JACDAC_WIRE_SERIAL codal::ZSingleWireSerial\n\n#define PERF_NOW() (TIM5->CNT)\n\n#define IMAGE_BITS 4\n\n\n// The parameters below needs tuning!\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA_0 0x00\n#define PA_1 0x01\n#define PA_2 0x02\n#define PA_3 0x03\n#define PA_4 0x04\n#define PA_5 0x05\n#define PA_6 0x06\n#define PA_7 0x07\n#define PA_8 0x08\n#define PA_9 0x09\n#define PA_10 0x0A\n#define PA_11 0x0B\n#define PA_12 0x0C\n#define PA_13 0x0D\n#define PA_14 0x0E\n#define PA_15 0x0F\n\n#define PB_0 0x10\n#define PB_1 0x11\n#define PB_2 0x12\n#define PB_3 0x13\n#define PB_4 0x14\n#define PB_5 0x15\n#define PB_6 0x16\n#define PB_7 0x17\n#define PB_8 0x18\n#define PB_9 0x19\n#define PB_10 0x1A\n#define PB_11 0x1B\n#define PB_12 0x1C\n#define PB_13 0x1D\n#define PB_14 0x1E\n#define PB_15 0x1F\n\n#define PC_0 0x20\n#define PC_1 0x21\n#define PC_2 0x22\n#define PC_3 0x23\n#define PC_4 0x24\n#define PC_5 0x25\n#define PC_6 0x26\n#define PC_7 0x27\n#define PC_8 0x28\n#define PC_9 0x29\n#define PC_10 0x2A\n#define PC_11 0x2B\n#define PC_12 0x2C\n#define PC_13 0x2D\n#define PC_14 0x2E\n#define PC_15 0x2F\n\n#define PD_0 0x30\n#define PD_1 0x31\n#define PD_2 0x32\n#define PD_3 0x33\n#define PD_4 0x34\n#define PD_5 0x35\n#define PD_6 0x36\n#define PD_7 0x37\n#define PD_8 0x38\n#define PD_9 0x39\n#define PD_10 0x3A\n#define PD_11 0x3B\n#define PD_12 0x3C\n#define PD_13 0x3D\n#define PD_14 0x3E\n#define PD_15 0x3F\n#endif\n\n#endif",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n#include \"USBJACDAC.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nextern USBJACDAC jacdacDebug;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n\nvoid set_usb_strings(const char *uf2_info);\n\n} // namespace pxt\n\nnamespace pins {\nclass CodalSPIProxy;\nclass CodalI2CProxy;\n} // namespace pins\n\ntypedef pins::CodalI2CProxy* I2C_;\ntypedef pins::CodalSPIProxy* SPI_;\n\nnamespace pxt {\n#ifdef CODAL_I2C\nCODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl);\n#endif\nCODAL_SPI* getSPI(DigitalInOutPin mosi, DigitalInOutPin miso, DigitalInOutPin sck);\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer* getJACDACTimer();\n#endif\n}\n\nnamespace serial {\nclass CodalSerialDeviceProxy;\n}\n\ntypedef serial::CodalSerialDeviceProxy* SerialDevice;\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
            "pxt.json": "{\n  \"name\": \"core---stm32\",\n  \"description\": \"The core library for Codal-based targets\",\n  \"files\": [\n    \"README.md\",\n    \"dal.d.ts\",\n    \"codal.cpp\",\n    \"usb.cpp\",\n    \"pxt.h\",\n    \"platform.h\",\n    \"platform.cpp\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"pins.cpp\",\n    \"pinsAnalog.cpp\",\n    \"pinsDigital.cpp\",\n    \"pinsPWM.cpp\",\n    \"pins.ts\",\n    \"pinscompat.ts\",\n    \"control.cpp\",\n    \"i2c.cpp\",\n    \"i2c.ts\",\n    \"spi.cpp\",\n    \"spi.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"hf2.cpp\",\n    \"hf2.h\",\n    \"hf2dbg.h\",\n    \"uf2format.h\",\n    \"uf2hid.h\",\n    \"ns.ts\",\n    \"dmac.cpp\",\n    \"dmac.h\",\n    \"timer.ts\",\n    \"light.cpp\",\n    \"light.h\",\n    \"keyvaluestorage.cpp\",\n    \"keyvaluestorage.ts\",\n    \"leveldetector.ts\",\n    \"pxtparts.json\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 1024\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\",\n      \"MS_\",\n      \"SCSI_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n#include \"CodalHeapAllocator.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#define GC_GET_HEAP_SIZE() device_heap_size(0)\n#define GC_STACK_BASE DEVICE_STACK_BASE\n#define xmalloc device_malloc\n#define xfree device_free\n\n#define GC_MAX_ALLOC_SIZE (16 * 1024)\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace pins {\n\n    /**\n     * Get a pin by configuration id (DAL.CFG_PIN...)\n     */\n    //% shim=pins::pinByCfg\n    function pinByCfg(key: int32): DigitalInOutPin;\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\n\n\ndeclare interface I2C {\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::readBuffer\n    readBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::writeBuffer\n    writeBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% help=pins/create-i2c\n    //% parts=i2c shim=pins::createI2C\n    function createI2C(sda: DigitalInOutPin, scl: DigitalInOutPin): I2C;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a SPI driver\n     */\n    //% help=pins/create-spi\n    //% parts=spi shim=pins::createSPI\n    function createSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin): SPI;\n}\n\n\ndeclare interface SPI {\n    /**\n     * Write to the SPI bus\n     */\n    //% shim=SPIMethods::write\n    write(value: int32): int32;\n\n    /**\n     * Transfer buffers over the SPI bus\n     */\n    //% argsNullable shim=SPIMethods::transfer\n    transfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI clock frequency\n     */\n    //% shim=SPIMethods::setFrequency\n    setFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI bus mode\n     */\n    //% shim=SPIMethods::setMode\n    setMode(mode: int32): void;\n}\ndeclare namespace light {\n\n    /**\n     * Send a programmable light buffer to the specified digital pin\n     * @param data The pin that the light are connected to\n     * @param clk the clock line if nay\n     * @param mode the color encoding mode\n     * @param buf The buffer to send to the pin\n     */\n    //% shim=light::sendBuffer\n    function sendBuffer(data: DigitalInOutPin, clk: DigitalInOutPin, mode: int32, buf: Buffer): void;\n}\ndeclare namespace configStorage {\n\n    /**\n     * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     * @param value the data (max 32 characters)\n     */\n    //% shim=configStorage::setBuffer\n    function setBuffer(key: string, value: Buffer): void;\n\n    /**\n     * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::getBuffer\n    function getBuffer(key: string): Buffer;\n\n    /**\n     * Removes the key from local storage\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::removeItem\n    function removeItem(key: string): void;\n\n    /**\n     * Clears the local storage\n     */\n    //% shim=configStorage::clear\n    function clear(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n\nclass CodalSPIProxy {\nprivate:\n    DevicePin* mosi; \n    DevicePin* miso; \n    DevicePin* sck;\n    CODAL_SPI spi;\npublic:\n    CodalSPIProxy* next;\n\npublic:\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck) \n        , next(NULL)\n    {\n    }\n\n    CODAL_SPI* getSPI() {\n        return &spi;\n    }\n\n    bool matchPins(DevicePin* mosi, DevicePin* miso, DevicePin* sck) {\n        return this->mosi == mosi && this->miso == miso && this->sck == sck;\n    }\n\n    int write(int value) {\n        return spi.write(value);\n    }\n\n    void transfer(Buffer command, Buffer response) {\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi.transfer(cdata, clength, rdata, rlength);\n    }\n\n    void setFrequency(int frequency) {\n        spi.setFrequency(frequency);\n    }\n\n    void setMode(int mode) {\n        spi.setMode(mode);\n    }\n};\n\nSPI_ spis(NULL);\n\n/**\n* Opens a SPI driver\n*/\n//% help=pins/create-spi\n//% parts=spi\nSPI_ createSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n  auto dev = spis;\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n\nCODAL_SPI* getSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n    auto spi = pins::createSPI(mosiPin, misoPin, sckPin);\n    return spi->getSPI();\n}\n\n}\n\nnamespace SPIMethods {\n\n/**\n* Write to the SPI bus\n*/\n//%\nint write(SPI_ device, int value) {\n    return device->write(value);\n}\n\n/**\n* Transfer buffers over the SPI bus\n*/\n//% argsNullable\nvoid transfer(SPI_ device, Buffer command, Buffer response) {\n    if (!device)\n        target_panic(PANIC_CAST_FROM_NULL);\n    if (!command && !response)\n        return;\n    device->transfer(command, response);\n}\n\n/**\n* Sets the SPI clock frequency\n*/\n//%\nvoid setFrequency(SPI_ device, int frequency) {\n    device->setFrequency(frequency);\n}\n\n/**\n* Sets the SPI bus mode\n*/\n//%\nvoid setMode(SPI_ device, int mode) {\n    device->setMode(mode);\n}\n\n}\n",
            "spi.ts": "namespace pins {\n\n    let _spi: SPI;\n    /**\n    * Gets the default SPI driver\n    */\n    //%\n    export function spi() {\n        if (!_spi) {\n            const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n            const miso = pins.pinByCfg(DAL.CFG_PIN_MISO);\n            const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n            _spi = pins.createSPI(mosi, miso, sck);\n        }\n        return _spi;\n    }\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    export function spiWrite(value: number) {\n        return spi().write(value);\n    }\n\n    /**\n     * Write a given command to SPI bus, and afterwards read the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    export function spiTransfer(command: Buffer, response: Buffer) {\n        spi().transfer(command, response);\n    }\n\n    /**\n     * Set the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    export function spiFrequency(frequency: number) {\n        spi().setFrequency(frequency);\n    }\n\n    /**\n     * Set the SPI signal mode\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    export function spiMode(mode: number) {\n        spi().setMode(mode);\n    }\n}",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n#ifndef BOOTLOADER_START\n#define BOOTLOADER_START 0x0\n#endif\n\n#ifndef BOOTLOADER_END\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifndef UF2_BINFO\n#define UF2_BINFO ((UF2_BInfo *)(BOOTLOADER_END - sizeof(UF2_BInfo)))\n#endif\n\n#ifndef UF2_INFO_TXT\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#endif\n\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return (BOOTLOADER_START + 0x100) <= (uint32_t)addr && (uint32_t)addr < (BOOTLOADER_END);\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_INFO_TXT))\n        return UF2_INFO_TXT;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
            "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n    uint32_t uf2_family;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
            "usb.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nnamespace pxt {\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\n#ifdef HF2_HID\nHF2 hf2hid(hf2buf);\n#endif\nDummyIface dummyIface;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\nUSBJACDAC jacdacDebug;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,   // bLength\n    0x01,   // bDescriptorType\n    0x0210, // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40, // bMaxPacketSize0\n    USB_DEFAULT_VID, USB_DEFAULT_PID,\n    0x4202, // bcdDevice - leave unchanged for the HF2 to work\n    0x01,   // iManufacturer\n    0x02,   // iProduct\n    0x03,   // SerialNumber\n    0x01    // bNumConfigs\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid platform_usb_init() __attribute__((weak));\nvoid platform_usb_init() {}\n\nvoid set_usb_strings(const char *uf2_info) {\n    static const char *string_descriptors[3];\n    static char serial[12];\n    itoa(target_get_serial() & 0x7fffffff, serial);\n\n    auto model = strstr(uf2_info, \"Model: \");\n    if (model) {\n        model += 7;\n        auto end = model;\n        while (*end && *end != '\\n' && *end != '\\r')\n            end++;\n        auto len = end - model;\n        auto dev = (char *)app_alloc(len + 10);\n        memcpy(dev, model, len);\n        strcpy(dev + len, \" (app)\");\n        // try to split into manufacturer and\n        auto sep = strstr(dev, \" / \");\n        if (sep) {\n            *sep = '\\0';\n            string_descriptors[0] = dev;\n            string_descriptors[1] = sep + 3;\n        } else {\n            string_descriptors[0] = dev;\n            string_descriptors[1] = dev;\n        }\n    }\n\n    string_descriptors[2] = serial;\n    usb.stringDescriptors = string_descriptors;\n}\n\nvoid usb_init() {\n    usb.deviceDescriptor = &device_desc;\n    set_usb_strings(UF2_INFO_TXT);\n\n    platform_usb_init();\n\n#ifdef STM32F4\n    // let's not waste EPs on the HF2 - it will run on CONTROL pipe instead\n    // this doesn't seem to currently work on SAMD, so only do it on STM, which\n    // has very few EPs\n    hf2.allocateEP = false;\n#endif\n    usb.add(hf2);\n\n#ifdef HF2_HID\n    hf2hid.useHID = true;\n    usb.add(hf2hid);\n#else\n    // the WINUSB descriptors don't seem to work if there's only one interface\n    // so we add a dummy interface\n    usb.add(dummyIface);\n#endif\n\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n#if CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n    usb.add(jacdacDebug);\n#endif\n\n    create_fiber(start_usb);\n}\n\n} // namespace pxt\n\n#else\nnamespace pxt {\nvoid usb_init() {}\n} // namespace pxt\n#endif\n\nnamespace control {\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    return pxt::usb.isInitialised();\n#else\n    return false;\n#endif\n}\n}\n\nnamespace pxt {\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n#if HF2_HID\n    hf2hid.sendSerial(data, len);\n#endif\n#endif\n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n} // namespace pxt\n"
        },
        "core---linux": {
            "Makefile": "include Makefile.inc\n\n\nCOMMON_FLAGS = -W -Wall -Wno-unused-parameter -Ipxtapp \\\n\t-fwrapv -fno-threadsafe-statics -ffunction-sections -O3 \\\n\t$(NPM_INCLUDES) -g\nLIBS = -lwiringPi -lm -lpthread -lrt -lasound\nCFLAGS = $(COMMON_FLAGS) -std=c99\nCXXFLAGS = $(COMMON_FLAGS) -std=c++11 -fno-rtti -fno-exceptions -fno-unwind-tables\nLDFLAGS = -Wl,--gc-sections -Wl,--sort-common -Wl,--sort-section=alignment -g -lwiringPi\nPREF = arm-linux-gnueabihf-\nCC = $(PREF)gcc\nLD = $(PREF)gcc\n#LIBSTDCPP = /usr/lib/gcc/arm-linux-gnueabi/4.9/libstdc++.a\nLIBSTDCPP = \nNPM_LIBS = $(wildcard node_modules/*/lib/*.a)\nNPM_INCLUDES = $(addprefix -I, $(wildcard node_modules/*/include))\n\nEXE = bld/pxt-app.elf\nHEX = $(EXE:.elf=.hex)\n\nDEPS = $(PXT_HEADERS) package.json Makefile Makefile.inc\n\nall: $(EXE)\n\n$(EXE): $(PXT_OBJS)\n\t$(LD) -o $(EXE) $(LDFLAGS) -Wl,-Map,$(EXE:.elf=.map) $(PXT_OBJS) $(LIBSTDCPP) $(LIBS) $(NPM_LIBS)\n\tcp $(EXE) $(EXE:.elf=.full)\n\t$(PREF)strip $(EXE)\n\tnode -p 'require(\"fs\").readFileSync(\"$(EXE)\").toString(\"hex\")' > $(HEX)\n\t@ls -l $(EXE)\n\nclean:\n\trm -rf bld\n\nbld/%.o: %.cpp $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CXXFLAGS) -c $< -o $@\n\nbld/%.o: %.s $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\nbld/%.o: %.c $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n",
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codalemu.cpp": "#include \"pxt.h\"\n#include <pthread.h>\n\nnamespace pxt {\n\nstatic pthread_mutex_t irqMutex;\nvoid target_disable_irq() {\n    pthread_mutex_lock(&irqMutex);\n}\nvoid target_enable_irq() {\n    pthread_mutex_unlock(&irqMutex);\n}\n\n} // namespace pxt\n\n",
            "config.cpp": "#include \"pxt.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nnamespace pxt {\n\nstruct EnvConfig {\n    const char *name;\n    const char *value;\n    EnvConfig *next;\n};\n\nstatic EnvConfig *readEnvConfig(const char *name) {\n    FILE *f = fopen(name, \"r\");\n    DMESG(\"read config: %s %s\", name, !f ? \"missing!\" : \"\");\n    if (!f)\n        return NULL;\n    EnvConfig *res = NULL;\n    EnvConfig *endres = NULL;\n    for (;;) {\n        char *line = NULL;\n        size_t len = 0;\n        int llen = getline(&line, &len, f);\n        if (llen <= 0)\n            break;\n        char *p = line;\n        while (isspace(*p))\n            p++;\n        if (!*p || *p == '#') {\n            free(line);\n            continue;\n        }\n\n        auto name = p;\n        while (isalnum(*p) || strchr(\"-_.\", *p))\n            p++;\n        auto endName = p;\n        while (isspace(*p))\n            p++;\n        if (*p == '=' || *p == ':') {\n            p++;\n        } else {\n            free(line);\n            continue;\n        }\n        *endName = 0;\n        while (isspace(*p))\n            p++;\n\n        auto e = new EnvConfig;\n        e->name = name;\n        e->value = p;\n        e->next = endres;\n\n        if (*p) {\n            auto ep = p + strlen(p) - 1;\n            while (ep > p && isspace(*ep))\n                ep--;\n            ep++;\n            *ep = 0;\n        }\n\n        DMESG(\"%s=%s\", e->name, e->value);\n\n        if (endres == NULL) {\n            res = e;\n        } else {\n            endres->next = e;\n        }\n        e->next = NULL;\n        endres = e;\n    }\n    fclose(f);\n\n    return res;\n}\n\nstatic int gotConfig;\nstatic EnvConfig *envConfig;\nstatic void readConfig() {\n    if (gotConfig)\n        return;\n    gotConfig = 1;\n    envConfig = readEnvConfig(\"/sd/arcade.cfg\");\n    DMESG(\"config done\");\n}\nconst char *getConfigString(const char *name) {\n    readConfig();\n    for (auto p = envConfig; p; p = p->next) {\n        if (strcmp(p->name, name) == 0)\n            return p->value;\n    }\n    return NULL;\n}\nint getConfigInt(const char *name, int defl) {\n    auto v = getConfigString(name);\n    if (!v)\n        return defl;\n    sscanf(v, \"%d\", &defl);\n    return defl;\n}\n\nconst int *getConfigInts(const char *name) {\n    static int buf[30];\n\n    buf[0] = ENDMARK;\n\n    auto v = getConfigString(name);\n\n    if (!v)\n        return buf;\n\n    int bp = 0;\n\n    while (bp < 25) {\n        while (isspace(*v))\n            v++;\n        if (!*v)\n            break;\n        if (sscanf(v, \"%i\", &buf[bp]) != 1)\n            break;\n        while (*v && !isspace(*v) && *v != ',')\n            v++;\n        while (isspace(*v))\n            v++;\n        if (*v == ',')\n            v++;\n        bp++;\n    }\n    buf[bp] = ENDMARK;\n\n    // if (gotConfig++ < 20)\n    //    DMESG(\"%s - %d %d %d len=%d\", name, buf[0], buf[1], buf[2], bp);\n\n    return buf;\n}\n\n} // namespace pxt",
            "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n * @param mode optional definition of how the event should be processed after construction.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n//% help=control/raise-event\nvoid raiseEvent(int src, int value) {\n    pxt::raiseEvent(src, value);\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return pxt::allocateNotifyEvent();\n}\n\n/** Write data to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n//%\nuint32_t _ramSize()\n{\n#ifdef POKY\n    return 128 * 1024;\n#else\n    // a lot! doesn't really matter how much\n    return 16 * 1024 * 1024;\n#endif\n}\n\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n    return false;\n}\n\n}\n\nnamespace serial {\n    /** Send DMESG debug buffer over serial. */\n    //%\n    void writeDmesg() {\n        pxt::dumpDmesg();\n    }\n}",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/codal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/codal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/codal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/codal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/codal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/codal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/codal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // built/codal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/codal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/codal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/codal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/codal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/codal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/codal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/codal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/codal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/codal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/codal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/codal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/codal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/codal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/codal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/codal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/codal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/codal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/codal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/codal/pxtapp/core---stm32f401re/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/codal/pxtapp/core---stm32f401re/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/codal/pxtapp/core---stm32f401re/platform.h\n    PXT_BOOTLOADER_CFG_ADDR = 134234056,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    // built/codal/pxtapp/core---stm32f401re/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/codal/pxtapp/core---stm32f401re/uf2hid.h\n    UF2_HID_H = 1,\n    // built/codal/pxtapp/pxtbase.h\n    MEMDBG_ENABLED = 0,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    // built/codal/pxtapp/pxtconfig.h\n    PXT_VM = 0,\n}\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "linux.cpp": "#include \"pxt.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <time.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <errno.h>\n\n#if defined(__linux__) && !defined(POKY)\n#include <malloc.h>\n#define MALLOC_STATS\n#endif\n\n// should this be something like CXX11 or whatever?\n#ifdef PXT_VM\n#define THROW throw()\n#else\n#define THROW /* nothing */\n#endif\n\n#define THREAD_DBG(...)\n\n#define MALLOC_LIMIT (8 * 1024 * 1024)\n#define MALLOC_CHECK_PERIOD (1024 * 1024)\n\nvoid *xmalloc(size_t sz) {\n#ifdef MALLOC_STATS\n    static size_t allocBytes = 0;\n    allocBytes += sz;\n    if (allocBytes >= MALLOC_CHECK_PERIOD) {\n        allocBytes = 0;\n        auto info = mallinfo();\n        // DMESG(\"malloc used: %d kb\", info.uordblks / 1024);\n        if (info.uordblks > MALLOC_LIMIT) {\n            target_panic(PANIC_MEMORY_LIMIT_EXCEEDED);\n        }\n    }\n#endif\n    auto r = malloc(sz);\n    if (r == NULL)\n        oops(50); // shouldn't happen\n    return r;\n}\n\nvoid *operator new(size_t size) {\n    return xmalloc(size);\n}\nvoid *operator new[](size_t size) {\n    return xmalloc(size);\n}\n\nvoid operator delete(void *p) THROW {\n    xfree(p);\n}\nvoid operator delete[](void *p) THROW {\n    xfree(p);\n}\n\nnamespace pxt {\n\nstatic uint64_t startTime;\nstatic pthread_mutex_t execMutex;\nstatic pthread_mutex_t eventMutex;\nstatic pthread_cond_t newEventBroadcast;\n\nstruct Thread {\n    struct Thread *next;\n    Action act;\n    TValue arg0;\n    TValue data0;\n    TValue data1;\n    pthread_t pid;\n    pthread_cond_t waitCond;\n    int waitSource;\n    int waitValue;\n};\n\nstatic struct Thread *allThreads;\nstatic struct Event *eventHead, *eventTail;\n\nstruct Event {\n    struct Event *next;\n    int source;\n    int value;\n};\n\nEvent lastEvent;\n\nEvent *mkEvent(int source, int value) {\n    auto res = new Event();\n    memset(res, 0, sizeof(Event));\n    res->source = source;\n    res->value = value;\n    return res;\n}\n\nvolatile bool paniced;\nextern \"C\" void drawPanic(int code);\n\nextern \"C\" void target_panic(int error_code) {\n    char buf[50];\n    int prevErr = errno;\n\n    paniced = true;\n    pthread_mutex_trylock(&execMutex);\n\n    snprintf(buf, sizeof(buf), \"\\nPANIC %d\\n\", error_code);\n\n    drawPanic(error_code);\n    DMESG(\"PANIC %d\", error_code);\n    DMESG(\"errno=%d %s\", prevErr, strerror(prevErr));\n\n    for (int i = 0; i < 10; ++i) {\n        sendSerial(buf, strlen(buf));\n        sleep_core_us(500 * 1000);\n    }\n\n    target_exit();\n}\n\nvoid startUser() {\n    pthread_mutex_lock(&execMutex);\n}\n\nvoid stopUser() {\n    pthread_mutex_unlock(&execMutex);\n}\n\nvoid sleep_core_us(uint64_t us) {\n    struct timespec ts;\n    ts.tv_sec = us / 1000000;\n    ts.tv_nsec = (us % 1000000) * 1000;\n    while (nanosleep(&ts, &ts))\n        ;\n}\n\nvoid sleep_ms(uint32_t ms) {\n    stopUser();\n    sleep_core_us(ms * 1000);\n    startUser();\n}\n\nvoid sleep_us(uint64_t us) {\n    if (us > 50000) {\n        sleep_ms(us / 1000);\n    } else {\n        sleep_core_us(us);\n    }\n}\n\nuint64_t currTime() {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000000LL + tv.tv_usec;\n}\n\nuint64_t current_time_us() {\n    return currTime() - startTime;\n}\n\nint current_time_ms() {\n    return current_time_us() / 1000;\n}\n\nvoid disposeThread(Thread *t) {\n    if (allThreads == t) {\n        allThreads = t->next;\n    } else {\n        for (auto tt = allThreads; tt; tt = tt->next) {\n            if (tt->next == t) {\n                tt->next = t->next;\n                break;\n            }\n        }\n    }\n    unregisterGC(&t->act, 4);\n    decr(t->act);\n    decr(t->arg0);\n    decr(t->data0);\n    decr(t->data1);\n    pthread_cond_destroy(&t->waitCond);\n    delete t;\n}\n\nstatic void runAct(Thread *thr) {\n    startUser();\n    pxt::runAction1(thr->act, thr->arg0);\n    stopUser();\n    disposeThread(thr);\n}\n\nstatic void mainThread(Thread *) {}\n\nvoid setupThread(Action a, TValue arg = 0, void (*runner)(Thread *) = NULL, TValue d0 = 0,\n                 TValue d1 = 0) {\n    if (runner == NULL)\n        runner = runAct;\n    auto thr = new Thread();\n    memset(thr, 0, sizeof(Thread));\n    thr->next = allThreads;\n    allThreads = thr;\n    registerGC(&thr->act, 4);\n    thr->act = incr(a);\n    thr->arg0 = incr(arg);\n    thr->data0 = incr(d0);\n    thr->data1 = incr(d1);\n    pthread_cond_init(&thr->waitCond, NULL);\n    if (runner == mainThread) {\n        thr->pid = pthread_self();\n    } else {\n        pthread_create(&thr->pid, NULL, (void *(*)(void *))runner, thr);\n        THREAD_DBG(\"setup thread: %p (pid %p)\", thr, thr->pid);\n        pthread_detach(thr->pid);\n    }\n}\n\nvoid releaseFiber() {\n    stopUser();\n    pthread_exit(NULL);\n}\n\nvoid runInParallel(Action a) {\n    setupThread(a);\n}\n\nstatic void runFor(Thread *t) {\n    startUser();\n    while (true) {\n        pxt::runAction0(t->act);\n        sleep_ms(20);\n    }\n}\n\nvoid runForever(Action a) {\n    setupThread(a, 0, runFor);\n}\n\nvoid waitForEvent(int source, int value) {\n    THREAD_DBG(\"waitForEv: %d %d\", source, value);\n    auto self = pthread_self();\n    for (auto t = allThreads; t; t = t->next) {\n        THREAD_DBG(\"t: %p\", t);\n        if (t->pid == self) {\n            pthread_mutex_lock(&eventMutex);\n            t->waitSource = source;\n            t->waitValue = value;\n            stopUser();\n            // spourious wake ups may occur they say\n            while (t->waitSource) {\n                pthread_cond_wait(&t->waitCond, &eventMutex);\n            }\n            pthread_mutex_unlock(&eventMutex);\n            startUser();\n            return;\n        }\n    }\n    DMESG(\"current thread not registered!\");\n    oops(52);\n}\n\nstatic void dispatchEvent(Event &e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    while(curr) {\n        setupThread(curr->action, fromInt(e.value));\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nstatic void *evtDispatcher(void *dummy) {\n    pthread_mutex_lock(&eventMutex);\n    while (true) {\n        pthread_cond_wait(&newEventBroadcast, &eventMutex);\n        while (eventHead != NULL) {\n            if (paniced)\n                return 0;\n            Event *ev = eventHead;\n            eventHead = ev->next;\n            if (eventHead == NULL)\n                eventTail = NULL;\n\n            for (auto thr = allThreads; thr; thr = thr->next) {\n                if (paniced)\n                    return 0;\n                if (thr->waitSource == 0)\n                    continue;\n                if (thr->waitValue != ev->value && thr->waitValue != DEVICE_EVT_ANY)\n                    continue;\n                if (thr->waitSource == ev->source) {\n                    thr->waitSource = 0; // once!\n                    pthread_cond_broadcast(&thr->waitCond);\n                } else if (thr->waitSource == DEVICE_ID_NOTIFY &&\n                           ev->source == DEVICE_ID_NOTIFY_ONE) {\n                    thr->waitSource = 0; // once!\n                    pthread_cond_broadcast(&thr->waitCond);\n                    break; // do not wake up any other threads\n                }\n            }\n\n            dispatchEvent(*ev);\n            delete ev;\n        }\n    }\n}\n\nint allocateNotifyEvent() {\n    static volatile int notifyId;\n    pthread_mutex_lock(&eventMutex);\n    int res = ++notifyId;\n    pthread_mutex_unlock(&eventMutex);\n    return res;\n}\n\nvoid raiseEvent(int id, int event) {\n    auto e = mkEvent(id, event);\n    pthread_mutex_lock(&eventMutex);\n    if (eventTail == NULL) {\n        if (eventHead != NULL)\n            oops(51);\n        eventHead = eventTail = e;\n    } else {\n        eventTail->next = e;\n        eventTail = e;\n    }\n    pthread_cond_broadcast(&newEventBroadcast);\n    pthread_mutex_unlock(&eventMutex);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // TODO support flags\n    setBinding(id, event, a);\n}\n\nstatic void runPoller(Thread *thr) {\n    Action query = thr->data0;\n    auto us = (uint64_t)toInt(thr->data1) * 1000;\n\n    // note that this is run without the user mutex held - it should not modify any state!\n    TValue prev = pxt::runAction0(query);\n    if (!isTagged(prev))\n        oops(30);\n\n    startUser();\n    pxt::runAction2(thr->act, prev, prev);\n    stopUser();\n\n    while (true) {\n        sleep_core_us(us);\n        if (paniced)\n            break;\n        TValue curr = pxt::runAction0(query);\n        if (!isTagged(curr))\n            oops(30);\n        if (curr != prev) {\n            startUser();\n            pxt::runAction2(thr->act, prev, curr);\n            stopUser();\n            if (paniced)\n                break;\n            decr(prev);\n            prev = curr;\n        }\n    }\n    //    disposeThread(thr);\n}\n\n//%\nvoid unsafePollForChanges(int ms, Action query, Action handler) {\n    setupThread(handler, 0, runPoller, query, fromInt(ms));\n}\n\nuint32_t afterProgramPage() {\n    return 0;\n}\n\nchar **initialArgv;\n\nvoid screen_init();\nvoid initKeys();\nvoid target_startup();\n\nvoid initRuntime() {\n    // daemon(1, 1);\n    startTime = currTime();\n\n    target_startup();\n\n    pthread_t disp;\n    pthread_create(&disp, NULL, evtDispatcher, NULL);\n    pthread_detach(disp);\n    setupThread(0, 0, mainThread);\n    target_init();\n    screen_init();\n    initKeys();\n    startUser();\n}\n\n#ifdef PXT_GC\n#define GC_BASE 0x20000000\n#define GC_PAGE_SIZE 4096\nvoid *gcAllocBlock(size_t sz) {\n    static uint8_t *currPtr = (uint8_t *)GC_BASE;\n    sz = (sz + GC_PAGE_SIZE - 1) & ~(GC_PAGE_SIZE - 1);\n    void *r = mmap(currPtr, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n    if (r == MAP_FAILED) {\n        DMESG(\"mmap %p failed; err=%d\", currPtr, errno);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n    currPtr = (uint8_t *)r + sz;\n    if (isReadOnly((TValue)r)) {\n        DMESG(\"mmap returned read-only address: %p\", r);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n    return r;\n}\n#endif\n\nstatic __thread ThreadContext *threadCtx;\n\nThreadContext *getThreadContext() {\n    return threadCtx;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    threadCtx = ctx;\n}\n\nvoid *threadAddressFor(ThreadContext *, void *sp) {\n    return sp;\n}\n\n} // namespace pxt\n",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "platform.cpp": "#include \"pxt.h\"\n\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    read(fd, &seed, sizeof(seed));\n    close(fd);\n    seedRandom(seed);\n}\n\nvoid sendSerial(const char *data, int len) {\n    /*\n    if (!serial) {\n        serial = new codal::_mbed::Serial(USBTX, NC);\n        serial->baud(9600);\n    }\n    serial->send((uint8_t*)data, len);\n    */\n}\n\nextern \"C\" void drawPanic(int code)\n{\n    // TODO\n}\n\n\nextern \"C\" void target_init()\n{\n    initRandomSeed();\n}\n\nvoid updateScreen(Image_ img);\n\nvoid screen_init() {\n    updateScreen(NULL);\n}\n\n}\n\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#define OUTPUT_BITS 12\n\n#define PAGE_SIZE 1024 // not really\n\n#define DEV_NUM_PINS 28\n\n#define DEV_PWM_PINS 0xffffffffULL\n#define DEV_AIN_PINS 0ULL\n\n\n// Codal doesn't yet distinguish between PWM and AIN\n#define DEV_ANALOG_PINS (DEV_PWM_PINS | DEV_AIN_PINS)\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER ZTimer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n\n\nnamespace pxt\n{\n\n    class ZPin;\n    class AbstractButton;\n    class MultiButton;\n    class CodalComponent;\n    \n    \n} // pxt\n\n#define IMAGE_BITS 4\n#define PXT_GC_THREAD_LIST 1\n\n#define PXT_IN_ISR() false\n\n#define PROGDIR \"/sd/prj\"\n#undef SETTINGSDIR\n\n// #define SETTINGSDIR \"/sd/cfg\"\n\n#endif\n",
            "platform_includes.h": "#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#define PROCESSOR_WORD_TYPE uintptr_t\n",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#define OUTPUT_BITS 12\n\n#define DEVICE_EVT_ANY 0\n#define DEVICE_ID_NOTIFY_ONE 1022\n#define DEVICE_ID_NOTIFY 1023\n\nnamespace pxt {\nvoid raiseEvent(int id, int event);\nint allocateNotifyEvent();\nvoid sleep_core_us(uint64_t us);\nvoid startUser();\nvoid stopUser();\n\nvoid target_disable_irq();\nvoid target_enable_irq();\n\nconst char *getConfigString(const char *name);\nint getConfigInt(const char *name, int defl);\n#define ENDMARK -0x7fff0123\nconst int *getConfigInts(const char *name);\n\nclass Button;\ntypedef Button *Button_;\n\nextern \"C\" void target_init();\n\nclass MMap : public RefObject {\n  public:\n    int length;\n    int fd;\n    uint8_t *data;\n\n    MMap();\n    void destroy();\n    void print();\n};\n\nextern volatile bool paniced;\nextern char **initialArgv;\nvoid target_exit();\n\n// Buffer, Sound, and Image share representation.\ntypedef Buffer Sound;\n\n// extern Event lastEvent;\n} // namespace pxt\n\n#undef PXT_MAIN\n#define PXT_MAIN                                                                                   \\\n    int main(int argc, char **argv) {                                                        \\\n        pxt::initialArgv = argv;                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#endif\n",
            "pxt.json": "{\n  \"name\": \"core---linux\",\n  \"files\": [\n    \"README.md\",\n    \"Makefile\",\n    \"dal.d.ts\",\n    \"linux.cpp\",\n    \"config.cpp\",\n    \"target.cpp\",\n    \"pxt.h\",\n    \"platform.h\",\n    \"platform.cpp\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"control.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\",\n    \"timer.ts\",\n    \"platform_includes.h\",\n    \"codalemu.cpp\",\n    \"pxtparts.json\"\n  ],\n  \"description\": \"The core library for Codal-based targets\",\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 1024\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\",\n      \"MS_\",\n      \"SCSI_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\nnamespace pxt {\nvoid dmesg(const char *fmt, ...);\nvoid vdmesg(const char *format, va_list arg);\n#define DMESG pxt::dmesg\nvoid *gcAllocBlock(size_t sz);\n}\n\nstatic inline void itoa(int v, char *dst) {\n    snprintf(dst, 30, \"%d\", v);\n}\n\nextern \"C\" void *xmalloc(size_t sz);\n#define xfree free\n\n#define GC_ALLOC_BLOCK gcAllocBlock\n\n#ifndef POKY\n// This seems to degrade performance - probably due to cache size\n//#define GC_BLOCK_SIZE (1024 * 64)\n#endif\n\n#define PXT_HARD_FLOAT 1\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     * @param mode optional definition of how the event should be processed after construction.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n    //% help=control/raise-event shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write data to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace serial {\n\n    /** Send DMESG debug buffer over serial. */\n    //% shim=serial::writeDmesg\n    function writeDmesg(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "target.cpp": "#include \"pxt.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <fcntl.h>\n\nnamespace pxt {\n\nvoid target_exit() {\n    kill(getpid(), SIGTERM);\n}\n\nextern \"C\" void target_reset() {\n    for (int i = 3; i < 1000; ++i)\n        close(i);\n    if (!fork()) {\n        execv(initialArgv[0], initialArgv);\n        exit(127);\n    } else {\n        target_exit();\n    }\n}\n\nvoid target_startup() {\n    int pid = getpid();\n    DMESG(\"runtime starting, pid=%d...\", pid);\n\n    FILE *pf = fopen(\"/tmp/pxt-pid\", \"r\");\n    if (pf) {\n        int p2 = 0;\n        fscanf(pf, \"%d\", &p2);\n        if (p2)\n            kill(p2, SIGTERM);\n        fclose(pf);\n    }\n    pf = fopen(\"/tmp/pxt-pid\", \"w\");\n    fprintf(pf, \"%d\", pid);\n    fclose(pf);\n}\n\nstatic FILE *dmesgFile;\n\nstatic int dmesgPtr;\nstatic int dmesgSerialPtr;\nstatic char dmesgBuf[4096];\n\nvoid dumpDmesg() {\n    auto len = dmesgPtr - dmesgSerialPtr;\n    if (len == 0)\n        return;\n    sendSerial(dmesgBuf + dmesgSerialPtr, len);\n    dmesgSerialPtr = dmesgPtr;\n}\n\n\nstatic void dmesgRaw(const char *buf, uint32_t len) {\n    if (!dmesgFile) {\n        dmesgFile = fopen(\"/tmp/dmesg.txt\", \"w\");\n        if (!dmesgFile)\n            dmesgFile = stderr;\n    }\n\n    if (len > sizeof(dmesgBuf) / 2)\n        return;\n    if (dmesgPtr + len > sizeof(dmesgBuf)) {\n        dmesgPtr = 0;\n        dmesgSerialPtr = 0;\n    }\n    memcpy(dmesgBuf + dmesgPtr, buf, len);\n    dmesgPtr += len;\n    fwrite(buf, 1, len, dmesgFile);\n\n    fwrite(buf, 1, len, stderr);\n}\n\nstatic void dmesgFlushRaw() {\n    fflush(dmesgFile);\n#ifdef __linux__\n    fdatasync(fileno(dmesgFile));\n#else\n    fsync(fileno(dmesgFile));\n#endif\n}\n\nvoid vdmesg(const char *format, va_list arg) {\n    char buf[500];\n\n    snprintf(buf, sizeof(buf), \"[%8d] \", current_time_ms());\n    dmesgRaw(buf, strlen(buf));\n    vsnprintf(buf, sizeof(buf), format, arg);\n    dmesgRaw(buf, strlen(buf));\n    dmesgRaw(\"\\n\", 1);\n\n    dmesgFlushRaw();\n}\n\nvoid dmesg(const char *format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    vdmesg(format, arg);\n    va_end(arg);\n}\n\nuint64_t readSerialNumber() {\n    static uint64_t bigSerialNumber;\n\n    if (bigSerialNumber)\n        return bigSerialNumber;\n\n    char buf[1024];\n    int fd = open(\"/proc/cpuinfo\", O_RDONLY);\n    int len = read(fd, buf, sizeof(buf) - 1);\n    close(fd);\n\n    if (len < 0)\n        len = 0;\n    buf[len] = 0;\n    auto p = strstr(buf, \"Serial\\t\");\n    if (p) {\n        p += 6;\n        while (*p && strchr(\" \\t:\", *p))\n            p++;\n        uint64_t s = 0;\n        sscanf(p, \"%llu\", &s);\n        bigSerialNumber = s;\n    }\n\n    if (!bigSerialNumber)\n        bigSerialNumber = 0xf00d0042f00d0042;\n\n    return bigSerialNumber;\n}\n\nint getSerialNumber() {\n    static int serial;\n\n    if (serial)\n        return serial;\n\n    uint64_t fullSerial = readSerialNumber();\n    serial = (fullSerial >> 32) ^ (fullSerial);\n\n    return serial;\n}\n\nuint64_t getLongSerialNumber() {\n    return readSerialNumber();\n}\n\n} // namespace pxt\n",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}"
        },
        "core---vm": {
            "Makefile": "include Makefile.inc\n\nBUILD := bld-$(CROSS_TRIPLE)\nSDL_OBJ := $(BUILD)/pxtapp/hw---vm/sdlmain.o\nPXT_OBJS := $(PXT_OBJS:bld/%=$(BUILD)/%)\nPXT_OBJS := $(PXT_OBJS:$(SDL_OBJ)=)\n\nCOMMON_FLAGS = -W -Wall -Wno-unused-parameter -Wno-unused-private-field -Ipxtapp \\\n\t-fwrapv -fno-threadsafe-statics -ffunction-sections -fno-strict-aliasing -O2 \\\n\t$(NPM_INCLUDES) -g\nLIBS = -lm -lpthread\nCFLAGS = $(COMMON_FLAGS) -std=c99\nCXXFLAGS = $(COMMON_FLAGS) -std=c++11 -fno-rtti -fno-exceptions -fno-unwind-tables\nLDFLAGS = -g\n\nCC = $(PREF)gcc\nLD = $(PREF)gcc\nLIBSTDCPP = \nNPM_LIBS = $(wildcard node_modules/*/lib/*.a)\nNPM_INCLUDES = $(addprefix -I, $(wildcard node_modules/*/include))\nSTRIP = strip\n\nifeq (i386,$(findstring i386,$(CROSS_TRIPLE)))\nX32 = -32\nendif\nifeq (i686,$(findstring i686,$(CROSS_TRIPLE)))\nX32 = -32\nendif\n\nifeq (darwin,$(findstring darwin,$(CROSS_TRIPLE)))\nSOFLAGS := -dynamiclib\nSONAME := libpxt$(X32).dylib\nEXE := $(BUILD)/pxt-vm-cli$(X32)\nSDL_EXE = $(BUILD)/pxt-vm-sdl$(X32)\nSTRIP = strip -S\nelse\nifeq (linux,$(findstring linux,$(CROSS_TRIPLE)))\nSOFLAGS := -shared\nSONAME := libpxt$(X32).so\nEXE := $(BUILD)/pxt-vm-cli-linux$(X32)\nCOMMON_FLAGS += -fPIC\nSDL_EXE = skip\nelse\nSOFLAGS := -shared\nLDFLAGS += -static\nSONAME := pxt$(X32).dll\nEXE := $(BUILD)/pxt-vm-cli$(X32).exe\nSDL_EXE = $(BUILD)/pxt-vm-sdl$(X32).exe\nifeq ($(X32),-32)\nLDFLAGS += -Wl,--image-base,0x08000000\nendif\nendif\nendif\n\nDEPS = $(PXT_HEADERS) package.json Makefile Makefile.inc\n\nall:\n\tCROSS_TRIPLE=win64 crossbuild make -j8 build-one\n\tCROSS_TRIPLE=linux crossbuild make -j8 build-one\n\tCROSS_TRIPLE=osx crossbuild make -j8 build-one\n\tCROSS_TRIPLE=win32 crossbuild make -j8 build-one\n\t#CROSS_TRIPLE=osx32 crossbuild make -j8 build-one\n\trm -f bld/*.tgz bld/*.b64\n\ttar zcf bld/all.tgz bld/*\n\tbase64 < bld/all.tgz > bld/all.tgz.b64\n\t@ls -l bld/\n\t@echo Build OK\n\ncreate-dir:\n\tmkdir -p $(BUILD) bld\n\nbuild-one: create-dir $(EXE)\nifneq ($(SDL_EXE),skip)\n\t$(MAKE) CXXFLAGS=\"$(CXXFLAGS) $(shell sdl2-config --cflags)\" $(SDL_EXE)\nendif\n\n$(EXE) $(BUILD)/$(SONAME): $(PXT_OBJS)\n\t$(LD) -o $(EXE) $(LDFLAGS) $(PXT_OBJS) $(LIBSTDCPP) $(LIBS) $(NPM_LIBS)\n\t$(LD) -o $(BUILD)/$(SONAME) $(SOFLAGS) $(LDFLAGS) $(PXT_OBJS) $(LIBSTDCPP) $(LIBS) $(NPM_LIBS)\n\t$(STRIP) -o bld/$(shell basename $(EXE)) $(EXE)\n\t$(STRIP) -o bld/$(SONAME) $(BUILD)/$(SONAME)\n\n$(SDL_EXE): $(SDL_OBJ)\n\t$(LD) -o $(SDL_EXE) $(LDFLAGS) $(SDL_OBJ) $(LIBSTDCPP) $(LIBS) $(shell sdl2-config --static-libs)\n\t$(STRIP) -o bld/$(shell basename $(SDL_EXE)) $(SDL_EXE)\n\nclean:\n\trm -rf bld bld-*\n\n$(BUILD)/%.o: %.cpp $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CXXFLAGS) -c $< -o $@\n\n$(BUILD)/%.o: %.s $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n$(BUILD)/%.o: %.c $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n",
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codalemu.cpp": "#include \"pxt.h\"\n#include <pthread.h>\n\nnamespace pxt {\n\nstatic pthread_mutex_t irqMutex;\nvoid target_disable_irq() {\n    pthread_mutex_lock(&irqMutex);\n}\nvoid target_enable_irq() {\n    pthread_mutex_unlock(&irqMutex);\n}\n\n} // namespace pxt\n\n",
            "config.cpp": "\n",
            "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n * @param mode optional definition of how the event should be processed after construction.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n//% help=control/raise-event\nvoid raiseEvent(int src, int value) {\n    pxt::raiseEvent(src, value);\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return pxt::allocateNotifyEvent();\n}\n\n/** Write data to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n//%\nuint32_t _ramSize()\n{\n#ifdef POKY\n    return 128 * 1024;\n#else\n    // a lot! doesn't really matter how much\n    return 16 * 1024 * 1024;\n#endif\n}\n\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n    return false;\n}\n\n}\n\nnamespace serial {\n    /** Send DMESG debug buffer over serial. */\n    //%\n    void writeDmesg() {\n        pxt::dumpDmesg();\n    }\n}",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/codal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/codal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/codal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/codal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/codal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/codal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/codal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/codal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/codal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/codal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/codal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/codal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/codal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/codal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/codal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/codal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/codal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/codal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/codal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/codal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/codal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/codal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/codal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/codal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/codal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/codal/pxtapp/core---stm32f401re/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/codal/pxtapp/core---stm32f401re/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/codal/pxtapp/core---stm32f401re/platform.h\n    PXT_BOOTLOADER_CFG_ADDR = 134234056,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    // built/codal/pxtapp/core---stm32f401re/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/codal/pxtapp/core---stm32f401re/uf2hid.h\n    UF2_HID_H = 1,\n    // built/codal/pxtapp/pxtbase.h\n    MEMDBG_ENABLED = 0,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    // built/codal/pxtapp/pxtconfig.h\n    PXT_VM = 0,\n}\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "keys.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nvoid initKeys() {}\n} // namespace pxt",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "platform.cpp": "#include \"pxt.h\"\n\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    read(fd, &seed, sizeof(seed));\n    close(fd);\n    seedRandom(seed);\n}\n\nvoid sendSerial(const char *data, int len) {\n    /*\n    if (!serial) {\n        serial = new codal::_mbed::Serial(USBTX, NC);\n        serial->baud(9600);\n    }\n    serial->send((uint8_t*)data, len);\n    */\n}\n\nextern \"C\" void drawPanic(int code)\n{\n    // TODO\n}\n\n\nextern \"C\" void target_init()\n{\n    initRandomSeed();\n}\n\nvoid updateScreen(Image_ img);\n\nvoid screen_init() {\n    updateScreen(NULL);\n}\n\n}\n\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#define PAGE_SIZE 1024 // not really\n\n#define DEV_NUM_PINS 28\n\n#define DEV_PWM_PINS 0xffffffffULL\n#define DEV_AIN_PINS 0ULL\n\n\n// Codal doesn't yet distinguish between PWM and AIN\n#define DEV_ANALOG_PINS (DEV_PWM_PINS | DEV_AIN_PINS)\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER ZTimer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n\n\nnamespace pxt\n{\n\n    class ZPin;\n    class AbstractButton;\n    class MultiButton;\n    class CodalComponent;\n    \n    typedef void (*reset_fn_t)();\n    void registerResetFunction(reset_fn_t fn);\n    void soft_panic(int errorCode);\n} // pxt\n\n#define IMAGE_BITS 4\n\n#define PXT_IN_ISR() false\n\n#define GC_BLOCK_SIZE (1024 * 64)\n\n#define PXT_REGISTER_RESET(fn) pxt::registerResetFunction(fn)\n\n#ifdef __APPLE__\n#include \"TargetConditionals.h\"\n#if TARGET_OS_IPHONE\n#define PXT_IOS 1\n#endif\n#endif\n\n#endif\n",
            "platform_includes.h": "#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#define PROCESSOR_WORD_TYPE uintptr_t\n",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"vm.h\"\n\n#define OUTPUT_BITS 12\n\n#define DEVICE_EVT_ANY 0\n#define DEVICE_ID_NOTIFY_ONE 1022\n#define DEVICE_ID_NOTIFY 1023\n\nnamespace pxt {\nvoid raiseEvent(int id, int event);\nint allocateNotifyEvent();\nvoid sleep_core_us(uint64_t us);\n\nvoid target_disable_irq();\nvoid target_enable_irq();\n\nclass Button;\ntypedef Button *Button_;\n\nextern \"C\" void target_init();\n\nclass MMap : public RefObject {\n  public:\n    int length;\n    int fd;\n    uint8_t *data;\n\n    MMap();\n    void destroy();\n    void print();\n};\n\nextern volatile bool paniced;\nextern char **initialArgv;\nvoid target_exit();\nextern volatile int panicCode;\n\n// Buffer, Sound, and Image share representation.\ntypedef Buffer Sound;\n\n} // namespace pxt\n\n#undef PXT_MAIN\n#define PXT_MAIN                                                                                   \\\n    int main(int argc, char **argv) {                                                              \\\n        pxt::initialArgv = argv;                                                                   \\\n        pxt::vmStart();                                                                            \\\n        return 0;                                                                                  \\\n    }\n\n#undef PXT_SHIMS_BEGIN\n#define PXT_SHIMS_BEGIN                                                                            \\\n    namespace pxt {                                                                                \\\n    const OpcodeDesc staticOpcodes[] __attribute__((aligned(0x20))) = {\n\n#undef PXT_SHIMS_END\n#define PXT_SHIMS_END                                                                              \\\n    { 0, 0, 0 }                                                                                    \\\n    }                                                                                              \\\n    ;                                                                                              \\\n    }\n\n#endif\n",
            "pxt.json": "{\n  \"name\": \"core---vm\",\n  \"files\": [\n    \"README.md\",\n    \"Makefile\",\n    \"dal.d.ts\",\n    \"scheduler.cpp\",\n    \"config.cpp\",\n    \"target.cpp\",\n    \"pxt.h\",\n    \"platform.h\",\n    \"platform.cpp\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"control.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\",\n    \"timer.ts\",\n    \"platform_includes.h\",\n    \"codalemu.cpp\",\n    \"keys.cpp\",\n    \"vm.cpp\",\n    \"vmload.cpp\",\n    \"vm.h\",\n    \"vmcache.cpp\",\n    \"verify.cpp\",\n    \"pxtparts.json\"\n  ],\n  \"description\": \"The core library for Codal-based targets\",\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 1024\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\",\n      \"MS_\",\n      \"SCSI_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\nnamespace pxt {\nvoid dmesg(const char *fmt, ...);\nvoid vdmesg(const char *format, va_list arg);\n#define DMESG pxt::dmesg\nvoid *gcAllocBlock(size_t sz);\n}\n\nstatic inline void itoa(int v, char *dst) {\n    snprintf(dst, 30, \"%d\", v);\n}\n\nextern \"C\" void *xmalloc(size_t sz);\n#define xfree free\n\n#define GC_ALLOC_BLOCK gcAllocBlock\n\n#ifndef POKY\n// This seems to degrade performance - probably due to cache size\n//#define GC_BLOCK_SIZE (1024 * 64)\n#endif\n\n#define PXT_HARD_FLOAT 1\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "scheduler.cpp": "#include \"pxt.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <errno.h>\n\n// __MINGW32__ is defined on both mingw32 and mingw64\n#ifdef __MINGW32__\n#include <windows.h>\n#else\n#include <sys/mman.h>\n#endif\n\n// should this be something like CXX11 or whatever?\n#define THROW throw()\n#define THREAD_DBG(...)\n\nvoid *xmalloc(size_t sz) {\n    auto r = malloc(sz);\n    if (r == NULL)\n        oops(50); // shouldn't happen\n    return r;\n}\n\nvoid *operator new(size_t size) {\n    return xmalloc(size);\n}\nvoid *operator new[](size_t size) {\n    return xmalloc(size);\n}\n\nvoid operator delete(void *p)THROW {\n    xfree(p);\n}\nvoid operator delete[](void *p) THROW {\n    xfree(p);\n}\n\nnamespace pxt {\n\nstatic uint64_t startTime;\n\nFiberContext *allFibers;\nFiberContext *currentFiber;\nstatic pthread_mutex_t eventMutex;\nstatic pthread_cond_t newEventBroadcast;\n\nstatic struct Event *eventHead, *eventTail;\n\nstruct Event {\n    struct Event *next;\n    int source;\n    int value;\n};\n\nEvent lastEvent;\n\nEvent *mkEvent(int source, int value) {\n    auto res = new Event();\n    memset(res, 0, sizeof(Event));\n    res->source = source;\n    res->value = value;\n    return res;\n}\n\nvolatile int panicCode;\nextern \"C\" void drawPanic(int code);\n\nvoid schedule() {\n    auto f = currentFiber;\n    if (!f->wakeTime && !f->waitSource)\n        oops(55);\n    f->resumePC = f->pc;\n    f->pc = NULL; // this will break the exec_loop()\n}\n\nvoid dmesg_flush();\n\nstatic void panic_core(int error_code) {\n    int prevErr = errno;\n\n    panicCode = error_code;\n\n    drawPanic(error_code);\n\n    DMESG(\"PANIC %d\", error_code % 1000);\n    DMESG(\"errno=%d %s\", prevErr, strerror(prevErr));\n\n    dmesg_flush();\n}\n\nextern \"C\" void target_panic(int error_code) {\n    panic_core(error_code);\n\n    while (1)\n        sleep_core_us(10000);\n}\n\nDLLEXPORT int pxt_get_panic_code() {\n    return panicCode;\n}\n\nvoid soft_panic(int errorCode) {\n    if (errorCode >= 999)\n        errorCode = 999;\n    if (errorCode <= 0)\n        errorCode = 1;\n    panic_core(1000 + errorCode);\n    systemReset();\n}\n\nvoid sleep_core_us(uint64_t us) {\n    struct timespec ts;\n    ts.tv_sec = us / 1000000;\n    ts.tv_nsec = (us % 1000000) * 1000;\n    while (nanosleep(&ts, &ts))\n        ;\n}\n\nvoid sleep_ms(uint32_t ms) {\n    currentFiber->wakeTime = current_time_ms() + ms;\n    schedule();\n}\n\nvoid sleep_us(uint64_t us) {\n    if (us > 50000) {\n        sleep_ms((uint32_t)(us / 1000));\n    } else {\n        sleep_core_us(us);\n    }\n}\n\nuint64_t currTime() {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000000LL + tv.tv_usec;\n}\n\nuint64_t current_time_us() {\n    if (!startTime)\n        startTime = currTime();\n    return currTime() - startTime;\n}\n\nint current_time_ms() {\n    return (int)(current_time_us() / 1000);\n}\n\nvoid disposeFiber(FiberContext *t) {\n    if (allFibers == t) {\n        allFibers = t->next;\n    } else {\n        for (auto tt = allFibers; tt; tt = tt->next) {\n            if (tt->next == t) {\n                tt->next = t->next;\n                break;\n            }\n        }\n    }\n\n    xfree(t->stackBase);\n    xfree(t);\n}\n\nFiberContext *setupThread(Action a, TValue arg = 0) {\n    //DMESG(\"setup thread: %p\", a);\n    auto t = (FiberContext *)xmalloc(sizeof(FiberContext));\n    memset(t, 0, sizeof(*t));\n    t->stackBase = (TValue *)xmalloc(VM_STACK_SIZE * sizeof(TValue));\n    t->stackLimit = t->stackBase + VM_MAX_FUNCTION_STACK + 5;\n    t->sp = t->stackBase + VM_STACK_SIZE;\n    *--t->sp = (TValue)0xf00df00df00df00d;\n    *--t->sp = 0;\n    *--t->sp = 0;\n    *--t->sp = 0;\n    *--t->sp = arg;\n    *--t->sp = 0;\n    *--t->sp = TAG_STACK_BOTTOM;\n    auto ra = (RefAction *)a;\n    // we only pass 1 argument, but can in fact handle up to 4\n    if (ra->numArgs > 2)\n        target_panic(PANIC_INVALID_IMAGE);\n    t->currAction = ra;\n    t->resumePC = (uint16_t *)ra->func;\n\n    t->img = vmImg;\n    t->imgbase = (uint16_t *)vmImg->dataStart;\n\n    // add at the end\n    if (allFibers)\n        for (auto p = allFibers; p; p = p->next) {\n            if (!p->next) {\n                p->next = t;\n                break;\n            }\n        }\n    else\n        allFibers = t;\n\n    return t;\n}\n\nvoid runInParallel(Action a) {\n    setupThread(a);\n}\n\nvoid runForever(Action a) {\n    auto f = setupThread(a);\n    f->foreverPC = f->resumePC;\n}\n\nvoid waitForEvent(int source, int value) {\n    currentFiber->waitSource = source;\n    currentFiber->waitValue = value;\n    schedule();\n}\n\nstatic void dispatchEvent(Event &e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    if (curr)\n        setupThread(curr->action, fromInt(e.value));\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        setupThread(curr->action, fromInt(e.value));\n}\n\nstatic void wakeFibers() {\n    for (;;) {\n        pthread_mutex_lock(&eventMutex);\n        if (eventHead == NULL) {\n            pthread_mutex_unlock(&eventMutex);\n            return;\n        }\n        Event *ev = eventHead;\n        eventHead = ev->next;\n        if (eventHead == NULL)\n            eventTail = NULL;\n        pthread_mutex_unlock(&eventMutex);\n\n        for (auto thr = allFibers; thr; thr = thr->next) {\n            if (thr->waitSource == 0)\n                continue;\n            if (thr->waitValue != ev->value && thr->waitValue != DEVICE_EVT_ANY)\n                continue;\n            if (thr->waitSource == ev->source) {\n                thr->waitSource = 0;\n            } else if (thr->waitSource == DEVICE_ID_NOTIFY && ev->source == DEVICE_ID_NOTIFY_ONE) {\n                thr->waitSource = 0;\n                break; // do not wake up any other threads\n            }\n        }\n\n        dispatchEvent(*ev);\n        delete ev;\n    }\n}\n\nstatic void mainRunLoop() {\n    FiberContext *f = NULL;\n    for (;;) {\n        if (panicCode)\n            return;\n        wakeFibers();\n        auto now = current_time_ms();\n        auto fromBeg = false;\n        if (!f) {\n            f = allFibers;\n            fromBeg = true;\n        }\n        while (f) {\n            if (f->wakeTime && now >= (int)f->wakeTime)\n                f->wakeTime = 0;\n            if (!f->wakeTime && !f->waitSource)\n                break;\n            f = f->next;\n        }\n        if (f) {\n            currentFiber = f;\n            f->pc = f->resumePC;\n            f->resumePC = NULL;\n            exec_loop(f);\n            if (panicCode)\n                return;\n            auto n = f->next;\n            if (f->resumePC == NULL) {\n                if (f->foreverPC) {\n                    f->resumePC = f->foreverPC;\n                    f->wakeTime = current_time_ms() + 20;\n                    // restore stack, as setupThread() does it\n                    for (int i = 0; i < 5; ++i) {\n                        if (*--f->sp == TAG_STACK_BOTTOM)\n                            break;\n                    }\n                    if (*f->sp != TAG_STACK_BOTTOM)\n                        target_panic(PANIC_INVALID_IMAGE);\n                } else {\n                    disposeFiber(f);\n                }\n            }\n            f = n;\n        } else if (fromBeg) {\n            sleep_core_us(1000);\n        }\n    }\n}\n\nint allocateNotifyEvent() {\n    static volatile int notifyId;\n    return ++notifyId;\n}\n\nvoid raiseEvent(int id, int event) {\n    auto e = mkEvent(id, event);\n    pthread_mutex_lock(&eventMutex);\n    if (eventTail == NULL) {\n        if (eventHead != NULL)\n            oops(51);\n        eventHead = eventTail = e;\n    } else {\n        eventTail->next = e;\n        eventTail = e;\n    }\n    pthread_cond_broadcast(&newEventBroadcast);\n    pthread_mutex_unlock(&eventMutex);\n}\n\nDLLEXPORT void pxt_raise_event(int id, int event) {\n    raiseEvent(id, event);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // TODO support flags\n    setBinding(id, event, a);\n}\n\nuint32_t afterProgramPage() {\n    return 0;\n}\n\nchar **initialArgv;\n\nvoid screen_init();\nvoid initKeys();\nvoid target_startup();\n\nvoid initRuntime() {\n    current_time_ms();\n    target_startup();\n\n    setupThread((TValue)vmImg->entryPoint);\n\n    target_init();\n    screen_init();\n    initKeys();\n\n    DMESG(\"start main loop\");\n\n    mainRunLoop();\n    systemReset();\n}\n\n#ifdef PXT_GC\n\n#ifdef PXT64\n#define GC_BASE 0x2000000000\n#define GC_PAGE_SIZE (64 * 1024)\n#else\n#define GC_BASE 0x20000000\n#define GC_PAGE_SIZE 4096\n#endif\n\n#ifdef PXT_IOS\nuint8_t *gcBase;\n#endif\n\nvoid *gcAllocBlock(size_t sz) {\n    static uint8_t *currPtr = (uint8_t *)GC_BASE;\n    sz = (sz + GC_PAGE_SIZE - 1) & ~(GC_PAGE_SIZE - 1);\n#ifdef __MINGW32__\n    void *r = VirtualAlloc(currPtr, sz, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (r == NULL) {\n        DMESG(\"VirtualAlloc %p failed; err=%d\", currPtr, GetLastError());\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n#elif defined(PXT_IOS)\n    if (!gcBase) {\n        gcBase = (uint8_t *)xmalloc(1 << PXT_IOS_HEAP_ALLOC_BITS);\n        currPtr = gcBase;\n    }\n    void *r = currPtr;\n    if ((uint8_t *)currPtr - gcBase > 1024 * 1024 - sz)\n        target_panic(20);\n#else\n    void *r = mmap(currPtr, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n    if (r == MAP_FAILED) {\n        DMESG(\"mmap %p failed; err=%d\", currPtr, errno);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n#endif\n\n    currPtr = (uint8_t *)r + sz;\n    if (isReadOnly((TValue)r)) {\n        DMESG(\"mmap returned read-only address: %p\", r);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n    return r;\n}\n\nvoid gcProcessStacks(int flags) {\n    int cnt = 0;\n    for (auto f = allFibers; f; f = f->next) {\n        auto end = f->stackBase + VM_STACK_SIZE - 1;\n        auto ptr = f->sp;\n        gcProcess((TValue)f->currAction);\n        gcProcess((TValue)f->r0);\n        if (flags & 2)\n            DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n        // VLOG(\"mark: %p - %p\", ptr, end);\n        while (ptr <= end) {\n            gcProcess(*ptr++);\n        }\n    }\n}\n#endif\n\n#define MAX_RESET_FN 32\nstatic reset_fn_t resetFunctions[MAX_RESET_FN];\n\nvoid registerResetFunction(reset_fn_t fn) {\n    for (int i = 0; i < MAX_RESET_FN; ++i) {\n        if (!resetFunctions[i]) {\n            resetFunctions[i] = fn;\n            return;\n        }\n    }\n\n    target_panic(PANIC_INTERNAL_ERROR);\n}\n\nvoid systemReset() {\n    if (!panicCode)\n        panicCode = -1;\n\n    dmesg(\"TARGET RESET\");\n\n    gcFreeze();\n\n    for (int i = 0; i < MAX_RESET_FN; ++i) {\n        auto fn = resetFunctions[i];\n        if (fn)\n            fn();\n    }\n\n    coreReset(); // clears handler bindings\n\n    currentFiber = NULL;\n    while (allFibers) {\n        disposeFiber(allFibers);\n    }\n\n    // this will consume all events, but won't dispatch anything, since all listener maps are empty\n    wakeFibers();\n\n    // mark all GC memory as free\n    gcReset();\n\n    pthread_exit(NULL);\n}\n\n} // namespace pxt\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     * @param mode optional definition of how the event should be processed after construction.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n    //% help=control/raise-event shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write data to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace serial {\n\n    /** Send DMESG debug buffer over serial. */\n    //% shim=serial::writeDmesg\n    function writeDmesg(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "target.cpp": "#include \"pxt.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <fcntl.h>\n\n//#define LOG_TO_STDERR 1\n//#define LOG_TO_FILE 1\n\nnamespace pxt {\n\nvoid target_exit() {\n    systemReset();\n}\n\nextern \"C\" void target_reset() {\n    vmStartFromUser(NULL);\n}\n\nvoid target_startup() {}\n\n#ifdef LOG_TO_FILE\nstatic FILE *dmesgFile;\n#endif\n\n#define LOG_QUEUE_SIZE (128 * 1024)\nclass LogQueue {\n    void writeCore(const char *buf, int len);\n\n  public:\n    int ptr;\n    char buffer[LOG_QUEUE_SIZE];\n    int rdPtr;\n    int numWrap;\n    LogQueue();\n    int write(const char *buf, int len);\n    int read(char *buf, int len);\n};\n\nLogQueue::LogQueue() {\n    ptr = 0;\n    rdPtr = 0;\n    numWrap = 0;\n    memset(buffer, 0, sizeof(buffer));\n}\n\nvoid LogQueue::writeCore(const char *buf, int len) {\n    memcpy(buffer + ptr, buf, len);\n    // did we pass it?\n    if (ptr < rdPtr && rdPtr <= ptr + len)\n        rdPtr = -1;\n    ptr += len;\n}\n\nint LogQueue::read(char *buf, int len) {\n    if (rdPtr < 0) {\n        if (numWrap == 0) {\n            rdPtr = 0;\n        } else {\n            rdPtr = ptr + 1;\n        }\n    }\n\n    if (rdPtr <= ptr) {\n        int av = ptr - rdPtr;\n        if (len > av)\n            len = av;\n        memcpy(buf, buffer + rdPtr, len);\n        rdPtr += len;\n    } else {\n        int latter = sizeof(buffer) - rdPtr;\n\n        if (latter >= len) {\n            memcpy(buf, buffer + rdPtr, len);\n            rdPtr += len;\n        } else {\n            memcpy(buf, buffer + rdPtr, latter);\n            buf += latter;\n            int len2 = len - latter;\n            if (len2 > ptr)\n                len2 = ptr;\n            memcpy(buf, buffer, len2);\n            rdPtr = len2;\n            len = latter + len2;\n        }\n    }\n\n    if (rdPtr >= (int)sizeof(buffer))\n        rdPtr = 0;\n\n    return len;\n}\n\nint LogQueue::write(const char *buf, int len) {\n    if (len > (int)sizeof(buffer) / 2)\n        return -1;\n\n    int left = sizeof(buffer) - ptr;\n\n    if (left < len + 1) {\n        writeCore(buf, left);\n        buf += left;\n        len -= left;\n        ptr = 0;\n        numWrap++;\n        if (rdPtr == 0)\n            rdPtr = -1;\n    }\n\n    writeCore(buf, len);\n    buffer[ptr] = 0;\n\n    return 0;\n}\n\nvoid dumpDmesg() {\n    // not enabled\n}\n} // namespace pxt\n\nLogQueue codalLogStore;\n\nDLLEXPORT int pxt_get_logs(int logtype, char *dst, int maxSize) {\n    if (logtype != 0)\n        return 0;\n    target_disable_irq();\n    int r = codalLogStore.read(dst, maxSize);\n    target_enable_irq();\n    return r;\n}\n\nnamespace pxt {\nstatic void dmesgRaw(const char *buf, uint32_t len) {\n#ifdef LOG_TO_FILE\n    if (!dmesgFile) {\n        dmesgFile = fopen(\"dmesg.txt\", \"w\");\n        if (!dmesgFile)\n            dmesgFile = stderr;\n    }\n#endif\n\n    if (codalLogStore.write(buf, len) != 0)\n        return; // if message too long, skip\n\n#ifdef LOG_TO_FILE\n    fwrite(buf, 1, len, dmesgFile);\n#endif\n#ifdef LOG_TO_STDERR\n    fwrite(buf, 1, len, stderr);\n#endif\n}\n\nvoid deepSleep() {\n    // nothing to do\n}\n\nvoid dmesg_flush() {\n#ifdef LOG_TO_FILE\n    fflush(dmesgFile);\n#endif\n}\n\nstatic void dmesgFlushRaw() {\n    dmesg_flush();\n}\n\nvoid vdmesg(const char *format, va_list arg) {\n    char buf[500];\n\n    target_disable_irq();\n\n    snprintf(buf, sizeof(buf), \"[%8d] \", current_time_ms());\n    dmesgRaw(buf, (uint32_t)strlen(buf));\n    vsnprintf(buf, sizeof(buf), format, arg);\n    dmesgRaw(buf, (uint32_t)strlen(buf));\n    dmesgRaw(\"\\n\", 1);\n\n    target_enable_irq();\n\n    dmesgFlushRaw();\n}\n\nvoid dmesg(const char *format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    vdmesg(format, arg);\n    va_end(arg);\n}\n\nint getSerialNumber() {\n    return 0;\n}\n\nuint64_t getLongSerialNumber() {\n    return 0;\n}\n\n} // namespace pxt\n",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "verify.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\nVMImage *setVMImgError(VMImage *img, int code, void *pos) {\n    img->errorOffset = pos ? (int)((uint8_t *)pos - (uint8_t *)img->dataStart) : 0;\n    img->errorCode = code;\n    return img;\n}\n\n// next free error 1057\n#define ERROR(code, pos) return setVMImgError(img, code, pos)\n#define CHECK(cond, code)                                                                          \\\n    do {                                                                                           \\\n        if (!(cond))                                                                               \\\n            ERROR(code, sect);                                                                     \\\n    } while (0)\n#define CHECK_AT(cond, code, pos)                                                                  \\\n    do {                                                                                           \\\n        if (!(cond))                                                                               \\\n            ERROR(code, pos);                                                                      \\\n    } while (0)\n#define ALIGNED(sz) (((sz)&7) == 0)\n\n#define FOR_SECTIONS()                                                                             \\\n    VMImageSection *sect, *next;                                                                   \\\n    for (sect = (VMImageSection *)img->dataStart;                                                  \\\n         (next = vmNextSection(sect), (uint64_t *)sect < img->dataEnd); sect = next)\n\n#define ALLOC_ARRAY(tp, sz) (tp *)gcPrealloc(sizeof(tp) * sz)\n\nstatic VMImage *countSections(VMImage *img) {\n    auto p = img->dataStart;\n    while (p < img->dataEnd) {\n        auto sect = (VMImageSection *)p;\n        CHECK(ALIGNED(sect->size), 1002);\n        CHECK(sect->size > 0, 1002);\n        img->numSections++;\n        p += sect->size >> 3;\n    }\n    CHECK_AT(p == img->dataEnd, 1003, p);\n    img->pointerLiterals = ALLOC_ARRAY(TValue, img->numSections);\n    img->sections = ALLOC_ARRAY(VMImageSection *, img->numSections);\n\n    return NULL;\n}\n\nstruct CompiledString {\n    uint32_t numbytes;\n    char utf8data[0];\n};\n\nstatic VMImage *loadSections(VMImage *img) {\n    auto idx = 0;\n\n    FOR_SECTIONS() {\n        CHECK(sect->size < 32000, 1014);\n        CHECK(sect->size >= 16, 1048);\n\n        if (sect->type == SectionType::InfoHeader) {\n            CHECK(sect->size >= sizeof(VMImageHeader), 1008);\n            auto hd = (VMImageHeader *)sect->data;\n            CHECK(hd->magic0 == VM_MAGIC0, 1009);\n            CHECK(hd->magic1 == VM_MAGIC1, 1010);\n            CHECK(hd->allocGlobals >= hd->nonPointerGlobals, 1011);\n            CHECK(hd->allocGlobals < 10000, 1012);\n            CHECK(idx == 0, 1013);\n            img->infoHeader = hd;\n        }\n\n        if (sect->type == SectionType::OpCodeMap) {\n            CHECK(img->opcodes == NULL, 1015);\n            auto curr = sect->data;\n            auto endp = sect->data + sect->size - 8;\n            CHECK(endp[-1] == 0, 1017);\n\n            while (curr < endp) {\n                if (*curr == 0)\n                    img->numOpcodes++;\n                curr++;\n            }\n            CHECK(img->numOpcodes >= VM_FIRST_RTCALL, 1016);\n\n            img->opcodes = ALLOC_ARRAY(OpFun, img->numOpcodes);\n            img->opcodeDescs = ALLOC_ARRAY(const OpcodeDesc *, img->numOpcodes);\n\n            int i = 0;\n            curr = sect->data;\n            while (curr < endp) {\n                img->opcodeDescs[i] = NULL;\n                img->opcodes[i] = NULL;\n                if (*curr) {\n                    for (auto st = staticOpcodes; st->name; st++) {\n                        if (strcmp(st->name, (const char *)curr) == 0) {\n                            img->opcodeDescs[i] = st;\n                            break;\n                        }\n                    }\n                    if (img->opcodeDescs[i] == NULL) {\n                        DMESG(\"missing opcode: %s\", (const char *)curr);\n                        setVMImgError(img, 1018, curr);\n                    } else {\n                        img->opcodes[i] = img->opcodeDescs[i]->fn;\n                    }\n                }\n                while (*curr)\n                    curr++;\n                curr++;\n                i++;\n            }\n            if (img->errorCode)\n                return img;\n        }\n\n        if (sect->type == SectionType::NumberLiterals) {\n            CHECK(!img->numberLiterals, 1004);\n            img->numNumberLiterals = (sect->size >> 3) - 1;\n            uint64_t *values = (uint64_t *)sect->data;\n\n#ifdef PXT64\n            img->numberLiterals = (TValue *)values;\n#else\n            img->numberLiterals = ALLOC_ARRAY(TValue, img->numNumberLiterals);\n#endif\n\n            for (unsigned i = 0; i < img->numNumberLiterals; ++i) {\n                auto ptr = &values[i];\n                auto v = *ptr;\n                if (isEncodedDouble(v))\n                    CHECK_AT(!isnan(decodeDouble(v)), 1005, ptr);\n                else if (v & 1)\n                    CHECK_AT((v >> 1) <= 0xffffffff, 1006, ptr);\n                else if (v == 0) {\n                    // OK - padding probably\n                } else\n                    CHECK_AT(false, 1007, ptr);\n#ifdef PXT32\n                img->numberLiterals[i] =\n                    v == 0 ? 0 : isEncodedDouble(v) ? fromDouble(decodeDouble(v)) : fromInt(v >> 1);\n#endif\n            }\n        }\n\n        if (sect->type == SectionType::ConfigData) {\n            img->numConfigDataEntries = (sect->size - 8) >> 3;\n            img->configData = (int32_t *)sect->data;\n            CHECK(img->configData[(img->numConfigDataEntries - 1) * 2] == 0, 1045);\n        }\n\n        img->sections[idx] = sect;\n\n        if (sect->type == SectionType::Literal) {\n            if (sect->aux == (int)BuiltInType::BoxedString ||\n                sect->aux == (int)BuiltInType::BoxedBuffer) {\n                auto str = (CompiledString *)sect->data;\n                CHECK(sect->size >= str->numbytes + 8 + 4, 1042);\n                auto v = sect->aux == (int)BuiltInType::BoxedString\n                             ? (TValue)mkString(str->utf8data, str->numbytes)\n                             : (TValue)mkBuffer((uint8_t *)str->utf8data, str->numbytes);\n                // registerGCPtr(v);\n                img->pointerLiterals[idx] = v;\n            } else {\n                CHECK(0, 1050);\n            }\n        } else if (sect->type == SectionType::Function || sect->type == SectionType::VTable) {\n            img->pointerLiterals[idx] = (TValue)sect;\n        } else {\n            img->pointerLiterals[idx] = nullptr;\n        }\n\n        idx++;\n    }\n\n    CHECK_AT(img->infoHeader != NULL, 1019, 0);\n    CHECK_AT(img->opcodes != NULL, 1020, 0);\n    CHECK_AT(img->numberLiterals != NULL, 1021, 0);\n    CHECK_AT(img->configData != NULL, 1022, 0);\n\n    return NULL;\n}\n\nstatic VMImage *loadIfaceNames(VMImage *img) {\n    FOR_SECTIONS() {\n        if (sect->type == SectionType::IfaceMemberNames) {\n            uint64_t *ptrs = (uint64_t *)sect->data;\n            uintptr_t *dst = (uintptr_t *)ptrs;\n            img->ifaceMemberNames = dst;\n            auto len = *ptrs++;\n            img->numIfaceMemberNames = (uint32_t)len;\n            *dst++ = len;\n            CHECK(sect->size >= 16 + len * 8, 1047);\n            for (unsigned i = 0; i < len; ++i) {\n                CHECK(ptrs[i] < img->numSections, 1051);\n                auto ss = img->sections[ptrs[i]];\n                CHECK(ss->type == SectionType::Literal &&\n                          (BuiltInType)ss->aux == BuiltInType::BoxedString,\n                      1052);\n                dst[i] = (uintptr_t)img->pointerLiterals[ptrs[i]];\n                // pointers have to be sorted\n                CHECK(i == 0 || dst[i - 1] < dst[i], 1053);\n                // and so strings\n                CHECK(i == 0 || String_::compare((String)dst[i - 1], (String)dst[i]) < 0, 1054);\n            }\n        }\n    }\n\n    return NULL;\n}\n\nvoid validateFunction(VMImage *img, VMImageSection *sect, int debug);\n\nstatic VMImage *validateFunctions(VMImage *img) {\n    FOR_SECTIONS() {\n        if (sect->type == SectionType::VTable) {\n            uint8_t *endp = sect->data + sect->size - 8;\n            auto vt = (VTable *)sect->data;\n            auto multBase = (uint16_t *)&vt->methods[VM_NUM_CPP_METHODS];\n            CHECK((uint8_t *)multBase < endp,\n                  1023); // basic size check, before dereferencing anything\n\n            auto maxMult = 0xffffffffU >> (vt->ifaceHashMult & 0xff);\n\n            CHECK(vt->numbytes < 1024, 1024);\n            CHECK((vt->numbytes & 7) == 0, 1025);\n            CHECK(vt->objectType == ValType::Object, 1026);\n            CHECK(vt->magic == VTABLE_MAGIC, 1027);\n            CHECK(vt->ifaceHashEntries > maxMult + 3, 1028);\n            CHECK((uint8_t *)(multBase + vt->ifaceHashEntries) < endp, 1029);\n            CHECK(vt->reserved == 0, 1030);\n            CHECK(vt->ifaceHashMult != 0, 1031);\n            CHECK((vt->ifaceHashEntries & 3) == 0, 1032);\n            CHECK((int)vt->classNo >= (int)BuiltInType::User0, 1055);\n            CHECK((int)vt->lastClassNo >= (int)vt->classNo, 1056);\n\n            uint32_t maxOff = 0;\n            uint32_t minOff = 0xfffffff;\n            for (unsigned i = 0; i < vt->ifaceHashEntries; ++i) {\n                uint32_t off2 = multBase[i];\n                if (off2 > maxOff)\n                    maxOff = off2;\n                if (off2 < minOff)\n                    minOff = off2;\n                auto ent = (IfaceEntry *)multBase + off2;\n                CHECK((uint8_t *)(ent + 1) <= endp, 1033);\n            }\n\n            CHECK(minOff * sizeof(IfaceEntry) == vt->ifaceHashEntries * 2, 1034);\n\n            auto last1 = (IfaceEntry *)multBase + maxOff + 1;\n            if (last1->memberId != 0)\n                maxOff++;\n\n            for (unsigned i = minOff; i <= maxOff; ++i) {\n                auto ent = (IfaceEntry *)multBase + i;\n                if (ent->memberId == 0)\n                    continue;\n                if (ent->aux == 0) {\n                    CHECK(ent->method < img->numSections, 1037);\n                    auto fn = img->sections[ent->method];\n                    CHECK(fn->type == SectionType::Function, 1039);\n                } else {\n                    CHECK(ent->aux < (vt->numbytes >> 3), 1035);\n                    CHECK(ent->aux == ent->method, 1036);\n                }\n            }\n\n            auto p = (uint8_t *)((IfaceEntry *)multBase + maxOff + 1);\n            while (p < endp)\n                CHECK(*p++ == 0, 1040);\n        }\n\n        if (sect->type == SectionType::Function) {\n            validateFunction(img, sect, 0);\n            if (img->errorCode) {\n                // try again with debug\n                validateFunction(img, sect, 1);\n                return img;\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic VMImage *injectVTables(VMImage *img) {\n    // this is the last FOR_SECTIONS() that will ever work\n    FOR_SECTIONS() {\n        if (sect->type == SectionType::Literal) {\n            switch ((BuiltInType)sect->aux) {\n            case BuiltInType::BoxedString:\n            case BuiltInType::BoxedBuffer:\n                break;\n            default:\n                CHECK(0, 1043);\n                break;\n            }\n        } else if (sect->type == SectionType::Function) {\n            if (!img->entryPoint)\n                img->entryPoint = (RefAction *)sect;\n            ((RefAction *)sect)->vtable = PXT_VTABLE_TO_INT(&RefAction_vtable);\n            ((RefAction *)sect)->func = (ActionCB)((uint8_t *)sect + VM_FUNCTION_CODE_OFFSET);\n        } else if (sect->type == SectionType::VTable) {\n            auto vt = (VTable *)sect->data;\n            vt->methods[0] = (void *)pxt::RefRecord_destroy;\n            vt->methods[1] = (void *)pxt::RefRecord_print;\n            vt->methods[2] = (void *)pxt::RefRecord_scan;\n            vt->methods[3] = (void *)pxt::RefRecord_gcsize;\n        }\n    }\n    return NULL;\n}\n\nVMImage *loadVMImage(void *data, unsigned length) {\n    auto img = new VMImage();\n    memset(img, 0, sizeof(*img));\n\n    DMESG(\"loading image at %p (%d bytes)\", data, length);\n\n    CHECK_AT(ALIGNED((uintptr_t)data), 1000, 0);\n    CHECK_AT(ALIGNED(length), 1001, 0);\n\n    img->dataStart = (uint64_t *)data;\n    img->dataEnd = (uint64_t *)((uint8_t *)data + length);\n\n    if (countSections(img) || loadSections(img) || loadIfaceNames(img) || validateFunctions(img) ||\n        injectVTables(img)) {\n        // error!\n        return img;\n    }\n\n    DMESG(\"image loaded\");\n\n    return img;\n}\n\nvoid unloadVMImage(VMImage *img) {\n    if (!img)\n        return;\n    free(img->dataStart);\n    memset(img, 0, sizeof(*img));\n    delete img;\n}\n\n} // namespace pxt\n",
            "vm.cpp": "#include \"pxt.h\"\n\n// TODO look for patterns in output for combined instructions\n// TODO check for backjumps (how many)\n// TODO getConfig() should have a callback into host\n\n#define SPLIT_ARG(arg0, arg1) unsigned arg0 = arg & 31, arg1 = arg >> 6\n#define SPLIT_ARG2(arg0, arg1) unsigned arg0 = arg & 255, arg1 = arg >> 8\n\n#define PUSH(v) *--ctx->sp = (v)\n#define POPVAL() *ctx->sp++\n#define POP(n) ctx->sp += (n)\n\n//#define TRACE DMESG\n#define TRACE NOLOG\n\nnamespace pxt {\n\n//%\nvoid op_stloc(FiberContext *ctx, unsigned arg) {\n    ctx->sp[arg] = ctx->r0;\n}\n\n//%\nvoid op_ldloc(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = ctx->sp[arg];\n}\n\n//%\nvoid op_ldcap(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = ctx->currAction->fields[arg];\n}\n\n//%\nvoid op_stglb(FiberContext *ctx, unsigned arg) {\n    globals[arg] = ctx->r0;\n}\n\n//%\nvoid op_ldglb(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = globals[arg];\n}\n\n//%\nvoid op_ldlit(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = ctx->img->pointerLiterals[arg];\n}\n\n//%\nvoid op_ldnumber(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = (TValue)ctx->img->numberLiterals[arg];\n}\n\n//%\nvoid op_jmp(FiberContext *ctx, unsigned arg) {\n    ctx->pc += (int)arg;\n}\n\n//%\nvoid op_jmpz(FiberContext *ctx, unsigned arg) {\n    if (!toBoolQuick(ctx->r0))\n        ctx->pc += (int)arg;\n}\n\n//%\nvoid op_jmpnz(FiberContext *ctx, unsigned arg) {\n    if (toBoolQuick(ctx->r0))\n        ctx->pc += (int)arg;\n}\n\nstatic inline VTable *getStaticVTable(VMImage *img, unsigned classId) {\n    return (VTable *)((uintptr_t)img->pointerLiterals[classId] + 8);\n}\n\n//%\nvoid op_newobj(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = (TValue)pxt::mkClassInstance(getStaticVTable(ctx->img, arg));\n}\n\nstatic inline void checkClass(FiberContext *ctx, TValue obj, unsigned classId, unsigned fldId) {\n    TRACE(\"check class: %p cl=%d f=%d\", obj, classId, fldId);\n    if (!isPointer(obj))\n        failedCast(obj);\n    auto vt = getVTable((RefObject *)obj);\n    auto vt2 = getStaticVTable(ctx->img, classId);\n    if (vt == vt2)\n        return;\n    if ((int)vt2->classNo <= (int)vt->classNo && (int)vt->classNo <= (int)vt2->lastClassNo) {\n        // double check field range - we don't really check class sequence numbers\n        if (8 + fldId * 8 >= vt->numbytes)\n            failedCast(obj);\n    }\n}\n\n//%\nvoid op_ldfld(FiberContext *ctx, unsigned arg) {\n    SPLIT_ARG2(fldId, classId);\n    auto obj = ctx->r0;\n    checkClass(ctx, obj, classId, fldId);\n    ctx->r0 = ((RefRecord *)obj)->fields[fldId];\n}\n\n//%\nvoid op_stfld(FiberContext *ctx, unsigned arg) {\n    SPLIT_ARG2(fldId, classId);\n    auto obj = POPVAL();\n    checkClass(ctx, obj, classId, fldId);\n    ((RefRecord *)obj)->fields[fldId] = ctx->r0;\n}\n\nstatic inline void runAction(FiberContext *ctx, RefAction *ra) {\n    if (ctx->sp < ctx->stackLimit)\n        error(PANIC_STACK_OVERFLOW);\n\n    PUSH((TValue)ctx->currAction);\n    PUSH(VM_ENCODE_PC(ctx->pc - ctx->imgbase));\n    ctx->currAction = ra;\n    ctx->pc = (uint16_t *)ra->func;\n}\n\n//%\nvoid op_callproc(FiberContext *ctx, unsigned arg) {\n    runAction(ctx, (RefAction *)ctx->img->pointerLiterals[arg]);\n}\n\nstatic void callind(FiberContext *ctx, RefAction *ra, unsigned numArgs) {\n    if (numArgs != ra->numArgs) {\n        int missing = ra->numArgs - numArgs;\n        TRACE(\"callind missing=%d\", missing);\n        if (missing < 0) {\n            // just drop the ones on top\n            POP(-missing);\n        } else {\n            // add some undefineds\n            while (missing--)\n                PUSH(TAG_UNDEFINED);\n        }\n    }\n\n    if (ra->initialLen != ra->len)\n        // trying to call function template\n        error(PANIC_INVALID_VTABLE);\n\n    runAction(ctx, ra);\n}\n\n//%\nvoid op_callind(FiberContext *ctx, unsigned arg) {\n    auto fn = ctx->r0;\n    if (!isPointer(fn))\n        failedCast(fn);\n    auto vt = getVTable((RefObject *)fn);\n    if (vt->objectType != ValType::Function)\n        failedCast(fn);\n\n    callind(ctx, (RefAction *)fn, arg);\n}\n\n//%\nvoid op_ret(FiberContext *ctx, unsigned arg) {\n    SPLIT_ARG(retNumArgs, numTmps);\n\n    // check if we're leaving a function that still has open try blocks\n    // (this results from invalid code generation)\n    if (ctx->tryFrame && ctx->tryFrame->registers[0] == (uintptr_t)ctx->currAction) {\n        DMESG(\"try frame %p left on return\", ctx->tryFrame);\n        target_panic(PANIC_VM_ERROR);\n    }\n\n    POP(numTmps);\n    auto retaddr = (intptr_t)POPVAL();\n    ctx->currAction = (RefAction *)POPVAL();\n    POP(retNumArgs);\n\n    if (retaddr == (intptr_t)TAG_STACK_BOTTOM) {\n        ctx->pc = NULL;\n    } else {\n        ctx->pc = ctx->imgbase + VM_DECODE_PC(retaddr);\n    }\n}\n\n//%\nvoid op_pop(FiberContext *ctx, unsigned) {\n    ctx->r0 = POPVAL();\n}\n\n//%\nvoid op_popmany(FiberContext *ctx, unsigned arg) {\n    POP(arg);\n}\n\n//%\nvoid op_pushmany(FiberContext *ctx, unsigned arg) {\n    while (arg--) {\n        PUSH(TAG_UNDEFINED);\n    }\n}\n\n//%\nvoid op_push(FiberContext *ctx, unsigned) {\n    PUSH(ctx->r0);\n}\n\n//%\nvoid op_ldspecial(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = (TValue)(uintptr_t)arg;\n}\n\n//%\nvoid op_ldint(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = TAG_NUMBER(arg);\n}\n\n//%\nvoid op_ldintneg(FiberContext *ctx, unsigned arg) {\n    ctx->r0 = TAG_NUMBER(-(int)arg);\n}\n\nTryFrame *beginTry();\n\n//%\nvoid op_try(FiberContext *ctx, unsigned arg) {\n    auto f = pxt::beginTry();\n    f->registers[0] = (uintptr_t)ctx->currAction;\n    f->registers[1] = (uintptr_t)(ctx->pc + (int)arg);\n    f->registers[2] = (uintptr_t)ctx->sp;\n}\n\nvoid restoreVMExceptionState(TryFrame *tf, FiberContext *ctx) {\n    // TODO verification\n    ctx->currAction = (RefAction *)tf->registers[0];\n    ctx->pc = (uint16_t *)tf->registers[1];\n    ctx->sp = (TValue *)tf->registers[2];\n    longjmp(ctx->loopjmp, 1);\n}\n\nstatic TValue lookupIfaceMember(TValue obj, VTable *vt, unsigned ifaceIdx) {\n    uint32_t mult = vt->ifaceHashMult;\n    uint32_t off = (ifaceIdx * mult) >> (mult & 0xff);\n\n    unsigned n = 3;\n    auto multBase = (uint16_t *)&vt->methods[VM_NUM_CPP_METHODS];\n    while (n--) {\n        uint32_t off2 = multBase[off];\n        auto ent = (struct IfaceEntry *)multBase + off2;\n\n        if (ent->memberId == ifaceIdx) {\n            if (ent->aux == 0) {\n                return vmImg->pointerLiterals[ent->method];\n            } else {\n                return ((RefRecord *)obj)->fields[ent->aux - 1];\n            }\n        }\n        off++;\n    }\n\n    return NULL;\n}\n\nstatic inline void callifaceCore(FiberContext *ctx, unsigned numArgs, unsigned ifaceIdx,\n                                 int getset) {\n    auto obj = ctx->sp[numArgs - 1];\n    if (!isPointer(obj))\n        failedCast(obj);\n    auto vt = getVTable((RefObject *)obj);\n    uint32_t mult = vt->ifaceHashMult;\n\n    if (!mult) {\n        if (vt->classNo == BuiltInType::RefMap) {\n            if (getset == 2) {\n                pxtrt::mapSet((RefMap *)obj, ifaceIdx, ctx->sp[0]);\n                POP(2); // and pop arguments\n            } else {\n                ctx->r0 = pxtrt::mapGet((RefMap *)obj, ifaceIdx);\n                if (getset == 0) {\n                    op_callind(ctx, numArgs);\n                } else {\n                    POP(1);\n                }\n            }\n            return;\n        }\n        missingProperty(obj);\n    }\n    uint32_t off = (ifaceIdx * mult) >> (mult & 0xff);\n\n    unsigned n = 3;\n    auto multBase = (uint16_t *)&vt->methods[VM_NUM_CPP_METHODS];\n    while (n--) {\n        uint32_t off2 = multBase[off];\n        auto ent = (struct IfaceEntry *)multBase + off2;\n\n        if (ent->memberId == ifaceIdx) {\n            if (ent->aux == 0) {\n                if (getset == 2) {\n                    ent++;\n                    if (ent->memberId != ifaceIdx)\n                        missingProperty(obj);\n                }\n                auto fn = ctx->img->pointerLiterals[ent->method];\n                callind(ctx, (RefAction *)fn, numArgs);\n            } else {\n                if (getset == 2) {\n                    // store field\n                    ((RefRecord *)obj)->fields[ent->aux - 1] = ctx->sp[0];\n                    POP(2); // and pop arguments\n                } else {\n                    // load field\n                    ctx->r0 = ((RefRecord *)obj)->fields[ent->aux - 1];\n                    if (getset == 0) {\n                        // and call\n                        op_callind(ctx, numArgs);\n                    } else {\n                        // if just loading, pop the object arg\n                        POP(1);\n                    }\n                }\n            }\n\n            return;\n        }\n        off++;\n    }\n\n    if (getset == 1) {\n        ctx->sp += 1; // pop object arg\n        ctx->r0 = TAG_UNDEFINED;\n    } else {\n        missingProperty(obj);\n    }\n}\n\n//%\nvoid op_calliface(FiberContext *ctx, unsigned arg) {\n    SPLIT_ARG(numArgs, ifaceIdx);\n    callifaceCore(ctx, numArgs, ifaceIdx, 0);\n}\n\n//%\nvoid op_callget(FiberContext *ctx, unsigned arg) {\n    callifaceCore(ctx, 1, arg, 1);\n}\n\n//%\nvoid op_callset(FiberContext *ctx, unsigned arg) {\n    callifaceCore(ctx, 2, arg, 2);\n}\n\n//%\nvoid op_mapget(FiberContext *ctx, unsigned arg) {\n    auto obj = ctx->sp[0];\n    if (!isPointer(obj))\n        failedCast(obj);\n    auto vt = getVTable((RefObject *)obj);\n    auto key = numops::toString(ctx->r0);\n    if (vt->classNo == BuiltInType::RefMap) {\n        ctx->r0 = pxtrt::mapGetByString((RefMap *)obj, key);\n        POP(1);\n    } else {\n        int k = pxtrt::lookupMapKey(key);\n        if (k == 0) {\n            POP(1);\n            ctx->r0 = TAG_UNDEFINED;\n        } else {\n            callifaceCore(ctx, 1, k, 1);\n        }\n    }\n}\n\n//%\nvoid op_mapset(FiberContext *ctx, unsigned arg) {\n    auto obj = ctx->sp[1];\n    if (!isPointer(obj))\n        failedCast(obj);\n    auto vt = getVTable((RefObject *)obj);\n    auto key = numops::toString(ctx->sp[0]);\n    ctx->sp[0] = (TValue)key; // save it, so it doesn't get GCed\n    if (vt->classNo == BuiltInType::RefMap) {\n        pxtrt::mapSetByString((RefMap *)obj, key, ctx->r0);\n        POP(2);\n    } else {\n        int k = pxtrt::lookupMapKey(key);\n        if (k == 0) {\n            missingProperty(obj);\n        } else {\n            ctx->sp[0] = ctx->r0;\n            callifaceCore(ctx, 2, k, 2);\n        }\n    }\n}\n\n//%\nvoid op_checkinst(FiberContext *ctx, unsigned arg) {\n    auto obj = ctx->r0;\n    ctx->r0 = TAG_FALSE;\n\n    if (isPointer(obj)) {\n        auto vt2 = getStaticVTable(ctx->img, arg);\n        auto vt = getVTable((RefObject *)obj);\n        if (vt == vt2)\n            ctx->r0 = TAG_TRUE;\n        else if ((int)vt2->classNo <= (int)vt->classNo && (int)vt->classNo <= (int)vt2->lastClassNo)\n            ctx->r0 = TAG_TRUE;\n    }\n}\n\nstatic TValue inlineInvoke(FiberContext *ctx, RefAction *fn, int numArgs) {\n    auto prevPC = ctx->pc;\n    auto prevR0 = ctx->r0;\n    // make sure call will push TAG_STACK_BOTTOM\n    ctx->pc = (uint16_t *)ctx->imgbase + 1;\n    callind(ctx, fn, numArgs);\n    exec_loop(ctx);\n    if (ctx->resumePC)\n        target_panic(PANIC_BLOCKING_TO_STRING);\n    auto r = ctx->r0;\n    ctx->pc = prevPC;\n    ctx->r0 = prevR0;\n    return r;\n}\n\nString convertToString(FiberContext *ctx, TValue v) {\n    if (isPointer(v)) {\n        auto vt = getVTable((RefObject *)v);\n        if ((int)vt->classNo >= (int)BuiltInType::User0) {\n            auto img = ctx->img;\n            if (!img->toStringKey) {\n                img->toStringKey = pxtrt::lookupMapKey(mkString(\"toString\"));\n                if (!img->toStringKey)\n                    img->toStringKey = -1;\n            }\n            if (img->toStringKey > 0) {\n                auto fn = lookupIfaceMember(v, vt, img->toStringKey);\n                if (fn && isPointer(fn) &&\n                    getVTable((RefObject *)fn)->objectType == ValType::Function) {\n                    PUSH(v);\n                    v = inlineInvoke(ctx, (RefAction *)fn, 1);\n                    PUSH(v); // make sure it doesn't get collected\n                }\n            }\n        }\n    }\n\n    auto rr = numops::toString(v);\n    if ((TValue)rr != v)\n        PUSH((TValue)rr); // make sure it doesn't get collected\n\n    return rr;\n}\n\nvoid exec_loop(FiberContext *ctx) {\n    if (ctx->img->execLock) {\n        DMESG(\"image locked!\");\n        target_panic(PANIC_VM_ERROR);\n    }\n    ctx->img->execLock = 1;\n    auto opcodes = ctx->img->opcodes;\n    setjmp(ctx->loopjmp);\n    while (ctx->pc) {\n        if (panicCode)\n            break;\n        uint16_t opcode = *ctx->pc++;\n        TRACE(\"0x%x: %04x %d\", (uint8_t *)ctx->pc - 2 - (uint8_t *)ctx->img->dataStart, opcode,\n              (int)(ctx->stackBase + VM_STACK_SIZE - ctx->sp));\n        if (opcode >> 15 == 0) {\n            opcodes[opcode & VM_OPCODE_BASE_MASK](ctx, opcode >> VM_OPCODE_ARG_POS);\n            if (opcode & VM_OPCODE_PUSH_MASK)\n                PUSH(ctx->r0);\n        } else if (opcode >> 14 == 0b10) {\n            ((ApiFun)opcodes[opcode & 0x1fff])(ctx);\n            if (opcode & VM_RTCALL_PUSH_MASK)\n                PUSH(ctx->r0);\n        } else {\n            unsigned tmp = ((int32_t)opcode << (16 + 2)) >> (2 + VM_OPCODE_ARG_POS);\n            opcode = *ctx->pc++;\n            opcodes[opcode & VM_OPCODE_BASE_MASK](ctx, (opcode >> VM_OPCODE_ARG_POS) + tmp);\n            if (opcode & VM_OPCODE_PUSH_MASK)\n                PUSH(ctx->r0);\n        }\n    }\n    ctx->img->execLock = 0;\n}\n\n} // namespace pxt\n\n//\n// Verification\n//\n\nnamespace pxt {\n\n// 1251\n#define FNERR(errcode)                                                                             \\\n    do {                                                                                           \\\n        setVMImgError(img, errcode, &code[pc]);                                                    \\\n        return;                                                                                    \\\n    } while (0)\n#define FORCE_STACK(v, errcode, pc)                                                                \\\n    do {                                                                                           \\\n        if (stackDepth[pc] && stackDepth[pc] != v)                                                 \\\n            FNERR(errcode);                                                                        \\\n        stackDepth[pc] = v;                                                                        \\\n    } while (0)\n\nvoid validateFunction(VMImage *img, VMImageSection *sect, int debug) {\n    uint16_t stackDepth[sect->size / 2];\n    memset(stackDepth, 0, sizeof(stackDepth));\n    int baseStack = 1; // 1 is the return address; also zero in the array above means unknown yet\n    int currStack = baseStack;\n    unsigned pc = 0;\n    auto code = (uint16_t *)((uint8_t *)sect + VM_FUNCTION_CODE_OFFSET);\n    auto lastPC = (sect->size - VM_FUNCTION_CODE_OFFSET) >> 1;\n    auto atEnd = false;\n\n    RefAction *ra = (RefAction *)sect;\n\n    unsigned numArgs = ra->numArgs;\n    unsigned numCaps = ra->initialLen;\n\n    if (numCaps > 200)\n        FNERR(1239);\n\n    while (pc < lastPC) {\n        if (currStack > VM_MAX_FUNCTION_STACK)\n            FNERR(1204);\n\n        FORCE_STACK(currStack, 1201, pc);\n\n        uint16_t opcode = code[pc++];\n        if (opcode == 0 && atEnd)\n            continue; // allow padding at the end\n\n        atEnd = false;\n        OpFun fn;\n        unsigned arg;\n        unsigned opIdx;\n        bool isRtCall = false;\n        bool hasPush = false;\n\n        if (opcode >> 15 == 0) {\n            opIdx = opcode & VM_OPCODE_BASE_MASK;\n            arg = opcode >> VM_OPCODE_ARG_POS;\n            hasPush = !!(opcode & VM_OPCODE_PUSH_MASK);\n        } else if (opcode >> 14 == 0b10) {\n            opIdx = opcode & 0x1fff;\n            arg = 0;\n            isRtCall = true;\n            hasPush = !!(opcode & VM_RTCALL_PUSH_MASK);\n        } else {\n            unsigned tmp = ((int32_t)opcode << (16 + 2)) >> (2 + VM_OPCODE_ARG_POS);\n            FORCE_STACK(0xffff, 1200, pc); // cannot jump here!\n            opcode = code[pc++];\n            opIdx = opcode & VM_OPCODE_BASE_MASK;\n            arg = (opcode >> VM_OPCODE_ARG_POS) + tmp;\n            hasPush = !!(opcode & VM_OPCODE_PUSH_MASK);\n        }\n\n        if (opIdx >= img->numOpcodes)\n            FNERR(1227);\n        auto opd = img->opcodeDescs[opIdx];\n\n        if (debug)\n            DMESG(\"%4d/%d -> %04x idx=%d arg=%d st=%d %s\", pc, lastPC, opcode, opIdx, arg,\n                  currStack, opd ? opd->name : \"NA\");\n\n        if (!opd)\n            FNERR(1228);\n\n        fn = img->opcodes[opIdx];\n\n        if (isRtCall) {\n            if (opd->numArgs > 1) {\n                currStack -= opd->numArgs - 1;\n                if (currStack < baseStack)\n                    FNERR(1229);\n            }\n        } else if (fn == op_pushmany) {\n            if (currStack == 1 && baseStack == 1)\n                baseStack = currStack = arg + 1;\n            else\n                currStack += arg;\n        } else if (fn == op_popmany) {\n            currStack -= arg;\n            if (currStack < baseStack)\n                FNERR(1205);\n        } else if (fn == op_push) {\n            currStack++;\n        } else if (fn == op_pop) {\n            if (arg)\n                FNERR(1243);\n            currStack--;\n            if (currStack < baseStack)\n                FNERR(1206);\n        } else if (fn == op_mapget) {\n            if (arg)\n                FNERR(1244);\n            currStack--;\n            if (currStack < baseStack)\n                FNERR(1245);\n        } else if (fn == op_mapset) {\n            if (arg)\n                FNERR(1246);\n            currStack -= 2;\n            if (currStack < baseStack)\n                FNERR(1247);\n        } else if (fn == op_ret) {\n            SPLIT_ARG(retNumArgs, numTmps);\n            if (currStack != baseStack)\n                FNERR(1207);\n            if (numTmps + 1 != (unsigned)baseStack)\n                FNERR(1208);\n            if (retNumArgs != numArgs)\n                FNERR(1209);\n            currStack = baseStack;\n            atEnd = true;\n        } else if (fn == op_ldloc || fn == op_stloc) {\n            if (arg == (unsigned)currStack - 1 || arg == (unsigned)currStack)\n                FNERR(1210); // trying to load return address/function\n            if (arg > (unsigned)currStack + numArgs)\n                FNERR(1211);\n        } else if (fn == op_ldcap) {\n            if (arg >= numCaps)\n                FNERR(1212);\n        } else if (fn == op_ldglb || fn == op_stglb) {\n            if (arg >= img->infoHeader->allocGlobals)\n                FNERR(1213);\n            // not supported (yet?)\n            if (arg < img->infoHeader->nonPointerGlobals)\n                FNERR(1214);\n        } else if (fn == op_ldfld || fn == op_stfld) {\n            SPLIT_ARG2(fldId, classId);\n\n            if (classId >= img->numSections)\n                FNERR(1236);\n            auto fsec = img->sections[classId];\n            if (fsec->type != SectionType::VTable)\n                FNERR(1234);\n\n            auto vt = getStaticVTable(img, classId);\n            if (fldId * 8 + 8 >= vt->numbytes)\n                FNERR(1235);\n\n            if (fn == op_stfld) {\n                currStack--;\n                if (currStack < baseStack)\n                    FNERR(1232);\n            }\n        } else if (fn == op_ldlit) {\n            if (arg >= img->numSections)\n                FNERR(1215);\n            auto fsec = img->sections[arg];\n            if (fsec->type != SectionType::Literal && fsec->type != SectionType::Function)\n                FNERR(1237);\n        } else if (fn == op_newobj || fn == op_checkinst) {\n            if (arg >= img->numSections)\n                FNERR(1219);\n            auto fsec = img->sections[arg];\n            if (fsec->type != SectionType::VTable)\n                FNERR(1238);\n        } else if (fn == op_ldnumber) {\n            if (arg >= img->numNumberLiterals)\n                FNERR(1217);\n        } else if (fn == op_callproc) {\n            if (arg >= img->numSections)\n                FNERR(1218);\n            auto fsec = img->sections[arg];\n            if (fsec->type != SectionType::Function)\n                FNERR(1220);\n            unsigned calledArgs = ((RefAction *)fsec)->numArgs;\n            currStack -= calledArgs;\n            if (currStack < baseStack)\n                FNERR(1221);\n        } else if (fn == op_callind) {\n            currStack -= arg;\n            if (currStack < baseStack)\n                FNERR(1223);\n        } else if (fn == op_calliface) {\n            SPLIT_ARG(numArgs, ifaceIdx);\n            if (ifaceIdx == 0 || ifaceIdx >= img->numIfaceMemberNames)\n                FNERR(1240);\n            currStack -= numArgs;\n            if (currStack < baseStack)\n                FNERR(1230);\n        } else if (fn == op_callget) {\n            if (arg == 0 || arg >= img->numIfaceMemberNames)\n                FNERR(1241);\n            currStack -= 1;\n            if (currStack < baseStack)\n                FNERR(1230);\n        } else if (fn == op_callset) {\n            if (arg == 0 || arg >= img->numIfaceMemberNames)\n                FNERR(1242);\n            currStack -= 2;\n            if (currStack < baseStack)\n                FNERR(1230);\n        } else if (fn == op_ldspecial) {\n            auto a = (TValue)(uintptr_t)arg;\n            if (a != TAG_TRUE && a != TAG_FALSE && a != TAG_UNDEFINED && a != TAG_NULL &&\n                a != TAG_NAN)\n                FNERR(1224);\n        } else if (fn == op_ldint || fn == op_ldintneg) {\n            // nothing to check!\n        } else if (fn == op_jmp || fn == op_jmpnz || fn == op_jmpz) {\n            unsigned newPC = pc + arg; // will overflow for backjump, but this is fine\n            if (newPC >= lastPC)\n                FNERR(1202);\n            FORCE_STACK(currStack, 1226, newPC);\n            if (fn == op_jmp) {\n                if (currStack != baseStack)\n                    FNERR(1203);\n                atEnd = true;\n            }\n        } else if (fn == op_try) {\n            unsigned newPC = pc + arg; // will overflow for backjump, but this is fine\n            if (newPC >= lastPC)\n                FNERR(1248);\n            if (currStack != baseStack)\n                FNERR(1249);\n            FORCE_STACK(currStack, 1250, newPC);\n        } else {\n            FNERR(1225);\n        }\n\n        if (hasPush)\n            currStack++;\n    }\n\n    if (!atEnd) {\n        pc--;\n        FNERR(1210);\n    }\n}\n\n} // namespace pxt",
            "vm.h": "#ifndef _PXT_VM_H\n#define _PXT_VM_H\n\n#include <pthread.h>\n#include <setjmp.h>\n\n#define VM_MAGIC0 0x000a34365458500aULL // \\nPXT64\\n\\0\n#define VM_MAGIC1 0x6837215e2bfe7154ULL\n\n#define VM_OPCODE_BASE_SIZE 6 // up to 63 base opcodes\n#define VM_OPCODE_PUSH_MASK (1 << VM_OPCODE_BASE_SIZE)\n#define VM_OPCODE_ARG_POS (VM_OPCODE_BASE_SIZE + 1)\n#define VM_OPCODE_BASE_MASK ((1 << VM_OPCODE_BASE_SIZE) - 1)\n#define VM_FIRST_RTCALL (VM_OPCODE_BASE_MASK + 1)\n#define VM_RTCALL_PUSH_MASK 0x2000\n\n#define VM_FUNCTION_CODE_OFFSET 24\n\n// The binary has space for 4 64 bit pointers, so on 32 bit machines we pretend there is 8 of them\n#ifdef PXT32\n#define VM_NUM_CPP_METHODS 8\n#else\n#define VM_NUM_CPP_METHODS 4\n#endif\n\n// maximum size (in words) of stack in a single function\n#define VM_MAX_FUNCTION_STACK 200\n#define VM_STACK_SIZE 1000\n\n#define VM_ENCODE_PC(pc) ((TValue)(((pc) << 9) | 2))\n#define VM_DECODE_PC(pc) (((uintptr_t)pc) >> 9)\n#define TAG_STACK_BOTTOM VM_ENCODE_PC(1)\n\n#define PXTEXT extern\n#ifdef __MINGW32__\n#define DLLEXPORT PXTEXT \"C\"\n#else\n#define DLLEXPORT PXTEXT \"C\"\n#endif\n\nnamespace pxt {\n\nstruct FiberContext;\ntypedef void (*OpFun)(FiberContext *ctx, unsigned arg);\ntypedef void (*ApiFun)(FiberContext *ctx);\n\n// keep in sync with backvm.ts\nenum class SectionType : uint8_t {\n    Invalid = 0x00,\n\n    // singular sections\n    InfoHeader = 0x01,       // VMImageHeader\n    OpCodeMap = 0x02,        // \\0-terminated names of opcodes and APIs (shims)\n    NumberLiterals = 0x03,   // array of boxed doubles and ints\n    ConfigData = 0x04,       // sorted array of pairs of int32s; zero-terminated\n    IfaceMemberNames = 0x05, // array of 32 bit offsets, that point to string literals\n\n    // repetitive sections\n    Function = 0x20,\n    Literal = 0x21, // aux field contains literal type (string, hex, image, ...)\n    VTable = 0x22,\n};\n\nstruct VMImageSection {\n    SectionType type;\n    uint8_t flags;\n    uint16_t aux;\n    uint32_t size; // in bytes, including this header\n    uint8_t data[0];\n};\n\nstatic inline VMImageSection * vmNextSection(VMImageSection *sect) {\n    return (VMImageSection *)((uint8_t *)sect + sect->size);\n}\n\nSTATIC_ASSERT(sizeof(VMImageSection) == 8);\n\nstruct OpcodeDesc {\n    const char *name;\n    OpFun fn;\n    int numArgs;\n};\n\nstruct IfaceEntry {\n    uint16_t memberId;\n    uint16_t aux;\n    uint32_t method;\n};\n\nextern const OpcodeDesc staticOpcodes[];\n\nstruct VMImageHeader {\n    uint64_t magic0;\n    uint64_t magic1;\n    uint64_t hexHash;\n    uint64_t programHash;\n\n    uint32_t allocGlobals;\n    uint32_t nonPointerGlobals;\n\n    uint64_t lastUsageTime;\n    uint64_t installationTime;\n    uint64_t publicationTime;\n    uint8_t reserved[64];\n    uint8_t name[128];\n};\n\nstruct VMImage {\n    TValue *numberLiterals;\n    TValue *pointerLiterals;\n    OpFun *opcodes;\n    int32_t *configData;\n    uintptr_t *ifaceMemberNames;\n\n    uint64_t *dataStart, *dataEnd;\n    VMImageSection **sections;\n    VMImageHeader *infoHeader;\n    const OpcodeDesc **opcodeDescs;\n    RefAction *entryPoint;\n\n    uint32_t numSections;\n    uint32_t numNumberLiterals;\n    uint32_t numConfigDataEntries;\n    uint32_t numOpcodes;\n    uint32_t numIfaceMemberNames;\n    uint32_t errorCode;\n    uint32_t errorOffset;\n    int toStringKey;\n\n    int execLock;\n};\n\n// not doing this, likely\nstruct StackFrame {\n    StackFrame *caller;\n    uint32_t *retPC;\n    TValue *stackBase;\n    uint32_t *fnbase;\n};\n\nstruct FiberContext {\n    FiberContext *next;\n\n    uint16_t *imgbase;\n    VMImage *img;\n    uint16_t *pc;\n    uint16_t *resumePC;\n    uint16_t *foreverPC;\n    TValue *sp;\n    TValue r0;\n    RefAction *currAction;\n\n    TryFrame *tryFrame;\n    TValue thrownValue;\n    jmp_buf loopjmp;\n\n    TValue *stackBase;\n    TValue *stackLimit;\n\n    // wait_for_event\n    int waitSource;\n    int waitValue;\n\n    // for sleep\n    uint64_t wakeTime;\n};\n\n\n#define PXT_EXN_CTX() currentFiber\n\nvoid restoreVMExceptionState(TryFrame *tf, FiberContext *ctx);\n#define pxt_restore_exception_state restoreVMExceptionState\n\nextern VMImage *vmImg;\nextern FiberContext *currentFiber;\nextern volatile int panicCode;\n\nvoid vmStart();\nVMImage *loadVMImage(void *data, unsigned length);\nvoid unloadVMImage(VMImage *img);\nVMImage *setVMImgError(VMImage *img, int code, void *pos);\nvoid exec_loop(FiberContext *ctx);\nvoid vmStartFromUser(const char *fn);\n\n#define DEF_CONVERSION(retp, tp, btp)                                                              \\\n    static inline retp tp(TValue v) {                                                              \\\n        if (!isPointer(v))                                                                         \\\n            failedCast(v);                                                                         \\\n        if (getVTable((RefObject *)v)->classNo != btp)                                             \\\n            failedCast(v);                                                                         \\\n        return (retp)v;                                                                            \\\n    }\n\nDEF_CONVERSION(RefCollection *, asRefCollection, BuiltInType::RefCollection)\nDEF_CONVERSION(RefAction *, asRefAction, BuiltInType::RefAction)\nDEF_CONVERSION(RefRefLocal *, asRefRefLocal, BuiltInType::RefRefLocal)\nDEF_CONVERSION(RefMap *, asRefMap, BuiltInType::RefMap)\n\nDEF_CONVERSION(Buffer, asBuffer, BuiltInType::BoxedBuffer)\nDEF_CONVERSION(Image_, asImage_, BuiltInType::RefImage)\n\nString convertToString(FiberContext *ctx, TValue v);\n\n} // namespace pxt\n\n#endif",
            "vmcache.cpp": "#include \"pxt.h\"\n#include <dirent.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <time.h>\n\nnamespace vmcache {\n\nstatic char *dataPath;\n\n#define OFFSET_OF(structName, field) ((uintptr_t)(&((structName *)NULL)->field) - (uintptr_t)NULL)\n\nstruct FullHeader {\n    VMImageSection sect;\n    VMImageHeader header;\n};\n\n\nstatic char *scriptPath(const char *scriptId) {\n    for (auto p = scriptId; *p; ++p)\n        if (!isalnum(*p) && *p != '-' && *p != '_') {\n            dmesg(\"invalid scriptId: %s at '%c'\", scriptId, *p);\n            return NULL;\n        }\n    auto baseLen = strlen(dataPath);\n    auto idLen = strlen(scriptId);\n    auto pathBuf = (char *)malloc(baseLen + 20 + idLen);\n    strcpy(pathBuf, dataPath);\n    strcat(pathBuf, \"/scripts-v0\");\n    if (*scriptId) {\n        strcat(pathBuf, \"/\");\n        strcat(pathBuf, scriptId);\n    }\n    return pathBuf;\n}\n\nDLLEXPORT void pxt_vm_set_data_directory(const char *path) {\n    free(dataPath);\n    dataPath = strdup(path);\n    dmesg(\"set vm cached dir %s\", dataPath);\n}\n\nint checkCache(const char *scriptId, bool updateTimestamp = true) {\n    auto pathBuf = scriptPath(scriptId);\n    if (!pathBuf)\n        return 0;\n    auto fh = fopen(pathBuf, updateTimestamp ? \"r+b\" : \"rb\");\n    free(pathBuf);\n    dmesg(\"cache %s for %s\", fh ? \"hit\" : \"miss\", scriptId);\n    if (fh) {\n        if (updateTimestamp) {\n            fseek(fh, OFFSET_OF(FullHeader, header.lastUsageTime), SEEK_SET);\n            int64_t now = time(NULL);\n            fwrite(&now, 1, 8, fh);\n        }\n        fclose(fh);\n        return 1;\n    }\n    return 0;\n}\n\nDLLEXPORT int pxt_vm_cache_hit(const char *scriptId) {\n    return checkCache(scriptId, false);\n}\n\nstatic int isValidHeader(FullHeader *fh) {\n    auto hd = &fh->header;\n    return fh->sect.type == SectionType::InfoHeader && fh->sect.size >= sizeof(FullHeader) &&\n           hd->magic0 == VM_MAGIC0 && hd->magic1 == VM_MAGIC1;\n}\n\nstatic int readHeader(const char *filepath, FullHeader *fh) {\n    memset(fh, 0, sizeof(*fh));\n    if (!filepath)\n        return 0;\n\n    auto fp = fopen(filepath, \"rb\");\n    int sz = 0;\n    if (fp != NULL) {\n        sz = (int)fread(fh, 1, sizeof(*fh), fp);\n        fclose(fp);\n    }\n    if (sz <= (int)sizeof(*fh))\n        return 0;\n    return 1;\n}\n\nstatic const char *readEntry(DIR *dp, FullHeader *hd) {\n    if (!dp)\n        return NULL;\n\n    for (;;) {\n        struct dirent *de = readdir(dp);\n        if (!de) {\n            closedir(dp);\n            return NULL;\n        }\n\n        if (de->d_name[0] == '.')\n            continue;\n\n        auto filepath = scriptPath(de->d_name);\n        readHeader(filepath, hd);\n        free(filepath);\n\n        if (!isValidHeader(hd))\n            continue;\n\n        hd->header.name[127] = 0; // make sure it's NUL terminated\n\n        return de->d_name;\n    }\n}\n\nstatic DIR *openCacheDir() {\n    auto dirpath = scriptPath(\"\");\n    auto dp = opendir(dirpath);\n    free(dirpath);\n    return dp;\n}\n\nstatic bool nameExists(const char *name) {\n    auto dp = openCacheDir();\n    FullHeader fh;\n    for (;;) {\n        if (!readEntry(dp, &fh))\n            break;\n        if (strcmp(name, (char*)fh.header.name) == 0)\n            return true;\n    }\n    return false;\n}\n\n//%\nRefCollection *list() {\n    auto res = Array_::mk();\n    registerGCObj(res);\n\n    auto dp = openCacheDir();\n    FullHeader fh;\n    for (;;) {\n        auto id = readEntry(dp, &fh);\n        if (!id)\n            break;\n        char buf[1024];\n        for (auto p = fh.header.name; *p; p++) {\n            if (*p == '\\\"' || *p < 32)\n                *p = '_';\n        }\n        snprintf(buf, 1023,\n                 \"{ \\\"id\\\": \\\"%s\\\", \\\"pubTime\\\": %lld, \\\"installTime\\\": %lld, \\\"usageTime\\\": %lld, \"\n                 \"\\\"name\\\": \\\"%s\\\" }\",\n                 id, fh.header.publicationTime, fh.header.installationTime, fh.header.lastUsageTime,\n                 fh.header.name);\n        auto str = mkString(buf, -1);\n        registerGCObj(str);\n        Array_::push(res, (TValue)str);\n        unregisterGCObj(str);\n    }\n\n    unregisterGCObj(res);\n    return res;\n}\n\nstatic int renameImage(uint8_t *data, int len) {\n    FullHeader *fh = (FullHeader *)data;\n    if (len < (int)sizeof(FullHeader))\n        return -1;\n    if (!isValidHeader(fh))\n        return -2;\n    fh->header.installationTime = (int64_t)time(NULL);\n    auto name = (char*)fh->header.name;\n    name[101] = 0; // make sure we have space at the end\n    dmesg(\"rename image from '%s'\", name);\n    if (nameExists(name)) {\n        int namelen = (int)strlen(name);\n        for (int i = 2; i <= 99; ++i) {\n            snprintf(name + namelen, 6, \" (%d)\", i);\n            if (!nameExists(name))\n                break;\n        }\n        dmesg(\"renamed to '%s'\", name);\n    } else {\n        dmesg(\"rename not needed\");\n    }\n    return 0;\n}\n\nDLLEXPORT int pxt_vm_save_in_cache(const char *scriptId, uint8_t *data, int len) {\n    if (!dataPath || len < 256)\n        return -1;\n    auto dp = scriptPath(\"\");\n#ifdef __WIN32__\n    mkdir(dp);\n#else\n    mkdir(dp, 0777);\n#endif\n    free(dp);\n    auto pathBuf = scriptPath(scriptId);\n    if (!pathBuf)\n        return -3;\n    if (renameImage(data, len))\n        return -4;\n    auto fh = fopen(pathBuf, \"wb\");\n    dmesg(\"saving %s in cache, %d bytes\", pathBuf, len);\n    free(pathBuf);\n    if (!fh)\n        return -2;\n    fwrite(data, len, 1, fh);\n    fclose(fh);\n    dmesg(\"saved.\");\n    return 0;\n}\n\nDLLEXPORT void pxt_vm_start(const char *fn);\n\nDLLEXPORT int pxt_vm_cache_start(const char *scriptId) {\n    if (!checkCache(scriptId))\n        return -1;\n    auto pathBuf = scriptPath(scriptId);\n    dmesg(\"starting %s from cache\", pathBuf);\n    pxt_vm_start(pathBuf);\n    return 0;\n}\n\n//%\nvoid run(String name) {\n    auto scriptId = name->getUTF8Data();\n    if (!checkCache(scriptId))\n        return;\n    auto pathBuf = scriptPath(scriptId);\n    dmesg(\"starting %s from cache from VM code\", pathBuf);\n    vmStartFromUser(pathBuf);\n}\n\n//%\nvoid del(String name) {\n    auto scriptId = name->getUTF8Data();\n    auto pathBuf = scriptPath(scriptId);\n    if (!pathBuf)\n        return;\n    dmesg(\"delete %s from cache\", pathBuf);\n    remove(pathBuf);\n    free(pathBuf);\n}\n\n} // namespace vmcache\n",
            "vmload.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\nVMImage *vmImg;\n\nstatic void vmStartCore(uint8_t *data, unsigned len) {\n    unloadVMImage(vmImg);\n    vmImg = NULL;\n\n    gcPreStartup();\n\n    auto img = loadVMImage(data, len);\n    if (img->errorCode) {\n        dmesg(\"validation error %d at 0x%x\", img->errorCode, img->errorOffset);\n        return;\n    } else {\n        dmesg(\"Validation OK\");\n    }\n    vmImg = img;\n\n    gcStartup();\n\n    globals = (TValue *)app_alloc(sizeof(TValue) * getNumGlobals());\n    memset(globals, 0, sizeof(TValue) * getNumGlobals());\n\n    initRuntime();\n}\n\nstatic void vmStartFile(const char *fn) {\n    auto f = fopen(fn, \"rb\");\n    if (!f) {\n        dmesg(\"cannot open %s\", fn);\n        return;\n    }\n\n    fseek(f, 0, SEEK_END);\n    auto len = (unsigned)ftell(f);\n    fseek(f, 0, SEEK_SET);\n    auto data = (uint8_t*)malloc(len + 16);\n    fread(data, len, 1, f);\n    fclose(f);\n\n    vmStartCore(data, len);\n}\n\nstatic uint8_t *vm_data;\nstatic unsigned vm_len;\nstatic const char *vm_filename;\n\nstatic void *multiStart(void *) {\n    if (vm_filename)\n        vmStartFile(vm_filename);\n    else\n        vmStartCore(vm_data, vm_len);\n    return NULL;\n}\n\nvoid vmStart() {\n    auto fn = pxt::initialArgv[1];\n    vmStartFile(fn);\n}\n\npthread_t vm_thread;\nint vm_has_thread;\n\nstatic void spinThread() {\n    if (vm_has_thread) {\n        void *dummy;\n        if (!panicCode)\n            panicCode = -1;\n        pthread_join(vm_thread, &dummy);\n        vm_has_thread = 0;\n    }\n    panicCode = 0;\n    pthread_create(&vm_thread, NULL, multiStart, NULL);\n    vm_has_thread = 1;\n}\n\nstatic void *startFromUserWorker(void *fn) {\n    void *dummy;\n    pthread_join(vm_thread, &dummy);\n    vm_thread = pthread_self();\n    panicCode = 0;\n    vmStartFile((char*)fn);\n    return NULL;\n}\n\nstatic const char *lastFN;\nvoid vmStartFromUser(const char *fn) {\n    pthread_t pt;\n    if (!fn && lastFN) {\n        dmesg(\"re-starting %s\", lastFN);\n        fn = lastFN;\n    }\n    lastFN = fn;\n    if (fn)\n        pthread_create(&pt, NULL, startFromUserWorker, (void*)fn);\n    systemReset();\n}\n\nDLLEXPORT void pxt_vm_start(const char *fn) {\n    vm_filename = fn;\n    spinThread();\n}\n\nDLLEXPORT void pxt_vm_start_buffer(uint8_t *data, unsigned len) {\n    vm_filename = NULL;\n    vm_data = data;\n    vm_len = len;\n    spinThread();\n}\n\n} // namespace pxt\n"
        },
        "serial": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum BaudRate {\n    //% block=115200\n    BaudRate115200 = 115200,\n    //% block=57600\n    BaudRate57600 = 57600,\n    //% block=38400\n    BaudRate38400 = 38400,\n    //% block=31250\n    BaudRate31250 = 31250,\n    //% block=28800\n    BaudRate28800 = 28800,\n    //% block=19200\n    BaudRate19200 = 19200,\n    //% block=14400\n    BaudRate14400 = 14400,\n    //% block=9600\n    BaudRate9600 = 9600,\n    //% block=4800\n    BaudRate4800 = 4800,\n    //% block=2400\n    BaudRate2400 = 2400,\n    //% block=1200\n    BaudRate1200 = 1200,\n    //% block=300\n    BaudRate300 = 300,\n    }\n\n\n    declare const enum SerialEvent {\n    //% block=\"data received\"\n    DataReceived = 4,  // CODAL_SERIAL_EVT_DATA_RECEIVED\n    //% block=\"rx buffer full\"\n    RxBufferFull = 3,  // CODAL_SERIAL_EVT_RX_FULL\n    }\n\n\n    declare const enum Delimiters {\n    //% block=\"new line\"\n    NewLine = 10,\n    //% block=\",\"\n    Comma = 44,\n    //% block=\"$\"\n    Dollar = 36,\n    //% block=\":\"\n    Colon = 58,\n    //% block=\".\"\n    Fullstop = 46,\n    //% block=\"#\"\n    Hash = 35,\n    //% block=\";\"\n    SemiColumn = 59,\n    //% block=\"space\",\n    Space = 32,\n    //% block=\"tab\"\n    Tab = 9,\n    //% block=\"pipe\"\n    Pipe = 124,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"serial\",\n  \"description\": \"UART communicatoin\",\n  \"files\": [\n    \"serial.cpp\",\n    \"serial.ts\",\n    \"enums.d.ts\",\n    \"shims.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "serial.cpp": "#include \"pxt.h\"\n#include \"Serial.h\"\n\nenum class BaudRate {\n  //% block=115200\n  BaudRate115200 = 115200,\n  //% block=57600\n  BaudRate57600 = 57600,\n  //% block=38400\n  BaudRate38400 = 38400,\n  //% block=31250\n  BaudRate31250 = 31250,\n  //% block=28800\n  BaudRate28800 = 28800,\n  //% block=19200\n  BaudRate19200 = 19200,\n  //% block=14400\n  BaudRate14400 = 14400,\n  //% block=9600\n  BaudRate9600 = 9600,\n  //% block=4800\n  BaudRate4800 = 4800,\n  //% block=2400\n  BaudRate2400 = 2400,\n  //% block=1200\n  BaudRate1200 = 1200,\n  //% block=300\n  BaudRate300 = 300\n};\n\nenum class SerialEvent {\n    //% block=\"data received\"\n    DataReceived = CODAL_SERIAL_EVT_DATA_RECEIVED,\n    //% block=\"rx buffer full\"\n    RxBufferFull = CODAL_SERIAL_EVT_RX_FULL\n};\n\nenum class Delimiters {\n    //% block=\"new line\"\n    NewLine = 10, //'\\n',\n    //% block=\",\"\n    Comma = 44, //',',\n    //% block=\"$\"\n    Dollar = 36, // '$',\n    //% block=\":\"\n    Colon = 58, // ':',\n    //% block=\".\"\n    Fullstop = 46, //'.',\n    //% block=\"#\"\n    Hash = 35, //'#',\n    //% block=\";\"\n    SemiColumn = 59,\n    //% block=\"space\",\n    Space = 32,\n    //% block=\"tab\"\n    Tab = 9, //'\\t'\n    //% block=\"pipe\"\n    Pipe = 124 // `|`,\n};\n\nnamespace serial {\n\nclass CodalSerialDeviceProxy {\nprivate:\n  DevicePin* tx;\n  DevicePin* rx;\npublic:\n  CODAL_SERIAL ser;\n  CodalSerialDeviceProxy* next;\n\n  CodalSerialDeviceProxy(DevicePin* _tx, DevicePin* _rx, uint16_t id)\n    : tx(_tx), rx(_rx), ser(*tx, *rx), next(NULL)\n  {\n    if (id <= 0)\n      id = allocateNotifyEvent();\n    ser.id = id;\n    ser.setBaud((int)BaudRate::BaudRate115200);\n  }\n\n  bool matchPins(DevicePin* _tx, DevicePin* _rx) {\n          return this->tx == _tx && this->rx == _rx;\n  }\n\n  void setRxBufferSize(uint8_t size) {\n    ser.setRxBufferSize(size);\n  }\n\n  void setTxBufferSize(uint8_t size) {\n    ser.setTxBufferSize(size);\n  }\n\n  void setBaudRate(BaudRate rate) {\n    ser.setBaud((int)rate);\n  }\n\n  int read() {\n    uint8_t buf[1];\n    auto r = ser.read(buf, 1, codal::SerialMode::ASYNC);\n    // r < 0 => error\n    if (r < 0) return r;\n    // r == 0, nothing read\n    if (r == 0) return DEVICE_NO_DATA;\n    // read 1 char\n    return buf[0];\n  }\n\n  Buffer readBuffer() {\n    int n = ser.getRxBufferSize();\n    // n maybe 0 but we still call read to force \n    // to initialize rx\n    auto buf = mkBuffer(NULL, n);\n    auto read = ser.read(buf->data, buf->length, SerialMode::ASYNC);\n    if (read == DEVICE_SERIAL_IN_USE || read == 0) { // someone else is reading\n      decrRC(buf);\n      return mkBuffer(NULL, 0);\n    }\n    if (buf->length != read) {\n      auto buf2 = mkBuffer(buf->data, read);\n      decrRC(buf);\n      buf = buf2;\n    }\n    return buf;\n  }\n\n  void writeBuffer(Buffer buffer) {\n    if (NULL == buffer) return;\n    ser.send(buffer->data, buffer->length);\n  }\n\n  void redirect(DevicePin* tx, DevicePin* rx, BaudRate rate) {\n      this->tx = tx;\n      this->rx = rx;\n      this->ser.redirect(*tx, *rx);\n      this->setBaudRate(rate);\n  }\n\n  void onEvent(SerialEvent event, Action handler) {\n    ser.setRxBufferSize(ser.getRxBufferSize()); // turn on reading\n    registerWithDal(ser.id, (int)event, handler);\n  }\n\n  void onDelimiterReceived(Delimiters delimiter, Action handler) {\n    registerWithDal(ser.id, CODAL_SERIAL_EVT_DELIM_MATCH, handler);\n    ManagedString d((char)delimiter);\n    ser.eventOn(d);\n  }\n};\n\ntypedef CodalSerialDeviceProxy* SerialDevice;\nstatic SerialDevice serialDevices(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//%\nSerialDevice internalCreateSerialDevice(DigitalInOutPin tx, DigitalInOutPin rx, int id) {\n  auto dev = serialDevices;\n  while(dev) {\n    if (dev->matchPins(tx, rx))\n      return dev;\n    dev = dev->next;\n  }\n\n  // allocate new one\n  auto ser = new CodalSerialDeviceProxy(tx, rx, id);\n  ser->next = serialDevices;\n  serialDevices = ser;\n  return ser;\n}\n\n}\n\nnamespace SerialDeviceMethods {\n  /**\n  * Sets the size of the RX buffer in bytes\n  */\n  //%\n  void setRxBufferSize(SerialDevice device, uint8_t size) {\n    device->setRxBufferSize(size);\n  }\n\n  /**\n  * Sets the size of the TX buffer in bytes\n  */\n  //%\n  void setTxBufferSize(SerialDevice device, uint8_t size) {\n    device->setTxBufferSize(size);\n  }\n\n  /**\n  Set the baud rate of the serial port\n  */\n  //%\n  void setBaudRate(SerialDevice device, BaudRate rate) {\n    device->setBaudRate(rate);\n  }\n\n  /**\n  * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n  */\n  //%\n  int read(SerialDevice device) {\n    return device->read();\n  }\n\n  /**\n  * Read the buffered received data as a buffer\n  */\n  //%\n  Buffer readBuffer(SerialDevice device) {\n    return device->readBuffer();\n  }\n\n  /**\n  * Send a buffer across the serial connection.\n  */\n  //%\n  void writeBuffer(SerialDevice device, Buffer buffer) {\n    device->writeBuffer(buffer);\n  }\n  \n  /**\n  */\n  //%\n  void redirect(SerialDevice device, DigitalInOutPin tx, DigitalInOutPin rx, BaudRate rate) {\n    device->redirect(tx, rx, rate);\n  }\n\n  /**\n  * Register code when a serial event occurs\n  */\n  //%\n  void onEvent(SerialDevice device, SerialEvent event, Action handler) {\n    device->onEvent(event, handler);\n  }\n\n  /**\n  * Registers code when a delimiter is received\n  **/\n  //%\n  void onDelimiterReceived(SerialDevice device, Delimiters delimiter, Action handler) {\n    device->onDelimiterReceived(delimiter, handler);\n  }\n}\n",
            "serial.ts": "/**\n * Reading and writing data over a serial connection.\n */\n//% weight=2 color=#002050 icon=\"\\uf287\"\n//% advanced=true blockGap=8\n//% groups='[\"Write\", \"Read\", \"Events\", \"Configuration\"]'\nnamespace serial {\n    export let NEW_LINE = \"\\r\\n\"; // \\r require or Putty really unhappy on windows\n\n    export class Serial {\n        serialDevice: SerialDevice;\n        decoder: UTF8Decoder;\n        constructor(serialDevice: SerialDevice) {\n            this.serialDevice = serialDevice;\n            this.decoder = new UTF8Decoder();\n        }\n\n        readString(): string {\n            const buf = this.serialDevice.readBuffer();\n            this.decoder.add(buf);\n            return this.decoder.decode();\n        }\n\n        readLine(timeOut?: number): string {\n            return this.readUntil(Delimiters.NewLine, timeOut);\n        }\n\n        readUntil(delimiter: Delimiters, timeOut?: number): string {\n            const start = control.millis();\n            do {\n                const s = this.decoder.decodeUntil(delimiter);\n                if (s !== undefined)\n                    return s;\n                const b = this.serialDevice.readBuffer()\n                this.decoder.add(b);\n                pause(1);\n            }\n            while (timeOut === undefined || (control.millis() - start < timeOut));\n            // giving up\n            return \"\";\n        }\n\n        writeString(text: string) {\n            if (!text) return;\n            const buf = control.createBufferFromUTF8(text);\n            this.serialDevice.writeBuffer(buf);\n        }\n\n        writeLine(text: string) {\n            this.writeString(text);\n            this.writeString(serial.NEW_LINE);\n        }\n    }\n\n    /**\n     * Creates a serial comm device\n     * @param tx \n     * @param rx \n     * @param id \n     */\n    //% help=serial/create-serial\n    //% parts=serial\n    export function createSerial(tx: DigitalInOutPin, rx: DigitalInOutPin, id?: number): Serial {\n        const dev = serial.internalCreateSerialDevice(tx, rx, id || 0);\n        return new Serial(dev);\n    }\n\n    let _device: Serial;\n    export function device(): Serial {\n        if (!_device) {\n            const tx = pins.pinByCfg(DAL.CFG_PIN_TX);\n            const rx = pins.pinByCfg(DAL.CFG_PIN_RX);\n            if (!tx || !rx) return undefined;\n            _device = serial.createSerial(tx, rx, DAL.DEVICE_ID_SERIAL);\n        }\n        return _device;\n    }\n\n    /**\n    * Read the buffered received data as a string\n    */\n    //% help=serial/read-string\n    //% blockId=serial_read_string block=\"serial|read string\"\n    //% weight=18\n    //% group=\"Read\"\n    export function readString(): string {\n        const d = device();\n        return d ? d.readString() : \"\";\n    }\n\n    /**\n     * Read a line of text from the serial port.\n     */\n    //% help=serial/read-line\n    //% blockId=serial_read_line block=\"serial|read line\"\n    //% weight=20 blockGap=8\n    //% group=\"Read\"\n    export function readLine(): string {\n        const d = device();\n        return d ? d.readLine() : \"\";\n    }\n\n    /**\n     * Read a line of text from the serial port and return the buffer when the delimiter is met.\n     * @param delimiter text delimiter that separates each text chunk\n     */\n    //% help=serial/read-until\n    //% blockId=serial_read_until block=\"serial|read until %delimiter=serial_delimiter_conv\"\n    //% weight=19\n    //% group=\"Read\"    \n    export function readUntil(delimiter: Delimiters, timeOut?: number): string {\n        const d = device();\n        return d ? d.readUntil(delimiter, timeOut) : \"\";\n    }\n\n    /**\n     * Write some text to the serial port.\n     */\n    //% help=serial/write-string\n    //% weight=87\n    //% blockId=serial_writestring block=\"serial|write string %text\"\n    //% group=\"Write\"\n    export function writeString(text: string) {\n        const d = device();\n        if (d) d.writeString(text);\n    }\n\n    /**\n     * Write a line of text to the serial port.\n     * @param value to send over serial\n     */\n    //% weight=90\n    //% help=serial/write-line blockGap=8\n    //% blockId=serial_writeline block=\"serial|write line %text\"\n    //% group=\"Write\"\n    export function writeLine(text: string): void {\n        const d = device();\n        if (d) d.writeLine(text);\n    }\n\n    /**\n     * Write a number to the serial port.\n     */\n    //% help=serial/write-number\n    //% weight=89 blockGap=8\n    //% blockId=serial_writenumber block=\"serial|write number %value\"\n    //% group=\"Write\"\n    export function writeNumber(value: number): void {\n        writeString(value.toString());\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the serial port.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=serial/write-value\n    //% blockId=serial_writevalue block=\"serial|write value %name|= %value\"\n    //% group=\"Write\"\n    export function writeValue(name: string, value: number): void {\n        if (name) {\n            writeString(name);\n            writeString(\":\");\n        }\n        writeNumber(value);\n        writeString(NEW_LINE);\n    }\n\n    /**\n    * Sets the size of the RX buffer in bytes\n    */\n    //% help=serial/set-rx-buffer-size\n    //% blockId=serialsetrxbuffersize block=\"serial set rx buffer size to $size\"\n    //% weight=10\n    //% group=\"Configuration\"\n    export function setRxBufferSize(size: number) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setRxBufferSize(size);\n    }\n\n    /**\n    * Sets the size of the TX buffer in bytes\n    */\n    //% help=serial/set-tx-buffer-size\n    //% blockId=serialsettxbuffersize block=\"serial set tx buffer size to $size\"\n    //% weight=9\n    //% group=\"Configuration\"\n    export function setTxBufferSize(size: number) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setTxBufferSize(size);\n    }\n\n    /**\n    * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n    */\n    //% Group=\"Read\"\n    export function read(): number {\n        const ser = device();\n        if (ser)\n            return ser.serialDevice.read();\n        else return DAL.DEVICE_NOT_SUPPORTED;\n    }\n\n    /**\n    * Read the buffered received data as a buffer\n    */\n    //% help=serial/read-buffer\n    //% blockId=serial_read_buffer block=\"serial|read buffer\"\n    //% weight=17\n    //% group=\"Read\"\n    export function readBuffer(): Buffer {\n        const ser = device();\n        if (ser)\n            return ser.serialDevice.readBuffer();\n        else\n            return control.createBuffer(0);\n    }\n\n\n    /**\n    * Send a buffer across the serial connection.\n    */\n    //% help=serial/write-buffer weight=6\n    //% blockId=serial_writebuffer block=\"serial|write buffer %buffer\"\n    //% group=\"Write\"\n    export function writeBuffer(buffer: Buffer) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.writeBuffer(buffer);\n    }\n\n\n    /**\n    Set the baud rate of the serial port\n    */\n    //% weight=10\n    //% blockId=serial_setbaudrate block=\"serial|set baud rate %rate\"\n    //% blockGap=8 inlineInputMode=inline\n    //% help=serial/set-baud-rate\n    //% group=\"Configuration\"\n    export function setBaudRate(rate: BaudRate) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setBaudRate(rate);\n    }\n\n\n    /**\n      Send console messages through the TX, RX pins\n      **/\n    //% blockId=serialsendtoconsole block=\"serial attach to console\"\n    //% group=\"Configuration\"\n    //% help=serial/attach-to-console\n    export function attachToConsole() {\n        console.addListener(logListener)\n    }\n\n    function logListener(priority: ConsolePriority, text: string) {\n        switch (priority) {\n            case ConsolePriority.Debug: writeString(\"dbg> \"); break;\n            case ConsolePriority.Error: writeString(\"err> \"); break;\n            case ConsolePriority.Warning: writeString(\"wrn> \"); break;\n        }\n        writeLine(text);\n    }\n\n\n    /**\n    * Set the serial input and output to use pins instead of the USB connection.\n    * @param tx the new transmission pin\n    * @param rx the new reception pin\n    * @param rate the new baud rate\n    */\n    //% weight=10\n    //% help=serial/redirect\n    //% blockId=serial_redirect block=\"serial|redirect to|TX %tx|RX %rx at rate %rate\"\n    //% tx.fieldEditor=\"gridpicker\" tx.fieldOptions.columns=3\n    //% tx.fieldOptions.tooltips=\"false\"\n    //% rx.fieldEditor=\"gridpicker\" rx.fieldOptions.columns=3\n    //% rx.fieldOptions.tooltips=\"false\"\n    //% blockGap=8 inlineInputMode=inline\n    //% group=\"Configuration\"\n    export function redirect(tx: DigitalInOutPin, rx: DigitalInOutPin, rate: BaudRate) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.redirect(tx, rx, rate);\n    }\n\n    /**\n    * Registers code when serial events happen\n    **/\n    //% weight=9\n    //% help=serial/on-event\n    //% blockId=serial_onevent block=\"serial on %event\"\n    //% blockGap=8\n    //% group=\"Events\"\n    export function onEvent(event: SerialEvent, handler: () => void) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.onEvent(event, handler);\n    }\n\n    /**\n    * Registers code when a delimiter is received\n    **/\n    //% weight=10\n    //% help=serial/on-delimiter-received\n    //% blockId=serial_ondelimiter block=\"serial on delimiter $delimiter received\"\n    //% blockGap=8\n    //% group=\"Events\"\n    export function onDelimiterReceived(delimiter: Delimiters, handler: () => void) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.onDelimiterReceived(delimiter, handler);\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace serial {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% shim=serial::internalCreateSerialDevice\n    function internalCreateSerialDevice(tx: DigitalInOutPin, rx: DigitalInOutPin, id: int32): SerialDevice;\n}\n\n\ndeclare interface SerialDevice {\n    /**\n     * Sets the size of the RX buffer in bytes\n     */\n    //% shim=SerialDeviceMethods::setRxBufferSize\n    setRxBufferSize(size: uint8): void;\n\n    /**\n     * Sets the size of the TX buffer in bytes\n     */\n    //% shim=SerialDeviceMethods::setTxBufferSize\n    setTxBufferSize(size: uint8): void;\n\n    /**\n    Set the baud rate of the serial port\n     */\n    //% shim=SerialDeviceMethods::setBaudRate\n    setBaudRate(rate: BaudRate): void;\n\n    /**\n     * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n     */\n    //% shim=SerialDeviceMethods::read\n    read(): int32;\n\n    /**\n     * Read the buffered received data as a buffer\n     */\n    //% shim=SerialDeviceMethods::readBuffer\n    readBuffer(): Buffer;\n\n    /**\n     * Send a buffer across the serial connection.\n     */\n    //% shim=SerialDeviceMethods::writeBuffer\n    writeBuffer(buffer: Buffer): void;\n\n    /**\n     */\n    //% shim=SerialDeviceMethods::redirect\n    redirect(tx: DigitalInOutPin, rx: DigitalInOutPin, rate: BaudRate): void;\n\n    /**\n     * Register code when a serial event occurs\n     */\n    //% shim=SerialDeviceMethods::onEvent\n    onEvent(event: SerialEvent, handler: () => void): void;\n\n    /**\n     * Registers code when a delimiter is received\n     **/\n    //% shim=SerialDeviceMethods::onDelimiterReceived\n    onDelimiterReceived(delimiter: Delimiters, handler: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "for(let i = 0; i < 10; ++i) {\n    serial.writeLine((++i).toString())\n}"
        },
        "corgio": {
            "README.md": "# Corgio\n\nA small wrapper to help in creating a Corgi based platformer.",
            "corgio.ts": "/**\n* Sprite Wrapper for a Corgi Platformer\n*/\n//% weight=100 color=#d2b48c icon=\"\\uf1b0\"\n//% groups='[\"Create\", \"Movement\", \"Speak\", \"Properties\"]'\nnamespace corgio {\n    export enum CorgiFlags {\n        None = 0,\n        HorizontalMovement = 1 << 0,\n        VerticalMovement = 1 << 1,\n        UpdateSprite = 1 << 2,\n        CameraFollow = 1 << 3,\n        All = ~(~0 << 4)\n    }\n\n    export let _corgi_still: Image[] = [\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . d e 4 4 4 4 4 e d . . . .\n            . . . d d 4 e d e 4 d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f e f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 e 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e a e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 4 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n    ];\n\n    export let _corgi_left: Image[] = [\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . . . . .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d . . . e 4 f .\n            f d 4 4 4 4 4 d d e e e 4 4 4 .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 4 4 4 4 4 .\n            . . . . . d d d 4 4 f 4 f 4 4 .\n            . . . . . . d 4 d 4 f f f 4 d d\n            . . . . . . f . . . . . . . d f\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 4 .\n            . . 4 d d f f d d 4 f 4 f 4 4 .\n            . . . . . d d d 4 d f f f 4 d d\n            . . . . . . d 4 d . . . . . d f\n            . . . . . . f . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 4 .\n            . . 4 d d f f d d 4 f 4 f 4 4 .\n            . . . . d d d 4 4 d f f f 4 d d\n            . . . f d 4 . . . . . . . . d f\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 f 4 f 4 . .\n            . . . . d d d 4 4 d f f f 4 d .\n            . . . f d 4 . . . . . . 4 d d .\n            . . . . . . . . . . . . . f . .\n            . . . . . . . . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 f 4 f 4 . .\n            . . . . d 4 d 4 4 d f f f 4 d .\n            . . . . d 4 . . . . . . 4 d d .\n            . . . . . f . . . . . . . f . .\n            . . . . . . . . . . . . . . . .\n        `\n    ];\n\n    export let _corgi_right: Image[] = reflect(_corgi_left);\n\n    /**\n     * Creates a new dart from an image and kind\n     * @param kind the kind to make the corgi \n     * @param x optional initial x position, eg: 10\n     * @param y optional initial y position, eg: 70\n     */\n    //% blockId=corgiCreate block=\"corgi of kind %kind=spritekind || at x %x y %y\"\n    //% expandableArgumentMode=toggle\n    //% inlineInputMode=inline\n    //% blockSetVariable=myCorg\n    //% weight=100\n    //% group=\"Create\"\n    export function create(kind: number,\n                            x: number = 10,\n                            y: number = 70): Corgio {\n        return new Corgio(kind, x, y);\n    }\n\n    // Round input towards 0; 1.4 becomes 1.0, -0.4 becomes 0.0\n    export function roundTowardsZero(input: number): number {\n        return Math.floor(input) + input < 0 ? 1 : 0;\n    }\n\n    // Normalize input number to 0, 1, or -1\n    export function normalize(input: number): number {\n        return input ? input / Math.abs(input) : 0;\n    }\n\n    // Set the animation for looking right to be the opposite of looking left\n    export function reflect(input: Image[]): Image[] {\n        let output: Image[] = [];\n        for (let i: number = 0; i < input.length; i++) {\n            let nextImage = input[i].clone();\n            nextImage.flipX();\n            output.push(nextImage);\n        }\n        return output;\n    }\n}\n\n/**\n * A Corgi Platformer\n **/\n//% blockNamespace=corgio color=\"#d2b48c\" blockGap=8\nclass Corgio {\n    private player: Sprite;\n    private stillAnimation: Image[];\n    private _leftAnimation: Image[];\n    private _rightAnimation: Image[];\n\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"horizontal speed\"\n    maxMoveVelocity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"gravity\"\n    gravity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"jump speed\"\n    jumpVelocity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"max jumps in a row\"\n    maxJump: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"rate horizontal movement is slowed\"\n    decelerationRate: number;\n\n    private controlFlags: number;\n    private initJump: boolean;\n    private releasedJump: boolean;\n    private count: number;\n    private touching: number;\n    private remainingJump: number;\n    private script: string[];\n\n    public constructor(kind: number, x: number, y: number) {\n        this.maxMoveVelocity = 70;\n        this.gravity = 300;\n        this.jumpVelocity = 125;\n\n        this.initJump = true;\n        this.releasedJump = true;\n        this.maxJump = 2;\n        this.count = 0;\n        this.touching = 2;\n        this.remainingJump = this.maxJump;\n        this.script = [\n            \"bark\"\n        ];\n\n        this.controlFlags = corgio.CorgiFlags.None;\n\n        this.stillAnimation = corgio._corgi_still;\n        this._leftAnimation = corgio._corgi_left;\n        this._rightAnimation = corgio._corgi_right;\n\n        this.player = sprites.create(this.stillAnimation[0], kind);\n        this.player.setFlag(SpriteFlag.StayInScreen, true);\n        this.player.ay = this.gravity;\n        this.player.x = x;\n        this.player.y = y;\n    }\n\n    /**\n     * Get the Corgio's sprite\n     */\n    //% group=\"Properties\"\n    //% blockId=corgSprite block=\"%corgio(myCorg) sprite\"\n    //% weight=8\n    get sprite(): Sprite {\n        return this.player;\n    }\n\n    /**\n     * Make the character move in the direction indicated by the left and right arrow keys.\n     */\n    //% group=\"Movement\"\n    //% blockId=horizontalMovement block=\"make %corgio(myCorg) move left and right with arrow keys || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    horizontalMovement(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.HorizontalMovement);\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.HorizontalMovement)) return;\n\n            let dir: number = controller.dx();\n\n            _this.player.vx = dir ? corgio.normalize(dir) * _this.maxMoveVelocity :\n                                    corgio.roundTowardsZero(_this.player.vx * _this.decelerationRate);\n        })\n    }\n\n    /**\n     * Make the character jump when the up arrow key is pressed, and grab onto the wall when falling.\n     */\n    //% group=\"Movement\"\n    //% blockId=verticalMovement block=\"make %corgio(myCorg) jump if up arrow key is pressed || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    verticalMovement(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.VerticalMovement);\n\n        controller.up.onEvent(ControllerButtonEvent.Released, function () {\n            _this.releasedJump = true;\n        })\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.VerticalMovement)) return;\n\n            if (controller.up.isPressed()) {\n                if (_this.contactLeft() && controller.right.isPressed()\n                        || _this.contactRight() && controller.left.isPressed()) {\n                    _this.remainingJump = Math.max(_this.remainingJump + 1, _this.maxJump);\n                }\n                _this.jumpImpulse();\n            }\n\n            if ((_this.contactLeft() && controller.left.isPressed()\n                    || _this.contactRight() && controller.right.isPressed())\n                    && _this.player.vy > - 10) {\n                _this.player.ay = _this.gravity >> 2;\n            } else {\n                _this.player.ay = _this.gravity;\n            }\n\n            if (_this.contactBelow()) {\n                if (_this.initJump) {\n                    _this.remainingJump = _this.maxJump;\n                }\n                _this.initJump = true;\n            }\n        })\n    }\n\n    /**\n     * Set camera to follow corgio horizontally, while keeping the screen centered vertically.\n     */\n    //% group=\"Movement\"\n    //% blockId=followCorgi block=\"make camera follow %corgio(myCorg) left and right || %on=toggleOnOff\"\n    //% weight=90 blockGap=5\n    follow(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.CameraFollow);\n\n        game.onUpdate(function () {\n            if (_this.controlFlags & corgio.CorgiFlags.CameraFollow) {\n                scene.centerCameraAt(_this.player.x, screen.height >> 1);\n            }\n        })\n    }\n\n    /**\n     * Make the character change sprites when moving.\n     */\n    //% group=\"Movement\"\n    //% blockId=updateSprite block=\"change image when %corgio(myCorg) is moving || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    updateSprite(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.UpdateSprite);\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.UpdateSprite)) return;\n\n            _this.count++;\n\n            if (_this.player.vx == 0) {\n                _this.player.setImage(_this.pickNext(_this.stillAnimation, 6));\n            } else if (_this.player.vx < 0) {\n                _this.player.setImage(_this.pickNext(_this._leftAnimation));\n            } else {\n                _this.player.setImage(_this.pickNext(_this._rightAnimation));\n            }\n        })\n    }\n\n    /**\n     * Add new phrase for the character to bark\n     * @param input phrase to add to script, eg: \"bark\"\n     */\n    //% group=\"Speak\"\n    //% blockId=addScript block=\"teach %corgio(myCorg) the word %input\"\n    //% weight=95 blockGap=5\n    addToScript(input: string): void {\n        this.script.push(input);\n    }\n\n    /**\n     * Have the character say one of the phrases in the script at random\n     */\n    //% group=\"Speak\"\n    //% blockId=bark block=\"make %corgio(myCorg) bark!\"\n    //% weight=95 blockGap=5\n    bark(): void {\n        this.player.say(Math.pickRandom(this.script), 250);\n    }\n\n    private jumpImpulse() {\n        if (this.remainingJump > 0 && this.releasedJump) {\n            this.releasedJump = false;\n            if (this.initJump) {\n                this.player.vy = -1 * this.jumpVelocity;\n                this.initJump = false;\n            } else {\n                this.player.vy = Math.clamp((-4 * this.jumpVelocity) / 3, -30,\n                                            this.player.vy - this.jumpVelocity);\n            }\n            this.remainingJump--;\n        }\n    }\n\n    private updateFlags(on: boolean, flag: corgio.CorgiFlags): void {\n        if (on) this.controlFlags |= flag;\n        else this.controlFlags &= corgio.CorgiFlags.All ^ flag;\n    }\n\n    private pickNext(input: Image[], state: number = 3): Image {\n        return input[(this.count / state) % input.length];\n    }\n\n    private contactLeft(): boolean {\n        let screenEdge = game.currentScene().camera.offsetX;\n        return this.player.left - screenEdge <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Left);\n    }\n\n    private contactRight(): boolean {\n        let screenEdge = screen.width + game.currentScene().camera.offsetX;\n        return screenEdge - this.player.right <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Right);\n    }\n\n    private contactBelow(): boolean {\n        let screenEdge = screen.height + game.currentScene().camera.offsetY;\n        return screenEdge - this.player.bottom <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Bottom);\n    }\n}\n",
            "pxt.json": "{\n  \"name\": \"corgio\",\n  \"description\": \"A Corgi platformer\",\n  \"files\": [\n    \"README.md\",\n    \"corgio.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\"\n  },\n  \"weight\": 79,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/a052fdd86d54009f6f682a405b87c332912be5ea/static/libs/corgio.png\"\n}"
        },
        "darts": {
            "README.md": "# Darts\n\nA small wrapper for projecting a path.",
            "darts.ts": "/**\n* A dart with path prediction\n*/\n//% weight=100 color=#6699CC icon=\"\\uf140\"\n//% groups='[\"Create\", \"Actions\", \"Properties\"]'\nnamespace darts {\n    /**\n     * Creates a new dart from an image and kind\n     * @param img the image for the sprite\n     * @param kind the kind to make the dart\n     * @param x optional initial x position, eg: 10\n     * @param y optional initial y position, eg: 110\n     */\n    //% blockId=dartsCreate block=\"dart %img=screen_image_picker of kind %kind=spritekind || at x %x y %y\"\n    //% expandableArgumentMode=toggle\n    //% inlineInputMode=inline\n    //% blockSetVariable=myDart\n    //% weight=100\n    //% group=\"Create\"\n    export function create(img: Image,\n                            kind: number,\n                            x: number = 10,\n                            y: number = 110): Dart {\n        return new Dart(img, kind, x, y);\n    }\n\n    /**\n     * Convert degrees to radians\n     * @param degree to convert\n     * @return converted value in radians\n     */\n    export function degreeToRadian(degree: number): number {\n        return degree * Math.PI / 180;\n    }\n\n    /**\n     * Evaluate the x component of a given vector\n     * @param degree angle of vector\n     * @param magnitude magnitude of vector\n     * @return x component of vector\n     */\n    export function xComponent(degree: number, magnitude: number): number {\n        return magnitude * Math.cos(degreeToRadian(degree));\n    }\n\n    /**\n     * Evaluate the y component of a given vector\n     * @param degree angle of vector\n     * @param magnitude magnitude of vector\n     * @return y component of vector\n     */\n    export function yComponent(degree: number, magnitude: number): number {\n        return -magnitude * Math.sin(degreeToRadian(degree));\n    }\n}\n\n/**\n * A dart\n **/\n//% blockNamespace=darts color=\"#6699CC\" blockGap=8\nclass Dart {\n    private dart: Sprite;\n    private bkgd: Image;\n\n    private controlKeys: boolean;\n    private trace: boolean;\n\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"angle\"\n    //% weight=8\n    public angle: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"power\"\n    //% weight=8\n    public pow: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"tracing time (seconds)\"\n    //% weight=8\n    public iter: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"trace color\"\n    //% weight=8\n    public traceColor: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"gravity\"\n    //% weight=8\n    public gravity: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"wind\"\n    //% weight=8\n    public wind: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"angle adjust rate\"\n    //% weight=8\n    public angleRate: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"wind\"\n    //% weight=8\n    public powerRate: number;\n\n    public constructor(img: Image,\n                        kind: number,\n                        x: number,\n                        y: number) {\n        this.dart = sprites.create(img, kind);\n        this.dart.x = x;\n        this.dart.y = y;\n\n        this.gravity = 20;\n        this.pow = 50;\n        this.angle = 10;\n        this.angleRate = 1;\n        this.powerRate = 1;\n        this.iter = 3;\n        this.wind = 0;\n        this.bkgd = scene.backgroundImage();\n\n        this.controlKeys = false;\n        this.trace = false;\n        this.traceColor = 1;\n    }\n\n    /**\n     * Gets the dart's sprite\n     */\n    //% group=\"Properties\"\n    //% blockId=dartSprite block=\"%dart(myDart) sprite\"\n    //% weight=8\n    get sprite(): Sprite {\n        return this.dart;\n    }\n\n    /**\n     * Set whether to show the trace for the estimated path\n     * @param on whether to turn on or off this feature, eg: true\n     */\n    //% blockId=setTrace block=\"trace %dart(myDart) path estimate || %on=toggleOnOff\"\n    //% weight=50\n    //% group=\"Actions\"\n    public setTrace(on: boolean = true): void {\n        let __this: Dart = this;\n        this.trace = on;\n\n        game.onUpdateInterval(50, function () {\n            let newBkgd: Image = __this.bkgd.clone();\n            scene.setBackgroundImage(newBkgd);\n            if (!__this.dart.ay && __this.trace) {\n                let xComp = darts.xComponent(__this.angle, __this.pow);\n                let yComp = darts.yComponent(__this.angle, __this.pow);\n                let camera = game.currentScene().camera\n                let xOffset = camera.offsetX;\n                let yOffset = camera.offsetY;\n\n                for (let i: number = 0.1; i < __this.iter; i += i / 5) {\n                    let x = __this.dart.x + i * xComp + (i ** 2) * __this.wind / 2;\n                    let y = __this.dart.y + i * yComp + (i ** 2) * __this.gravity / 2;\n                    newBkgd.setPixel(x - xOffset,\n                                    y - yOffset,\n                                    __this.traceColor);\n                }\n            }\n        })\n    }\n\n    /**\n     * Throw the dart with the current settings\n     */\n    //% blockId=throwDart block=\"throw %dart(myDart)\"\n    //% weight=50\n    //% group=\"Actions\"\n    public throwDart(): void {\n        this.dart.vx = darts.xComponent(this.angle, this.pow);\n        this.dart.vy = darts.yComponent(this.angle, this.pow);\n        this.dart.ay = this.gravity;\n        this.dart.ax = this.wind;\n    }\n\n    /**\n     * Stop the dart at the current location\n     */\n    //% blockId=stopDart block=\"stop %dart(myDart)\"\n    //% weight=50\n    //% group=\"Actions\"\n    public stopDart(): void {\n        this.dart.ay = 0;\n        this.dart.ax = 0;\n        this.dart.vx = 0;\n        this.dart.vy = 0;\n    }\n\n    /**\n     * Set whether to control the dart with the arrow keys; left and right\n     * to adjust the angle, and up and down to increase / decrease power\n     * @param on whether to turn on or off this feature, eg: true\n     */\n    //% blockId=controlKeys block=\"control %dart(myDart) with arrow keys || %on=toggleOnOff\"\n    //% weight=50\n    //% group=\"Actions\"\n    public controlWithArrowKeys(on: boolean = true): void {\n        let __this: Dart = this;\n        this.controlKeys = on;\n\n        game.onUpdate(function () {\n            if (__this.controlKeys) {\n                __this.angle -= controller.dx() * __this.angleRate / 5;\n                __this.pow -= controller.dy() * __this.powerRate / 5;\n            }\n        })\n    }\n\n    /**\n     * Update background image to new image so dart can continue to trace\n     */\n    //% blockId=updateBackground block=\"change %dart(myDart) background to image %img=background_image_picker\"\n    //% weight=15\n    //% group=\"Properties\"\n    public updateBackground(img: Image): void {\n        this.bkgd = img;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"darts\",\n  \"description\": \"A sprite with path projection\",\n  \"files\": [\n    \"README.md\",\n    \"darts.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\"\n  },\n  \"weight\": 78,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/098edb99d681c55d6fac97f78decd8f3aa5be051/static/libs/darts.png\"\n}"
        },
        "keyboard": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum KeyboardMediaKey\n    {\n    //% block=\"mute\"\n    Mute = 0,\n    //% block=\"volume up\"\n    VolumeUp = 1,\n    //% block=\"volume down\"\n    VolumeDown = 2,\n    //% block=\"play pause\"\n    PlayPause = 3,\n    //% block=\"stop\"\n    Stop = 4,\n    //% block=\"previous track\"\n    PreviousTrack = 5,\n    //% block=\"next track\"\n    NextTrack = 6,\n    //% block=\"mail\"\n    Mail = 7,\n    //% block=\"calculator\"\n    Calculator = 8,\n    //% block=\"web search\"\n    WebSearch = 9,\n    //% block=\"web home\"\n    WebHome = 10,\n    //% block=\"web favourites\"\n    WebFavourites = 11,\n    //% block=\"web refresh\"\n    WebRefresh = 12,\n    //% block=\"web stop\"\n    WebStop = 13,\n    //% block=\"web forward\"\n    WebForward = 14,\n    //% block=\"web back\"\n    WebBack = 15,\n    }\n\n\n    declare const enum KeyboardFunctionKey\n    {\n    //% block=\"F1\"\n    F1Key = 0,\n    //% block=\"F2\"\n    F2Key = 1,\n    //% block=\"F3\"\n    F3Key = 2,\n    //% block=\"F4\"\n    F4Key = 3,\n    //% block=\"F5\"\n    F5Key = 4,\n    //% block=\"F6\"\n    F6Key = 5,\n    //% block=\"F7\"\n    F7Key = 6,\n    //% block=\"F8\"\n    F8Key = 7,\n    //% block=\"F9\"\n    F9Key = 8,\n    //% block=\"F0\"\n    F10Key = 9,\n    //% block=\"F11\"\n    F11Key = 10,\n    //% block=\"F12\"\n    F12Key = 11,\n\n    //% block=\"print screen\"\n    PrintScreen = 12,\n    //% block=\"scroll lock\"\n    ScrollLock = 13,\n    //% block=\"pause\"\n    Pause = 14,\n    //% block=\"insert\"\n    Insert = 15,\n    //% block=\"home\"\n    Home = 16,\n    //% block=\"page up\"\n    PageUp = 17,\n    //% block=\"delete\"\n    DeleteForward = 18,\n    //% block=\"end\"\n    End = 19,\n    //% block=\"page down\"\n    PageDown = 20,\n\n    //% block=\"right arrow\"\n    RightArrow = 21,\n    //% block=\"left arrow\"\n    LeftArrow = 22,\n    //% block=\"down arrow\"\n    DownArrow = 23,\n    //% block=\"up arrow\"\n    UpArrow = 24,\n    }\n\n\n    declare const enum KeyboardKeyEvent {\n    //% block=\"press\"\n    Press = 0,\n    //% block=\"up\"\n    Up = 1,\n    //% block=\"down\"\n    Down = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "jacdac.ts": "namespace jacdac {\n\n    //% fixedInstances\n    export class KeyboardService extends Host {\n        constructor() {\n            super(\"keyb\", jacdac.KEYBOARD_DEVICE_CLASS);\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            const cmd = data.getNumber(NumberFormat.UInt8LE, 0);\n            switch (cmd) {\n                case JDKeyboardCommand.Type: {\n                    let s = \"\";\n                    for (let i = 1; i < data.length; ++i) {\n                        const c = data[i];\n                        if (c)\n                            s += String.fromCharCode(c);\n                    }\n                    keyboard.type(s);\n                    break;\n                }\n                case JDKeyboardCommand.Key: {\n                    const key = String.fromCharCode(data.getNumber(NumberFormat.UInt8LE, 1));\n                    const ev: KeyboardKeyEvent = data.getNumber(NumberFormat.UInt8LE, 2);\n                    keyboard.key(key, ev);\n                    break;\n                }\n                case JDKeyboardCommand.MediaKey: {\n                    const key: KeyboardMediaKey = data.getNumber(NumberFormat.UInt8LE, 1);\n                    const ev: KeyboardKeyEvent = data.getNumber(NumberFormat.UInt8LE, 2);\n                    keyboard.mediaKey(key, ev);\n                    break;\n                }\n                case JDKeyboardCommand.FunctionKey: {\n                    const key: KeyboardFunctionKey = data.getNumber(NumberFormat.UInt8LE, 1);\n                    const ev: KeyboardKeyEvent = data.getNumber(NumberFormat.UInt8LE, 2);\n                    keyboard.functionKey(key, ev);\n                    break;\n                }\n            }\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"keyboard service\"\n    export const keyboardService = new KeyboardService();\n}",
            "keyboard.cpp": "// https://github.com/lancaster-university/codal-core/blob/master/source/drivers/HIDKeyboard.cpp\n\n#include \"pxt.h\"\n\nenum class KeyboardMediaKey\n{\n    //% block=\"mute\"\n    Mute,\n    //% block=\"volume up\"\n    VolumeUp,\n    //% block=\"volume down\"\n    VolumeDown,\n    //% block=\"play pause\"\n    PlayPause,\n    //% block=\"stop\"\n    Stop,\n    //% block=\"previous track\"\n    PreviousTrack,\n    //% block=\"next track\"\n    NextTrack,\n    //% block=\"mail\"\n    Mail,\n    //% block=\"calculator\"\n    Calculator,\n    //% block=\"web search\"\n    WebSearch,\n    //% block=\"web home\"\n    WebHome,\n    //% block=\"web favourites\"\n    WebFavourites,\n    //% block=\"web refresh\"\n    WebRefresh,\n    //% block=\"web stop\"\n    WebStop,\n    //% block=\"web forward\"\n    WebForward,\n    //% block=\"web back\"\n    WebBack\n};\n\nenum class KeyboardFunctionKey\n{\n    //% block=\"F1\"\n    F1Key,  \n    //% block=\"F2\"\n    F2Key,\n    //% block=\"F3\"\n    F3Key,\n    //% block=\"F4\"\n    F4Key, \n    //% block=\"F5\"\n    F5Key,\n    //% block=\"F6\"\n    F6Key,\n    //% block=\"F7\"\n    F7Key,\n    //% block=\"F8\"\n    F8Key,\n    //% block=\"F9\"\n    F9Key,\n    //% block=\"F0\"\n    F10Key,\n    //% block=\"F11\"\n    F11Key,\n    //% block=\"F12\"\n    F12Key,\n\n    //% block=\"print screen\"\n    PrintScreen,\n    //% block=\"scroll lock\"\n    ScrollLock,\n    //% block=\"pause\"\n    Pause,\n    //% block=\"insert\"\n    Insert,\n    //% block=\"home\"\n    Home,\n    //% block=\"page up\"\n    PageUp,\n    //% block=\"delete\"\n    DeleteForward,\n    //% block=\"end\"\n    End,\n    //% block=\"page down\"\n    PageDown,\n\n    //% block=\"right arrow\"\n    RightArrow,\n    //% block=\"left arrow\"\n    LeftArrow,\n    //% block=\"down arrow\"\n    DownArrow,\n    //% block=\"up arrow\"\n    UpArrow,\n};\n\nenum class KeyboardKeyEvent {\n    //% block=\"press\"\n    Press,\n    //% block=\"up\"\n    Up,\n    //% block=\"down\"\n    Down\n};\n\nnamespace keyboard {\n    /**\n    * Send a sequence of keystrokes to the keyboard\n    */\n    //% blockId=keyboardType block=\"keyboard type %text\"\n    //% blockGap=8 weight=100\n    //% text.shadowOptions.toString=true\n    //% help=keyboard/type\n    void type(String text) {\n        if (NULL != text)\n            pxt::keyboard.type(text->getUTF8Data(), text->getUTF8Size());\n    }\n\n    /**\n    * Send a key command\n    */\n    //% blockId=keyboardStandardKey block=\"keyboard key %key|%event\"\n    //% blockGap=8 weight=99\n    //% help=keyboard/key\n    void key(String key, KeyboardKeyEvent event) {\n        if (!key->getUTF8Size()) return;\n        uint16_t ckey = key->getUTF8Data()[0];\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n\n    /**\n    * Send a media key command\n    */\n    //% blockId=keyboardMediaKey block=\"keyboard media key %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/media-key\n    void mediaKey(KeyboardMediaKey key, KeyboardKeyEvent event) {\n        codal::MediaKey ckey = (codal::MediaKey)((int)codal::MediaKey::Mute + (int)key);\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n\n    /**\n    * Send a function key command\n    */\n    //% blockId=keyboardFunctionKey block=\"keyboard function key %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/function-key\n    void functionKey(KeyboardFunctionKey key, KeyboardKeyEvent event) {\n        codal::FunctionKey ckey = (codal::FunctionKey)((int)codal::FunctionKey::F1Key + (int)key);\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n}",
            "keyboard.ts": "/**\n * Keyboard emulation\n */\n//% icon=\"\\uf11c\" color=\"#303030\"\nnamespace keyboard {\n\n}",
            "pxt.json": "{\n  \"name\": \"keyboard\",\n  \"description\": \"Keyboard emulation over HID\",\n  \"files\": [\n    \"keyboard.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"keyboard.ts\",\n    \"jacdac.ts\"\n  ],\n  \"tests\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"yotta\": {\n    \"config\": {\n      \"DEVICE_USB\": 1,\n      \"DEVICE_KEYBOARD\": 1\n    }\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/8b6f4efaed3912ffb0c7df018708db951cac5f0a/static/libs/keyboard.png\"\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace keyboard {\n\n    /**\n     * Send a sequence of keystrokes to the keyboard\n     */\n    //% blockId=keyboardType block=\"keyboard type %text\"\n    //% blockGap=8 weight=100\n    //% text.shadowOptions.toString=true\n    //% help=keyboard/type shim=keyboard::type\n    function type(text: string): void;\n\n    /**\n     * Send a key command\n     */\n    //% blockId=keyboardStandardKey block=\"keyboard key %key|%event\"\n    //% blockGap=8 weight=99\n    //% help=keyboard/key shim=keyboard::key\n    function key(key: string, event: KeyboardKeyEvent): void;\n\n    /**\n     * Send a media key command\n     */\n    //% blockId=keyboardMediaKey block=\"keyboard media key %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/media-key shim=keyboard::mediaKey\n    function mediaKey(key: KeyboardMediaKey, event: KeyboardKeyEvent): void;\n\n    /**\n     * Send a function key command\n     */\n    //% blockId=keyboardFunctionKey block=\"keyboard function key %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/function-key shim=keyboard::functionKey\n    function functionKey(key: KeyboardFunctionKey, event: KeyboardKeyEvent): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "mouse": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum MouseButton {\n    //% block=\"right\" enumval=2\n    Right = 0x02,\n    //% block=\"middle\" enumval=4\n    Middle = 0x04,\n    //% block=\"left\" enumval=1\n    Left = 0x01,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "jacdac.ts": "namespace jacdac {\n    //% fixedInstances\n    export class MouseService extends Host {\n        constructor() {\n            super(\"mous\", jacdac.MOUSE_DEVICE_CLASS);\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            const cmd: JDMouseCommand = data[0];\n            switch (cmd) {\n                case JDMouseCommand.Button:\n                    const btns = data[1];\n                    const down = !!data[2];\n                    mouse.setButton(btns, down);\n                    break;\n                case JDMouseCommand.Move:\n                    const x = data.getNumber(NumberFormat.Int8LE, 1);\n                    const y = data.getNumber(NumberFormat.Int8LE, 2);\n                    mouse.move(x, y);\n                    break;\n                case JDMouseCommand.TurnWheel:\n                    const w = data.getNumber(NumberFormat.Int8LE, 1);\n                    mouse.turnWheel(w);\n                    break;\n            }\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"mouse service\"\n    export const mouseService = new MouseService();\n}",
            "mouse.cpp": "// https://github.com/lancaster-university/codal-core/blob/master/source/drivers/HIDMouse.cpp\n\n#include \"pxt.h\"\n\nenum class MouseButton {\n    //% block=\"right\" enumval=2\n    Right = 0x02,\n    //% block=\"middle\" enumval=4\n    Middle = 0x04,\n    //% block=\"left\" enumval=1\n    Left = 0x01\n};\n\nnamespace mouse {\n    /** \n    * Set the mouse button state to up or down\n    */\n    //% help=mouse/set-button\n    //% blockId=mouseSetButton block=\"mouse button %index|%down=toggleDownUp\"\n    void setButton(MouseButton button, bool down) {\n        if (down)\n            pxt::mouse.buttonDown((codal::USBHIDMouseButton)button);\n        else\n            pxt::mouse.buttonUp((codal::USBHIDMouseButton)button);\n    }\n\n    /**\n    * Move the mouse in the X and Y direction\n    **/\n    //% help=mouse/move\n    //% blockId=mouseMove block=\"mouse move x %x|y %y\"\n    //% x.min=-128 x.max=127\n    //% y.min=-128 y.max=127\n    void move(int x, int y) {\n        pxt::mouse.move(x, y);\n    }\n\n    /**\n    * Turn the mouse wheel\n    **/\n    //% help=mouse/turn-wheel\n    //% blockId=mouseWheel block=\"turn wheel %w\"\n    //% w.min=-128 w.max=127\n    void turnWheel(int w) {\n        pxt::mouse.moveWheel(w);\n    }\n}",
            "mouse.ts": "/**\n * Mouse emulation\n */\n//% icon=\"\\uf245\" color=\"#303030\"\nnamespace mouse {\n\n}",
            "pxt.json": "{\n  \"name\": \"mouse\",\n  \"description\": \"Mouse emulation over HID\",\n  \"files\": [\n    \"mouse.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"mouse.ts\",\n    \"jacdac.ts\"\n  ],\n  \"tests\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"yotta\": {\n    \"config\": {\n      \"DEVICE_USB\": 1,\n      \"DEVICE_MOUSE\": 1\n    }\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/f0e9010dcba551b54c2254c5c024f96d3575bc0e/static/libs/mouse.png\"\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace mouse {\n\n    /** \n     * Set the mouse button state to up or down\n     */\n    //% help=mouse/set-button\n    //% blockId=mouseSetButton block=\"mouse button %index|%down=toggleDownUp\" shim=mouse::setButton\n    function setButton(button: MouseButton, down: boolean): void;\n\n    /**\n     * Move the mouse in the X and Y direction\n     **/\n    //% help=mouse/move\n    //% blockId=mouseMove block=\"mouse move x %x|y %y\"\n    //% x.min=-128 x.max=127\n    //% y.min=-128 y.max=127 shim=mouse::move\n    function move(x: int32, y: int32): void;\n\n    /**\n     * Turn the mouse wheel\n     **/\n    //% help=mouse/turn-wheel\n    //% blockId=mouseWheel block=\"turn wheel %w\"\n    //% w.min=-128 w.max=127 shim=mouse::turnWheel\n    function turnWheel(w: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "hw": {
            "basepins.d.ts": "//% advanced=true\ndeclare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_LED)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SDA)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCL)\n    const SCL: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCK)\n    const SCK: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MISO)\n    const MISO: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MOSI)\n    const MOSI: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_RX)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_TX)\n    const TX: DigitalInOutPin;\n}\n",
            "config.ts": "namespace config {\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 120;\n}\n",
            "pxt.json": "{\n  \"name\": \"hw\",\n  \"description\": \"Hardware definition - web-browser only\",\n  \"files\": [\n    \"basepins.d.ts\",\n    \"config.ts\"\n  ],\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"screen\": \"*\",\n    \"mixer\": \"*\",\n    \"game\": \"*\"\n  },\n  \"public\": true,\n  \"skipLocalization\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "hw---stm32f401": {
            "basepins.d.ts": "//% advanced=true\ndeclare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_LED)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SDA)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCL)\n    const SCL: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCK)\n    const SCK: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MISO)\n    const MISO: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MOSI)\n    const MOSI: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_RX)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_TX)\n    const TX: DigitalInOutPin;\n}\n",
            "config.ts": "namespace config {\n    // all defined in bootloader\n}\n",
            "device.d.ts": "declare namespace input {\n    //% block=\"button A\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_A,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonA: Button;\n    //% block=\"button B\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_B,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonB: Button;\n    //% block=\"button Left\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_LEFT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonLeft: Button;\n    //% block=\"button Right\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_RIGHT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonRight: Button;\n\n    //% block=\"button Up\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_UP,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonUp: Button;\n    //% block=\"button Down\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_DOWN,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonDown: Button;\n\n    //% block=\"button Menu\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_MENU,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonMenu: Button;\n}\n",
            "pxt.json": "{\n  \"name\": \"hw---stm32f401\",\n  \"description\": \"STM32F4 board\",\n  \"files\": [\n    \"config.ts\",\n    \"basepins.d.ts\",\n    \"device.d.ts\"\n  ],\n  \"card\": {\n    \"name\": \"F4\",\n    \"description\": \"Board based on STM32F4xx\",\n    \"learnMoreUrl\": \"https://arcade.makecode.com/hardware#f4\",\n    \"cardType\": \"hw\",\n    \"imageUrl\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4BAMAAACHjORcAAAAD1BMVEUAP62OLsT/gTX///8AAAAWHMbsAAABvklEQVRo3u2WDW7DIAyFkTjBpJ4gXMCKTxAp9z/TbEPcNJRtJdbKMj9R6xnMF35SteHDWA504C8Cb2vRovlyDohFi+b/C0gnaADUS5HsNFA3OzDwvuF1NQEKROHGwOU2MDC/gze7SxFnAlz2bnDgSpKNGwFVDuwFrqvVpdT5tYF0Ysd8rL8iDnSgAx3owO+ALpeN4G5jCFgPR+RuMdSoXGL8CRAgllQVI03l7mLKgw9PRhrmuLVcBAw7AiHT1EgtRQaoeIAXo89mSK6udoIIPJ1NIYsRp8oDCmQelhVSe75C2Ayp8B+3LHHXJIV86DUwoBi9FPm4rqiILDAEShwbiAFPAaM5EPqAzZuL2HeGEJpAsAaiERBV8KTzFBDr3554DgjWQDQHwttXGBEIYHmGwB+rW0aUglhsDYQXgRD1DMXW35QeYKTQAEIHkGMTGPqAoQWEDiBuegYMrwOb00UDAHGvTmBbDvx7QNwUXINrMpYDd0oP2VwNvQWYcJpnjqUxJeUejmI0ksRQQRM4pwnTNLORhjwpiSc742Eop6Q2UGg6C3l9GcgrxOOQAr/cssR7o8lJ+pP2qNGCq7yHnfoEQuYXTuqHoj8AAAAASUVORK5CYII=\"\n  },\n  \"compileServiceVariant\": \"stm32f401\",\n  \"cppDependencies\": {\n    \"accelerometer\": \"file:../accelerometer\",\n    \"lightsensor\": \"file:../lightsensor\"\n  },\n  \"dependencies\": {\n    \"core---stm32\": \"*\",\n    \"screen---st7735\": \"*\",\n    \"mixer---stm32\": \"*\",\n    \"buttons\": \"*\",\n    \"game---hw\": \"*\",\n    \"jacdac-game\": \"*\"\n  },\n  \"public\": true,\n  \"skipLocalization\": true,\n  \"yotta\": {\n    \"optionalConfig\": {\n      \"DEVICE_JACDAC_DEBUG\": 1\n    },\n    \"config\": {\n      \"DEVICE_USB\": 1,\n      \"DEVICE_WEBUSB\": 1,\n      \"PXT_DEFAULT_ACCELEROMETER\": \"ACCELEROMETER_TYPE_MMA8453\"\n    }\n  },\n  \"dalDTS\": {\n    \"corePackage\": \"../core---stm32\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "hw---samd51": {
            "basepins.d.ts": "//% advanced=true\ndeclare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_LED)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SDA)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCL)\n    const SCL: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCK)\n    const SCK: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MISO)\n    const MISO: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MOSI)\n    const MOSI: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_RX)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_TX)\n    const TX: DigitalInOutPin;\n}\n",
            "config.ts": "namespace config {\n    // all from bootloader\n}\n",
            "device.d.ts": "declare namespace input {\n    //% block=\"button A\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_A,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonA: Button;\n    //% block=\"button B\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_B,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonB: Button;\n    //% block=\"button Left\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_LEFT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonLeft: Button;\n    //% block=\"button Right\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_RIGHT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonRight: Button;\n\n    //% block=\"button Up\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_UP,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonUp: Button;\n    //% block=\"button Down\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_DOWN,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonDown: Button;\n\n    //% block=\"button Menu\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_MENU,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonMenu: Button;\n}\n",
            "pxt.json": "{\n  \"name\": \"hw---samd51\",\n  \"description\": \"SAMD51 board\",\n  \"files\": [\n    \"config.ts\",\n    \"basepins.d.ts\",\n    \"device.d.ts\"\n  ],\n  \"card\": {\n    \"name\": \"D5\",\n    \"description\": \"Board based on Microchip ATSAMD51\",\n    \"learnMoreUrl\": \"https://arcade.makecode.com/hardware#d5\",\n    \"cardType\": \"hw\",\n    \"imageUrl\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4BAMAAACHjORcAAAAD1BMVEUAP6143FL/gTX///8AAACgtqsbAAABr0lEQVRo3u2WgY2DMAxFI2WCk24CsoDFnwCJ/Wc622lwUxpVgHWlNF+p9eOYRwiUEH6c1YEd+I/A31k1mZfeESBUk3nWVwB53fyAMwvIQJebMlVRdWKgXrAjUPWFQMfHZlYBTsCS6cArAu31NavcX7B+m5T5awPXG/10rk+RDuzADuzADnwF7OryEZmNIWA9HKFpNRFcbuYVkCjmrinGwDluxbCKMYGHJZZ2KxLYI5AybTFam41J+jKZ5dxkRTHUAiQdswm0mOrMecCAPATxVraeIRUjMqBdskZr0C7ZWtfAADH1TQldV1SEiByBGs8NRMAhYHQH0j4gQA0g9q0hhSaQvIFwAmIRPUkeAmK998RjQPIGwh1Ib59hBDHAcw1Jfl53GdCCqPYZkDYCKWolqW38U7YDI4cGkLYDNTaBYR8wtIC0A4iiZ8CwHSihXXgCIO7lAKzVgZ8HxE39a/30GpzVgXdKVW+sht4GTBjGkWNpQkk5I1GMRZYaLmgCxzQgDaMYbZCDknpwEg9DuctqA4VmR0Hml4EyQzwOVcDmJWu0xgcnzaclY6YUXOU53Kk/Y5YfN7mU0qQAAAAASUVORK5CYII=\"\n  },\n  \"compileServiceVariant\": \"samd51\",\n  \"cppDependencies\": {\n    \"accelerometer\": \"file:../accelerometer\",\n    \"lightsensor\": \"file:../lightsensor\"\n  },\n  \"dependencies\": {\n    \"core---samd\": \"*\",\n    \"screen---st7735\": \"*\",\n    \"mixer---samd\": \"*\",\n    \"buttons\": \"*\",\n    \"game---hw\": \"*\",\n    \"jacdac-game\": \"*\"\n  },\n  \"yotta\": {\n    \"optionalConfig\": {\n      \"DEVICE_JACDAC_DEBUG\": 1\n    },\n    \"config\": {\n      \"DEVICE_USB\": 1,\n      \"DEVICE_WEBUSB\": 1\n    }\n  },\n  \"public\": true,\n  \"skipLocalization\": true,\n  \"dalDTS\": {\n    \"corePackage\": \"../core---samd\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "hw---rpi": {
            "config.ts": "\nnamespace config {\n    export const PIN_LED = DAL.PC_8;\n\n    export const PIN_SCK = DAL.PA_5;\n    export const PIN_MISO = DAL.PA_6;\n    export const PIN_MOSI = DAL.PA_7;\n\n    export const PIN_RX = DAL.PA_10;\n    export const PIN_TX = DAL.PA_9;\n\n    export const PIN_SDA = DAL.PB_7;\n    export const PIN_SCL = DAL.PB_6;\n\n    export const PIN_D14 = DAL.PB_9;\n    export const PIN_D15 = DAL.PB_8;\n\n    export const PIN_BTN_LEFT = DAL.PB_10;\n    export const PIN_BTN_UP = DAL.PA_15;\n    export const PIN_BTN_RIGHT = DAL.PA_5;\n    export const PIN_BTN_DOWN = DAL.PC_13;\n\n    export const PIN_BTN_A = PIN_SDA;\n    export const PIN_BTN_B = PIN_SCL;\n    export const PIN_BTN_MENU = PIN_RX;\n\n    export const PIN_DISPLAY_CS = DAL.PB_12;\n    export const PIN_DISPLAY_SCK = DAL.PB_13;\n    export const PIN_DISPLAY_MOSI = DAL.PB_15;\n    export const PIN_DISPLAY_DC = DAL.PC_5;\n    export const PIN_DISPLAY_RST = DAL.PC_4;\n    export const PIN_DISPLAY_MISO = DAL.PB_14;\n    export const PIN_DISPLAY_BL = DAL.PA_4;\n\n    // it's really piezo speaker, not an amp\n    export const PIN_SPEAKER_AMP = DAL.PB_8;\n\n    export const DISPLAY_CFG0 = 0x00000080;\n    export const DISPLAY_CFG1 = 0x000603;\n\n    export const DISPLAY_CFG2 = 22; // MHz\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 120;\n}\n",
            "device.d.ts": "declare namespace input {\n}\n\ndeclare namespace control {\n    //% shim=control::programList\n    function programList() : string[];\n}",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Key {\n    LEFT = 1,\n    UP = 2,\n    RIGHT = 3,\n    DOWN = 4,\n    A = 5,\n    B = 6,\n    MENU = 7,\n    LEFT2 = 8,\n    UP2 = 9,\n    RIGHT2 = 10,\n    DOWN2 = 11,\n    A2 = 12,\n    B2 = 13,\n    RESET = 14,\n    EXIT = 15,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "gamesel.cpp": "#include \"pxt.h\"\n\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <unistd.h>\n\nnamespace control {\n\n\n//%\nRefCollection *programList() {\n    DIR *d = opendir(PROGDIR);\n    auto res = Array_::mk();\n    registerGCObj(res);\n    for (;;) {\n        struct dirent *ent = readdir(d);\n        if (!ent)\n            break;\n        int len = strlen(ent->d_name);\n        if (len <= 4)\n            continue;\n        if (strcmp(ent->d_name + len - 4, \".elf\") != 0)\n            continue;\n        ent->d_name[len - 4] = 0; // chop extension\n        //DMESG(\"add: '%s'\", ent->d_name);\n        auto tmp = (TValue)mkString(ent->d_name, -1);\n        registerGCPtr(tmp);\n        res->head.push(tmp);\n        unregisterGCPtr(tmp);\n    }\n    closedir(d);\n    unregisterGCObj(res);\n    return res;\n}\n\n/** Run specified user program. */\n//%\nvoid runProgram(String prog) {\n    char *p;\n    asprintf(&p, \"%s/%s.elf\", PROGDIR, prog->getUTF8Data());\n    initialArgv = new char*[3];\n    initialArgv[0] = p;\n    initialArgv[1] = (char*)\"--run\";\n    initialArgv[2] = 0;\n    target_reset();\n}\n\n/**\n * Deletes a user program\n */\n//%\nvoid deleteProgram(String prog) {\n    char *p;\n    asprintf(&p, \"%s/%s.elf\", PROGDIR, prog->getUTF8Data());\n    unlink(p);\n}\n\n} // namespace control\n",
            "keys.cpp": "#include \"pxt.h\"\n\n#include <wiringPi.h>\n#include <wiringPiI2C.h>\n#include <pthread.h>\n\nnamespace music {\nvoid playTone(int frequency, int ms);\n}\n\nnamespace pxt {\n\nenum class Key {\n    LEFT = 1,\n    UP,\n    RIGHT,\n    DOWN,\n    A,\n    B,\n    MENU,\n    LEFT2,\n    UP2,\n    RIGHT2,\n    DOWN2,\n    A2,\n    B2,\n    RESET,\n    EXIT,\n};\n\n/*\nBTN_A = 12, 16\nBTN_B = 6, 13\nBTN_MENU = 20\nBTN_EXIT = 22, 23\nBTN_RESTART = 26\nJOYSTICK_ADDR = 0x48\n# Free pins: 4, 5, 17, 24, 25, 27\n*/\n\nconst int INTERNAL_KEY_UP = 2050;\nconst int INTERNAL_KEY_DOWN = 2051;\n\nstatic int adcFD;\n\n#define SWAP(v) (uint16_t)((v >> 8) | (v << 8))\n#define MID 0x3300\n#define DEAD 0x1000\n\nstatic int readADC(int channel) {\n    if (!adcFD) {\n        int addr = getConfigInt(\"JOYSTICK_ADDR\", -1);\n        if (addr < 0)\n            adcFD = -1;\n        else\n            adcFD = wiringPiI2CSetup(0x48);\n    }\n\n    if (adcFD < 0)\n        return MID;\n\n    uint16_t config = 0x8383;\n    config += 0x4000 + 0x1000 * channel;\n\n    wiringPiI2CWriteReg16(adcFD, 0x01, SWAP(config));\n    sleep_core_us(1000);\n\n    config = wiringPiI2CReadReg16(adcFD, 0x00);\n    return SWAP(config);\n}\n\n#define SET(s) r |= 1 << (int)(Key::s)\n#define KEY(s)                                                                                     \\\n    if (isPressed(\"BTN_\" #s, (int)Key::s))                                                         \\\n    SET(s)\n\nstatic int isPressed(const char *name, int keyPos) {\n    static uint64_t parsedPin[(int)Key::EXIT + 1];\n\n    if (parsedPin[keyPos] == 0) {\n        auto pins = getConfigInts(name);\n        for (int i = 0; pins[i] != ENDMARK; ++i) {\n            auto p = pins[i];\n            auto mask = 1ULL << p;\n            parsedPin[keyPos] |= mask;\n            pinMode(p, INPUT);\n            pullUpDnControl(p, PUD_UP);\n        }\n        // make sure it's non-zero\n        parsedPin[keyPos] |= 1ULL << 63;\n    }\n\n    for (int i = 0; i < 63; ++i) {\n        if ((parsedPin[keyPos] >> i) & 1)\n            if (!digitalRead(i))\n                return 1;\n    }\n\n    return 0;\n}\n\nstatic uint32_t readBtns() {\n    uint32_t r = 0;\n\n    KEY(A);\n    KEY(B);\n    KEY(LEFT);\n    KEY(RIGHT);\n    KEY(UP);\n    KEY(DOWN);\n    KEY(MENU);\n    KEY(EXIT);\n    KEY(RESET);\n\n    KEY(A2);\n    KEY(B2);\n    KEY(LEFT2);\n    KEY(RIGHT2);\n    KEY(UP2);\n    KEY(DOWN2);\n\n    uint16_t ch0 = readADC(0), ch1 = readADC(1);\n\n    if (ch0 < MID - DEAD)\n        SET(UP);\n    if (ch0 > MID + DEAD)\n        SET(DOWN);\n\n    if (ch1 < MID - DEAD)\n        SET(LEFT);\n    if (ch1 > MID + DEAD)\n        SET(RIGHT);\n\n    return r;\n}\n\nstatic void *btnPoll(void *dummy) {\n    (void)dummy;\n\n    uint32_t state = readBtns();\n    int k = 0;\n    while (1) {\n        sleep_core_us(5000);\n        uint32_t nstate = readBtns();\n\n        if (k++ % 30 == 0) {\n            // DMESG(\"CH0 %p CH1 %p\", readADC(0), readADC(1));\n        }\n\n        if (state != nstate) {\n            for (int i = 1; i < 32; ++i) {\n                uint32_t mask = 1 << i;\n                int ev = 0;\n                if ((state & mask) && !(nstate & mask))\n                    ev = INTERNAL_KEY_UP;\n                else if (!(state & mask) && (nstate & mask)) {\n                    ev = INTERNAL_KEY_DOWN;\n                    if (i == (int)Key::EXIT)\n                        target_exit();\n                    else if (i == (int)Key::RESET)\n                        target_reset();\n                }\n                if (ev) {\n                    // DMESG(\"evt: %d at %d\", ev, i);\n                    raiseEvent(ev, i);\n                    raiseEvent(ev, 0); // any key\n                }\n            }\n            state = nstate;\n        }\n    }\n\n    return NULL;\n}\n\nvoid initKeys() {\n    DMESG(\"init keys\");\n    // music::playTone(0, 0); // start music process early\n\n    wiringPiSetupGpio();\n\n    pthread_t disp;\n    pthread_create(&disp, NULL, btnPoll, NULL);\n    pthread_detach(disp);\n}\n\n} // namespace pxt\n",
            "pxt.json": "{\n  \"name\": \"hw---rpi\",\n  \"description\": \"Raspberry Pi\",\n  \"files\": [\n    \"keys.cpp\",\n    \"config.ts\",\n    \"gamesel.cpp\",\n    \"enums.d.ts\",\n    \"shims.d.ts\",\n    \"device.d.ts\"\n  ],\n  \"card\": {\n    \"name\": \"Pi0\",\n    \"description\": \"Raspberry Pi Zero (custom piCore Linux image)\",\n    \"learnMoreUrl\": \"https://arcade.makecode.com/hardware#pi0\",\n    \"cardType\": \"hw\",\n    \"imageUrl\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4BAMAAACHjORcAAAAD1BMVEUAAAD/k8T/9gn/gTX///8CbOdcAAAB3klEQVRo3u1aQW7EIAyMlBcg+QXNB1D8AiT//01lsONuKZUQzWGjethmhMdMsAu9dLd0Mx5iKIlKYzwBEWUy1iRHr4mI65saqRVslan0LoQUQ695vhuKFCyAABY3EDcSDNJ5p9m6zlALF11oBiQ287lmpE6jHyUT3qBvFHFDHdZPMHYiauCataoztL3Z+23hNRSqK3fa2LCVYz1MtlvEXnqIsMdfNYs/6WC/t2Hg7/i4Gf/WkG0ABx/nwWebg9cMmc/LUJk9dovhwWbIq4YHytTFYAzEeL2Hx4mnglsfEVvuIVArvPi9js1TwdubYedcN8XKDN4q58p7hg5+zZkAwyiDMzxgaMNUz6nPmR1qMhj5A0PPYZ4wZIx9z+BaHAJu4i/0nAmgR7ACaw+zl6lgz4G2jFqhc+Am7Hf3cuIMdudMjwx4cOXmDZFmhzqDYTS4cvMl4+1uyMrDKzffQ/5arL1fuXIO/1MFI+y2+gyvXKXlX2JcuUAgEAgEAoFAIBAIBAKBQOA7HvAf8F8VfMPDQfVHOmnCUIp/6ipKBVZF6pSoeqqUXNIpEsaGWEJ42lqSFiRCvCSSTrIp9AlDfFpxlJphpV7yKf1espAVIlfhMGxx74YmeMlIeNgXJ+42/ASw+1fGCliG7AAAAABJRU5ErkJggg==\"\n  },\n  \"compileServiceVariant\": \"rpi\",\n  \"dependencies\": {\n    \"core---linux\": \"*\",\n    \"mixer---linux\": \"*\",\n    \"screen---linux\": \"*\",\n    \"settings---files\": \"*\",\n    \"controller---none\": \"*\",\n    \"game\": \"*\"\n  },\n  \"public\": true,\n  \"skipLocalization\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /** Run specified user program. */\n    //% shim=control::runProgram\n    function runProgram(prog: string): void;\n\n    /**\n     * Deletes a user program\n     */\n    //% shim=control::deleteProgram\n    function deleteProgram(prog: string): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "hw---vm": {
            "config.ts": "\nnamespace config {\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 120;\n}\n\ncontrol.internalOnEvent(INTERNAL_KEY_DOWN, 100, () => control.reset())\n",
            "device.d.ts": "declare namespace input {\n}\n\ndeclare namespace control {\n}",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Key {\n    KEY_LEFT = 1,\n    KEY_UP = 2,\n    KEY_RIGHT = 3,\n    KEY_DOWN = 4,\n    KEY_A = 5,\n    KEY_B = 6,\n    KEY_MENU = 7,\n    KEY_RESET = 100,\n    KEY_EXIT = 101,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "pxt.json": "{\n  \"name\": \"hw---vm\",\n  \"description\": \"VM\",\n  \"files\": [\n    \"sdlmain.cpp\",\n    \"config.ts\",\n    \"enums.d.ts\",\n    \"shims.d.ts\",\n    \"device.d.ts\"\n  ],\n  \"card\": {\n    \"name\": \"VM\",\n    \"description\": \"VM\",\n    \"learnMoreUrl\": \"https://arcade.makecode.com/hardware#vm\",\n    \"cardType\": \"hw\"\n  },\n  \"compileServiceVariant\": \"vm\",\n  \"dependencies\": {\n    \"core---vm\": \"*\",\n    \"mixer---ext\": \"*\",\n    \"screen---ext\": \"*\",\n    \"settings---files\": \"*\",\n    \"game\": \"*\"\n  },\n  \"public\": true,\n  \"skipLocalization\": true,\n  \"experimentalHw\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "sdlmain.cpp": "#include \"SDL.h\"\n#include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#if UINTPTR_MAX == 0xffffffff\n#define BINSUFF \"-32\"\n#elif UINTPTR_MAX == 0xffffffffffffffff\n#define BINSUFF \"\"\n#else\n#error \"UINTPTR_MAX has invalid value\"\n#endif\n\n#if defined(__IPHONEOS__) || defined(__ANDROID__)\n#define PXT_STATIC 1\n#define PXT_TOUCH 1\n#define PXT_IOS 1\n#endif\n\n#if defined(__WINDOWS__)\n#include <windows.h>\n#define WIN_StringToUTF8(S)                                                                        \\\n    SDL_iconv_string(\"UTF-8\", \"UTF-16LE\", (char *)(S), (SDL_wcslen(S) + 1) * sizeof(WCHAR))\n#define WIN_UTF8ToString(S)                                                                        \\\n    (WCHAR *)SDL_iconv_string(\"UTF-16LE\", \"UTF-8\", (char *)(S), SDL_strlen(S) + 1)\n#endif\n\n#ifndef PXT_STATIC\n#if defined(__MACOSX__)\n#define SONAME \"libpxt\" BINSUFF \".dylib\"\n#elif defined(__WINDOWS__)\n#define SONAME \"pxt\" BINSUFF \".dll\"\n#else\n#define SONAME \"libpxt\" BINSUFF \".so\"\n#endif\n#endif\n\n#define WIDTH 160\n#define HEIGHT 120\n\nint win_width, win_height;\n\nSDL_Rect activeDisplayRect;\n\nSDL_Renderer *renderer;\n\nconst int SCREEN_WIDTH = WIDTH * 4;\nconst int SCREEN_HEIGHT = HEIGHT * 4;\n\nconst int INTERNAL_KEY_UP = 2050;\nconst int INTERNAL_KEY_DOWN = 2051;\n\nenum Key {\n    KEY_LEFT = 1,\n    KEY_UP,\n    KEY_RIGHT,\n    KEY_DOWN,\n    KEY_A,\n    KEY_B,\n    KEY_MENU,\n    KEY_RESET = 100, // passed as event to TS, which does control.reset()\n    KEY_EXIT,        // handled here\n};\n\nint mapKeyCode(int sdlCode) {\n    switch (sdlCode) {\n    case SDLK_ESCAPE:\n        return KEY_EXIT;\n    case '/':\n        return KEY_RESET;\n    case 'a':\n    case SDLK_LEFT:\n        return KEY_LEFT;\n    case 'd':\n    case SDLK_RIGHT:\n        return KEY_RIGHT;\n    case 'w':\n    case SDLK_UP:\n        return KEY_UP;\n    case 's':\n    case SDLK_DOWN:\n        return KEY_DOWN;\n    case ' ':\n    case 'q':\n    case 'z':\n        return KEY_A;\n    case 'x':\n    case 'e':\n    case SDLK_RETURN:\n        return KEY_B;\n\n    case 'm':\n        return KEY_MENU;\n\n    case 'j':\n        return KEY_LEFT + 7;\n    case 'i':\n        return KEY_UP + 7;\n    case 'l':\n        return KEY_RIGHT + 7;\n    case 'k':\n        return KEY_DOWN + 7;\n    case 'u':\n        return KEY_A + 7;\n    case 'o':\n        return KEY_B + 7;\n\n    default:\n        return 0;\n    }\n}\n\ntypedef void (*get_pixels_t)(int width, int height, uint32_t *screen);\ntypedef void (*raise_event_t)(int src, int val);\ntypedef void (*vm_start_t)(const char *fn);\ntypedef void (*vm_start_buffer_t)(uint8_t *data, unsigned len);\ntypedef int (*get_logs_t)(int logtype, char *dst, int maxSize);\ntypedef int (*get_panic_code_t)();\ntypedef void (*get_audio_samples_t)(int16_t *buf, unsigned numSamples);\n\n#ifdef PXT_STATIC\nextern \"C\" {\nvoid pxt_screen_get_pixels(int width, int height, uint32_t *screen);\nvoid pxt_raise_event(int src, int val);\nvoid pxt_vm_start(const char *fn);\nvoid pxt_vm_start_buffer(uint8_t *data, unsigned len);\nint pxt_get_logs(int logtype, char *dst, int maxSize);\nint pxt_get_panic_code();\nvoid pxt_get_audio_samples(int16_t *buf, unsigned numSamples);\n}\n#else\nget_audio_samples_t pxt_get_audio_samples;\nraise_event_t pxt_raise_event;\nvm_start_buffer_t pxt_vm_start_buffer;\n#endif\n\nint exitReq;\n\nvoid raise_key(Key k, int ev) {\n    if (k == KEY_EXIT && ev == INTERNAL_KEY_UP)\n        exitReq = 1;\n    pxt_raise_event(ev, k);\n    pxt_raise_event(ev, 0); // any\n}\n\nvoid fatal(const char *msg, const char *info = \"\") {\n    SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, \"%s %s (SDL Error: %s)\", msg, info ? info : \"\",\n                    SDL_GetError());\n    exit(1);\n}\n\n#ifndef PXT_TOUCH\nvoid init_touch_keys() {}\nvoid draw_touch_keys() {}\nvoid handle_touch_events(SDL_Event &) {}\n#else\nstruct OnScreenKey {\n    Key keyId;\n    SDL_Point center;\n    char name;\n    bool isPressed, prevPressed;\n};\n\nstruct TrackedFinger {\n    SDL_FingerID fingerId;\n    OnScreenKey *lastKey, *secondLastKey;\n};\n\n#define NUM_FINGERS 10\n#define NUM_KEYS 8\n\nOnScreenKey keys[NUM_KEYS];\nTrackedFinger fingers[NUM_FINGERS];\n\nint distance(SDL_Point &a, SDL_Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nvoid add_key(Key kid, char name, int x, int y) {\n    for (int i = 0; i < NUM_KEYS; ++i) {\n        if (keys[i].keyId == 0) {\n            auto k = &keys[i];\n            k->keyId = kid;\n            k->center.x = x;\n            k->center.y = y;\n            k->name = name;\n            break;\n        }\n    }\n}\n\nvoid init_touch_keys() {\n    int widthLeft = activeDisplayRect.x;\n    int widthRight = win_width - activeDisplayRect.x - activeDisplayRect.w;\n\n    int kps = widthLeft / 2 - 10;\n    if (kps > win_height / 6)\n        kps = win_height / 6;\n    int kpx = widthLeft / 2;\n    int menuY = win_height / 10;\n    int kpy = win_height / 2 + menuY;\n\n    add_key(KEY_MENU, 'M', kpx - kps, menuY);\n    add_key(KEY_EXIT, 'E', kpx + kps, menuY);\n\n    add_key(KEY_LEFT, '<', kpx - kps, kpy);\n    add_key(KEY_RIGHT, '<', kpx + kps, kpy);\n    add_key(KEY_UP, '^', kpx, kpy - kps);\n    add_key(KEY_DOWN, 'v', kpx, kpy + kps);\n\n    int abx = win_width - widthRight / 2;\n    int ay = win_height / 2 - kps;\n    int by = win_height / 2 + kps;\n\n    add_key(KEY_A, 'A', abx, ay);\n    add_key(KEY_B, 'B', abx, by);\n}\n\nvoid draw_touch_keys() {\n    SDL_Rect keyR;\n    int sz = 3;\n    keyR.w = sz * 2;\n    keyR.h = sz * 2;\n    for (int i = 0; i < NUM_KEYS; ++i) {\n        SDL_SetRenderDrawColor(renderer, 255, keys[i].isPressed ? 255 : 0, 0, 255);\n        keyR.x = keys[i].center.x - sz;\n        keyR.y = keys[i].center.y - sz;\n        SDL_RenderFillRect(renderer, &keyR);\n    }\n}\n\nvoid handle_touch_events(SDL_Event &e) {\n    if (e.type == SDL_FINGERDOWN || e.type == SDL_FINGERUP || e.type == SDL_FINGERMOTION) {\n        SDL_Point p;\n        p.x = e.tfinger.x * win_width;\n        p.y = e.tfinger.y * win_height;\n\n        int i, firstFree = -1;\n        for (i = 0; i < NUM_FINGERS; ++i) {\n            if (fingers[i].lastKey) {\n                if (fingers[i].fingerId == e.tfinger.fingerId)\n                    break;\n            } else {\n                if (firstFree == -1)\n                    firstFree = i;\n            }\n        }\n\n        if (e.type == SDL_FINGERUP) {\n            if (i != NUM_FINGERS)\n                fingers[i].lastKey = NULL;\n        } else {\n            if (i == NUM_FINGERS) {\n                i = firstFree;\n                if (i == -1)\n                    fatal(\"too many fingers?\");\n            }\n            fingers[i].fingerId = e.tfinger.fingerId;\n            auto nearest = &keys[0];\n            auto nearestDistance = -1;\n            for (int j = 0; j < NUM_KEYS; ++j) {\n                auto dist = distance(p, keys[j].center);\n                if (nearestDistance == -1 || nearestDistance > dist) {\n                    nearestDistance = dist;\n                    nearest = &keys[j];\n                }\n            }\n\n            fingers[i].secondLastKey = NULL;\n            auto minDistance = (win_height / 5) * (win_height / 5);\n            if (nearestDistance > minDistance)\n                nearest = NULL;\n            else {\n                auto secondNearest = &keys[0];\n                auto secondNearestDist = -1;\n                for (int j = 0; j < NUM_KEYS; ++j) {\n                    if (&keys[j] == nearest)\n                        continue;\n                    auto dist = distance(p, keys[j].center);\n                    if (secondNearestDist == -1 || secondNearestDist > dist) {\n                        secondNearestDist = dist;\n                        secondNearest = &keys[j];\n                    }\n                }\n\n                auto maxDist = nearestDistance * 16 / 10;\n                if (secondNearestDist < maxDist) {\n                    fingers[i].secondLastKey = secondNearest;\n                }\n            }\n\n            fingers[i].lastKey = nearest;\n        }\n\n        for (int j = 0; j < NUM_KEYS; ++j) {\n            keys[j].prevPressed = keys[j].isPressed;\n            keys[j].isPressed = false;\n        }\n\n        for (int i = 0; i < NUM_FINGERS; ++i) {\n            if (fingers[i].lastKey)\n                fingers[i].lastKey->isPressed = true;\n            if (fingers[i].secondLastKey)\n                fingers[i].secondLastKey->isPressed = true;\n        }\n\n        for (int j = 0; j < NUM_KEYS; ++j) {\n            if (keys[j].prevPressed != keys[j].isPressed)\n                raise_key(keys[j].keyId, keys[j].isPressed ? INTERNAL_KEY_DOWN : INTERNAL_KEY_UP);\n        }\n    }\n}\n#endif\n\n#define SDL_CHECK(call)                                                                            \\\n    if (!(call)) {                                                                                 \\\n        fatal(\"SDL Call error\", #call);                                                            \\\n    }\n\n#ifndef PXT_STATIC\nvoid *loadPXTLib(char *argv[]) {\n    const char *exename = argv[0];\n    if (exename == NULL || !strchr(exename, '/'))\n        exename = \"./vm\";\n    int solen = strlen(exename) + strlen(SONAME);\n    char namebuf[solen + 1];\n    strcpy(namebuf, exename);\n    strcpy(strrchr(namebuf, '/') + 1, SONAME);\n\n    void *vmDLL = SDL_LoadObject(namebuf);\n    if (!vmDLL) {\n        fatal(\"can't load DLL\", namebuf);\n    }\n\n    return vmDLL;\n}\n#endif\n\nchar logtmp[64 * 1024];\n\nvoid flush_logs(get_logs_t get_logs) {\n    while (1) {\n        int sz = get_logs(0, logtmp, sizeof(logtmp) - 1);\n        if (sz <= 0)\n            break;\n        for (int i = 0; i < sz;) {\n            int j;\n            for (j = i; j < sz; ++j) {\n                if (logtmp[j] == '\\n') {\n                    break;\n                }\n            }\n            logtmp[j] = 0;\n            SDL_Log(\"%s\", logtmp + i);\n            i = j + 1;\n        }\n    }\n}\n\nvoid audioCallback(void *userdata, Uint8 *stream, int len) {\n    pxt_get_audio_samples((int16_t *)stream, len / 2);\n}\n\nSDL_AudioDeviceID audioDev;\nvoid openAudio() {\n    SDL_AudioSpec wanted, actual;\n\n    SDL_zero(wanted);\n    SDL_zero(actual);\n    wanted.freq = 44100;\n    wanted.format = AUDIO_S16SYS;\n    wanted.channels = 1;\n    wanted.samples = 1024;\n    wanted.callback = audioCallback;\n\n    int n = SDL_GetNumAudioDevices(0);\n    for (int i = 0; i < n; ++i) {\n        SDL_Log(\"audio %d %s\", i, SDL_GetAudioDeviceName(i, 0));\n    }\n\n    audioDev = SDL_OpenAudioDevice(NULL, 0, &wanted, &actual, 0);\n\n    // SDL_CHECK(SDL_OpenAudio(&wanted, &actual) == 0);\n\n    SDL_Log(\"audio device %d Hz, %d ch, %d sampl\", actual.freq, actual.channels, actual.samples);\n}\n\nstatic void SDLCALL logOutput(void *userdata, int category, SDL_LogPriority priority,\n                              const char *message) {\n    (void)userdata;\n\n#if defined(__WINDOWS__)\n    static HANDLE stdoutHandle;\n\n    if (!stdoutHandle) {\n        AttachConsole(ATTACH_PARENT_PROCESS);\n        stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n    }\n\n    unsigned len = strlen(message) + 2;\n    char msgNL[len + 1];\n    strcpy(msgNL, message);\n    strcat(msgNL, \"\\r\\n\");\n\n    OutputDebugString(msgNL);\n\n    unsigned long charsWritten;\n    WriteFile(stdoutHandle, msgNL, len, &charsWritten, NULL);\n#else\n    fprintf(stderr, \"%s\\n\", message);\n#endif\n}\n\n#ifdef PXT_IOS\nextern \"C\" void fetchSources(const char *scriptId);\nextern \"C\" void initCache();\n#endif\n\nextern \"C\" int main(int argc, char *argv[]) {\n#ifdef PXT_IOS\n    initCache();\n#endif\n\n    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_INFO);\n\n    SDL_LogSetOutputFunction(logOutput, NULL);\n\n#ifndef PXT_STATIC\n    SDL_Log(\"loading %s ...\", SONAME);\n\n    void *vmDLL = loadPXTLib(argv);\n    get_pixels_t pxt_screen_get_pixels =\n        (get_pixels_t)SDL_LoadFunction(vmDLL, \"pxt_screen_get_pixels\");\n    vm_start_t pxt_vm_start = (vm_start_t)SDL_LoadFunction(vmDLL, \"pxt_vm_start\");\n    pxt_vm_start_buffer = (vm_start_buffer_t)SDL_LoadFunction(vmDLL, \"pxt_vm_start_buffer\");\n    pxt_raise_event = (raise_event_t)SDL_LoadFunction(vmDLL, \"pxt_raise_event\");\n    get_logs_t pxt_get_logs = (get_logs_t)SDL_LoadFunction(vmDLL, \"pxt_get_logs\");\n    get_panic_code_t pxt_get_panic_code =\n        (get_panic_code_t)SDL_LoadFunction(vmDLL, \"pxt_get_panic_code\");\n    pxt_get_audio_samples = (get_audio_samples_t)SDL_LoadFunction(vmDLL, \"pxt_get_audio_samples\");\n\n    if (!pxt_screen_get_pixels || !pxt_vm_start || !pxt_vm_start_buffer || !pxt_raise_event ||\n        !pxt_get_logs || !pxt_get_panic_code || !pxt_get_audio_samples) {\n        fatal(\"can't load pxt function from DLL\", \"\");\n    }\n#endif\n\n    SDL_CHECK(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) >= 0);\n\n    SDL_Window *window =\n        SDL_CreateWindow(\"MakeCode Arcade64\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,\n                         SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n\n    SDL_GetWindowSize(window, &win_width, &win_height);\n\n    SDL_CHECK(window != NULL);\n\n    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n\n    SDL_Surface *surf;\n    surf = SDL_CreateRGBSurfaceWithFormat(0, WIDTH, HEIGHT, 32, SDL_PIXELFORMAT_BGRA32);\n\n    SDL_CHECK(surf != NULL);\n\n    openAudio();\n\n    memset(surf->pixels, 0, HEIGHT * WIDTH * 4);\n\n    SDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, surf);\n\n    int ww2 = win_height * 4 / 3;\n    int freeSpace = win_width - ww2;\n    int widthLeft = 3 * freeSpace / 4;\n    activeDisplayRect.x = widthLeft;\n    activeDisplayRect.y = 0;\n    activeDisplayRect.h = win_height;\n    activeDisplayRect.w = ww2;\n\n    init_touch_keys();\n\n    SDL_RenderClear(renderer);\n    SDL_RenderCopy(renderer, tex, NULL, &activeDisplayRect);\n    SDL_RenderPresent(renderer);\n\n    int now = SDL_GetTicks();\n    int nextLoad = now + 100;\n    int lastLoad = 0;\n\n    SDL_Event e;\n    int quit = 0;\n    int numFr = 0;\n    int prevTicks = SDL_GetTicks();\n\n    const char *imageName = argv[1];\n#ifdef PXT_IOS\n    const char *imageID = NULL;\n    imageName = \"menu.pxt64\";\n#endif\n\n    while (!quit) {\n        now = SDL_GetTicks();\n\n        if (nextLoad && now >= nextLoad) {\n#ifdef PXT_IOS\n            if (imageID) {\n                fetchSources(imageID);\n                imageID = NULL;\n            } else\n#endif\n                pxt_vm_start(imageName);\n            SDL_PauseAudioDevice(audioDev, 0);\n            // SDL_PauseAudio(0);\n            nextLoad = 0;\n            lastLoad = now;\n        }\n\n        while (SDL_PollEvent(&e)) {\n            if (e.type == SDL_QUIT) {\n                quit = 1;\n            }\n            if ((e.type == SDL_KEYDOWN || e.type == SDL_KEYUP) && !e.key.repeat) {\n                int ev = e.type == SDL_KEYDOWN ? INTERNAL_KEY_DOWN : INTERNAL_KEY_UP;\n                auto kk = (Key)mapKeyCode(e.key.keysym.sym);\n                if (kk == KEY_EXIT) {\n                    quit = 1;\n                    break;\n                }\n                if (kk)\n                    raise_key(kk, ev);\n            }\n#ifdef PXT_IOS\n            if (e.type == SDL_DROPFILE) {\n                char *p = e.drop.file;\n                while (*p && *p != ':')\n                    p++;\n                while (*p && (*p == ':' || *p == '/'))\n                    p++;\n                char *beg = p;\n                if (*p == '_') {\n                    p++;\n                    while (isalnum(*p))\n                        p++;\n                } else if (isdigit(*p)) {\n                    while (isdigit(*p) || *p == '-')\n                        p++;\n                }\n                if (p - beg > 8) {\n                    *p = 0;\n                    nextLoad = now + 300;\n                    SDL_free((void *)imageID);\n                    imageID = SDL_strdup(beg);\n                }\n                SDL_free(e.drop.file);\n            }\n#endif\n\n            if (e.type == SDL_MOUSEBUTTONDOWN) {\n                // quit = 1;\n            }\n            handle_touch_events(e);\n        }\n\n        pxt_screen_get_pixels(WIDTH, HEIGHT, (uint32_t *)surf->pixels);\n\n        SDL_UpdateTexture(tex, NULL, surf->pixels, WIDTH * 4);\n\n        SDL_SetRenderDrawColor(renderer, 40, 40, 40, 255);\n        SDL_RenderClear(renderer);\n        SDL_RenderCopy(renderer, tex, NULL, &activeDisplayRect);\n\n        draw_touch_keys();\n        SDL_RenderPresent(renderer);\n\n        flush_logs(pxt_get_logs);\n\n        if (exitReq) {\n            if (!nextLoad && now > 2000 + lastLoad) {\n                SDL_Log(\"exit at key request\");\n                nextLoad = now;\n            }\n            exitReq = 0;\n        }\n\n        if (!nextLoad) {\n            int code = pxt_get_panic_code();\n            if (code == -1) {\n                // restart done in user code\n            } else if (code >= 1000) {\n                SDL_Log(\"hit soft crash, code=%d; restarting\", code - 1000);\n                nextLoad = now + 3000;\n            } else if (code != 0) {\n                SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, \"fatal runtime error %d; bye\", code);\n                exit(1);\n            }\n        }\n\n        numFr++;\n        int now = SDL_GetTicks();\n        if (now - prevTicks > 1000) {\n            // printf(\"fps=%d\\n\", numFr);\n            prevTicks = now;\n            numFr = 0;\n        }\n\n#ifdef PXT_IOS\n        SDL_Delay(25);\n#endif\n    }\n\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /** Run specified user program. */\n    //% shim=control::runProgram\n    function runProgram(prog: string): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "feather": {
            "README.md": "# feather\n\nProvides pin definition for Adafruit Feather compatible boards.\n\n\nSee https://learn.adafruit.com/assets/78438",
            "device.d.ts": "declare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A0)\n    const A0: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A1)\n    const A1: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A2)\n    const A2: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A3)\n    const A3: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A4)\n    const A4: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_A5)\n    const A5: PwmPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D0)\n    const D0: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D1)\n    const D1: PwmPin;\n\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D4)\n    const D4: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D5)\n    const D5: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D6)\n    const D6: PwmPin;\n\n\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D9)\n    const D9: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D10)\n    const D10: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D11)\n    const D11: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D12)\n    const D12: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D13)\n    const D13: PwmPin;\n\n}\n",
            "pxt.json": "{\n  \"requiredCategories\": [\n    \"pins\"\n  ],\n  \"name\": \"feather\",\n  \"description\": \"Adafruit Feather pinout\",\n  \"files\": [\n    \"README.md\",\n    \"device.d.ts\",\n    \"targetoverrides.d.ts\"\n  ],\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"public\": true,\n  \"weight\": 2,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/38c1b1631af5ed348d5c988ad3182be9aaa94d2e/static/libs/feather.png\"\n}",
            "targetoverrides.d.ts": "declare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D2)\n    const D2: PwmPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D3)\n    const D3: PwmPin;\n}"
        },
        "sevenseg": {
            "README.md": "# Seven segment\n\nFunctions and classes to create a seven segment display.\n",
            "pxt.json": "{\n  \"name\": \"sevenseg\",\n  \"description\": \"Seven segment digit display\",\n  \"files\": [\n    \"README.md\",\n    \"sevenseg.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/b8e8179f3eb19b05ac3c1b23fd25464b0efd8aa9/static/libs/sevenseg.png\"\n}",
            "sevenseg.ts": "enum SegmentStyle {\n    //% block=\"blank\"\n    Blank = 0,\n    //% block=\"thin\"\n    Thin = 1,\n    //% block=\"narrow\"\n    Narrow = 2,\n    //% block=\"medium\"\n    Medium = 3,\n    //% block=\"thick\"\n    Thick = 4\n}\n\nenum DigitRadix {\n    //% block=\"decimal\"\n    Decimal = 10,\n    //% block=\"hex\"\n    Hex = 16,\n    //% block=\"octal\"\n    Octal = 8,\n    //% block=\"alpha\"\n    Alpha = 25\n}\n\nenum SegmentScale {\n    //% block=\"full\"\n    Full,\n    //% block=\"half\"\n    Half\n}\n\n// \"ABCDEFHJLoPUY-°\"\nenum SegmentCharacter {\n    //% block=\"A\"\n    A = 10,\n    //% block=\"B\"\n    B,\n    //% block=\"C\"\n    C,\n    //% block=\"D\"\n    D,\n    //% block=\"E\"\n    E,\n    //% block=\"F\"\n    F,\n    //% block=\"H\"\n    H,\n    //% block=\"J\"\n    J,\n    //% block=\"L\"\n    L,\n    //% block=\"o\"\n    o,\n    //% block=\"P\"\n    P,\n    //% block=\"U\"\n    U,\n    //% block=\"Y\"\n    Y,\n    //% block=\"-\"\n    Hyphen,\n    //% block=\"°\"\n    Degree\n}\n\n/**\n* Seven segment display digits and gizmos\n*/\n//% icon=\"\\uf2a1\" color=\"#4682B4\" blockGap=8\n//% groups='[\"Create\", \"Counter\", \"Digits\"]'\nnamespace sevenseg {\n\n    // Copy these array sets along with the array mapping string into Node to get the\n    // formatting of the segment buffer data.\n\n    /*\n    var fullSegment: number[][] = [\n        [1, 0, 14, 0, 2, 1, 13, 1, 3, 2, 12, 2, 4, 3, 11, 3],\n        [15, 2, 15, 14, 14, 3, 14, 13, 13, 4, 13, 12, 12, 5, 12, 11],\n        [15, 17, 15, 29, 14, 18, 14, 28, 13, 19, 13, 27, 12, 20, 12, 26],\n        [1, 31, 14, 31, 2, 30, 13, 30, 3, 29, 12, 29, 4, 28, 11, 28],\n        [0, 17, 0, 29, 1, 18, 1, 28, 2, 19, 2, 27, 3, 20, 3, 26],\n        [0, 2, 0, 14, 1, 3, 1, 13, 2, 4, 2, 12, 3, 5, 3, 11],\n        [2, 15, 13, 15, 2, 16, 13, 16, 3, 14, 12, 14, 3, 17, 12, 17]\n    ];\n    \"hex`\" + fullSegment.map(n => n.toString(16)).map(n => n.length < 2 ? \"0\" + n : n).join(\"\") + \"`\"\n    */\n\n    // packed metrics of pixel drawing for full size digit segments\n    const fullSegment: Buffer[] = [\n        hex`01000e0002010d0103020c0204030b03`,\n        hex`0f020f0e0e030e0d0d040d0c0c050c0b`,\n        hex`0f110f1d0e120e1c0d130d1b0c140c1a`,\n        hex`011f0e1f021e0d1e031d0c1d041c0b1c`,\n        hex`0011001d0112011c0213021b0314031a`,\n        hex`0002000e0103010d0204020c0305030b`,\n        hex`020f0d0f02100d10030e0c0e03110c11`\n    ];\n\n    /*\n    var halfSegment: number[][] = [\n        [1, 0, 6, 0, 2, 1, 5, 1],\n        [7, 2, 7, 6, 6, 3, 6, 5],\n        [7, 8, 7, 13, 6, 9, 6, 12],\n        [1, 15, 6, 15, 2, 14, 5, 14],\n        [0, 8, 0, 13, 1, 9, 1, 12],\n        [0, 2, 0, 6, 1, 3, 1, 5],\n        [2, 7, 5, 7, 2, 7, 5, 7]\n    ];\n    \"hex`\" + halfSegment.map(n => n.toString(16)).map(n => n.length < 2 ? \"0\" + n : n).join(\"\") + \"`\"\n    */\n\n    // packed metrics of pixel drawing for half size digit segments\n    const halfSegment: Buffer[] = [\n        hex`0100060002010501`,\n        hex`0702070606030605`,\n        hex`0708070d0609060c`,\n        hex`010f060f020e050e`,\n        hex`0008000d0109010c`,\n        hex`0002000601030105`,\n        hex`0207050702070507`\n    ];\n\n    // Seven segment layout and id assignments\n    //\n    //          a\n    //      =========\n    //     ||       ||\n    //   f ||       || b\n    //     ||   g   ||\n    //      =========\n    //     ||       ||\n    //   e ||       || c\n    //     ||   d   ||\n    //      =========\n\n    /*\n    const segmapIds = [\"abcdef\", \"bc\", \"abdeg\", \"abcdg\", \"bcfg\", \"acdfg\", \"acdefg\", \"abc\", \"abcdefg\", \"abcdfg\"];\n    var segmap = [\n        0b11111100, // '0' digit maps \"abcdef..\"\n        0b01100000, // '1' digit maps \".bc.....\"\n        0b11011010, // '2' digit maps \"ab.de.g.\"\n        0b11110010, // '3' digit maps \"abcd..g.\"\n        0b01100110, // '4' digit maps \".bc..fg.\"\n        0b10110110, // '5' digit maps \"a.cd.fg.\"\n        0b10111110, // '6' digit maps \"a.cdefg.\"\n        0b11100000, // '7' digit maps \"abc.....\"\n        0b11111110, // '8' digit maps \"abcdefg.\"\n        0b11110110, // '9' digit maps \"abcd.fg.\"\n        0b11101110, // 'A' digit maps \"abc.efg.\"\n        0b00111110, // 'b' digit maps \"..cdefg.\"\n        0b10011100, // 'C' digit maps \"a..def..\"\n        0b01111010, // 'd' digit maps \".bcde.g.\"\n        0b10011110, // 'E' digit maps \"a..defg.\"\n        0b10001110, // 'F' digit maps \"a...efg.\"\n        0b01101110, // 'H' digit maps \".bc.efg.\"\n        0b01111000, // 'J' digit maps \".bcde...\"\n        0b00011100, // 'L' digit maps \"...def..\"\n        0b00111010, // 'o' digit maps \"..cde.g.\"\n        0b11001110, // 'P' digit maps \"ab..efg.\"\n        0b01111100, // 'U' digit maps \".bcdef..\"\n        0b01110110, // 'Y' digit maps \".bcd.fg.\"\n        0b00000010, // '-' digit maps \"......g.\"\n        0b11000110  // '°' digit maps \"ab...fg.\"\n    ];\n    \"hex`\" + segmap.map(n => n.toString(16)).map(n => n.length < 2 ? \"0\" + n : n).join(\"\") + \"`\"\n    */\n    \n    const segmap: Buffer = hex`fc60daf266b6bee0fef6ee3e9c7a9e8e6e781c3ace7c7602c6`;\n\n    export function drawSegment(digit: Image, segment: Buffer, thickness: SegmentStyle, color: number) {\n        let offset = 0;\n        let x, y, w, h = 0;\n        if (segment.length >= thickness * 4) {\n            for (let i = 0; i < thickness; i++) {\n                x = segment.getNumber(NumberFormat.Int8LE, offset + 0);\n                y = segment.getNumber(NumberFormat.Int8LE, offset + 1);\n                w = segment.getNumber(NumberFormat.Int8LE, offset + 2) - x + 1;\n                h = segment.getNumber(NumberFormat.Int8LE, offset + 3) - y + 1;\n                digit.fillRect(x, y, w, h, color);\n                offset += 4;\n            }\n        }\n    }\n    \n    export function drawDigit(digit: Image, value: number, thickness: SegmentStyle, scale: SegmentScale, color: number) {\n        let segment: Buffer = null;\n        let digitMap = segmap.getNumber(NumberFormat.Int8LE, value)\n\n        digit.fill(0);\n        for (let i = 0; digitMap != 0; i++) {\n            if ((digitMap & 0x80) != 0) {\n                segment = scale == SegmentScale.Full ? fullSegment[i] : halfSegment[i];\n                if (scale == SegmentScale.Half && thickness > SegmentStyle.Narrow) {\n                    thickness = SegmentStyle.Narrow;\n                }\n                drawSegment(digit, segment, thickness, color)\n            }\n            digitMap = digitMap << 1;\n        }\n    }\n    \n    /**\n     * Create a seven segment display digit\n     * @param thickness the width of the segments, eg: SegmentStyle.Thick\n     * @param value optional initial display value, eg: 0\n     */\n    //% group=\"Create\"\n    //% blockId=sevenseg_create block=\"create seven segment digit || of %thickness with value %value\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=myDigit\n    //% value.min=0 value.max=9 value.defl=0\n    //% weight=99\n    export function createDigit(thickness: SegmentStyle = SegmentStyle.Thick, value: number = 0): SevenSegDigit {\n        return new SevenSegDigit(thickness, value)\n    }\n\n    /**\n     * Create a seven segment counter display\n     * @param thickness the width of the segments, eg: SegmentStyle.Thick\n     * @param scale the size of the segments, eg: SegmentScale.Full\n     * @param numDigits the number of digits displayed, eg: 1\n     */\n    //% group=\"Create\"\n    //% blockId=sevenseg_createcounter block=\"create counter || of %thickness segments at %scale size with %numDigits digits\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=myCounter\n    //% numDigits.min=1 numDigits.max=5 numDigits.defl=1\n    //% weight=100\n    export function createCounter(thickness: SegmentStyle = SegmentStyle.Thick, scale: SegmentScale = SegmentScale.Full, numDigits: number = 1): DigitCounter {\n        return new DigitCounter(thickness, scale, numDigits)\n    }\n}\n\n//% blockNamespace=sevenseg color=\"#4682B4\" blockGap=8\nclass SevenSegDigit {\n    private digit: Image;\n    private digitSprite: Sprite;\n    private _value: number;\n    private thickness: SegmentStyle;\n    private color: number;\n    private scale: SegmentScale;\n    private _x: number;\n    private _y: number;\n    private _radix: number;\n    \n    constructor(thickness: SegmentStyle = SegmentStyle.Thick, value: number = 0) {\n        this._value = value;\n        this.digit = image.create(16, 32);\n        this.digitSprite = sprites.create(this.digit, 0);\n        this._x = this.digitSprite.x\n        this._y = this.digitSprite.y\n        this.thickness = thickness;\n        this.color = 2;\n        this.scale = SegmentScale.Full;\n        this._radix = DigitRadix.Decimal;\n        sevenseg.drawDigit(this.digit, this.value, thickness, this.scale, this.color);\n    }\n\n    /**\n     * Set the display value to a digit character: '0'- '9'\n     * @param alphaChar the display value, eg: \"0\"\n     */\n    //% group=\"Digits\"\n    //% blockId=sevenseg_setalpha block=\"set %sevenseg(myDigit) display value to %alphaChar\"\n    //% weight=40\n    setDigitAlpha(alphaChar: SegmentCharacter) {\n        const matchChars = \"0123456789ABCDEFHJLoPUY-°\";\n        if (alphaChar == this.value || alphaChar < 0 || alphaChar >= matchChars.length)\n            return;\n        this.value = alphaChar;\n        sevenseg.drawDigit(this.digit, this.value, this.thickness, this.scale, this.color);\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"value\" weight=90\n    get value(): number {\n        return this._value;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"value\" weight=90\n    set value(value: number) {\n        value = value | 0;\n        if (value != this.value) {\n            if (value >= 0 && value < this._radix) {\n                this._value = value;\n            } else {\n                this._value = value % this._radix;\n            }\n            sevenseg.drawDigit(this.digit, this._value, this.thickness, this.scale, this.color);\n        }\n    }\n\n    /**\n     * Set the display digit color\n     * @param color of the digit display, eg: 2\n     */\n    //% group=\"Digits\"\n    //% blockId=sevenseg_setcolor block=\"set %sevenseg(myDigit) display color to %color=colorindexpicker\"\n    //% weight=35\n    setDigitColor(color: number): void {\n        this.color = color;\n        sevenseg.drawDigit(this.digit, this.value, this.thickness, this.scale, this.color);\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"x\"\n    get x(): number {\n        return this.digitSprite.x;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this._x = v;\n        this.digitSprite.x = v;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"y\"\n    get y(): number {\n        return this.digitSprite.y;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this._y = v;\n        this.digitSprite.y = v;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"height\"\n    get width(): number {\n        return this.digitSprite.width;\n    }\n\n    //% group=\"Digits\" blockSetVariable=\"myDigit\"\n    //% blockCombine block=\"height\"\n    get height(): number {\n        return this.digitSprite.height;\n    }\n\n    /**\n     * Set the display radix of the digit\n     * @param radix of the digit display, eg: DigitRadix.Decimal\n     */\n    //% blockId=sevenseg_setradix block=\"set display radix of %sevenseg(myDigit) to %radix\"\n    //% group=\"Digits\" weight=30\n    setRadix(radix: DigitRadix) {\n        this._radix = radix;\n        sevenseg.drawDigit(this.digit, this.value, this.thickness, this.scale, this.color);\n    }\n\n    /**\n     * Set the display digit size\n     * @param scale of the digit display, eg: SegmentScale.Full\n     */\n    //% group=\"Digits\"\n    //% blockId=sevenseg_setdigitscale block=\"set %sevenseg(myDigit) to %scale size\"\n    //% weight=25\n    setScale(scale: SegmentScale): void {\n        if (scale != this.scale) {\n            this.scale = scale;\n            if (scale == SegmentScale.Full) {\n                this.digit = image.create(16, 32)\n           } else {\n                this.digit = image.create(8, 16)\n           }\n           this.digitSprite.setImage(this.digit);\n           this.digitSprite.x = this._x;\n           this.digitSprite.y = this._y;\n           sevenseg.drawDigit(this.digit, this.value, this.thickness,this.scale, this.color);\n        }\n    }\n}\n\n//% blockNamespace=sevenseg color=\"#4682B4\" blockGap=8\nclass DigitCounter {\n    private _count: number;\n    private limit: number\n    private _x: number;\n    private _y: number;\n    private numDigits: number;\n    private maxDigits: number\n    private digits: SevenSegDigit[];\n    private thickness: SegmentStyle;\n    private color: number;\n    private scale: SegmentScale;\n\n    constructor(thickness: SegmentStyle = SegmentStyle.Thick, scale: SegmentScale = SegmentScale.Full, numDigits: number = 3) {\n        this._count = 0;\n        this.maxDigits = 5;\n        this.color = 2\n        this.scale = scale;\n        numDigits = Math.clamp(1, this.maxDigits, numDigits);\n\n        this.thickness = thickness;\n        this.digits = [];\n        this.digits.push(new SevenSegDigit(this.thickness, 0));\n        this.digits[0].setScale(this.scale);\n        this.digits[0].setDigitColor(this.color);\n        this.numDigits = 1;\n        this.limit = 10;\n        this._x = this.digits[0].x;\n        this._y = this.digits[0].y;\n\n        for (let i = 1; i < numDigits; i++) {\n            this.addDigit();\n        }\n    }\n\n    /**\n     * Add a digit to the counter\n     */\n    addDigit() {\n        let newDigit: SevenSegDigit = null\n        if (this.numDigits < this.maxDigits) {\n            newDigit = new SevenSegDigit(this.thickness, 0);\n            newDigit.setScale(this.scale)\n            newDigit.setDigitColor(this.color)\n            this.digits.push(newDigit);\n            this.numDigits += 1;\n            this.limit = this.limit * 10;\n            this.adjustDigitPositions();\n        }\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"count\"\n    get count() {\n        return this._count;\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"count\"\n    set count(value: number) {\n        if (value >= 0 && value < this.limit) {\n            this._count = value;\n            this.updateDisplayValue()\n        }\n    }\n\n    private updateDisplayValue()\n    {\n        let decimator = 1;\n        let updateValue = 0;\n        for (let i = 0; i < this.digits.length; i++) {\n            updateValue = this._count / decimator % 10;\n            this.digits[i].value = updateValue;\n            decimator = decimator * 10;\n        }\n    }\n\n    private adjustDigitPositions() {\n        let spacing = this.digits[0].width * 4 / 3;\n        let offset = this.digits[0].x + spacing / 2;\n        for (let i = 0; i < this.numDigits; i++) {\n            this.digits[i].x = offset;\n            offset -= spacing;\n        }\n    }\n\n    private moveDigits() {\n        let spacing = this.digits[0].width * 4 / 3;\n        for (let i = 1; i < this.numDigits; i++) {\n            this.digits[i].x = this.digits[i - 1].x - spacing;\n            this.digits[i].y = this.digits[0].y;\n        }\n        this._x = (this.digits[0].x + this.digits[this.numDigits - 1].x) / 2;\n        this._y = this.digits[0].y;\n    }\n    \n    /**\n     * Set the counter display digit color\n     * @param color of the digit display, eg: 2\n     */\n    //% group=\"Counter\"\n    //% blockId=sevenseg_setcountercolor block=\"set %sevenseg(myCounter) display color to %color=colorindexpicker\"\n    //% weight=86\n    setDigitColor(color: number): void {\n        this.color = color;\n        for (let i = 0; i < this.numDigits; i++) {\n            this.digits[i].setDigitColor(color);\n        }\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"x\"\n    get x(): number {\n        return this._x;\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this.digits[0].x += v - this._x;\n        this.moveDigits()\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"y\"\n    get y(): number {\n        return this._y;\n    }\n\n    //% group=\"Counter\" blockSetVariable=\"myCounter\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this.digits[0].y = v;\n        this.moveDigits()\n    }\n}\n"
        },
        "settings": {
            "Flash.h": "#ifndef CODAL_FLASH_H\n#define CODAL_FLASH_H\n\n#include \"CodalDevice.h\"\n\nnamespace codal {\nclass Flash {\n  public:\n    /**\n     * Return page size in bytes at given address (doesn't have to be page-aligned).\n     */\n    virtual int pageSize(uintptr_t address) = 0;\n\n    /**\n     * Erase page at given page-aligned address.\n     */\n    virtual int erasePage(uintptr_t address) = 0;\n\n    /**\n     * Write given number of bytes within one page. Flash has to be erased first.\n     */\n    virtual int writeBytes(uintptr_t dst, const void *src, uint32_t len) = 0;\n};\n\nclass ZFlash : public Flash {\n  public:\n    virtual int pageSize(uintptr_t address);\n    virtual int erasePage(uintptr_t address);\n    virtual int writeBytes(uintptr_t dst, const void *src, uint32_t len);\n};\n\n#define CODAL_FLASH codal::ZFlash\n#define DEVICE_FLASH_ERROR 922\n\n\n} // namespace codal\n\n#endif\n",
            "RAFFS.cpp": "#include \"RAFFS.h\"\n#include \"CodalDmesg.h\"\n#include \"NotifyEvents.h\"\n#include \"MessageBus.h\"\n#include \"Timer.h\"\n\n#include <stddef.h>\n\n#define RAFFS_MAGIC 0x7776e0da\n#define M1 0xffffffffU\n\n#define CHECK\n//#undef CHECK\n\nusing namespace codal;\n\n#define oops() target_panic(DEVICE_FLASH_ERROR)\n\n#define OFF2(v, basePtr) (uint32_t)((uint8_t *)v - (uint8_t *)basePtr)\n#define OFF(v) OFF2(v, basePtr)\n\n#define REAL_OFF(dst) (OFF(dst) <= OFF2(dst, altBasePtr()) ? OFF(dst) : OFF2(dst, altBasePtr()))\n\n#undef NOLOG\n#define NOLOG(...) ((void)0)\n#ifndef RAFFS_TEST\n#define LOG DMESG\n#define LOGV NOLOG\n#endif\n\n#define LOGVV NOLOG\n\n#if 0\n#undef LOGV\n#define LOGV DMESG\n#endif\n\n#if 0\n#undef LOGVV\n#define LOGVV DMESG\n#endif\n\nusing namespace pxt::raffs;\n\nstatic uint16_t raffs_unlocked_event;\n\nstruct FSHeader {\n    uint32_t magic;\n    uint32_t bytes;\n    uint32_t numgc;\n    uint32_t reserved;\n};\n\n// https://tools.ietf.org/html/draft-eastlake-fnv-14#section-3\nstatic uint16_t fnhash(const char *fn) {\n    uint32_t h = 0x811c9dc5;\n    while (*fn)\n        h = (h * 0x1000193) ^ (uint8_t)*fn++;\n    return h ^ (h >> 16);\n}\n\nFS::FS(Flash &flash, uintptr_t baseAddr, uint32_t bytes)\n    : flash(flash), baseAddr(baseAddr), bytes(bytes) {\n    locked = false;\n\n    basePtr = NULL;\n    endPtr = NULL;\n    freeDataPtr = NULL;\n    metaPtr = NULL;\n    readDirPtr = NULL;\n    cachedMeta = NULL;\n    flashBufAddr = 0;\n    blocked = NULL;\n    gcHorizon = -10000000;\n    minGCSpacing = 0;\n\n    if (bytes > 0x20000)\n        oops();\n\n    auto page = flash.pageSize(baseAddr);\n    // baseAddr and bytes needs to page-aligned, and we need even number of pages\n    auto numPages = bytes / page;\n    if ((baseAddr & (page - 1)) || bytes % page || numPages < 2 || (numPages & 1))\n        oops();\n\n    if (!raffs_unlocked_event)\n        raffs_unlocked_event = codal::allocateNotifyEvent();\n}\n\nvoid FS::erasePages(uintptr_t addr, uint32_t len) {\n    auto end = addr + len;\n    auto page = flash.pageSize(addr);\n    if (addr & (page - 1))\n        oops();\n    while (addr < end) {\n        if (flash.pageSize(addr) != page)\n            oops();\n        flash.erasePage(addr);\n#ifdef CHECK\n        for (int i = 0; i < page; ++i)\n            if (((uint8_t *)addr)[i] != 0xff)\n                oops();\n#endif\n        addr += page;\n    }\n}\n\nvoid FS::oopsAndClear() {\n    erasePages(baseAddr, bytes);\n    oops();\n}\n\nvoid FS::flushFlash() {\n    if (flashBufAddr) {\n        int r = flash.writeBytes(flashBufAddr, flashBuf, sizeof(flashBuf));\n        if (r)\n            oopsAndClear();\n#ifdef CHECK\n        for (unsigned i = 0; i < sizeof(flashBuf); ++i)\n            if (flashBuf[i] != 0xff && flashBuf[i] != ((uint8_t *)flashBufAddr)[i])\n                oopsAndClear();\n#endif\n        flashBufAddr = 0;\n    }\n}\n\nvoid FS::writeBytes(void *dst, const void *src, uint32_t size) {\n    LOGVV(\"write %x%s %d %x:%x:%x:%x\", REAL_OFF(dst), OFF(dst) == REAL_OFF(dst) ? \"\" : \"*\", size,\n          ((const uint8_t *)src)[0], ((const uint8_t *)src)[1], ((const uint8_t *)src)[2],\n          ((const uint8_t *)src)[3]);\n\n    while (size > 0) {\n        uint32_t off = (uintptr_t)dst & (sizeof(flashBuf) - 1);\n        uintptr_t newaddr = (uintptr_t)dst - off;\n        if (newaddr != flashBufAddr) {\n            flushFlash();\n            memset(flashBuf, 0xff, sizeof(flashBuf));\n            flashBufAddr = newaddr;\n        }\n\n        unsigned n = sizeof(flashBuf) - off;\n        if (n > size)\n            n = size;\n        memcpy(flashBuf + off, src, n);\n        size -= n;\n        src = (const uint8_t *)src + n;\n        dst = (uint8_t *)dst + n;\n    }\n}\n\n#define IS_VALID(hd) ((hd)->magic == RAFFS_MAGIC && (hd)->bytes == bytes)\n\nvoid FS::format() {\n    cachedMeta = NULL;\n    readDirPtr = NULL;\n    clearBlocked();\n\n    LOG(\"formatting...\");\n\n    FSHeader hd;\n    hd.reserved = M1;\n    hd.numgc = 1;\n\n    // in case the secondary header is valid, copy #gc\n    auto hd2 = (FSHeader *)(baseAddr + bytes / 2);\n    if (IS_VALID(hd2)) {\n        hd.numgc = hd2->numgc + 1;\n    }\n\n    // write the primary header\n    erasePages(baseAddr, bytes / 2);\n    hd.magic = RAFFS_MAGIC;\n    hd.bytes = bytes;\n    writeBytes((void *)baseAddr, &hd, sizeof(hd));\n\n    flushFlash();\n}\n\n#define NUMBLOCKED (int)(sizeof(blocked->fnptrs) / sizeof(uint16_t))\n\nbool FS::checkBlocked(MetaEntry *m) {\n    auto fnptr = m->fnptr;\n    for (auto p = blocked; p; p = p->next) {\n        for (int i = 0; i < NUMBLOCKED; ++i)\n            if (p->fnptrs[i] == fnptr) {\n                if (m->isFirst())\n                    p->fnptrs[i] = 0;\n                return true;\n            }\n    }\n    if (!m->isFirst()) {\n        for (auto p = blocked; p; p = p->next) {\n            for (int i = 0; i < NUMBLOCKED; ++i)\n                if (p->fnptrs[i] == 0) {\n                    p->fnptrs[i] = fnptr;\n                    return false;\n                }\n        }\n        auto p = new BlockedEntries;\n        memset(p, 0, sizeof(*p));\n        p->next = blocked;\n        blocked = p;\n        p->fnptrs[0] = fnptr;\n    }\n    return false;\n}\n\nvoid FS::clearBlocked() {\n    while (blocked) {\n        auto p = blocked;\n        blocked = p->next;\n        delete p;\n    }\n}\n\nbool FS::tryMount() {\n    if (basePtr)\n        return true;\n\n    auto hd0 = (FSHeader *)baseAddr;\n    auto hd1 = (FSHeader *)(baseAddr + bytes / 2);\n\n    auto v0 = IS_VALID(hd0);\n    auto v1 = IS_VALID(hd1);\n\n    if (v0 && v1) {\n        // we account for overflows\n        // they should not occur in normal operation though\n        if (hd0->numgc + 1 == hd1->numgc)\n            v0 = false;\n        else if (hd1->numgc + 1 == hd0->numgc || hd1->numgc < hd0->numgc)\n            v1 = false;\n        else\n            v0 = false;\n    }\n\n    uintptr_t addr;\n\n    if (v0)\n        addr = baseAddr;\n    else if (v1)\n        addr = baseAddr + bytes / 2;\n    else\n        return false;\n\n    basePtr = (uint8_t *)addr;\n    endPtr = (MetaEntry *)(addr + bytes / 2);\n\n    auto p = (uint32_t *)endPtr - 2;\n    while (*p != M1)\n        p -= 2;\n    metaPtr = (MetaEntry *)(p + 2);\n\n    p = (uint32_t *)metaPtr - 1;\n    while (*p == M1)\n        p--;\n    freeDataPtr = (uint8_t *)RAFFS_ROUND(p + 1);\n\n    auto fp = (uint32_t *)freeDataPtr;\n    if (fp[0] != M1 || fp[1] != M1)\n        oopsAndClear();\n\n    LOG(\"mounted, end=%x meta=%x free=%x\", OFF(endPtr), OFF(metaPtr), OFF(freeDataPtr));\n\n    return true;\n}\n\nvoid FS::mount() {\n    // if (basePtr) return;\n    if (tryMount())\n        return;\n    format();\n    if (!tryMount())\n        oopsAndClear();\n}\n\nFS::~FS() {}\n\nint FS::write(const char *keyName, const void *data, uint32_t bytes) {\n    auto isDel = data == NULL && bytes == M1;\n    if (!isDel && !data && bytes)\n        oops();\n\n    if (isDel)\n        LOGV(\"del: %s\", keyName);\n    else\n        LOGV(\"write: %s sz=%d\", keyName, bytes);\n\n    lock();\n    uint32_t szneeded = bytes;\n    auto existing = findMetaEntry(keyName);\n    auto prevBase = basePtr;\n\n    cachedMeta = NULL;\n\n    if (!existing) {\n        if (isDel) {\n            unlock();\n            return -1;\n        }\n        szneeded += strlen(keyName) + 1;\n    }\n\n    if (!tryGC(sizeof(MetaEntry) + RAFFS_ROUND(szneeded))) {\n        unlock();\n        return -1;\n    }\n\n    // if the GC happened, find the relocated meta entry\n    if (prevBase != basePtr)\n        existing = findMetaEntry(keyName);\n\n    MetaEntry newMeta;\n    if (existing) {\n        newMeta.fnhash = existing->fnhash;\n        newMeta.fnptr = existing->fnptr;\n    } else {\n        newMeta.fnhash = fnhash(keyName);\n        newMeta.fnptr = writeData(keyName, strlen(keyName) + 1);\n    }\n    newMeta.dataptr = isDel ? 0 : writeData(data, bytes);\n    newMeta._datasize = bytes;\n    if (existing)\n        newMeta._datasize |= RAFFS_FOLLOWING_MASK;\n    finishWrite();\n\n    writeBytes(--metaPtr, &newMeta, sizeof(newMeta));\n    flushFlash();\n\n    unlock();\n    return 0;\n}\n\nint FS::read(const char *keyName, void *data, uint32_t bytes) {\n    lock();\n    int r = -1;\n    MetaEntry *meta;\n    if (keyName) {\n        cachedMeta = meta = findMetaEntry(keyName);\n    } else {\n        meta = cachedMeta;\n    }\n    if (meta != NULL && meta->dataptr) {\n        r = meta->datasize();\n        if (data) {\n            if (bytes > (unsigned)r)\n                bytes = r;\n            memcpy(data, basePtr + meta->dataptr, bytes);\n        }\n    }\n    unlock();\n    return r;\n}\n\nint FS::remove(const char *keyName) {\n    return write(keyName, NULL, M1);\n}\n\nvoid FS::lock() {\n    while (locked)\n        fiber_wait_for_event(DEVICE_ID_NOTIFY, raffs_unlocked_event);\n    locked = true;\n    mount();\n}\n\nvoid FS::unlock() {\n    if (!locked)\n        oops();\n    flushFlash();\n    locked = false;\n#ifndef RAFFS_TEST\n    Event(DEVICE_ID_NOTIFY, raffs_unlocked_event);\n#endif\n}\n\nMetaEntry *FS::findMetaEntry(const char *filename) {\n    uint16_t h = fnhash(filename);\n    uint16_t buflen = strlen(filename) + 1;\n\n    for (auto p = metaPtr; p < endPtr; p++) {\n        // LOGV(\"check at %x %x %x\", OFF(p),p->fnhash,h);\n        if (p->fnhash == h && memcmp(fnptr(p), filename, buflen) == 0)\n            return p;\n    }\n\n    // LOGV(\"fail\");\n\n    return NULL;\n}\n\nvoid FS::forceGC(filename_filter filter) {\n    lock();\n    tryGC(0x7fff0000, filter);\n    unlock();\n}\n\nbool FS::tryGC(int spaceNeeded, filename_filter filter) {\n    int spaceLeft = (intptr_t)metaPtr - (intptr_t)freeDataPtr;\n\n#ifdef RAFFS_TEST\n    for (auto p = (uint32_t *)freeDataPtr; p < (uint32_t *)metaPtr; p++) {\n        if (*p != M1) {\n            LOG(\"value at %x = %x\", OFF(p), *p);\n            oopsAndClear();\n        }\n    }\n#endif\n\n    if (spaceLeft > spaceNeeded + 32)\n        return true;\n    \n    int now = (int)system_timer_current_time();\n    if (minGCSpacing) {\n        gcHorizon += minGCSpacing;\n        int nextGC = now - minGCSpacing * 2;\n        // LOG(\"now=%d n=%d gch=%d\", now, nextGC, gcHorizon);\n        if (nextGC > gcHorizon)\n            gcHorizon = nextGC;\n        if (gcHorizon > now)\n            target_panic(921);\n    }\n\n    LOG(\"running flash FS GC; needed %d, left %d\", spaceNeeded, spaceLeft);\n\n    readDirPtr = NULL;\n    cachedMeta = NULL;\n\n    auto newBase = (uintptr_t)altBasePtr();\n\n    flushFlash();\n\n    erasePages(newBase, bytes / 2);\n\n    auto metaDst = (MetaEntry *)(newBase + bytes / 2);\n    auto newBaseP = (uint8_t *)newBase;\n    freeDataPtr = newBaseP + sizeof(FSHeader);\n\n    for (int iter = 0; iter < 2; ++iter) {\n        clearBlocked();\n        auto offset = sizeof(FSHeader);\n        for (auto p = metaPtr; p < endPtr; p++) {\n            MetaEntry m = *p;\n            const char *fn = fnptr(&m);\n\n            if (filter && !filter(fn))\n                continue;\n\n            if (checkBlocked(&m) || m.dataptr == 0)\n                continue;\n\n            LOGV(\"GC %s sz=%d @%x\", fn, m.datasize(), m.dataptr);\n            auto fnlen = strlen(fn) + 1;\n            auto sz = fnlen + m.datasize();\n\n            if (iter == 0) {\n                auto fd = freeDataPtr;\n                writeData(fn, fnlen);\n                writeData(basePtr + m.dataptr, m.datasize());\n                if (freeDataPtr - fd != (int)sz)\n                    oops();\n            } else {\n                m.fnptr = offset;\n                m.dataptr = offset + fnlen;\n                m._datasize &= ~RAFFS_FOLLOWING_MASK;\n                writeBytes(--metaDst, &m, sizeof(m));\n            }\n            offset += sz;\n        }\n        if (iter == 0)\n            finishWrite();\n    }\n\n    clearBlocked();\n    flushFlash();\n\n    LOG(\"GC done: %d free\", (int)((intptr_t)metaDst - (intptr_t)freeDataPtr));\n\n    FSHeader hd;\n    hd.magic = RAFFS_MAGIC;\n    hd.bytes = bytes;\n    hd.numgc = ((FSHeader*)basePtr)->numgc + 1;\n    hd.reserved = M1;\n    writeBytes(newBaseP, &hd, sizeof(hd));\n    flushFlash();\n\n    basePtr = newBaseP;\n    endPtr = (MetaEntry *)(newBase + bytes / 2);\n    metaPtr = metaDst;\n\n    if ((intptr_t)metaDst - (intptr_t)freeDataPtr <= spaceNeeded + 64) {\n        if (filter != NULL && spaceNeeded != 0x7fff0000) {\n            LOG(\"out of space! needed=%d\", spaceNeeded);\n#ifdef RAFFS_TEST\n            oops();\n#endif\n        }\n        return false;\n    }\n\n    return true;\n}\n\nDirEntry *FS::dirRead() {\n    lock();\n\n    if (readDirPtr == NULL) {\n        readDirPtr = metaPtr;\n        clearBlocked();\n    }\n\n    while (readDirPtr < endPtr) {\n        auto m = *readDirPtr++;\n        if (checkBlocked(&m) || m.dataptr == 0)\n            continue;\n        dirEnt.size = m.datasize();\n        dirEnt.flags = 0;\n        dirEnt.name = fnptr(&m);\n        unlock();\n        return &dirEnt;\n    }\n\n    readDirPtr = NULL;\n    clearBlocked();\n    unlock();\n    return NULL;\n}\n\nuint16_t FS::writeData(const void *data, uint32_t len) {\n    LOGVV(\"writeData: @%x %x:%x sz=%d\", REAL_OFF(freeDataPtr), ((const uint8_t *)data)[0],\n          ((const uint8_t *)data)[1], len);\n    writeBytes(freeDataPtr, data, len);\n    auto r = freeDataPtr - basePtr;\n    freeDataPtr += len;\n    return r;\n}\n\nvoid FS::finishWrite() {\n    auto nfp = RAFFS_ROUND(freeDataPtr);\n    int tailSz = nfp - (uintptr_t)freeDataPtr;\n    uint64_t z = 0;\n    if (tailSz) {\n        writeData(&z, tailSz);\n    } else {\n        if (((uint32_t *)nfp)[-1] == M1)\n            writeData(&z, 8);\n    }\n    flushFlash();\n}\n\nint FS::readFlashBytes(uintptr_t addr, void *buffer, uint32_t len) {\n    lock();\n    memcpy(buffer, (void *)addr, len);\n    unlock();\n    return len;\n}\n\n#ifdef RAFFS_TEST\nvoid FS::dump() {}\n\nvoid FS::debugDump() {\n    // dump();\n}\n#endif",
            "RAFFS.h": "#ifndef CODAL_RAFFS_H\n#define CODAL_RAFFS_H\n\n#include \"Flash.h\"\n\nnamespace pxt {\nnamespace raffs {\n\nstruct DirEntry {\n    uint32_t size;\n    uint16_t flags;\n    const char *name;\n};\n\nstruct BlockedEntries {\n    BlockedEntries *next;\n    uint16_t fnptrs[32];\n};\n\n#define RAFFS_FOLLOWING_MASK 0x8000\n#define RAFFS_FLASH_BUFFER_SIZE 64\n\nstruct MetaEntry {\n    uint16_t fnhash;    // hash of file name\n    uint16_t fnptr;     // offset in bytes; can't be 0xffff\n    uint16_t _datasize; // size in bytes; highest bit is set if this isn't first block\n    uint16_t dataptr;   // offset in bytes; 0x0 - deleted\n\n    uint16_t datasize() { return _datasize & 0x7fff; }\n    bool isFirst() { return (_datasize & RAFFS_FOLLOWING_MASK) == 0; }\n};\n\n#define RAFFS_ROUND(x) ((((uintptr_t)(x) + 7) >> 3) << 3)\n\ntypedef bool (*filename_filter)(const char *);\n\nclass FS {\n    codal::Flash &flash;\n\n    uint8_t *basePtr, *freeDataPtr;\n    MetaEntry *endPtr, *metaPtr, *readDirPtr, *cachedMeta;\n    uintptr_t baseAddr;\n    uint32_t bytes;\n    int32_t gcHorizon;\n    DirEntry dirEnt;\n    uintptr_t flashBufAddr;\n    uint8_t flashBuf[RAFFS_FLASH_BUFFER_SIZE];\n    BlockedEntries *blocked;\n    volatile bool locked;\n\n    void erasePages(uintptr_t addr, uint32_t len);\n    void flushFlash();\n    void writeBytes(void *dst, const void *src, uint32_t size);\n    void mount();\n    void lock();\n    void unlock();\n    MetaEntry *findMetaEntry(const char *filename);\n    bool tryGC(int spaceNeeded, filename_filter filter = NULL);\n\n    bool checkBlocked(MetaEntry *m);\n    void clearBlocked();\n    void oopsAndClear();\n\n    uint16_t writeData(const void *data, uint32_t len);\n    void finishWrite();\n    const char *fnptr(MetaEntry *m) { return (const char *)(basePtr + m->fnptr); }\n\n    uint32_t *altBasePtr() {\n        if ((uintptr_t)basePtr == baseAddr)\n            return (uint32_t *)(baseAddr + bytes / 2);\n        else\n            return (uint32_t *)baseAddr;\n    }\n\n  public:\n    // Minimum time in ms that has to pass between two GCs; we shall panic 920 if GCs happen more often\n    // (avareged over 3x this time).\n    // This is usually set to around 10s (10000), so that if user writes a program that writes to flash in\n    // a loop, it doesn't wear out flash completely.\n    uint16_t minGCSpacing;\n    \n\n    FS(codal::Flash &flash, uintptr_t baseAddr, uint32_t bytes);\n    ~FS();\n\n    // returns 0 for success, negative for error\n    int write(const char *keyName, const void *data, uint32_t bytes);\n    // returns total number of bytes in key's value or -1 when file doesn't exists\n    // if keyName==NULL it will re-use last keyName\n    int read(const char *keyName, void *data, uint32_t bytes);\n    // deletes given key if it exists\n    int remove(const char *keyName);\n\n    void format();\n    bool exists(const char *keyName) { return read(keyName, NULL, 0) >= 0; }\n    uint32_t totalSize() { return bytes / 2; }\n    uint32_t freeSize() { return (uintptr_t)endPtr - (uintptr_t)freeDataPtr; }\n    void forceGC(filename_filter filter = NULL);\n    // this allow raw r/o access; will lock the instance as needed\n    int readFlashBytes(uintptr_t addr, void *buffer, uint32_t len);\n    bool tryMount();\n\n    void dirRewind() { readDirPtr = NULL; }\n    DirEntry *dirRead(); // data is only valid until next call to to any of File or FS function\n\n#ifdef RAFFS_TEST\n    void debugDump();\n    void dump();\n#else\n    void debugDump() {}\n#endif\n};\n\n} // namespace raffs\n} // namespace pxt\n\n#endif\n",
            "README.md": "# Settings store in internal MCU flash\n\nThis packages implements a simple key-value storage, in vein of browser's `localStorage`.\nKeys are strings and values are buffers, but APIs are provided to also use strings,\nnumbers and number arrays as values.\n\nKeys with names starting with `#` are _system keys_.\nUser applications should not read or write these directly.\n\nFollowing system keys are used:\n* `#run` - current run number; incremented on each reset; it's also used to seed the\n  random number generator; accessible via `settings.runNumber()`\n* `#volume` - last music volume set explicitly by user using the game menu\n* `#scope` - keeps the name of the program; if the current name of the program\n  doesn't match what is in that key, all non-system keys are cleared;\n  this happens for example when a new game (or rather a game with a new name) \n  is uploaded to a hardware device\n\nThe size of storage is typically limited to 16 kilobytes.\nThis applies in browser and in Arcade devices.\nSmaller MCUs may limit it further (eg., it's 1k on SAMD21 devices).\n\n## Panics 920, 921 and 922\n\nWhen the there is no more space to write a key to storage, all non-system keys\nare deleted.\nThen, if more than 25% of space is still occupied (by system keys),\nall keys are deleted.\nFinally, a panic 920 is issued.\nThe user has to reset the device, and hopefully next run will fix things.\n\nAll flash devices have a limited number of erases (at least 10,000),\nbefore they start failing.\nThe settings storage implemented here doesn't erase on every write (typically\nit will erase every hundred writes or so),\nbut still if your program would keep writing in a loop, you would likely\nhit 10,000 erases in about half hour.\n\nFor this reason, if erases happen too often (i.e., you're writing too much),\npanic 921 will be issued.\n\nIf flash memory is found to be inconsistent, panic 922 is issued.\nIn most cases, the entire flash memory is cleared before that, so that\na device reset will hopefully fix things.\n\n## Storage structure\n\nSettings are written using a very simple log file system.\nThe flash to be used is divided in two equal regions.\nOne region is used for writing, and when it fills up, data is compressed\n(garbage collected) into the other region, which is to be used from now\non until next compression\n\nEach region starts with a header, followed by data section containing\nkey names and values.\nData section grows in the positive direction.\nFrom the end of the region, the meta-data section grows in the negative\ndirection.\nMeta-data entries are 8 bytes each and contain hash of key name,\nvalue size, and points to key name and value in the data sections.\nWhen a file is overwritten, simply a new meta-data section for it\nis written.\nWhen a file is to be found, it is searched from the most recent meta-data\nentry.\n",
            "SAMDFlash.cpp": "#include \"pxt.h\"\n#include \"Flash.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\n#if defined(SAMD51) || defined(SAMD21)\nnamespace codal {\n\n#ifdef SAMD51\n#define waitForLast()                                                                              \\\n    while (NVMCTRL->STATUS.bit.READY == 0)                                                         \\\n        ;\n#else\n#define waitForLast()                                                                              \\\n    while (NVMCTRL->INTFLAG.bit.READY == 0)                                                        \\\n        ;\n#endif\n\nstatic void unlock() {\n#ifdef SAMD51\n    // see errata 2.14.1\n    NVMCTRL->CTRLA.bit.CACHEDIS0 = true;\n    NVMCTRL->CTRLA.bit.CACHEDIS1 = true;\n\n    CMCC->CTRL.bit.CEN = 0;\n    while (CMCC->SR.bit.CSTS) {\n    }\n    CMCC->MAINT0.bit.INVALL = 1;\n#endif\n}\n\nstatic void lock() {\n#ifdef SAMD51\n    // re-enable cache\n    NVMCTRL->CTRLA.bit.CACHEDIS0 = false;\n    NVMCTRL->CTRLA.bit.CACHEDIS1 = false;\n\n    // re-enable cortex-m cache - it's a separate one\n    CMCC->CTRL.bit.CEN = 0;\n    while (CMCC->SR.bit.CSTS) {\n    }\n    CMCC->MAINT0.bit.INVALL = 1;\n    CMCC->CTRL.bit.CEN = 1;\n#endif\n}\n\nint ZFlash::pageSize(uintptr_t address) {\n#ifdef SAMD51\n    if (address < 1024 * 1024)\n        return NVMCTRL_BLOCK_SIZE; // 8k\n#else\n    if (address < 256 * 1024)\n        return 256;\n#endif\n    target_panic(DEVICE_FLASH_ERROR);\n    return 0;\n}\n\n#ifdef SAMD51\n#define CMD(D21, D51) NVMCTRL->CTRLB.reg = NVMCTRL_CTRLB_CMDEX_KEY | D51\n#else\n#define CMD(D21, D51) NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | D21\n#endif\n\nint ZFlash::erasePage(uintptr_t address) {\n    LOG(\"Erase %x\", address);\n#ifdef SAMD51\n    NVMCTRL->CTRLA.bit.WMODE = NVMCTRL_CTRLA_WMODE_MAN_Val;\n#else\n    NVMCTRL->CTRLB.bit.MANW = 1;\n#endif\n    waitForLast();\n    unlock();\n#ifdef SAMD51\n    NVMCTRL->ADDR.reg = address;\n#else\n    // yeah... /2\n    NVMCTRL->ADDR.reg = address / 2;\n#endif\n    CMD(NVMCTRL_CTRLA_CMD_ER, NVMCTRL_CTRLB_CMD_EB);\n    waitForLast();\n    lock();\n    return 0;\n}\n\n#if 0\n#define CHECK_ECC()                                                                                \\\n    if (NVMCTRL->INTFLAG.bit.ECCSE || NVMCTRL->INTFLAG.bit.ECCDE)                                  \\\n    return -10\n#else\n#define CHECK_ECC() ((void)0)\n#endif\n\nint ZFlash::writeBytes(uintptr_t dst, const void *src, uint32_t len) {\n#ifdef SAMD51\n    CHECK_ECC();\n\n    // only allow writing double word at a time\n    if (len & 7)\n        return -1;\n    if (dst & 7)\n        return -2;\n\n    // every double-word can only be written once, otherwise we get ECC errors\n    // and no, ECC cannot be disabled\n    for (unsigned i = 0; i < (len >> 3); ++i)\n        if (((uint64_t *)dst)[i] != 0xffffffffffffffff &&\n            ((uint64_t *)src)[i] != 0xffffffffffffffff)\n            return -3;\n#define WRITE_SIZE 16\n#else\n    if ((dst & 3) || (len & 3))\n        return -1;\n\n    for (unsigned i = 0; i < len; ++i)\n        if (((uint8_t *)dst)[i] != 0xff && ((uint8_t *)src)[i] != 0xff)\n            return -3;\n#define WRITE_SIZE 64\n#endif\n\n    uint32_t writeBuf[WRITE_SIZE >> 2];\n    uint32_t idx = 0;\n\n    waitForLast();\n    unlock();\n    __DMB();\n\n    while (idx < len) {\n        uint32_t off = dst & (WRITE_SIZE - 1);\n        uint32_t n = WRITE_SIZE - off;\n        if (n > len - idx)\n            n = len - idx;\n        uint32_t *sp;\n        volatile uint32_t *dp;\n        if (n != WRITE_SIZE) {\n            memset(writeBuf, 0xff, WRITE_SIZE);\n            memcpy((uint8_t *)writeBuf + off, src, n);\n            sp = writeBuf;\n            dp = (uint32_t *)(dst - off);\n        } else {\n            sp = (uint32_t *)src;\n            dp = (uint32_t *)dst;\n        }\n\n        bool need = false;\n        for (unsigned i = 0; i < (WRITE_SIZE >> 2); ++i)\n            if (sp[i] != 0xffffffff) {\n                need = true;\n                break;\n            }\n\n        if (need) {\n            CMD(NVMCTRL_CTRLA_CMD_PBC, NVMCTRL_CTRLB_CMD_PBC);\n            waitForLast();\n\n            uint32_t q = WRITE_SIZE >> 2;\n\n            target_disable_irq();\n            while (q--) {\n                auto v = *sp++;\n                *dp = v;\n                dp++;\n            }\n\n            CMD(NVMCTRL_CTRLA_CMD_WP, NVMCTRL_CTRLB_CMD_WQW);\n            target_enable_irq();\n            waitForLast();\n        }\n\n        src = (uint8_t *)src + n;\n        dst += n;\n        idx += n;\n    }\n\n    CHECK_ECC();\n\n    lock();\n\n    return 0;\n}\n} // namespace codal\n#endif\n",
            "STM32Flash.cpp": "#include \"pxt.h\"\n#include \"Flash.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\n#ifdef STM32F4\nnamespace codal {\nstatic void waitForLast() {\n    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY)\n        ;\n}\n\nstatic void unlock() {\n    FLASH->CR |= FLASH_CR_LOCK;\n    FLASH->KEYR = FLASH_KEY1;\n    FLASH->KEYR = FLASH_KEY2;\n}\n\nstatic void lock() {\n    FLASH->CR |= FLASH_CR_LOCK;\n}\n\nint ZFlash::pageSize(uintptr_t address) {\n    address |= 0x08000000;\n    if (address < 0x08010000)\n        return 16 * 1024;\n    if (address < 0x08020000)\n        return 64 * 1024;\n    if (address < 0x08100000)\n        return 128 * 1024;\n    target_panic(DEVICE_FLASH_ERROR);\n    return 0;\n}\n\nint ZFlash::erasePage(uintptr_t address) {\n    waitForLast();\n    unlock();\n\n    address |= 0x08000000;\n    uintptr_t ptr = 0x08000000;\n    int sectNum = 0;\n    while (1) {\n        ptr += pageSize(ptr);\n        if (ptr > address)\n            break;\n        sectNum++;\n    }\n\n    FLASH->CR = FLASH_CR_PSIZE_1 | (sectNum << FLASH_CR_SNB_Pos) | FLASH_CR_SER;\n    FLASH->CR |= FLASH_CR_STRT;\n\n    waitForLast();\n\n    FLASH->CR = FLASH_CR_PSIZE_1;\n    lock();\n\n    // cache flushing only required after erase, not programming (3.5.4)\n    __HAL_FLASH_DATA_CACHE_DISABLE();\n    __HAL_FLASH_DATA_CACHE_RESET();\n    __HAL_FLASH_DATA_CACHE_ENABLE();\n\n    // we skip instruction cache, as we're not expecting to erase that\n\n    return 0;\n}\n\nint ZFlash::writeBytes(uintptr_t dst, const void *src, uint32_t len) {\n    LOG(\"WR flash at %p len=%d\", (void *)dst, len);\n\n    if ((dst & 3) || ((uintptr_t)src & 3) || (len & 3))\n        return -1;\n\n    for (unsigned i = 0; i < len; ++i)\n        if (((uint8_t *)dst)[i] != 0xff && ((uint8_t *)src)[i] != 0xff)\n            return -3;\n\n    waitForLast();\n    unlock();\n\n    dst |= 0x08000000;\n\n    FLASH->CR = FLASH_CR_PSIZE_1 | FLASH_CR_PG;\n\n    volatile uint32_t *sp = (uint32_t *)src;\n    volatile uint32_t *dp = (uint32_t *)dst;\n    len >>= 2;\n\n    while (len-- > 0) {\n        uint32_t v = *sp++;\n        if (v != 0xffffffff) {\n            *dp++ = v;\n            waitForLast();\n        } else {\n            dp++;\n        }\n    }\n\n    FLASH->CR = FLASH_CR_PSIZE_1;\n    lock();\n\n    LOG(\"WR flash OK\");\n\n    return 0;\n}\n} // namespace codal\n#endif\n",
            "pxt.json": "{\n  \"name\": \"settings\",\n  \"description\": \"Settings storage in internal flash\",\n  \"files\": [\n    \"README.md\",\n    \"RAFFS.cpp\",\n    \"RAFFS.h\",\n    \"Flash.h\",\n    \"STM32Flash.cpp\",\n    \"SAMDFlash.cpp\",\n    \"settings.cpp\",\n    \"settings.ts\",\n    \"shims.d.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "settings.cpp": "\n#include \"pxt.h\"\n#include \"RAFFS.h\"\n#include \"GhostFAT.h\"\n\nusing namespace pxt::raffs;\nusing namespace codal;\n\nnamespace settings {\n\nclass WStorage {\n  public:\n    CODAL_FLASH flash;\n    FS fs;\n    bool isMounted;\n\n    WStorage() : flash(), \n#if defined(STM32F4)\n    fs(flash, 0x8008000, 32 * 1024),\n#elif defined(SAMD51)\n    fs(flash, 512*1024 - 32*1024, 32 * 1024),\n#elif defined(SAMD21)\n    fs(flash, 256*1024 - 2*1024, 2 * 1024),\n#else\n    fs(flash),\n#endif\n    isMounted(false)\n    {\n        fs.minGCSpacing = 10000;\n    }\n};\nSINGLETON(WStorage);\n\nstatic WStorage *mountedStorage() {\n    auto s = getWStorage();\n    if (s->fs.tryMount())\n        return s;\n    s->fs.exists(\"foobar\"); // forces mount and possibly format\n    return s;\n}\n\n//%\nint _set(String key, Buffer data) {\n    auto s = mountedStorage();\n    return s->fs.write(key->getUTF8Data(), data->data, data->length);\n}\n\n//%\nint _remove(String key) {\n    auto s = mountedStorage();\n    return s->fs.remove(key->getUTF8Data());\n}\n\n//%\nbool _exists(String key) {\n    auto s = mountedStorage();\n    return s->fs.exists(key->getUTF8Data());\n}\n\n//%\nBuffer _get(String key) {\n    auto s = mountedStorage();\n    auto sz = s->fs.read(key->getUTF8Data(), NULL, 0);\n    if (sz < 0)\n        return NULL;\n    auto ret = mkBuffer(NULL, sz);\n    registerGCObj(ret);\n    s->fs.read(NULL, ret->data, ret->length);\n    unregisterGCObj(ret);\n    return ret;\n}\n\nstatic bool isSystem(const char *fn) {\n    return fn[0] == '#';\n}\n\n//%\nvoid _userClean() {\n    auto s = mountedStorage();\n    DMESG(\"clearing user files\");\n    s->fs.forceGC(isSystem);\n    // if system files take more than 25% of storage size, we reformat\n    // it likely means user code has written some 'system' files\n    if (s->fs.freeSize() < 3 * s->fs.totalSize() / 4) {\n        s->fs.format();\n    }\n}\n\n//%\nRefCollection *_list(String prefix) {\n    auto st = mountedStorage();\n    st->fs.dirRewind();\n    auto res = Array_::mk();\n    registerGCObj(res);\n\n    auto prefData = prefix->getUTF8Data();\n    auto prefLen = prefix->getUTF8Size();\n    auto wantsInternal = prefData[0] == '#';\n\n    for (;;) {\n        auto d = st->fs.dirRead();\n        if (!d)\n            break;\n        if (!wantsInternal && d->name[0] == '#')\n            continue;\n        if (memcmp(d->name, prefData, prefLen) != 0)\n            continue;\n        auto str = mkString(d->name, -1);\n        registerGCObj(str);\n        res->head.push((TValue)str);\n        unregisterGCObj(str);\n    }\n    unregisterGCObj(res);\n    return res;\n}\n\n\n} // namespace settings\n",
            "settings.ts": "namespace settings {\n    //% shim=pxt::seedAddRandom\n    declare function seedAddRandom(n: number): void;\n\n    //% shim=settings::_set\n    declare function _set(key: string, data: Buffer): int32;\n\n    //% shim=settings::_remove\n    declare function _remove(key: string): int32;\n\n    //% shim=settings::_exists\n    declare function _exists(key: string): boolean;\n\n    //% shim=settings::_get\n    declare function _get(key: string): Buffer;\n\n    //% shim=settings::_userClean\n    declare function _userClean(): void;\n\n    //% shim=settings::_list\n    declare function _list(prefix: string): string[];\n\n    export function runNumber() {\n        return readNumber(\"#run\") || 0\n    }\n\n    function setScope(scope: string) {\n        if (!scope || scope.length > 100)\n            control.panic(922)\n        const currScope = readString(\"#scope\")\n        if (currScope != scope) {\n            _userClean()\n            writeString(\"#scope\", scope)\n        }\n    }\n\n    function initScopes() {\n        const rn = runNumber() + 1\n        writeNumber(\"#run\", rn)\n\n        seedAddRandom(control.deviceSerialNumber() & 0x7fffffff)\n        seedAddRandom(rn)\n\n        setScope(control.programName())\n    }\n\n    initScopes()\n\n    /** \n     * Delete all non-system settings.\n     */\n    export function clear(): void {\n        _userClean()\n    }\n\n    /**\n     * Set named setting to a given buffer.\n     */\n    export function writeBuffer(key: string, value: Buffer) {\n        if (_set(key, value)) {\n            // if we're out of space, clear user storage\n            _userClean()\n            // and panic - reset should hopefully recreate needed files\n            control.panic(920)\n        }\n    }\n\n    /**\n     * Set named settings to a given string.\n     */\n    export function writeString(key: string, value: string) {\n        writeBuffer(key, control.createBufferFromUTF8(value))\n    }\n\n    /**\n     * Set named settings to a given number.\n     */\n    export function writeNumber(key: string, value: number) {\n        writeBuffer(key, msgpack.packNumberArray([value]))\n    }\n\n    /**\n     * Set named settings to a given array of numbers.\n     */\n    export function writeNumberArray(key: string, value: number[]) {\n        writeBuffer(key, msgpack.packNumberArray(value))\n    }\n\n    /**\n     * Read named setting as a buffer. Returns undefined when setting not found.\n     */\n    export function readBuffer(key: string) {\n        return _get(key)\n    }\n\n    /**\n     * Read named setting as a string.\n     */\n    export function readString(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return buf.toString()\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumber(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else {\n            const nums = msgpack.unpackNumberArray(buf)\n            if (nums && nums.length >= 1)\n                return nums[0]\n            return undefined\n        }\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumberArray(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return msgpack.unpackNumberArray(buf)\n    }\n\n    /**\n     * Return a list of settings starting with a given prefix.\n     */\n    export function list(prefix?: string) {\n        if (!prefix) prefix = \"\"\n        return _list(prefix)\n    }\n\n    /**\n     * Remove named setting.\n     */\n    export function remove(key: string) {\n        _remove(key)\n    }\n\n    /**\n     * Check if a named setting exists.\n     */\n    export function exists(key: string) {\n        return _exists(key)\n    }\n}\n",
            "shims.d.ts": "\n"
        },
        "settings---files": {
            "pxt.json": "{\n  \"name\": \"settings\",\n  \"description\": \"Settings storage in files\",\n  \"files\": [\n    \"settings.cpp\",\n    \"settings.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "settings.cpp": "#define _GNU_SOURCE 1\n\n#include \"pxt.h\"\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <errno.h>\n\n#define FAIL(msg)                                                                                  \\\n    do {                                                                                           \\\n        DMESG(\"FAILURE: %s\", msg);                                                                 \\\n        abort();                                                                                   \\\n    } while (0)\n\nnamespace settings {\n\n#define ADD(c)                                                                                     \\\n    do {                                                                                           \\\n        buf[dp] = (c);                                                                             \\\n        dp++;                                                                                      \\\n        if (dp > 1000)                                                                             \\\n            FAIL(\"too long\");                                                                      \\\n    } while (0)\n\nconst char *hexD = \"0123456789abcdef\";\n\nstatic char *encodeString(const char *str) {\n    static char buf[1024];\n    int dp = 0;\n    for (auto sp = str; *sp; ++sp) {\n        auto c = *sp;\n        if (('0' <= c && c <= '9') || ('a' <= c && c <= 'z'))\n            ADD(c);\n        else if (('A' <= c && c <= 'Z')) {\n            ADD('-');\n            ADD(c | 0x20);\n        } else {\n            ADD('_');\n            ADD(hexD[(c >> 4) & 0xf]);\n            ADD(hexD[c & 0xf]);\n        }\n    }\n\n    ADD(0);\n\n    return buf;\n}\n\nstatic int hex(char c) {\n    if ('0' <= c && c <= '9')\n        return c - '0';\n    c |= 0x20;\n    if ('a' <= c && c <= 'f')\n        return c - 'a' + 10;\n    return -1;\n}\n\nstatic char *decodeString(const char *str) {\n    static char buf[1024];\n    int dp = 0;\n\n    if (strlen(str) > 1000)\n        FAIL(\"too long decode\");\n\n    for (auto sp = str; *sp; ++sp) {\n        auto c = *sp;\n        if (('0' <= c && c <= '9') || ('a' <= c && c <= 'z'))\n            ADD(c);\n        else if (c == '-' && sp[1]) {\n            ADD(sp[1] & ~0x20);\n            sp++;\n        } else if (c == '_' && hex(sp[1]) >= 0 && hex(sp[2]) >= 0) {\n            ADD((hex(sp[1]) << 4) | hex(sp[2]));\n            sp += 2;\n        }\n    }\n\n    ADD(0);\n\n    return buf;\n}\n\nstatic const char *settingsDirectory() {\n    static char *name;\n    if (name)\n        return name;\n#ifdef SETTINGSDIR\n    asprintf(&name, \"%s/%s\", SETTINGSDIR, encodeString(programName()->getUTF8Data()));\n#else\n    asprintf(&name, \"%s.data\", initialArgv[0]);\n#endif\n#ifdef __WIN32__\n    mkdir(name);\n#else\n    mkdir(name, 0777);\n#endif\n    return name;\n}\n\nstatic const char *keyName(const char *key) {\n    static char *lastName;\n    if (lastName)\n        free(lastName);\n    auto dirname = settingsDirectory();\n    asprintf(&lastName, \"%s/%s\", dirname, encodeString(key));\n    return lastName;\n}\n\nstatic const char *keyName(String key) {\n    return keyName(key->getUTF8Data());\n}\n\nstatic FILE *openKey(String key, const char *mode) {\n    return fopen(keyName(key), mode);\n}\n\n//%\nint _set(String key, Buffer data) {\n    // DMESG(\"set[%s] - %p\", key->getUTF8Data(), data);\n    auto f = openKey(key, \"wb\");\n    if (!f) {\n        DMESG(\"errno=%d\", errno);\n        FAIL(\"can't write file\");\n    }\n    fwrite(data->data, data->length, 1, f);\n    fclose(f);\n    return 0;\n}\n\n//%\nint _remove(String key) {\n    return remove(keyName(key));\n}\n\n//%\nbool _exists(String key) {\n    auto f = openKey(key, \"rb\");\n    fclose(f);\n    return f != NULL;\n}\n\n//%\nBuffer _get(String key) {\n    auto f = openKey(key, \"rb\");\n    if (f == NULL)\n        return NULL;\n    fseek(f, 0, SEEK_END);\n    auto sz = ftell(f);\n    auto ret = mkBuffer(NULL, sz);\n    registerGCObj(ret);\n    fseek(f, 0, SEEK_SET);\n    fread(ret->data, ret->length, 1, f);\n    fclose(f);\n    unregisterGCObj(ret);\n    return ret;\n}\n\n//%\nvoid _userClean() {\n    auto dp = opendir(settingsDirectory());\n    if (!dp)\n        return;\n    for (;;) {\n        dirent *ep = readdir(dp);\n        if (!ep)\n            break;\n        auto name = decodeString(ep->d_name);\n        if (name[0] == '#')\n            continue;\n        remove(keyName(name));\n    }\n    closedir(dp);\n}\n\n//%\nRefCollection *_list(String prefix) {\n    auto res = Array_::mk();\n    registerGCObj(res);\n\n    auto prefData = prefix->getUTF8Data();\n    auto prefLen = prefix->getUTF8Size();\n    auto wantsInternal = prefData[0] == '#';\n\n    auto dp = opendir(settingsDirectory());\n\n    for (;;) {\n        dirent *ep = dp ? readdir(dp) : NULL;\n        if (!ep)\n            break;\n        auto name = decodeString(ep->d_name);\n        if (!wantsInternal && name[0] == '#')\n            continue;\n        if (memcmp(name, prefData, prefLen) != 0)\n            continue;\n        auto str = mkString(name, -1);\n        registerGCObj(str);\n        res->head.push((TValue)str);\n        unregisterGCObj(str);\n    }\n    if (dp)\n        closedir(dp);\n    unregisterGCObj(res);\n\n    return res;\n}\n\n} // namespace settings\n",
            "settings.ts": "namespace settings {\n    //% shim=pxt::seedAddRandom\n    declare function seedAddRandom(n: number): void;\n\n    //% shim=settings::_set\n    declare function _set(key: string, data: Buffer): int32;\n\n    //% shim=settings::_remove\n    declare function _remove(key: string): int32;\n\n    //% shim=settings::_exists\n    declare function _exists(key: string): boolean;\n\n    //% shim=settings::_get\n    declare function _get(key: string): Buffer;\n\n    //% shim=settings::_userClean\n    declare function _userClean(): void;\n\n    //% shim=settings::_list\n    declare function _list(prefix: string): string[];\n\n    export function runNumber() {\n        return readNumber(\"#run\") || 0\n    }\n\n    function setScope(scope: string) {\n        if (!scope || scope.length > 100)\n            control.panic(922)\n        const currScope = readString(\"#scope\")\n        if (currScope != scope) {\n            _userClean()\n            writeString(\"#scope\", scope)\n        }\n    }\n\n    function initScopes() {\n        const rn = runNumber() + 1\n        writeNumber(\"#run\", rn)\n\n        seedAddRandom(control.deviceSerialNumber() & 0x7fffffff)\n        seedAddRandom(rn)\n\n        setScope(control.programName())\n    }\n\n    initScopes()\n\n    /** \n     * Delete all non-system settings.\n     */\n    export function clear(): void {\n        _userClean()\n    }\n\n    /**\n     * Set named setting to a given buffer.\n     */\n    export function writeBuffer(key: string, value: Buffer) {\n        if (_set(key, value)) {\n            // if we're out of space, clear user storage\n            _userClean()\n            // and panic - reset should hopefully recreate needed files\n            control.panic(920)\n        }\n    }\n\n    /**\n     * Set named settings to a given string.\n     */\n    export function writeString(key: string, value: string) {\n        writeBuffer(key, control.createBufferFromUTF8(value))\n    }\n\n    /**\n     * Set named settings to a given number.\n     */\n    export function writeNumber(key: string, value: number) {\n        writeBuffer(key, msgpack.packNumberArray([value]))\n    }\n\n    /**\n     * Set named settings to a given array of numbers.\n     */\n    export function writeNumberArray(key: string, value: number[]) {\n        writeBuffer(key, msgpack.packNumberArray(value))\n    }\n\n    /**\n     * Read named setting as a buffer. Returns undefined when setting not found.\n     */\n    export function readBuffer(key: string) {\n        return _get(key)\n    }\n\n    /**\n     * Read named setting as a string.\n     */\n    export function readString(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return buf.toString()\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumber(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else {\n            const nums = msgpack.unpackNumberArray(buf)\n            if (nums && nums.length >= 1)\n                return nums[0]\n            return undefined\n        }\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumberArray(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return msgpack.unpackNumberArray(buf)\n    }\n\n    /**\n     * Return a list of settings starting with a given prefix.\n     */\n    export function list(prefix?: string) {\n        if (!prefix) prefix = \"\"\n        return _list(prefix)\n    }\n\n    /**\n     * Remove named setting.\n     */\n    export function remove(key: string) {\n        _remove(key)\n    }\n\n    /**\n     * Check if a named setting exists.\n     */\n    export function exists(key: string) {\n        return _exists(key)\n    }\n}\n"
        },
        "screen": {
            "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.filter=\"!tile !dialog\"\n    //% weight=100 group=\"Create\" duplicateShadowOnDrag\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8;20,15;40,15\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tile_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"16,16;32,32;8,8\"\n    //% img.fieldOptions.filter=\"tile\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileImage(img: Image) {\n        return img\n    }\n\n    //% blockId=dialog_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"15,15;18,18;21,21;24,24;9,9;12,12\"\n    //% img.fieldOptions.filter=\"dialog\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _dialogImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n\n    /**\n     * A position picker\n     */\n    //% blockId=positionPicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"position\" color=\"#ffffff\" colorSecondary=\"#ffffff\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __positionPicker(index: number) {\n        return index;\n    }\n}\n",
            "font12.jres": "{\n    \"image.font12\": {\n        \"mimeType\": \"font/x-mkcd-b26\",\n        \"data\": \"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1Ad0AMwGAAD4CQAI/gcAAGNSEAjwBLwG8gG0AuQMAAD8AQAIAAj+BwAAZFIAACQIrAeWAqwCpA8kAAAA/AEACP4PAABlUqACKgoqCeoPKgG+AqAGAAD8CQAI/gcAAGdSwAc+AKoHqgT6BKoErgcAAPwAAAj/BwAAaVKICGwEbAIMAfwPDAFqAigEAAD8CQAI/gdqUgAFfAU8BT4FvAP8AQQBdAUGBXQFBAMAAG9SAgDeD1YF1gdWBVYF3g8AAPwJAAj+BwAAcFIAAKwE/AKsAfwPqgL6BgAA+AEACP4HAAByUowAvA+0BbQF9gW0B7QHjAcAAPwBAAj+B3VSEAAQDtAD+AX0BeQF6AcAAPgBAAj8BwAAf1IACHYFcAV0A/oPeANwA3YFAAD4CQAI/geDUkgE/Af8B/4H/Af8B/wH/AcABPgBAAj8B4dSAA74ARgE2AZ+A2wPbAIIBPABAAj8DwAAiFKAAHwI9Am0CbQF+ANUAVwJ9glcCVQHAACJUgAAnAnKC8kJsAfOBUIFDgT4AQAI/gcAAI1SCAjoBKwC6gBLCKIG5AQAAPwBAAj+BwAAkVI4AEgM9AOMApYCvALMDyAA/AEACP4HAACbUgAAEAgQBBACkAF+ABAAEAgQCBAM8AMAAJ1SAAQUAmQB5AAcCQAEiAN+AAgICAj4BwAAnlIAAIgJaAQIAogBfggICAgM+AMAAOABAACfUgQCBAL8AQQJBAkQBBAD/ggQCBAM8AMAAKBSCAgIBv4BCAgICPgHAAD8DwQEBAT8DwAAoVJACFAJSAksBTYDpAEkCTQJTAlEB0AAAACjUigIqAikCKIEoAOeAJAIiAiCCIQHCAAAAKhSAAAkBOQDJAKkAiQDAAgQB/4AEAjwBwAAqVIABP4DkgSSAv4LAAQQA/AIHwgQCPAHAACqUgAIRAlcCWYFJANcAUQBNAkkCVwHRAAAAKtSAABIB8gEfgJIAkAHEAAQD/4AEAjwBwAAsVIADvwBFAz0A1QI1AcEABAH/AAQCPAHAACyUgAApAikBJQHrASkBDAAEA7+ARAI8AcAALNSAAi0CJQElgSUA9QAlAiUCJYIlAc0AAAAtFIACLgIigSKBIgC6wGICIgIjAiKBzgAAAC5UigIqASoAgwBqAIICFAEEAP+CBAI8AcAAL9SAAAUCFQJfgUUBcADNAEeCQQJPAdAACAAwVIAALQEhAS0B4QEtAwEBBAD/ggQCPAHAADDUgAANAIUCV4HlAE0CQAEEAP+CBAI8AcAAMdSAAgCCvoKqgaqAvoCqgKuCqoK+gYAAAAAyVIQCPgElgP0AJwH8AgYCpgJfggICvgJAATLUgAI7gkqBKoDKgjuCwAAEAf+ABAI8AcAANJSAADkAr4C9A++AuQIBAQQA/4IEAjwBwAA1VIAAHwJfAn8B3oNCAQYApABfggQCPAHAADYUoAAggf/BaoEqgT/BYIMCAL/AQgE+AMAANlSAAAqA6oI6gc2AOAJSAcuATQJNAksB0QB3VIADP4Dkgj+B4ABagk4B64BOAluCaoHAAHeUhIIkgioBK4EoAKiAaQIqAimCCgHcgAAAN9SAAJEAfwFfgN8A3wBfAV+BfwDfAFEAgAA4lIAAKwJrAnuBawFgAP4ARgJDgl4BoAAYADkUgAI9AnWBfQH1gX0BQAMEAP+CBAI8AcAAOdSAAAgAewPuAfoB6gHqA4ABvwBEAjwBwAA8lIAAf4N/gH+Af4N/gEIC5gIfgAIAfgMAADzUgQIfQVtAf8E7AL8AgAGiAF/BAgE+AMAAPVSAAz8A8wP/AHsA/wLzA8ADP4DEAjwBwAA+FIAAfoPuweAB7sHugcADAgD/wAIBPgDAAD+UkAAYAAQA84CKAIIAUgJiAkICggI+AcAAP9SQAAgBhgBjgB4CAgGiAF4CAgICAz4AwAAAFMAAGAAEARMAkoCSAJICQgJCAgIDPgDAAAFUyAAEADIBy4JKAkoCegJCAgICvgJAAQAAAZTQABgBBACzgFoCJgEiAN4CQgJCAz4AwAACFMAAHAA6AMGAuUChAL0AgQCxAsECPwHAAAVUwAAAAD8ByAIIAggCCAIIAggCCAIAAYAABZTQAAgAPgPBgACAAAA/gcgCCAIEAgICAAGF1MAABAEEAIQAv4PAAAAAP4HIAgQCAgICAcZUyAGvAE8AvwDvAS8BAAE/AUQBhAGCAaIBSBTAAD+DwIIAgr6CUoISghKCMoLSghCCAIIKlMAAP4HAgQqBSoF+gUCBPoFqgSqBIoEAAAvUwAA/g8SCIYLIgj6C6oKqgr6C6oKqgoAADlTAAD8DwQExAQ8BAQEBAR8BIQEhARkBAAAOlMAAPwPBAQUBSQFpAREBKQElAQEBQQEAAA7UwAA/g8CBCIFKgWqBHoE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AAD8AwQB/AkABP4DEgDSB5IIkgheBgAAZlQAAPwDBAH8ABAD7gIgCQgG/gEICPgHAABoVAAAAA7+AQIAqgeqAroCqgsqCAII/gcAAHNUAAD8AwQB/AEABEgCSAH+D0gBSAJIBAAAdVQAAPwDBAH8AQAA9AMUARQB9AkECPwHBAB7VAAA/AMEAfwBAAD8AyQBJAH/DyQBJAH8A3xUAAD8AwQB/AEAALQIhAj8B4IAsgCKAAAAfVQAABAA0AdYAlgC1AMSANQPWABIAtABEACLVAAA/AMEAfwBEAAIAA4A+A8oASgBKAEAAIxUAAKUAVQA/AdSAAAA/AcEAgQCBAL8BwAAkFQAAPwDBAH8AWAA/A8CANAAEAkQCP4HEACSVAAIHAgUBNQDXABAAFwAVADUBxwIAAgABpVUAAD8AwQB/AEAAJAPkASQBP4EkASQDxAAllQAAPwHBAH8DAAC/gkIDPAD/A8EBPwPAACaVAAA/AMEAfwBUABIAi4CtQQ0BUwJRABAAKZUAAD8AwQB/AEACOwErAL+AawCrAS8CQAIp1QAAPwDBAH8AUAIvASUA2AA+AkACP4HAACoVCAAEQCKD6AErASjBJIEjgSSBKIPLgAAAKpUAAD8BwQC/AMACKwHIAD+DyAAqAMkDAAArFQAAPwDBAH8AQAIKAioBAoDzAUIBGgIQAivVAAA/AMEAfwBEAGID1YJZQl0CVwJhA+AALFUAAD8AQQB/AEAAPgHqAKsAqoCqAL4BwAAslQAAPwDBAH8CQAITgRMAvgBTAJOBEoIAACzVAAA/AMEAfwBAAgkBbQEbwIkApQFRAgAALhUAAz4AwgAqAeoAqgKCAv+CAgHyggsCAAGvVQAAPwDBAH4AP4PAgQiBfoEogUCBP4PAADAVAACBAF0AVQP1ARVBNYEVAFUAnQFBAUACMFUAADAD0AEXgTSBxIA0g9SBF4EQATADwAAxFQAAPwDBAH8AQAIiAT+AogAiAD+AogMgAjHVAAA/AMEAfwBAAgkCSQJvg8kCSQJIAkAAMhUAAD8AwQB/AFgADAPqASmBKgEMA9gAEAAyVQQANQHVAJeAlQC1AkQDP4CEAOSBFQIAAfNVAAA/AMEAfwBAAD4DwgA6AMuAegJCAj4B85UAAD8AwQB/AEACCQIzgQEAwQFzgQkCAQI0VQAAPwDBAH8BUAEBAT8BwQE/AcEBOQEAADXVAAA/AMEAfwBAAB8AQIBkA8+AUgBRAEkAN9UAAD8AwQB/AEABPwFggQQAs4ICAj4BwAA4VQAAAAI/wutBq0GrQKtAq0GrQb/CwAIAADlVAAARAB8B2wFbAVsBWwHfABECPwPRAAAAOZUAAD8AwQB/AEACPwPkgAQDP4DkAVWCAAG6FQAAPwDBAH8AQAA9g9QAV4BUAlQCfYHAADpVPwDBAH8AQAAfAlUCVQJ/A9UCVQJfAkAAOpUAAD8AwQB+AwCAv4Jkgj+B/wPAgD+AwAA7VSACJ4IkgiSBJ4DwACcA5QE1ATcCIAIAADyVAAAEgCyD78EigSgBJ4EiQSJBLkHCQAIAPpU/AMEAfwBAADoD6gCqAL+D6gCqgrsBwAA/FQAAPwBhAD8AAAAvAisCK4OrAGsAbwABAAGVQAA/AMEAfwJQAgoCZ4GiAT8BswFWAhACAdVAAAAD/4AIg7qCqoKagqqCqoKKg0iAQAACVUAAPwDBAH8AQAIKAkuBeoDKAUuCSgJAAAQVQAG/AEEAFwHXAVcBf4FXAVcBXwHFAAAABRVAAD8AwQB/AEAAKoHugSuBKoEugSiByAAJFX8AwQB/AEACPgElAKWAfQBnAKUBPQEgAgsVQAA/AMEAfwBAAz4AygIPgdsAGwHTAgABC5VCAAIAHwPXgVcBVwFfgVcBVwFXA9EAAAAL1UAAPwDBAH8AQAA/A+qBKgE/geoBKgEAAAxVQAA/AMEAfwBAAD+B2oFagVqBWoF/gcAADdVAAD8AwQB/AEACPQH7ADmAmUKZAr0ByQAOFUAAPwDBAH8CAAGKACkBLIJNAr0ACQGCAg+VQAA/AMEAfwBAAjUChQK/A8UCtIKUAoQCEZVAAAAAPQPFAB8BxYFNAVUBVwHFAD0DwAASlUAAPwDBAH4AP4PMgDMAeQDFAHkCPwHBABPVQAA/g8qAKoHvgKAAr4CqgMqCCoI/gcAAFNVwgA6AKoHqgSqBLoEkATOBLQENAdMAIQAX1UABvwBqgeqAqoCugMgBH4CiAHoAhgEAABhVQAA/AMEAfwBAAAoAf4PAAD+DygBKAEAAGRV/AMEAfwBAAB8AtQC1AJ+AlQPVAJ8AgAAZVUAAPwDBAH8ARAASAdEBfIFVAVEBUgHUABmVQAA/AMEAfwBAAz+AwgIYAiJCQoO6AkAAGpVAAD8AwQB/AGACP4HQAD4D4wEigT4DwAAeFX8AwQB/AEADKwDLAYsAf4PLAEsArwPCAB8VQAA/AMEAfwBAABsB6QApg+0AKQEpAMAAIBVAAD8BwQC/AMAAKQPtAlWCVQJpA6MAAAAglX8AwQB/AEAAPwA1A/UCPwJ1ALUB/wJAACDVQAA/AMEAfwA4A8UALQCngfUAhQI9AcAAIRVAAFEAVQPVgtUC/wLVAtUC9YL1A9EAQAAh1UAAPwDBAH8DGQCng/0AZQCYAj4CP4HAACJVQAA/AMEAfwBYAD4DwYAUAlUBdQDXAVQCYpVAAD8AwQB/AzwAwgHqAIIDX4CiAVqCAAGlFUAAPwDBAH8DAAC/Ak0CPQKtA+0CrwKAACYVfwDBAH8AQAAvA+wALAP/gCwD7AAvA8AAJpVAAD8AYQAfAjwBVgFNgOUAzwFUAXwCQABnFUAAQQBfA/cC1wLXgtcC1wL3At8DwQBAAGdVQAA/AMEAfwBAAC+BqoEqgWqCKoIvgcAAKdVAAD8AwQB/AEICPQLtAq2CrQK1AscCAAAqlUAAIQIvAisD7wIhAj+CYQCvASsCrwKhAirVQAA/AMEAfwJAAg+BTQDwAM8BQQJfAkAAKxVKAAsAJwP/ADcB9wF3AXcBfwHmgioDyAArlUAAAAE/gVaBVoF/g9QBV4FWgX6BQ4EAACyVQAA/gMCAf4BGAznApAAUAaOAAgI+AcAALVV/gGCAP4AAADwD5IElwTyB5AElwTyBwIAtlUAABgACgd8BVgF3gVYBVgFfAUKBxgAAAC3VfwDBAH8AQAI1AtUCFQGVgFUBFQI1AsACLtVAAD8AwQB/AEYANgPtALyD5QBGAjIBxAAxVUAAPwDBAH8AQAIfAVcBV4DXgPcBXwFAAnOVQAA/AMEAfwBAAz+AKoGqgD+BKoBgg8AANNVAAD8AwQB/AEACFIFdgOGD5YDUgUwBQAI2lUAAPwDBAH8CQAE/ADUDtYA1AXcCMAHAADcVQAA/AMEAfwBQAA0B34H1AfcB9QH1AcAAOFV/AMEAfwBAATIAlQKogcQAFICdArkBwgA41UAANwP1AfUD9wPhAFUAtQLBAj8BwAAAADkVfwBBAH8AQAE4AdsBngG7gdoBmgG7A8gCOhVAAD8AwQB/AAADkQAkAPMAqgLqAroBwAC71UAAPwDBAH4AD4BYgJqBFoFWgRCAX4DAAL9VQAA/AMEAfwEJAL+D1QBdAkQBs4BCAY4CAZW/AMEAfwBAAj0CtQK1gb0A9QG1gr0CgAACVYAAIIOvgLuCq4KrwauDO4Krgq+CoIOAAAOVgAA+AMIAfAFBAV8BfwDfAN8BfwFfAcEAxdWAAAMAEYP1gv0C/YL9Av0C/YLxQ+cAAAAG1YAAPwDBAH8CPgHBAH0DyYChAH0D6QABAMfVgAA/AMEAfwAgA9+BVAFiA/8BwQA/AMAADFWAAD8AYQAfAgAB/wOtAHcBfwH1AHcDwAAMlYAAPwDBAH8A3wCrg98Av4HkgD+DwAAAAA0VgAA/AMEAfwBEATYA+4C9AfwAu4C1AcQADZWAAD8AwQB+AAEDf4BVAH+DfwDJADiDyIAO1YAAPwDBAH8AQAAfA/cC14LXAvcC3wPBAE/VvwBhAD8AAAIXgVWAVIF/glaAVIFXgAADkFWAAD8AwQB/AAgDVQB3AcEC9wLVAl0AQANYlYAAPwDBAH4CXwIDAVkA3YBJANEBXwJAABoVgAAQAJcD1QJ1Al8D2AATA/0CXQJXA9AAmpWAAD8AwQB/AnABbwF9AOUD/QPvAPgBQAIdFYAAPwBhAD8BBAE9Af0AvYC9ALUBvQHEAiHVgAA/AMECfwH5As/COQPJA3kA/8PJACgA7RWAA7gAbwE9Af0B+wPuAHUCXQG/AVgCAAAt1YAAPwDBAH8BQAM/A/sCf4B9AfsBfwJAAC8VgAA/AMEAfwBAAD0D/IF+gwyAbkItQeAAMJWAAAIAv4H/gf+B/4G+AD+Bv4H/gcIBQAByVYAAP4BggB8AfcGpQIHA/0PVwX1B1cFAADKVgAFtAP8C/wH/AWeBfwB/AP8BdwHlAcAANpWAAD+DwIEAgWCBEIEOgTCBAIFAgT+DwAA21YAAPwPBATEBTwEBAQEBHwEhAQEBPwPAADeVgAA/g8CBPIEkgSSBJIE8gQCBAIE/g8AAOBWAAD+DwIEIgUiBaIEegSiBCIFAgT+DwAA4lYAAP4HAgSSBFIEUgUyBfoFEgQCBP4HAADjVgAA/gcCBAoEagQKBQoF+gQKBAIE/gcAAO1WAAD+BwIEKgXqBCoE6gUqBSoFAgT+BwAA8FYAAP4PAgSiBWIE+gViBKIEIgUCBP4PAADyVgAA/g8CBJIE+gWSBJIE+gWSBAIE/g8AAPNWAAD+DwIGWgdCBcoEwgQyBQoFAgT+DwAA9FYAAP4PAgSqBKoE+gWqBKoEigUCBP4PAAD6VgAA/g8CBBIE0gVSBXoFUgXSBQIE/g8AAP1WAAD+DwIEKgUqBfoFKgVqBSoFAgT+DwAA/lYAAP8PAQQpBS0FFQWVBa0GJQYBBP8PAAAGV/4HAgbeBlYGVgVWBVYEXgbCBgIE/gcAAAhXAAD+BwIEPgT+BToGugZ6BjoFAgT+BwAAC1cAAP4HAgTqBaoFSgR6BYoFbgYCBP4HAAANVwAA/gcCBP4FfgV+Bf4FfgV6BQIE/gcAAA9XAAD+BwIEagTqBfoG6gb6BmoEAgT+BwAAElcAAP4PAgzqDWoLegtqC2oL6gsCDP4PAAATVwAA/g8CCMIL+gvqC+oL6gv6CwII/g8AABZXAAD+BwIE/gf2B/YH9gd+BuIHAgT+BwAAGFf+DwIE/gT+Bf4E/gT+Bv4H/gQCBP4PAAAfVwAEIAQgBCAEIAT+ByAEIAQgBCAEAAQAACNXQAhECEwJLAk0CaQPNAk0CUwJRAhACAAAJ1cAAAAM/AMECEQIRAj0D0QIRAhECAQIAAAoVwgBiADIDzgAjgiICIgI6A+ICIgIiAgAAC1XAAgkCSQJJAkkCb8PJAkkCSQJJAkgCAAAMFcAAhAC/gEQAUAA/AcgCCAI/gkQCBAJ+AQzVwAEEAL+AxABAAz+AwAAAAD8BwAAAAD+DzpXAAIQAv4DEAEAASIJ8gQqAuYJIgzgAwAAPlcABBAC/gMQCgAEhAN8CIQEJAc8BeAEAAhAVxACEAL+ARABAAjwDwAIAAj+DyAIIAggCEJXAAIQAv8BkAQABv4BMgzSAhIDkgJyBAIIR1cAAhAC/gEQATAADAIqASgJqAgIDPgDAABKVxACEAL+ARAJAAwIAvgBSghICEgIyAcIAE5XAAIQAv4BEAFACDQICgboAQgCSAQ4CAAAT1cAAhAC/gEQAUQBRAAkAPwPBAAkAMQAgABQVyAIkAiOCLAIgAj+D6AIkAiOCJAIIAgAAFFXAAIQAv4BEAEADOgDKgAqAOgHCAgIBgAAV1cAAhAB/gGQAIAICARIA/4AyAFIAngEQAhaVwAIPggACQAJfglGDyoJEgkqCSYJQAgAAFtXAAIQAv4BEAEABCQGpAVkBCQEpAUkDgAIXVcAAhAC/gEQAQAI/gkCBAIC+gECBAIE/glfVwACEAL+ARABgAkIBHgEigOMAngECAgIBGBXAAR+BQIFPgUCBaAHMAUOBRAFIAVABAAAYVcAAhAC/gMQCQAM+APICX4GSAbICVgIAABkVxAC/gEQAQAA/AMkASQB/w8kASQB/AMAAGZXgAAQAf4AkAAABP4EkgSSBJIEkgT+BAAEalcAABAC/gMQAQIAugCCAP4PggCyAIoAAACCVwAAQAJUCvQLVApUCvwPVAryC1IKQAAAAINXAAIQAv4BEAEABCgEyAUKBAgH6AQIBAAAhFeICIgKaAoYCkwKSA94CqwKrAqICkgIAACLVwAAQATKBD4ECgV+BQoHAAUeBUAFfgQABJJXQAhoCUgJbAkKCQgPaAlMCUgJKAlACAAAo1cAAhAC/gMQCQQI9AtUClQKVApUCvQLBAimVwAAAAj+CqoKKgoqD2oKqgqqCt4KgAqACKtXJASUBf4FFAUABdQHNAUeBQQFfASABEAArlcABBAC/AMQAoAAqAK4A6wKqAqYCqgGqADDVwAEEAL+AxABQAgoCS4F6AMsBSwJIAkAAMtXAAIQAv4BEAEACHwJVAlUCfwPVAlUCXwJzlcAABAC/gEADPgDKAAoCsgJfgSIB24ICAbUVwACEAL+ARABAADoD6gCqAL+D6gCqgrqB99XAAAQAv4BEAFAAKgC6AoIBH4CiAVqCAwG4FcAAhAC/gEQAQAC/AK0ArYPtAK0AvwCAAL3VwAAlALUAp4P9AIQCEgG/gEIAQgA+AcADPlXAAEQAv4BAAEkAKQHtASmBKQEvASsByQA+lcAAEgBSAX8BHgFeAd4BXgF/ARIBUgBAAD8VwACEAH+ARABAAC0B7QCrgs2CDQI9A80AABYAAAIAf8AAAb/AQUOdQRFBPUHRQR3BwAAAlgAADgICgrsCqgKrg+oCqgK7AoKCjgIAAAFWAAEfgVWBXYFVgVeBwAFSgUyBToFRgRAAAZYEAIQAf4BgAAwAPwPqgSoBP4HqASoBAAAFVgACP4KCgp2CgAKfA8+CjwKvAr8CgQIAAAhWBAAEAR+BQAFXgU6BxoFegU6BV4FUAQAACRYEAQQBP4DEAqACL4GqgSqD6oKqgq+CoAIKlgAABAE/gMQAwQP/glUC1QLVAn+DQQJAAAvWAAAmAmcCXwFXAMOAVwBXAd8CVwJWAUAADBYAAIQAf4BEAD8DwQE/AZ8B3wF/AV8BEAAMVgAAFQBdAHeB3QBAAD+D2IIsgQyA+4MAAQ0WAACCAL+AQgAQAn+BWoDagVqA2oJfgcAADVYAAIQAf4BEAHUAFQA3gd0BVAFWAXWBxAAOlgAAQgB/gCACb4EqgTqAz4AKgDqD74BAAFBWAAIQAl+C2oLKgo+DyoKqgpqC34LQAkAAEpYAAQQAv4DEAEAAXwIVgfVAPwHVAhUC3wLTFgIAQgB/wEIAUAA3wFVBdUHlQFVCd8PAABRWAAAaAjMCngKTAooD4AKfApUClQK/AgAAFRYAAIQAv4BEAFEACQHJgVUBVQFJgUkB0QAV1jaCAIKigqoCiwKrA6qCvoKLAqsCqgICABYWAACCAH/AQgBAAb8ARwGXQX6BVwFfAcUAFpYAAIQAv4BkAUGBaoCegqKCToGygAmBwAAXlgAAIQKtAq0CfQKtAq2DvQKtAm0CoQKAABpWAABEAH+ARAFOAT2B9QH1ATUB/QEhAcABGtYAAQQAv4DEAEACPwLvAq+ArwK/AsECgAAdVgAAAAM/gfqBP4FagVrB34F6gXqBfoEAAB+WEQIfAl8C/4LfAoAD4gKaAoeCvgIAAnACINYAAIIAv8BiAgICPoFXgNbAV4P+gkIBAAAhVgACH4Lagv+C2oLfg8QCpIK+goWCnIIAACKWAAArAisCu4LvAqID+gKPApICvgIAAnACJNYAAFEBfwEfgV8BXwFfAd8BX4E/AREBQABl1gAAhAC/gEAAXwA1w/UCvwK1ArXCvwPAACZWAAAEAP+AZAABADsB+QH/gbkBmwF5AcAAJxYAAB+BIoGdgYABlYHPAW0BfQFFgVkBIAAnlgAABAD/wGAADwA5g90BXwFZAXnDzwAAACoWAAEIAR+BToFegU+B3oFPgU6BX4FIAQAAK5YAAD+CAIKfgoACvYPOwp+Cn4K3gp+CAgIs1gAAhAC/gEQAQQI1AfcB94D1APUB9QLEAjBWEAAfgRqBWoFagVuBzQFPAV2BTQFPAUABMdYAAAQAf4BAAF8BMwH/Af+B/wHzAd8BAQEylgAABAC/gEAA/QK1A70Cd4F9ALUBvQIAAjTWAAM/gPKAf4G/ga+B8IHEgf6BvIGtAQAAdhYAARwBX4FfgV+BX4HLgV+BX4FfgVwBAAA3lgAABAC/gEAAFwCrA48CW4JPALsBvwIAADiWAAAEAT8AwAI/AcEAPQOZAgEDvQKpAoAAORYAAAQAv4BAAV8BOwN/gvGAfwH7AX8CQQB61ggACAEIAQgBCAE/gcgBCAEIAQgBCAAAADuWAACGAIAAf4PAAAgCCAI/g8gCCAIIAgAAO9YgAieB5AA/g8AACAIIAggCP4PIAggCCAI8FgAAAQM1ANUAVQB3gFUAVQBVAHUAwQAAADyWAAIxAhUCFQGVAFeAFQAVAdUCFQIxAQAAPNYAAjECFQIVATUA94A1ADUB1QIVAjECAAE9lgAAMQIVApUCFQPVAheCFQPVAhUCsQIAAD5WAAANAS8BXwFfAV+BXwFfAf8BdwFFAQAAPpYAABkCDQLtAr0Dj4I9A60CrQKNAtkCAAA/ViUANwG/Ab8BvwG/gD8BPwC/ArcD9QCgAAEWYAIYAjeBAgD6AIYBAAI/gsgCEAIgAgAAAdZQABQAEgPrAq2CqQPtAqsCswKxA9AAEAACVkECkQKNAmEBaQGngTEBvwGhAmUCCQIAAANWQAACAgICnYJ3gdcBVwFXAVcC3wJBAgACA9ZAAgECnwJfAX8B3wFfAV8B3wJfAkECAAIFVkAAEAAIAgQCEgETgSKAggBiABoABgAAAAWWUAAYAhQBI4CiAFoABAAIAD+D4AAAAEAAhpZAABQCEgJRAk0BaYElAZMAkQBwABAAAAAHFmEAEQA9A8EAEQIZgS0AxQDlAR0BBQIAAAfWSAA8AMsCegJCAj4BwAAqAiWBFQCTAHAACBZCAmoBHYFVALMARAAzAMqAegJCAj4BwAAIlnEAHwKbApuC/wLbAVsBXYDbAF8AMQAAAAlWQAI/ATUAvwP1AL8ABAISAnWBrQEjAOAACdZEAgQBBACEAHQAD4AUACQARACEAQQCAAAKVlACEQIRAREAkQD/ABEAUQCRARECEAIAAAqWRAIEAQQBBAD0AI+BFAIkAEQAhAEEAgAACtZQAhIBEgESAJIAf4ASAFIAkgESARACAAALVkAAEAIRAhEBEQERAP8AEQDRARCBEIIQAguWQAAgAj4CIgEiAP+AIgBiAaIBPgIgAgAADFZYAhwBE4ESALIAX4AyAFIAkgESARACAAANFlABEgIUgRUBEQCwAF+AEACQAJABEAIAAA3WQAABAjsBKwErAL+AawDrASsCrwKhAkAADhZAAAoAKgAqAK4A6wCqAqoCrgKqAaoACgAOVkAAIAIiAioCIgEiAP+AIgDiASoBIgIgAg6WQAAqACoAKgAmAaMAIoImAiYD6gAqACoAD5ZCAmICGgECAQIA/wACAOIBGgIiAgICQAAR1kAADQAtAe0ArQCrAKuAywINAj0BzQAIABIWSgEqAyoApgIrAiqB6gAmAKoAqgMKAAAAElZAACgAKwCbAIsArwCrg+sAiwCbAKsAqAAS1lAAEQA5A9UBUwFxgdMBVQFZAXkD0QAQABOWRQEVARMBVwFVgV1B1QFXAVMBVQFFAQAAE9ZkABUCFwFfAVcA94BXANcBXwFXAlcCJAAUVkAAFQJVAl+CVQFQANCAyIFHglCCT4JAABUWSABJAkUBawDJAEmAXUBJAGMDxQBJAEgAVVZJAlUCUQJJAUcBQYDBgF8BQQFFAUkCQAIVlkgCSQJEAl+CQAFSANEAyYFJAkcCQQJAABXWSAAJAEUBfwHdAV2BXQFdAV8BRQNJAkgAFpZAAmECawFZAW0A6oBYgNSA0IFSgUACQAAYFkAAAQF/AXuBe4F3APcA+4F7gX8BQQFAABiWSgBKgGqAK4P6gq7CqoKugqmCqYPKgAqAGVZAAAACXwJDAVkBXYDJANMBQQFfAkACQAAZ1kACXwJBAVsBWwFLAN+ASwDLAOEBfwFAAloWQAALgkgCX4FAAUkA5IBFgORBf0FFQkQCWpZAABUATQB/AP0B/YB9AX0BfQD/AGUARQBblkAABoAmg/+Cv4K+w/6CvoK/gr6D0oAAABzWQAAEAgQCdAIMAkeBRICEAKQBXAEEAgQCHRZiAj4BA4DyAE4CAAMNATEA8QCPAQACAAAdlkICPgMDgOIA3AIBAf8AAQEPAgkCOAHAAB4WQAA+AgOBYgDeAwAAEQARAD8D0QARABAAHlZAAj4DA4DiAF4BgAA/AcQCP4JCAj4CAAGfVkACOgMHgOIA3gEAABECEQI9A9MAEQAQACCWQAACAj4CA4F6AMQAPwPBAQEBAQE/A8AAINZAAj4CA4FiAN4BAAAxAdECEQIRAj8CAAGhFmACIQIvAqkC6QKpgSkBKQHpAikCIQIAACGWQAAGAOAAP4PAACQCHAJHgYQA/AEEAgQCIdZCAj4BA4DiAF4AAAERAREBEQERAT8DwAAiFkACPgMDgPoAhgEcAFEAUQJZAlcDMADAACSWQAI+AwOA+gDGAzwA0gASgBKAEgA+AAAAJNZCAj4BI4CyAE4AgAIaASoBT4CqAVoBAgIllkABPwEBwPEAjwAAAwiAqIBfgChASECIASZWQAA6AieBsgBOAIACDwEgAT+AgACjAEwAJ5ZEAjwBA4DiAN4AAgI4A9cCEQI/A9ACAAApVkAAEQIVAbEB2QGbAJEAmIF8gRKBEAIAACoWQgA+AkOBYgDcAQAAAgP+ABOCEgIyAcIAK5ZAAj4DA8D+AgADP4DEgDSB5IIkgheCAAGs1kAANAIPgUQA/gEAADUAwoI+A8IANgBCAK5WQAI+AgOBYgDeAAADEgCSAH+D0gBSAJIBLtZFAlcCVwLXAvcBX4FXAVcB1wFfAkUCQAAxlkACPgJDAb4BQAA/AdEBFQFVAxEDPwHQATJWQAA6AgfB8gBOAbAASQAJAD+DyQA5AMAAMpZCAj4CA4H6AEQBngARA/EAP4PRADEBwAAy1kAAOgNHgOIAXgCAACwD64EoASsBDAHQADQWQAA+AkOBugDEAj8DyQJJAkkCfwPAAgAANFZAAD4DA4DiAN4BAAAkA+QBP4EkASQDwAA01kAAOgIHgXIAzgAIAicCJAI/g+QCJAIAAjUWagIrAisC5wKzAb8BIwCmgWqBKoIqAgAANpZAAj4BA4D8AgMCYAE/gMAAP4HQAicCIQG3FmgCKwIrQquC6wGvASsBq4FrQSsCKQIAADlWRAI8AQeA5ADeAQAAagHfgkoCTgJKAUkAOhZAAj4DI4DcAQEAOwMrAL+AawCrAS8CQAI61kAAPQMjwLkARgA/g+SBJIEngeSBPIEAATsWQAI+AQPA+gBEAD+BwIE8gSeB5IE8gQCBPtZAAD4DA8D6AEQAv4PAgXiBLoFAgT+DwAA/1kAAKIIlArUC8AGpgSUBIwGlAWkCKwIAAABWgAO+AEIBNgFeALYAwgI/gQIA8oEKggABgNaAAj4CA4H+AQAACQJJAm+DyQJJAkgCQAABFrICMgIrgqYC9gG/gSYBpwFqgTqCMgIAAAHWgAI+AQOA8gBOAZQADQPHAAUADIPUgCAABhaAAj4BA4D+AYAAPwPVARWBNQBVAO8BIAEG1oAAPANHgP4AAQIcAlcB+QBZAN8BcAJAAkcWgAA+AyOA3gIAgb+AZII/gf8DwIA/gMAAB9aCAj4CA4F6AMYAMAPvAK0ArQKtAr8DwAAJVoACPgM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XgmcB5wAXAFEAhwEAAS5WwAALAIkAZQPRAkmCSQJRAmUDyQBDAIAAL1bAAAMCNwLXAh8BF4DXAR8CFwI3AscCAAGvlsAAAwJBAX0BVQFTgFMAcwFTAVEBQwJAAC/W4AATADkBxQABADWB1QFdAVUBVQF1AcAAMJbAABMA0QI9A9UAEYLFAh0BJQD1AQ0CAAIxFsAAIwAxAfUBbQFtgW0B9QA1AjED4wAAADFWwAIDAjkC7QGtAb2A7QCtAa0BuQLDAgAAMZbAAAMAaQHhATkBE4HpASUBEQEFA9kAAAAx1tACFQE1ANUANQHVggECHQLVAvUCFQIAATMWwAADACEB/wF3AXeB9wF3AX8BYQHDAAAANJbAACMBLwCvAH8BL4IvAr8CLwJvAKMBAAA01sAAIQP9AD0AvQC9gP0AvQC9Ab0BIQHAADbWwAIDAjEC9QL9AfWA9QD9AfUC8QLDAgAAN1bAAAsAQQB/APECX4IfAt8BXwFfAvMCQAI3lsAAAwK5Ar0CvQG9gP0AvQG9ArkCgwKAADfWwAATAlkBbQB9AmGD5QBpAPUAzQFnAgAAOFbAACMAIQF/AX8A/wD/gH8BfwH/AGMAoAA4lsACWwHRAH0DwQA9gn0C/QF9Af0CKwJAADlWwABXAlcCbwKnAt+B0QGvAR8BXwBDAEAAOZbAAAUCNQH/Af8A/4D/AP8B/wH3AcUCAAA51sAAAwBxANUA9QLagvsD2QDRAPUAwwDAADoW4AEtAK0CrQL9AK2DrQC9Aq0C7QKhAIAAOlbAAFMAWQP9AtUC3YPVAtUC/QLVA9EAQAB61sAAAQB9AT0AvQA5gLEAfQA9AX0BIQDAADsWwAIDAjEC9QH1AfWA8QD1AfUC8QPDAgAAO5bAACMCEQI1AP0CtYO1AL0AtQLRAiMCAAA9VsAAFQI9AfUAfQK1AcGAPQHdAt0C3QOAAT2WwAEFgjWB94H1gPHA+4D7gP+B+4HLggAAPhbAAAIACgAaACIAQgICAgICP8HCAAIAAgA+VsACCQMRAKEAXwCAALQABAJEAj/BxAAAAD6W6AAqACoAKgGqAS8AKgIqAjoB6gAqACgAPtbAAAAAUQBVANUA1QBVAlUCVQHfAEAAQAB/FsAAAABPAFUA1QFVAFUCVQJVAdcAUABAAH+WwAIKAxIAo4BaAYIBFAA0AEQCP4PEAAAAP9b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/gMAAvgHwACmD5IIsAjGD4gA8FwAAPgH/wcABPwHAAAkBVcF2g9WBVIFEAT2XAAAAA78BFwFXAdeBVwFXAVcAVwJQAcAAPtcAAD4A/4D+AMAACgFjAXKAogCLgVoBAAAA10AAPAD/gPwAwAAVAPEAP4HxABUAUQCAAAHXQAJfAUYAVgJWAlcD1gBWAFYBRgFfAkAAA5d+AcAAv4DAAL4AwAAtAOsAq4LNAj0ByAAFF1AACwA6A9YBVgFXgX4B1gFWAVYBVwFAAQWXQAM/gMMCKwKrAquCuwOrAqsCqwKrgoICBddAAAAAPYPFABUBnYG1gd0BnQGFAj2BwAAKV0AAAwM7AOoCegPDgAICOgHqAKoCuwHAABKXQAA8AP8A/ADDADsBgwB/A8MAWwCqgQABEtd/AMAAv4DAALwBf4Dyg+qCq4KqgruDwAATF0gAOwPKAUoBegPDgDIDCgCqAEoBqwIYABQXQAA5g8cANwJXAn+D1wNXA2MCPwHBggABmldEACWD/QA9AD0B/QF9gX0BfQH9AiWDxAAi10AAAAA8Af+A/AJ/ARcDV4DXAtcCUAHAAC6XSAAkwCqAqoEsgcHAP4FrgWuAa4F/wUACM1dIAl8C3gFeAV4Cw4A+ATYA/gD3AbQBvAC3V0ACAAM/AMAAAAAAAD4BwAAAAAAAPwPAADeXQAAcAgABv4BIAAAAP4HAABwAAAA/g8AAOFdAAhECMgHAAT4CAQLcAiMCSAK2AgECwAI4l0AAAAF+wWoA6oD/Q+oAaoDrgX9BQAFAADjXQAAAAn+BagFqgP8D6gBqAOsBfoFAAkAAOVdAAQEBAQEBAQEBPwHBAQEBAQEBAQABAAA5l0AAAgMCAPICHwISghICMgPSAhICEgICAjnXQQCBAL8AwQBAAEEAHwERAhECEQMxAMAAOhdAAAAAP4PkgSSBJIEkgSSBJIE8gUCBAAA6V0EAgQC/AEECQAE/AMEAHQABAD8DwAIAAbrXQAFhAR0BIQEBAT8BwQFhAR0BIQEBAUAAO5dgAioBKoDrgioCfgJqA+uCaoJqAmACAAA8V0AAAAA5AckCCQIJAgkCCQIJAh8CAAHAAHyXQAABAD0B0QIRAhECEQIRAhECPwIAAYAAvRdAAAAAPwHRAhECHwIRAhECEQI/AgABgAA910AACABKAHoB74KqAqoCr4K6AuoCCAF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SAAAAP4PEAAgAMAAgABTYogAiAj+D0gASAAAAAQIBAj8BwQABAAAAFRiiACICP4PSABADAQD/AAEADwIJAjgBwAAVWKICIgI/g9IAEgIAAf4BAYEQASABwAMAABYYogAiAj+D0gAAABEAEQA/AdCCCIIIgggBltiiACICP4PSABIAAAEBAQEBPwHBAQEBAQEY2IIAYgI/geIAAAA/A8EBAQEBAQEBPwHAABnYoAAiAj/D0gAAAxIA/8AiAAIAPgHAAgABmligACICP4PSAAADPgDCAAKAAwACAAIAAAAa2KIAIgI/g+IAEgAAAREBEQERAREBPwPAABsYogAiAj/B4gAAAqiCXIEKgPmCCIO4AEAAG1iiACICP8HiABACAIIQg7+CUIIQg7+CQAIbmIIAYgI/g+IACAIUAROA8AAQghOCPAHYABvYpgAmAj+D1gAAAj4DwAIAAj/DyAIIAggCHBiiACICP4PiABACBAE0AM+AJAHFggQCBAGcWKIAIgI/g9IAAAH/ADEBAQFPAOQBHAIAABzYogAiAz+A4gIAA78AWQEpAUkAqQFZAgACHZigACICP4PSAAACEgESAP+AEgDSARICAAAeWKIAIgI/g+IAAAA/g8gBAAA/gcgCBgIEAZ+YogAiAj+D0gAAAgQBD4C0AMSBdQIFAgQBn9iAAAQBBAD9AAECqQK9AesAgwC5AAgAxAEgGKIAIgI/g9IAAAIaASoBT4CKAXoBCgIAACEYogAiAj+D0gAAAh4CAAE/gQAAowBUAAAAIpigACICP4HSAAAAPwHRAhECHwIRAhECPwIkWKAAIgI/gcAAPwHAgICAPwPBAAEBPwDAACSYogAiAj/D0gAAAAiCCoI6g82AKYAYgAAAJNigACICP4PSAAADvwBBAD8DwIA/gACDwAIlWKIAIgI/gdIAAAI3gRCBUIC3gVQCAgIAACWYogAiAj+D0gASAAAASIBTAEAAf4PgACAAJdiAACIAIgI/gdIAAAM6AMuACgA6AcICAAGmGKIAIgI/gdIAAAO/gEiACIAIgDiDyIAIgCaYoAAiAj+D0gAQAgEBKQDfADkByQIJAggBJtiAACICP4HSAAAD/8A+AcACfgIDgr4CQAEnGKIAIgI/g9IAAAMiAN+CKgFKALoBSgICAieYggJiAj+D4gAAAz8A0QARADEAUQCfAwACKJiiACICP4PSABAABAAyAcnCCUJyAgQBhAApGKIAIgI/gdIAAAM+ANIAEoASgBIAPgAAAClYogIiAj+D0gAAAD+DyIA8gwyAzIF7gQACKtiCAGIDP4DiAgADvgByAV+BkgFyARYCAAArGKAAIgI/g9IAAAAsA+sBKIEoASkBJgPIACxYpAAkAj8B1AAAACwB64IqAjoCQgJ+AgABrViiACICP4PSAAAAPwPJAQiAD4M4gciCCAGuWKIAIgI/g+IAEAECAJIAf4PyABIA0gEAAC8YoAAiAj+B4gAAAD8AaQApAD8D6QApAD8Ab1iiACICP4HCADgD5AEkAT+B5AEkATwDwAAwmIAAJAI/AdAAOgMqAL+AagA/g+oALgHAADFYogAiAj+D0gAAAj8CSQJJAkkCSQJ/AkACMZiiACICP4HiAAADPwDIgCiAOIPIgEiAgAAyWKAAIgI/g9IAAAEKATIBQoECAfoBAgEAADLYgAAiAj+B0gAAA/+AMgHAAn+CggK+AkABM1iCAGICP4HiAAAAPgPiASOBIoEiAT4DwAA0GKIAIgI/AdIAAAIvASkAqQBpAikCLwHAADSYogASAj/D0gAAAD+D5IEkgSSBJIE8gQCBNNiiACICP4PSAAIAYAA5A9cBEQERATEDwAA1GKIAIgI/g9IAAAMiAN+CKgFKgKqBWoICAjWYoAAiAj+B4gAIACQAM4HSAjoC0gI6AsICNhigACICP4PQAAQAMgDLgEoAegJCAj4BwAA2WKAAIgI/gdIAAAAvAcgBP4HIAQgBLwPAADaYgABGAn+B5gAAAiYBNQDkgCQANQPmACgANtigACICP8HSAAAAKIPmgSGBKIEogSeBwAA3GIAAJQMlAL8AZIAAwAoASoB/g8qASoBAAHdYogAiAj+B0gAQAEUAVQB/A9UAVQBBAEAAN9igACICP4PSAAABP4DAAG8DAACwAE+AQAO4GKAAEgI/gdgAP4MiANwBPwJBAj8CwAKgAnhYogAiAj+D0gAAA74AQgEiAduBAgFCAUIDuJigACICP8PiAAADpABfgwQBPIHlAhUCBAE42KAAJAI/AeQAAAE6AK4CqwI6A+IAIgCCATlYoAAiAj+B0gAAAz+A5IAkgD+D5IAkgj+B+ZigACICP4HiAAABJIElgSQBJgElgQQBAAA6GKAAIgI/geIAAACHAnQBH4FUALUBVQIEAjpYogAiAj+D0gAAAKkApwC1A+cAqQCJAIAAOxigABICP4PSAAAAJIPkgj+CJIIkgiRDxAA7WKAAIgI/g9IAAAEUATQBxAE/AEQBhQMAADvYoAAiAj/D0gAAAnSCCIK+gsmCNIIEgkAAPFigACICP4PSAAACIgE/gKIAIgA/gKIBIAI82KgAKgCagJsC3gL7gcoAygDbgKoAqAAAAD3YgABEAn8B5AAAAAoAagD/AqoCrgKqAYkAPxiAAEICf4HyAAACIkE+gOIAIgA/A+LAIAA/mKIAIgI/gdIAAAAmA+EBKIEogSkBIgHMAD/YggByAH4AfwF+gX6A/oB/AH4AfgBiAEIAQFjkACQCPwHUAAAAKgCqAK8CKgI6AeoACAAAmOAAIgI/g9IAAAIJAkkCb4PJAkkCSAJAAAHY4gASAj+D0gAAADeB2QFZAVkBWIF4gcYAAljCAEIDf4DCAhACFwIxAV3BkQDxARcCAAAEWOAAIgI/g9IAAAJiAT+AwAA/gdACJwIhAYWY4AASAj+D0AABABUBFQLRgnUCFQIBAYAABljiAJKAiwCuAqqCuwHqAKIAj4CSgJIAgAAH2MAAQgJ/gfIAAAIqAiIBv4BiAOoBIgIAAAgYwAAiAj+B0gAAAikBKYDvAC0D8wIrAiABCFjiAGICP4HSAAABC4FIAU+BSAFKAXmDwAAI2OAAIgI/g9IABAAWAlWCfQHXAFUAfABQAAkYwAAiAj+B0gAAAhEBEwDNgAkAFwPRABEACVjAACICP8HAACWAtICsgKaAtIPkgKWAgACKGOAAIgI/gdIAEAJLAUrA+gDKgMuBSgJAAgqYwAAiAz/AwAIkgb+AZII/gf8DwIA/gMAACtjgACICP4HSAAgCBwJYAn+DyAJHAkgCUAAL2OAAIgM/wOICAAO/gHCD1IE0gVSAVIOAAg6YwAAiAj/D0gAAgw+A+IEAAgiCf4JIgkiCT1jgACICP4HQAAQCPgIlASWAvQBnAeUCPAIRmOAAIgI/wcAAP4PAgRSBPoFUgQCBP4PAABJY4AAiAj+D0gAAAy8AyQE5A+kCKQIvAgACE1jiACICP4PSAAAAX4BagFqAeoPagF+AQABT2OIAEgI/g9IAAAEvgSqBKoHqgSqBL4EAARQY4gAiAj+B0gAAADuD6oCqgKqCqoK7g8AAFVjCAGICP4HiAAAAOgPqAKoAv4PqAKsCuwHXGOIAEgM/gMACLwErAWsBv4ErAasBbwIAAReY4AAiAj+D0gAAAiUBJYC1AGUCJYMNAMAAF9jgACICP4HSAAACOAJLgQqAqoBKgQuCOALYWOAAIgI/g+IACAEmAUkBKIFJAQIB9AEAABiY4gM/gNACBAI+ASUApYB9AGcApQE9ASACGNjAAEICf4HiAAABvwEhAaWBIQGvAiABwAAZ2OAAEgI/wdIAAAAagK+AqsPqgLqAqoCAABoY4gAiAj+B0gAEABMB1IFegVSBUQFSAdQAG5jQABICP4PSAAAB/4AMgeyBPIEsgS+BwAAcmMAARAJ/A+QAAQC1AdwCVwNUA1UDtQIQAN3Y4AAiAz/A0gIAgiqBqoEqgT/D6oK+goiCIBjAACICP4HAAD8DxQA9A8AABQO6gEIBjgIg2OAAEQI/wcEAGAAtQe1APUPtQC/BOADAACIY4AAiAj+B8gAYAhoCKQEqgeiBLoGagUACIljiAj+B0gAAAL4AqgCqAKuD6wCrAL8AgQCjGMAABwCzQL/AvwK/gf8AvwC/wKNApwCAACPYwABCAn+BxgAjAKqAugDqAKoCogI+AcAAJJjiACICP4PSABAAAgBKAHWDvwHKAEoAQAAmGOAAIgI/gcAAP4PCgDqDooI6g+KCO4OAACZYwABCAn+B4gAAAKsCqQK6geiAqoC6gOAAJtjgACQCPwHAAAoBb4HKAUAAPwPQADAAAAAoGOAAIgI/g+IAAAE9AKUCJYHlACUAvQCBAShY4AAiAj+B0gAAASUAoQB1A+CAbICigQAAKJjAAEICf4HwAAMBKQClAHED5QBpAKsBAAApWOAAIgI/gdIAAAIpAqsC6YEpAa0BaQIoACnYwABiAj+D0gADAikCJQIhg+UCKQIDAgAAKhjSABICP4PQAAwAPwPqgSoBP4HqASoBAAEqWOAAJAI/AdQAAAA6AO4AqwC6geoCrgK6AuqY4gASAj+D0gAAADUB14FVAVUBV4F1AcAALBjAACUCPwHsgA4BuYB/AMQCJII/geSAIAAsmMIAQgJ/gcIAAABvgPqBaoEqgKqCL4HAAC3YwAAiAj+B0gAAg74AU4HAAD+DwIA/gMAAMljgACICPwHSAAACXQFHANcD3wDFAU0CRAAz2NAAEQE/wMkAAAA9A+UBJcE9AeUBJcE9A/QYwABCAn+B4gAAAy+AqoEqg+qCqoKvgqACNJjAABEBP8DRAAAAOoPqgQKBP4HCQTpDwAA2mMEAYQM/wfEAAAG3wNVCVUFVQNVCV8HAADbY4AAiAj+B4gACAh4CTYFlAM8A1AFcAkACOFjAACQDvwBAAz8AzQItAr0CrQPtAq8CgAI42MAAIgI/gdAABwPsACwD/4AsA+wALwPAADqY0AAiAj+B0AAEgH+D0IAGgwAA/4AAAM4DO1jAAEICf4HiAAAAP4G6gSqBaoIqgi+BwAA7mMgAEgI/gdIAAAC+gK6AroC+g+6AroC+gL0Y4AAiAj+D4gAAgRWAvIJ1gbSBNkHVQhACPpjiACICP4HSADAAIwOpASsBOwHogSyBKoO/WMAAIgM/wNACB4IwAteCEAHVgjUCwQIAAQBZAAASAj+BwAA8g9CAFgHqgLaAgIL/gcAAAJkQACICP4PSAAACKoKmAveBJgGqgWqCIAABWQAAIgI/gdAABoI/AU4BLoHOAjuCQoIAAYNZIgAiAj+D0gAAAjsBewD7AHsAewF7AkACA9kgABQCPwHkAAAAHgDeAN4AX4JeAl8B3gBE2SAAIgM/gNICAAM1QNWCHwJVA9XCVQJAAAWZAAACAn+B4gAAAJUCsQKpgqeD4wKhAoAABxkiAj+B0gAAAi8CLQJoAb+BKAGtAm8CAAIHmSAAIQI/wckAIAPWgBaB1sFWgdaAMIPAAAsZAAAEA78AYAM+AN+CfgHAADeDUICngUgCC1kAACICP4HSABAAG4HVgVcBWQFTgdEAAQANmRAAEgI/A8gAJAPaAB4B3QFcgV0BWgHEAA6ZAABBA3/B4QADAj/BasDqgH/BasDqg6CAERkAACIDPwDKAiABLwGvAG8BbwGvAakCQAARmSAAIgI/gdAABwFVA1cC9QJXAVUBVwJAABHZIAAiAj+B0gAAAasBKQE6geiBKoEqg4AAEpkAABICP4POALIATgBMAD+D6gE/gesBAAEVGQAAIgI/geAAIgCBAK0Au4OxAIEArQCgABYZIAAiAj+BwgA4A8UAFwH9gVcBxQI9AcAAGdkAABICP4PSABMAOgHaAVuBegHaAVsBQAAaWQADPwDBAC0A7QLtguEB7QDtAN0A3QDVAJ4ZIAASAj+D0gAAAl0CXYH9AF0A3YFdAkECYNkAAL8A/wD/gv8C7wH2APWA1IDdgNUAoACh2QAAIgH/gDwD14A/AdwAPQHOgbFATwGAASQZJAAkAj8B5AAGAj8C9gG3gbYAv4PmAIAApFkgACQCPwHAACYA/wL2AvcB9gD/AMYAwAAkmSICP4HSAAQAPQPvgK0Cv4PEAjuBogDeAyVZAAAkAj8BwAA/A1YAfwFAAD4DyQA5A8kAJ5kSAj+B1gAAAj0CvQK9Ar2D/QK9Ar0ChAIpGRAAEQM/wcAAPIPvwLaDxAIOATHA3wMAAClZAAACAn8BwgAoAu8CuQOQAsoBfwHqAkAAKtkAAGQCPwHUAAADfwBKgHoDSgB6A0oAegNrWSAAIgI/gdYANQAVAe8BbwHlAW6BdIHkACuZIAAhA7/AWAE4Ae/BrUG9Q91BHUD/wVgBLBkAACICP4HoABOCfYFVgVAAU4F9gVWBUAJsmRAAEgI/g9IAAIJeAVuA+gBbgN4BWoJAAi8ZAAASAf+AAAO/AEsAdwHrAN/AqQDFQQAA79kAACICP4HCADoDLQC9AQSAPIMtALkBAgIwWRAAEgI/gcAALQMZAMEAPoHVAX8B1QFAATFZAAAiAj+B0AAfATMB/wH/gf8B8wHfAQABMdkAABICP4HIAC+AvoCvgK6D74C+gK+AgAAymRABPwE/Af+B/wO+A+QB+4GogbmBqgECAHLZIAASAj+B0gAAACaB/wF2AXeB9gF/gWKB81kAACQDPwDEAjABbwF9AOUD/QDvAXgCQAAzmQUADwCvgO4A84LvAuED6gDtgOUAywDRALSZAABiAj+B4gACA7EAZIH2gXyA7QJxA8AANRkgACICP4PSAAYDvgBrgy8D8wPvA/IDwAA2mSAAEgI/g8ABPgDGADYBf4DfA9sAWwGAATgZAAAiAj+BwgAYAzUA+QCvgK8ArwC7A8EAOZkAAAIDf4DCAksCZQB1Am+D7QB9AEcDQAA7GQAAIgI/AcAAF4N1ANUDAADLAT0DzwJZAj0ZIAAiA7+AQAM/ANECPQL9Av2A/QL1AsAAPpkAACIDP4DwAh2B8oM7gcKAG4GqgquCgAA/mQAAYgI/gcIAMIIfgreB14HXgf+C8IKAAgAZVQAzAJeAkwD4AvmC9QHwgNIA14CzAJUAA9lAACYDP4DAAjoB2YC9A8AAN4H1Av0CgAAFGUAAIgI/gcAAP4H9gR+A/AH7gP2CP4HAAAcZUAAJAT/AyAAiw9+AfoCewb6AXoE+wcgAB1lAACQCPwHUADEA/wC/A88APwD/APkByACJGUAAAAASAj+D/4L9Af+DvQPrgT6B6gEAAAvZQgIKARoBKgEKAM+AigDqARoBCgECAgAADZlAAD8AwABAAH+DwAAMARuBIgD6AIYBAgIOWUAAOQBJAIkAXwFYAwwBM4CCAHoAhgECAg7ZQQBBAH8AQQJZAkQBG4CiAOIAngECAgAAD5lAAgIBvgBKgjIByAAEAzuAogDeAQICAAAP2UEBPQDBAL8AyQCZAgwBO4CCAPoBBgIAAhFZQgAyA9IBH4EyA9gCDwEygKIA3gECAgAAEhlCAioBIoCjAMoBEAAMAzOAogDeAQICAAATGUAAJIPkgT+BJIEgg8gABQM6gKIA3gECAhPZUAA+AFWAfQFVAX0A2AJHgTlAsQDPAQECFFlCAJoCQgJ/g/IAAoJYAh+BIkD6AIYDAAAVmUABFQC1AH+BNQE1ANAAH4GiAFoAhgGAARXZQAI/AVUBVQB/AVgADgMzAKIA3gECAgAAFhlUAJYCVQI8gdEAGQLMAjuBAgD6AQYCAAIWWUAAlQCVAneD/QBWAk2CHwEiwPIAjgMCAhdZQAA9g/QAf4P0AH2DwAIPgTJA+gEGAgAAF5lAADuD+ABfgKgCe4PQAh+BIgD6AQYCAAAYmUAAAgC+gOqAqoC/g8AADAM7gKIA3gECAhjZQAA6g+vAqoCrwrKByAAGgx1AsQDPAQECGZlCAL4CtgK3A7YA3gKYAj+BAgD+AQICAAAbGVEAPQDVgHUCRYM9AMwCG4GiAHoAhgMAAhwZaAIqgqYB/4EmAeKCCAIPgTJA4gCeAQICHJlAAD0D/QD9gJ0CfQHAADgDD4DKAPoDAAIdGVAAFwIPAi+DrwI3A/YCrYKtApMCEQIAAB1ZQAA+g8OA/sCDgn6BxAAPwzEA3wGBAgAAHdlAAS/AqsB/wWrBb8DmAg/BMIDcgIODAIEeGUICXwLfAv+BXwFfAtgCTAE7gN4BAgIAACDZQAAXQl+Bf8HVANeAWgA5gNWBVwFZAVABIdlAAAICAgIGARoBIgCCgGIAmgEGAQICAgIiWUiBBIM0gNWAVoBSwFKAVYBVgHSBxIAEgCLZWQAZA9kAVQBXA/WAVQBXA9kAWQJZAdgAIxlCAhoBI4DfAIACNQP9AcQAP4D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/g8oAIwARAAkACQA/A8EADQAxABwZ4gIiAZIACgAGAL+DBgAKAxIAIgGiAgIAHFnAAAEBPwErAKsAf4PrAGsAqwC/AQEBAAAfmeIAUgA/wdIAIAEOASGB2AEAQSOBTAGAAB/ZwgDiAD+D4gAAAz8A2QIpAUkBqQFZAgAAIFniANIAP4PSAAADIQDfAiEBTQCLAXgCAAIhGeIAUgA/g9IAAAAnAFqAQgJyAkIDPgDAACJZ4gDSAD+D0gAiAAACEQIRAj8D0QIRAhECJBniANIAP8PSACIAAAM/AMiACIA4g8iACAAlWeIA0gA/g9oAIAIOASIA34A6AcICDgIAAaXZwAAiAFIAP8PKAAoAoABSAD/D2gAiAMAAZpniANIAP8PSACgCBAEbgSIA8gCOAQICAAAnGcAAIAEvgSqAqoBqgH+D6oBqgK+BIAEAACdZ4gBSAD/D0gAiAggBKgEKAU+AigF6AQICJ5ngAFIAP8HSAAAB/4AAASAA34AgAMABAAAoGeIA0gA/g9IAAABJAEcAQYBhA88ASABEAGiZ4gDSAD+D0gAAAD8DwQIFAvkCLQJBAoACKNnAAAEAbQAlARUBH4JVApUCpQKtAAEAQAAqmeIA0gA/w9AABAAyAckCCMJJAnICBAGEACrZ4ABSAD+DygAQA/8AAQG9AEEAvwHAAwAAK9niAFIAP4PSABAABAPkAT+BJAEkASQBxAAtmcAAKQIlASOAoQB3A+AAbwCpAKkBLwEAATEZ4ABSAD+DygAAAD0DxQAlAF8AJQJFAj0B89nCAGIAP4PSAAAAPgPiASOBIoEiAT4DwAA0GcAAIQEhAS+AqwB7AesAKwBvgKEBIQEAADTZ4gEqgSqAoACpAG0D44BhAL8AsAEwASwBNRnAAlQCVQFNAN8A9wPdAMcAxQFNAkQCQAA2GeIAUgA/g8oACgBgAD0D0wERAREBMQPBADcZwgDiAD+D0gAAAD8DyQJJAkkCSQJ5AkECOVnAABICCgIqA9YDVwNSA1YDagPKAhICAAA72eIA0gA/g9IAAAA9AMUAfQJBAj8BwQAAADxZwAAiANIAP8PyAAICQAIigj6D4wIiAgICPNngANIAP4PAAD8CQIF+gIAAPwPBAD8AwAA9GegBL4EoAK/AqQBgA+fAaQCpAKkBKIEkAT7ZwAAJAgUCNQPrAquCqQKrArUDxQIJAgAAANoiAFIAP8PSAAAD/wAFA70AVIIUgjSBwAABGgABFAEXAJQAdIA1A/QAFABWAJUAlAEAAQHaIgBSAD+D0gAiAQgAqQJJAjkDyQApAEgBgtokANQAP8PUAAEBnwBRwjkD0QARAMEBAAAD2iIAUgA/g9IAEAEEgSWBJAEmASWBBAEAAARaAADiAD+D0gAAAbkARwDQADQCRAI/gcQABZoiAFIAP4PaAD6D4oFfgQKBH4EigT6DwAAF2gECXQJVAVUBXwD1A9UAXwDVAVUBXQJBAkhaIgBSAD/D0gACAhgBBgE2AIOAcgCKARICCpoiANIAP4PaACABBAETgPIAP4PyAFIAkAEN2gIAYgA/g9IAAABSgFKAfgPSAFOAQgBAAA4aIgBSAD/D0gAiAggBGgFmAROAigDqASICDloiANIAP8PSAAAAP4PUgjSCFIBUgZ+BQAJPGjEASQA/w8EAEwA5A9nBFsEWgRmBOIHQAA9aBAEVAJUAd4PVAFUCRAE/gIQA9IEFAgABj5oQAhkCRQFBAU8AwYPRAE8AwQFFAUkCQAIQmiIA0gA/g9IAAAIJAkkCb4PJAkkCSAJAABDaIADSAD+D0AADAmABP4DAAD+B0AInAgEBUZoiANIAP4PKABAAPwPBAhUCvQLVApUCgAISGgAAJQJlAW0BVQDVg9UAXQDlAWUBRQJAAhMaAAAAAl4BVgFWAPeD1wBXANcBXwFBAkAAFBoCAOIAP4PAAD8DwQA1ANUAtQDBAj8BwAAUWiQCZgFXgV+AxYBhg9WAVoDWgWwBYAJAABTaMQBJAD/DyQAAAT9BSUFJQUlBSUF/QUBAFxoiANIAP8PSADKCEIIxAVxBlYCQAXcBEIIY2iIA0gA/w9IAAIELAUgBT8FIAUoBeYPAABlaIgBSAD+DygAgAhUBDQDHAAUADIPUgCAAGZoiAFIAP4PSAAAAXwBAgGQDz4BSAFGASQAaWjEASQA/wcUAAAO/AEEBCUE9QckBCQEAAB2aIABSAD+BwgA4g9SAVoB+g9WAVIJ8gcAAH9oiAFIAP4HSAAAAX4BagFqAeoHagF+AQABgWhMCWAJEgVYA0IDMg8OAUIDQgU+BQwJMAmFaBABkAD8D5AAoATYA6wCqALoC6gK6AeAApNoCAOIAP4PSAAAAFQBRAHGD3QBRAFEAQAAnWgAACAA/A8CAPgDAACoBq4AlA+0AKwCpASiaIQBRAD+DyQABADxB1YBUAFeAVAF9gcAAKZoAAASCYoEXwRGBWoCSAJKAd8ARgAKABAAp2iIAUgA/gcoACAAqge+BKoEqgS6BKIHAACoaEAIKgkaBX4FGQOqDwABHgNABUAFfwkACa1ogANIAP4PSABAClgJHgXKBpgGngmoCAAIr2iIAUgA/g9IAAAE6gSsAvgPqACuBLgDAACwaAADiAD/D0gAgAzoA4gA6A/+BAgH6gggBLNogAFIAP4PSAAADLQDLACnDyQAtA8gBAAAtWgAADQIDATeA0wBVAFAAkwA3gcMCBQIJAa2aIgDSAD/D0gAAA/+AAoCqgLqB0oJTgkABMBoCAGIAP4PQAAQBQgFJASiBAwGkAVQBAAAxGhECVQF1AXMA8wB7g/MAcwDzAPMBVQFVAnJaIQDRAD/DyQAQACeB6oAqgDrD6oAvgSAA8toiAFIAP4PaABACQgF/gVYAVgB/gEIDQAAzWiQA1AA/g9QAAAA/A9UCVQA1Ad8CQAFAADSaIgBSAD+D0gAAABsAjwCrg+sAjwCbAKgANVohAFEAP8PZABMBkQBVATXB1QARAFMAgAA2miAA0gA/g8ABP4Dkgj+BwAM/gOSCP4HAADfaIgBSAD/D0gAAAT8BKwCrAH+D6wBrAL8BOBoAAgYCQoFfAVYA94PWANYA34FCgUYCQAA42gIA4gA/g9IAIAIFAZUAP4PVABUBXwFEAjuaAAApASUAtQPjAKMBD4EjALUD5QBpAKABPVoAADEASQA/w8kAAAD3wD1B/8H1QBfA0AC+miIAUgA/gdAABwA/Af0B1YFVAVkBQwHAAAFaYgDSAD+DwgAIAC0B6wCrgssCOQHIAAAAA1pyAAoAP8HCADgDwQE/AVcBV4FXAX8BQQEDmmIAUgA/g8AADAA/A+qBKgE/geoBKgEAAASaYABSAD+DwgAIA3+AygIgAkcBOQDdAYMCBxpkANQAP4PEADwCTgJNAXyAzQDOAX4CRAIMGmAA0gA/g8AAPwDVAL8DwAA/g8CAP4DAABKaRADkAD8D5AAAAj8B9QB1AXUA9QJ/AcAAFNpgAFIAP4DAAz+A0IAqgT6B6oEQgT+AwAMWmkAAFQITAZeA1QEwA9UCUwJXglMCNQIAAheaQADiAD+D0AAHAhUBNwDVAFcCVQJXAdAAGNpwAEkAP8PFACAA38A5Q9VBVcFVQX1DwcAbWkICWoFbAV4A24B6A9oAX4DbAVqBQgJAAB1aYgDSAD/DwgA4gmiCO4I+gtCCJIJcgoAAHxpgAFIAP4PKACICKoKmAfeBJgGqgWqCAAAfWkAAKQEpASAAvwB1gfUAfwBgAKsBKIEAACCaQADiAD+DwAA/AdUAnwJIATEA3wPRAhEBIZpgAFIAP4PCADwB7gC9A8WANYDBAjoBwgAnGmIAUgA/g8IAEAIXAbcAVYJVAlUCVQHAACuaQAE4gTsBK4CogCgD7IAqAKmAqgEogQAALRpAAOIAP4PyAAAALwPogqQCqQPnAqECrwPy2kAAMgDKAD/DwAA/A++ArwC/AO+CvwHEALNacgAKAD/BygACAboAXwHewV8BXQFdAcAANBpgAFIAP4PCAB8AFQIVgf8ANQHVAl8CwAI2GkIA4gA/g+IAAAEVgVUAPwPVAJWBVQFAAD9aYgDSAD+D0gAegDaD/8K2gr/CtoK+g8AAAJqwATsBNoCwAK8ANYH1gD8AogC9gTgBAAAEWqIB0gA/w9IAYQBJgkMDbgPDgF+BRAJAAATaoABSAD+D2gAAAh8C3wL/AV+BXwHfAl8CRlqiANIAP8PSAAcBWwBfAlsD3wBbAV8BQAFHmoAA5AA/g8AAPwHBAn0CtQLVAm0CoQLAAAfaoABUAD+D1AAAAL0AvwC9g/0AvQC9AIQAiFqgAFIAP4PaAAACXQFdgP0AXQDdgV0BQQJI2qEAUQA/w9EAAANKwOqCD4HagIrBaIMAAApajgDuAD8B7gAKACAAOwHuAeoB6gHqAcAACpqiAFIAP8PSAAICPoJXwVaBfoBXwVaBfoJMWqIA0gA/g8AAF4JOguODRwFQgV6C0IJXgk5agADiAD/D8gA4Ai0Cr4M9AYABJAA/g8QAEtqkANQAP4PEAAyD7IA8gf+BfIH0QCwDyAAX2qIA0gA/w9AAOYMuAO0Ct8IpAe4CrQIoARhaoABSAD+D0gACAS4BWwD7gq8CawHrAE4AmtqiAFIAP8PSAASCPIFfwV6BfoBfwVyBfIJlGqIA0gA/w9AABoH/AXYBd4H2AX+BYgHAACiaoABSAD+DwgA2Ay4AvQEFgDEDKgC6AQACMNqgAFIAP4HAAD+BwIE/gX+Bf4F/gX+BRIE+2qAA0gA/g8IAH4JLgv+DQAFXgUuC14JAAAEa4ABSAD+DwAA/gfuBOYD8A/mA+4M/gcAAAprCAOIAP4PiAEwAdQPNg+ADzYPVA90CQAAIGtACDAIDAQKAogBeACIAQgCSAQ4CAgIAAAhawAABAaEAQgIYAgeBAoD6AAIA0gEOAQACCJrFAQkAsQBPAMECDAEDgPoAAgDKAQYCAAAI2sABPwDFAAUAPIHAgAwDA4D6AAIATgGCAgnawAA/A8EBaQE1AQEDWAMHgf4AAgDeAwICDJriADED6IEkASSBOQHsAwOA/gACAM4BAAIOmsAAAgJ/AVYAfwFAAEwDA4D6AAIAzgMCAA9a1AIWAtUCPIHVA0ACDAEDgPoAAgDOAQICD5rAASqAqoIrweqAKICMAgOBugBCAM4DAgIR2sAAf4HqgSqBaoIvgcAABwOygEIAjgMAABJayQErQL+B/wDrgH9BDgMBwPkAAwDBAQAAExrgAC8B6wFvAeECLwHsAgOBvgBCAN4DAAAUGsAAP4DggTaBaoE2gUADBAD7gAIAygMGABTayAB7A+sB7gHqAfgDGAEHAPwARAC8AwAAGFrAAG6D7sHgAe7B5oHMAAPDuQBBAN8DAAAYmsABAAE8AcABAAEAAT+ByAEIAQgBCAEAABjawAEBATkBwQEBAQEBPwHRAREBEQERAQABGRrAAjwDwAIAAj+ByAEAAD+ByAIIAgQCBAGZWsgCCALvAigCCAIIAT+ByQCJAKkAaQAIABmawAAEAjUBxQE1AeUBBAE/gAQBxQIFAgQBmdrAAjwBwAE/gcgAggKaAioBT4CKAXoBAgIaWugAKAFfAhgCCAFIAX+BCQCpAEkAKQAIAFqayQIpAikDpQIlAi8CIQPlAqUCqQKpAoACG9rEADQBxwE0AWQBd4FngW0BRQE9AfwBxAAcmsIDOgDKABsC+gHaAIuCXwErAO8BKgIKAZzaxAO0AFQBNwC0A/QAF4J9AxUA3QFVAkQBHRrAAz8AwQIVAh0DxQIhA9UCvQKNArUCAAAd2sADPwDBAhsCPwObAgED2wK/ApsCqQIAAB4awAIfAdUBNYHPAVAADwHvAD8D7wAqAcAAHlrAACEAEQIJARUBJwCFAGUAHQAFAAEAAAAe2sAAMQIZAScBhQB9AAEAPwHRAgkCDQIJAZ8a8AAIgieBBID8gAAAEQARAD+D0IAQgBAAIprgABiCB4GkgFyBBAETgPIAP4PSAFIAkAEi2uAAOIIngSSA3IAAAioBP8EaANlBVUJQASWa0AAYgxeApIBcADkDwQE/AVuBWwF/AUEBJhrgABiCF4GkgFyCAIJqAUvBxgFXQsVC6AItGsAAPwPFAXkBBQNQAzeCEIHQgb+CWAIGAi1awAAAAL8D1ICUgIRCUAI3gVCAl4FoAgYCLdrAAz+A1UJVQk9B0AA4AheB0IG/gVgCAAAumsAAFIGVAHMD1MBAAjeBEIFQgJ+BeAEGAi8awAAbAxsA+4A7AcEAmAI3gRCA14DwAQACL9rAAf/APUOpQD1AqcEAASvAqECLwHoAgAEwGsAAHwJUglAB1QFPA1ACH4JQgb+CWAIAADBawAA/ATSBMAH1AQ8AkAI/gVCAv4FYAgAAMVrAABUATQL1goUB8QCEAjOBUIC3gVQCAAAy2sAACAA4Ak8BSQDpAF8CSQJJAf8ASABAADNawAAIADwAy4CogKqAqoKIgoiDv4DIAIAAM5rAABIAMQHcwJKAsoDegpKCkoO+gNCAkAAz2vAAMgC6AOmApQDlAPUA5QKlAr0B8QCwADSayABIgHqB2oFagX/B2oFag1qDeoHIgUAAdNrEAD4B7YFlAz0BwAAtA8sAKYPJAC0ByAI1GsAAAAA/g8gBCAEAAD+B0AIIAgQCBAHAADVawAAQAF+AUgBKAGADz4BSAFIAUQBJAEAANlrAABACn4L5AdkBVQDXgDkB2QKZAlQCUAE22sAACgBKAEoASQB/AckCaQIkgiSCJAIgAbrawAAxAT8BewF7APuB+wL7ArsCnwKxAoAAO9rJAEkAfwHkgiCCCgKZAoQCc4JEArMCgAED2wAAAAI/AckBCIEIgR+AKIDIgQhCCIIIAYRbAAAAAj8B6QEpASkBOQEpAGkBrwIgAgABhNsCAD4AQoCCAIACP4PkgiSBPIBkgaeCAAEFGwgABgARgBVAFQAVABUAFQA1AMUBAQIAAQXbAAIWAlGBVQCVALUBdQEVADUAxQMBAgABBtsEAAYCYQFIwMqCSoJqgeqACoB6gMKDAAGImwIAKgEtgW+BXwHfAW8BbwFHAD8AwQMAAYjbBAAGAlEBSMBqg8qASoBag0qAOoHAggABidsEADIAsQC3gLcD9wC3ALcAhwA/AcECAAGNGwAABAEEAKQAXAIAAj+ByAAwAAgARgC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AAF/BNUH9wTdB4AErgelBKQHBATubwAAEgakASAA/g9jBXgD7gF+BXgFKgkAAP5vAACBB0EAAAP+DPoBXgXrB1sHUwH3AwAEEXAQACQPJACABbwE/A68DLwO/AK8BLwJgAIfcBEEpgMAAAIAEwy6AzoD+A86AbsHugO6DyxwEAyiA4QANgZUAf4HJgHyBG4FagH6BQAETHAAACIIRAYEA3QO1A82D4QPdg9UD3QPAABRcAAAIgasAQAE6gPqB/oF4gHqA/oF6gUABGNwEAAmD0AAFwJNA6ADnAO2C/oLXAcSAkAAa3AACGAIGAQAAoABfgCAAQACQAQ4CAAIAABtcAAAAghCBDIEAgLCAT4AwgACA2ICEgQABG9wQAhwBAAC/gEQAgQABAgECPwHBAAEAAAAcHAEAoQBdAAOCOQEJAIEAfQABAFkAiQMAAB1cAAIAAmqCCoEKgKqASoCKgQqBb4IAAgAAHZwcAQADv4BAAEYBQAEIAQgBP4HIAQgBCAEfXAACAwJ0gQABAgD1gACAwgEDAXSCAAIAAB+cAAAmAiICGgECAIKAewACAMIBMgEGAgAAH9wOAgABv4BAAMIAPAHAAQABP4HAAQABPgPiXBwCAAG/gEAAjgIAgzyA5IAkgCSAPIBAACOcAAAQAgoCaQEIAQYA8YBGAIgBKQFJAhACJJwQAAwDv4BAAEYCkAIOAQABP4CAAKYASAAlXA4CAAG/gEQAgAI6AcqACoA6AcICAgGAACrcDgIAAb+AQADCABIBGgG2gVIBCgHCAQAAK1wAAzsAygIqAmoBC4GqAEoAigEKAmsCCAIrnBwCAAE/AMwBgAA+AcuCSgJ6AsICvgJAASzcBgIAAb+AQACGADgDxQAnAF8AJQJFAj0B7hwcAgADv4BAAIoBDAADgD4DygBKAEoAQgAuXAAAAAM4AKgAKAGvgCkAqQEpADkAgQEAAC6cAABiAyKAsoAuAasAKoCqAi4CuAIgAcAALxwOAgABv4BCAEQBHQDXgj0D0QARANEBAAAwXB4CAAG/gEIAxAAPAekACQI9A8kAKIDIATCcHgIAAb+AQABGAEABJYEkASYBJYEEAQAAMhwIAkSBw4DygBqDBoAAAR8CQABAAX+BQAIz3AACAAM/AFUAVQFVAFWBVQBVAtcCUAHAADYcDgIAAb+ARACgAiIBP4CiACIAP4CiAwACNtwQAgwBv4BEAYABPgIiAj+B4gE+AYACAAA33B4CAAO/gEQAP4PAgQiBfoEogUCBP4PAADkcPAIAAz8AwAEEAUAAagD/AqoCrgKqAYkAOZwIAQYBAAD/wAIAwAI+QQJAu8BCQT5BQAI53B4CAAG/gEAApAIhASmA7wAtA/ECKQIgATrcAAIighiChQJAAQqA1oELgSaCIoKeAgAAO1wAAAkBCQDfwAUBoAAZAA/BwQAfAKABkAICXEAABAIFAT0AVQJXANcAVwDXAlcCRQHAAAVcSAIEA7+ARACgAj4BJYC9AGcAvQEgAgAABpxAAAkChQLvgQMBKQDMAIMBH4FDAUUCCAEIXEoCCgN/gElAfwNJAH8BSQJ/AEkBSAIAAAmcRAIEAz4AV4BWA1YAfwBWg1YAVgBCA0ACDBxeAgABv4BAAI4ANAPSAUGBUQEXAXEDwAANnGICKgGbgJuABQFDAGAAGgGHgBoAooOgAg8cUAIOAQAAv4BEAikBPQDpgCkD/QIpAgABExxeAgABv4BAAKQCPwK1ArWD9QK1Ar8CAAATnEECfwEXQReAVwN/AAEAHYMBQH8AQQMAABVcQAAAAj+BLIAzgK6DAAA/gQSCRIDng8ACFlx8AgADPwDIAj0CpQK/AqUDvwKlAr0CgAAXnEAABgJVgVUAVwN9AEAABwN6gjIAjgFCAlkcTgEAAb+AQABEASEBL4CrAHsB74BhAIABGdxAAj8DZQAlADsDBQAzAFEBVQJVAHMDQAIaXE4CAAG/AEQAgAI/AusCqwCrAasBvwLAAhucQAAMA40APQBdAV+AXQFdAV4AfQBEgwAAH1xAAAQDv4BEA78A6wEbADqB6oEagL6DwAAhHE8CAAG/wEIAgAM/gCqBqsIqgqqAP4GAASKcQQEfAc/ALwAvgb8AAACZwSqAIkCRAwAAJRxGAAgDP4DEAQkAZQPRAkmCUQJlA8kAQAAmXEABAAG/gCSAO4GugAAAH4GkgSSAJ4CQASfcQQIvAy8Af4BvAwYAIgFfggIAPgEAAmAAKxxAAGcCHwEXgFcDdwAEAAIBb4MyAC4BAgJsXEAAEwJXAXOAVwNLAEIAZgMfggIAPgFgAjDcTgIAAb+AQgJMASuAHQODADIDj4AaA6KAMhxGAQAB/4AKAFSBLoFugS1BLYH+gUYBCgA0nEYCCAG/gEQAgwI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/g8SAPIDAABOc1AJPgUYBX8FEAO0AToDHwPaA3YFEgUQCWhzAACUC0gI8AdMAPQFfAX0B3wN9Az8BwAAcnMAAJYJWAjmBwAA9An+C/QF/AX+C5QJBAh1cwAAMgmMCPIH5A/aC9AAvg/SCZAO/gwAAHhzAAD+B/oF/gX0BeoPBgwQA/4AkAMWDAAAe3PQDygAvg/+B+wP3AcADBAO/gEQAxQMAACEcwgIKAhICKgGGAWOBEgEKAUoBggECAgAAIdzgAK0AgQClALsAqYOlALEAhQClAKEAgAAiXMACEQIRAhECEQI/A9ECEQJRAlECgAIAACLcwAERAREBEQERAT8B0QERAREBEQEAAQAAJFzAAAkBCQC/AMkAgAI/AcEAAQA/AcACAAGm3MABiQC/AMkAQAABAF0AUQBRAl8DMADAACpcwQEJAL8AyQKAAkkBOQDJADkDyQIJAggBqtzBAIkAvwDJAEECTAEbgSIA4gCeAQICAAIr3MABCQC/AMkAoAAxAAkAPwPBABkAIQAAACwcwQEJAL8AyQCAAj+BAIC+gECB34IAAgABrJzAAIkAvwBJAEAADAASAJUAkYNyAhQABAAu3MABCQC/AMkAAAM+APICX4GSAbICRgIAADCcwAEJAT8AyQCAAD0AxQB9AkECPwHBAAAAMpzAAAkBPwDBAJACP4HQgD+B/wPQgD+D0AAzXMEAiQC/AMkARABSAgkBZIExARIAhABAADgcwQEJAL8AyQCAABcBkgB/g9IAUgCQAQAAO1zAABEBPwHRAQAAvAIAAT+AwAI/A9ECAQI8nMAACQE/AMgAgwAjAL0ApQC1A+UApQCAAL+cyQEJAL8AyQKAAj8BVQDVAFUD1QJ/AkABAN0AAIkAvwDJAEMA2gCCAj+B4gACgNqBAAEBnQABCQC/AMkAgAJfAhUCdQP/A9UCVQJfAkJdAAEJAL8AyQCAAi0BywApg8kALQHJAgAABB0AAQkAvwDJAIACPQJFAQQAt4BEAQUCPQLInQABCQC/AMkAoAA1ALUCbwIxAdkAJQDAAQmdAACJAL8ASQBAAC0B7QCrAMuCPQPNAAAACp0AAQkAvwDJAIACAgF/gVYAVgB/gUIBQAIM3QAACQC/AEgA4gA/g9IAAADyAD+D0gAiAM0dAAAWgBaAV4BegFaAVgBegVeA1oBWgCQADx0AAhEBPwH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8gMAAFIBfgJTAlIN0gASADB4hAD0DywE5AcAALQAhAD8D4QAtACAAAAAMniCAPoHJgQiBPIDOAecCJgI+AgICPgJAAQ0eIQA9A8sBOQDAAz4A8gISAl+BkgHyAgYCDh4AACEAPQPLATAA/wP5AgUCPQLFAj0CQAAQHiEAPQPLATkBwAAvAcgBCAE/gcgBDwEgA9VeAAAQgD6BxYC8gMACPoECgLuAQoE+gUABF14AAAEAfQPTASED/AHHABQAV4BEAn0DwAAa3gAAIQA9AcsBOQHAAC0DywApg8kALQPIARseIQA/A8kBOQHAAD8CKwKrAb8BawIrAj8CG54hAD0DywExAcQAPgPVgH0D1wBVAnwBwAAjHiCAPoHJgIiAuIDAABqAioJ6g8qAb4CoASNeIIA+gcmAiIC4gMAAV8DVQNVCdUPXwEAAY54hAD0DywE5AcAAGQBFAEkAcYPNAEkAUQBkXiEAPQHLAIkAuQDfADUAX4BVAHUB3wBAAGXeIQA9AcsBOAHxAA0DKQDRgD0BxQI9AkABJ94hAD0D0wEwAcIAHwNSAP8D2gDfAVICQAAp3gAAMoE6gL+D+oKgAr8CtQK1grUDvwAAACpeAAAhAD8ByQC5AsACPwHrAKsAqwG/A8ACLB4hAD8DyQE4AeIAA4J/A8ICPwPCgjICQAAs3iEAPwHJALkAwAIrAdoAC4NqAMoBKwJIAC6eIQA9A9MBMQHTADkD1wJVgn0D1QJVAlMCbx4AACCAP4HIgLAB34DqgSqAP4GqgGCDwAAwXiEAfwPJATkAwwIaA+OCOgOSAioD84IKA7KeAAAUgLSB3oFbgVqB2oC6gdqBXoFQgdAANB4UAVQBTwDVA8WC3wLCAtmC1ILvg+YAYAB1XgAAEQA9A8sBOADyA/8D84IzA/sCMgPAAjaeIQB9A8sBCQExAf8AtwG3A7+CtwP/AIEA+h4AA78AQQEtAS0DrQLlgqECrQKtAq0DpQA9HhEAPQPLATEByAAmgnaD9YI1gyaCiAIAAAOeYQA/AckAsQLFAhMBF4H0A9MCV4JVAkQCBl5AAAEAfwD5AsOCFQH1AFACAwH7A8sCWQAOnkAACAEJAKkASQIJAjkDyQAJACkASQCIAQ8eQAAiAGKAO4PWACIAQAA/gcACAAIAAgABj55AAAIAYgAzg+4AAgJIAggCP4PIAggCCAIQXkAAIgASgDsD1gAiAAAAPwPBAB0AowBAABCeQABiADKD3gAiAAgAPwHIAj+CRAI+AgABkh5CAGIAM4PeACICQAE/AMkACIA4g8iACAASXkIAYgA7g9YAIgIAAjwDwAI/g8gCCAIAAhQeYgAiADuD1gACAGAAPgPTgRIBEgEyA8AAFV5iACIAM4PfAAICOAMAALyB8QIMAhsBoAAVnkIAYgAyg+4AAAI/A8kCSQJJAkkCfwPAAhdeYgBSADuD1gAgAg8BCQD5AAkAOQPPAgABl55iAGIAO4PXACAAPgDKAEoAf4PKAH4AQAAX3kAAIAElgS0ArQAvge0ALQCtAKWBIAEAABleQgBiADOD3gACABAAUoBSgH4D0oBSgEIAWh5BAl0BdQF1AH8CdQJ1Af8AdQF1AV0DQQJbXkQABABmAhuBEwBdAlICUYPWAFkA1QDjAx3eQgBiADKD7gAAARUAtQBfgNUCVQPRAEAAHh5CAGKAOoPmAAAANwPVAH0AFQLVAjcDwAAenkIAYgA6g9YAEAICAn+BVgBWAH+BQgJAACAeQAABAr8C4wD/AvcC94P/AOMB/wHBAoAAIF5AAAUCUwFXgFMCUQJUA9MAV4FDAU0CSAAhHmIAIgAzg98AAgAQgQqAioJ6gcqAb4CoASFeYQARADmD1wABAHwAaoB+AesAaoB+AEAAI15gACIAOwPGADAD3wAxAf0AtQDVAj8BwAAj3mIAEgA7gdYAIIA+g9qBWoF6gdqBXoFwgemeQAAJAWzBYAF6wH+AdoHgAG+A4IDPgUABad5AAGKAOoPkAAEAHwP3AteC1wL3At8DwQBqnnEACQA9Q8tAEAC/wKtAv8PqgKtAv8CAAKueYgBSgDqD5gAAAj+C/8K6gr/CuoK/gsACLF5AAGKAOoPkADED/wF/Af+BvwC/A/cAgAAuXkAAIQPvACsBKwE/AesBKwCrAq6CIIHAAC6eQAAgA/8ANQC1AL8A9QC1ALUCPwIgA8AALt5BAAED3QBZAVkB9YFVAVUA0QJdAkEBwQAvXkQAAgP6AHEAZQFsge6BbIHhAnoDwgAAAC+eSAEJAIkAaQAZAD8D2IAogAiASICIAQAAL95AACQCFQIVAQ0A3wANAA0B1IIUgiQBIAAwHmICEwILAScA4wAvACKCpoJKglKB0gAAADBeQACkgFSAP4PUgBSBAAH+AQGBMAEAA8ACMN5AABQCFQIVAQ0A7wAlAA0B1IIVAhQBgAAyXkAACgEugS6AroBugH+D7oBugL5AigEAADLeQAAkgNSAP4PUgAACDgEgAN+AIADMAQICM15lANSAP4PUgACAPgBiACIAP4PiACIAPgB0XkAAJQDUgD+D1IAEAFCAUwBAAH+DwABAAHSeQAAlAFSAP4PEgCACDgEgAR+AgAB2AAAANh5EgOSAP4PUgCACWAE+geCCGAIHgjgBgAA33kUA5QA/A9UAJQJAAj8DyQJJAn8DwAIAADkeQAAFAOUAPwPkACEALQAhAD8D4QAtACEAOZ5IAGsCGwErAO8A64PbAEsA2wErAggAQAA6XmUA1QA/A9SAJIIEAROAkgB/gBIA0gEQAjveQAAlANUAPwPUgAACHwGRAFEAEQBfA4ACPB5kgNSAP4PUgCSAhACzwEECPwPBADsAQQC+3kAAJQBVAD8D1IAAgmoBKwEVgV0AswBQAAAehADkgD+DxIAAAHqB6wAvACkD6wAqgSoAwV6EgOSAP4PQgAICPQEkgOQAJIP5AgICBAEC3oAABgDmAD8DwABPAikCqQKpA+kCrwKAAgNepIBUgD+D1IAAADyB1QBUAFeAVAF9gcAAA56AACUA1IA/g8CADgMygNIAMwPTgh6CAAGGnoAAJQBVAD8D1IAEAD+D6gE/AeqBKgEAAAjehAA+AVWBfQFXAX0BiAHpAD8D6QAIgcAAC56AADKASoA/wMACP4Krgr+D64K/QoACAAAMXoUA5IA/g+SAAAC6A+kAqQC6gOiCroK4gcyehQDkgD+D1IAEgDADxIAwg9aBUIF2g8AADN6JAIkAfwPogAABlgAVgVWC1QJXAHwBQAIN3qUA1QA/A9SAAAJfgmWBdYGvgZWBVYIXgA7eooBSgD+D0kAAADKB6oEgQQtBKEE7QcAADx6FAOUAPwPUgBABVwFtAJ2CbQG1ABcA0AEPXoUA5IA/geSABAAdAesB64HtAe2B5YHVAA/eooDSgD+D0kAgA9eAFYPVgVXB14Awg8CAEJ6FAOSAP4PUgCABnwArAysCf4KrAKsBvwIRnoSA5IA/g9SAIAIvAwsBSwF7gYsArwCgABMehAM+AFWDfQBXA3wAgQGpAH8D6QAIgcAAk16mAFYAPwHVAAQBPwF/AX+AfwB/AX8BRAETnoABM4C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SAduANAPTADgCggIOATIAg4DyAQ4BAgIDX1IB24A0A9MAAAB+A8IAcgAPgDICPgHAAAQfRAOnADyDsgAgAIECEQM/AtECPwPQAgAABR9SAduANAPTAEAAOgDCAEIAf4HBAnkCQAEGX1IB3YA0A9MAGQBAAT+ByIE/gEiBiEMAAAafUgHWAD2D2AAQAsEB/wAhAQkBTwD4AQgCBt9SAd2ANAPTAAAC3AITgbAAUIITgjQByAAIH0gACoJagVqA+oL/wlqByoBqgWqCSALIAghfUgHfgDQD0wAxAoACAgH+AAuCCgI6AcIACJ9AAA0CBQFVAX0AV4JVA80AbQFFAU0CQAAJ30ACB4JgAXeAcAJogmSD14BUgUeBSIJIAArfRAJHAlQBV4FtAGQD04BFAWUBRIJCAoAAC99AAAACD4FagXqAX4Jag8qAaoFPgUACAAIMH1IB3YA0A9MAcAA/A9EBEQE/AdEBEQE/A85fUgHbgDQD0wAAAMgAKIPngSCBKIEng8AAEJ9SAduANAPTACAAogATgQ1BTQFTAlAAAAAQ30QDtwAsgZIAEAHSABoBloFzAQoBggMAABEfUgHbgDQD0wAAAMACPwPJAkkCSQJ/A8ACEx9SAduANAPTAAAA0IIJgkqCZIPKgkmCUAIUH1IB24A0A9MAKADBACkD6QEvwSkBKQPJABVfbAN7ACiBJgCAAD0BzQJLAnkCTQJLAngBV59SAd4ANYPUAAACygImAQYA84DCAQoCCgAYX1IB24A0A/MAMQDkADID9YEpATcBEQPgABmfUgHbgDQD2wBIACQD4wEogSkBIgEkA8gAG59AAAsCCwFlgHUCcwJgA9eAVIFEgUeCQAAcX1ID3YA0Q9MAAAJBAS8AycALAC8DwQIAARyfQAAkA78AJIGSAIAAFgDdgjQD0wA4AIABHV9SAd2ANAPTAAACxAIiAamBaQEiAawDBAAdn1IB24A0A9MAQAA+AeWCJYI/AicCJQI8AaTfZAMvAHiDNgAAAo6CEIJEgnqD4IJPglGCJl9QAduANAPTAAAAf4PAASoBP4FoAQsBQAEmn0AAEgHfgDQD6wDgAlUBFQDXgBUBtQIBAScfTAO7ACiDJgCAACMDKQCpwCkD6QArAKADKB9MA7sAKICmAQABNoCVAjUD3QATAKABAAArX1IB24A0A9MAEADEAD+D6gE/AeqBKgEAACxfU4HcADsD0AB/A/sA+QDJAKsCyQI/AcAALJ9SAd4ANYPgAL8DwwAvAPkBLQEBAD8DwAAv31IB24A0A9sAQAAvgeqAKoA6w+qAL4EgAPKfQABPgUuBb4F7gGuB6IBWgMaAyYFQgUAAM99SAd2ANAPTAAAAV4EQAD8D2QJcQhGA4gE0X1IB24A0A9MAAAFIASqAioI6gc+AaAGAADSfUgDdgDQD0wA4AOEAJQHfgVUBVwF1gcQANp9SAduANAPzADABZwCrAksCO4PLAO8BAAE4H1IB3gA1g9IAQgAoAeUAJwA1g+cALQHAADjfSAIvAziAtgCgAQgBH4DtAq0B7wBIAYAAOh9SAduANAPTAAAD/wHrAKsD6wCrA+8AoQP6X1IB24A0A9MAEAJFARcA/QJ1AbSBtwFVAjvfUgHWAD2D2ACAAT0BbwHtgW0D7wF8AUABPR9SAd4ANYPSAAAAvwErAKsAf4PrAH8AgQE+32QDtwAsgTAAZwE1AeUBAQA8AwOA/gEAAgBfkgHXgDwD2wAgAIgBGoDqgpqB74AIAcAAAR+RANfAOgPJgAAAfwHvAK8AvwHvAq8CvwNI35AAnwBfAD8B/wASAIYAXwE1ANUANACgAAmfkgHbgDQD8wAQAL2D5gHFgTwD5YIEAgAACt+EA7eAHEEbAMBCHYG4AksCLsK+wsmCgAILn5AB34A0A9MAUAA7A8EANYHdAVUBdQHAAAxfhAO3gCxDMwCAAD3DwAEzgMBBOgHhgiYCD1+kA7cALIMiAIADPwChAaWCaQLhAD8BgAAPn5IB24A0A9MAAAK/Aj8Bf4F/AH8BfwJEAhBfgAIMAq+CjwL/AM8D4gCXgZkB1wKhAoAAEp+QAdOAPAP7AHAB/QHHgT0A5AG/geQDBYCVH6gAy4A8Ae8ABAA/Ae2AtgPPwPQBBYOAABefpAO3ACyBIgCAAiqCeoHrwEKD+oJqgmABWp+AAd4AJQGUgEIADQH8gX6BdIF9AX0BwQAa34AAH4Kfgd/B/4PfgsYB/YC0gp+CpgKgAhwfkgHbgDQD0wBAATwAt4B+gfqAdYC8AQAAHN+kA7cALICCAk+DOsD6wm+BzQMiwN4DAAAfH4QDtwAsgZIAv4PNAi6DzgJPgisDxALAAiMfpgO9gCRBkgBEgjuB/4H7wP+A+4H+gcACI9+gA7cAKIGWAEADPwD9An+C/4O/Av8C4QJln5QB3wAagIACXYE9QcQBPYPMAT+B9AMFgKgfqAEsAVsBSIFkAQAAPwBAAEAAQAB/g8AAKJ+AAAwCewEogSYBgAABAQEBPwHBAQEBAQEpH4AADAJqAVmBRAFQABEAEQA/A9EAEIAQACmfqAEuAXkBJIEgAIwAI4AiAgICQgM+AMAAKd+IAW4BeYEkAIQDIQDfAiEBTQCrAVgCAAIqn4AACAFuAVmBRAFAADEB0QIRAhECPwIAAasfiAFuAVmBRAEAAKoAKgA/g+oAKgEiAMAAK9+IAW4BWcFEAUABPQBBAEEAf8HBAn0DQQEsX4AADAF6AWmBJACAAh4CAAE/gQAApgBIACyfgAAmAXXBLEEAAD+DwIAsgHaAQII/g8AALN+AAAwBc4FIgUAAPAPEAPwAJ4IEAjwDwAAtX4AADAF7AWiBJAAAA7+AQAMAAP+AAAHAAi3fgAAIAW4BWYFAAFgCFgExANACEYI2AdgALh+IAW4BWYFMAUAAPwPRAhEBPwBRAZCCEAGuX4AADAF7ASiApgKAAg4BMoCDgPoBBgECAi6fgAAMAWsBWIFGAEACAgH+ABOCEgIyAcIAL1+AAAwCawFYwUYAQIIQgz+C0IIQg7+CQAIv34AALgF5ASSAoAKEAhQBH4EyAMqBaoIAATDfrgE5ASyAgAAVAZ8AVYI9A9EAEQBBAYAAMR+AAAgBbgFZgUQAQAI/A8kCSQJ/A8ACAAAxX4AACAJuAVmBQAA+AMoASgB/g8oAfgBAADGfiAFsAVuBSIFAAD8D0QERAT8B0QE/A8AAMd+IAW4BOYEkAIACHwGRAFEAEQARAF8DgAIyH4AADAF6AWmBJAEEABIAlYEJAVUBUwIgADNfjAFnATyAogCIACiD5oEhgSiBKIEngcAAM9+IA24BeYEkAAACKQIpAiUD6wIpAggCAAA0X4AADgL5gmQAQAIKA3+AwAA/A8EAHwChAHSfiAAmATkArICCABABugBCAh+BIgHaggIBtN+MAXsBKICmAIAAKQHpASkBL8EpASkBwAA1X4gBbwE4gSYAgAIpASmA7wAtA/ECKQIAATYfjAF7AWiBIACIAiQDqwJpgSIBpAEoAgAANl+IAW4BOYCgAIgAKAPsA+uBKgEsA8gAEAA234gBLgFZgUSAkAAqAKoAq4ClA+sAqQCIALcfgAAMAXsBKICkAIQAEgPtgSkBLQETA9AAN1+IAWcBOIEmAQAAPgHlgiWCPQInAjwCAAG3n4gCbgFZgUQAUAIOAiYBQoCyAUoCEgIAADffiAFuAVmBZIEEAJACGgHXgBID2gISAhIBuJ+AAAgCbgFZAUAAOAPvAK0ArQKtAr8DwAA434wBawE4gSYAgAIrAScA4wAvACaCSoHAADlfjAF6ASmAqACCAhEBeQGagLCBVoMQAQAAOd+IAC4BeYEsAIAAPgHBASgBP4FYASsBQAA6X4wBZwE8gKYCgAI3AVcBF4DXABcBNwJEADqfgAAmAT2ApICAAJUANQHfgVUBVwF1AcSAO1+IAW4BOYEkAIAALQIFAUeA9QBFAVwBRAI7n4AALAF7ASiBDgAoAe0AqwCrgs0CNQHNADzfgAAsAVsBSIFAAD8A7QC9Ae0CrQK/AsAAPR+sATsBKICmAIgAPwPqgSoBPoHqASoBAAA9X4gAJgF1gSxAgAAvgeqAOsPqgCqBL4DAAD4fgAAsAXsBKICAAj8BwQA1Af0AgQJ/AcAAPx+AAAgBbgFZgUABRgAiAKqCKwPqACoAoAE/X4AADAF6AUkBQABKAyoAygE7g8oCSgJAAD/fgAAuAVkBRIFiABABCoCKgnqByoBvgKgBAV/AAC8BeIEmQIIAOIHEgTyB14F8gfyBwAABn8AANgCTgJ5AQAE7wQ/AqABKAMmBOwFBAQTfyAFvATjBJgCwAxUAvIJ1gbRBt0FVQgACBR/EAWsBWIFGAUAALQHnADWD5wAlAS0AwAAFX8AADgF5ASyBAgCoAiqC5gG3gSYB5oEqAgWfwAAuALkApIAAAb8AZQH1gPUB1QB3AcAABh/IAS8BWMFGQAABWwFawWqCqoHvgEgBiAEGX+QBNwCowKYAgIA6g9iBX4FfgViBeoPIAAafyAFsARuBSAFAAB4AXgFfAF4CfwP+AEAAR1/AADcBbMEiAAiCOAHBAivCuoLrgqiCgAIIH8AADgF5AUSAQAM/AN0CK4K/g+sCvwKAAgpfyABuATmAgACjADkDxQA1gd0BVQF1AcAADR/EAS8BOMCGAC+DOsD6gm+BzQMywN4DAAANn8AAFAASA9HBEQE/AdEBEQERARED0AAAAA4fwAAqAcmBPwDJAKkBwAABAT8BwQEBAQAADp/AACoByYE/AckBAQHwADIDv4ByAL4BMAIUH8QAAgH/gckBwQBNA/+DxQP5A8+DzQPBABRfwAA/A8EACQD5AAEBCQGxAE0CwQI/AcAAFV/AAAEAVQBVAFUAcQPTAFMAVQBVAEEAQAAV38AAB4JkghSCH4FUgZSAl4CUgHSAB4AAABafwAAngCyCLIPHgQSBBIA3gMSCBII3g8AAGJ/AABcCVQNVAtcCdQJVAlcCVQFVAVcCQAAaX8AABwC1APUA9wD9Af0A/wD9AP0AzwCAAJqfwACvAq0CrQG7AEUABQA7A+0ArQCvAIAAm5/IADcBzQENAT8B/QH9Af8B/QH9Ac8BAAEcH8gAP4H+gX6Bf4F+gcKAO4BCggKCO4PAAByfyABrgC6ALoHfgV6BXoFfgV6BfoHPgAgAHV/AAgOBPoA+gH+B/oA+gL+APoC+gSeAwAAd38AAFwI9Af0AfwKlAd0BrwKtAq0CrwKAACFfwAAbg3aAUoNDgVKAPoPrgqqCuoPrgqgCop/AAFIAUoBTAFIAfgPSAFMAUoBSAEAAQAAjn9ACFgJWglcBVgD+AFYA1wFWgVYCUAJAACefyABuAS4BHwEeAX4B3gFeAV8BfgHKAQAAKF/UARcApwCHgCcBVwEXANeAl4E3AVQBAAApH8AAagB+g+uBKoEvgcIAUoB+A9IAUsBAACofyAJLAyuAi4ILAn8BKwErAOuBKwIpAsACKl/QAPEC9QL1g/UA/wLVAlWB9YFVAtACQAEr38AACgBKg34Ay4BAAG+A2oEagVqCX4IwAe9fxQCJAEkCYQI/AcAABQCZAEECYQI/AcAAMF/SATEBFICWgrYDxAAWATaAlIKRArIDwgAxX8oCOgEPwPoBAAIkgqCCv4LCAhCDP4PAAjMf0QILAkkCQQNPAmACSwJLA1UCUQJfAkAANJ/QAAoAKQP5ArECvwKgAqsCqQKhA98AAAA1H8oCSoH+AGrAAECMAkCCP4HEAGCCP4HAADgfwACKgKuAq4C6gImD7ADZAKqAqoCLgIAAul/AAj8D+wH6g/qB/gOsgH+B5gB/g8AAAAA8H/8AqwCrg+sAvwCAAJYCvQPQgAUCvgHEAD5fwAJqAfsAQ4HbAkECZAL/AkACFQK/AkABPt/QADUD7IFvge6BZMHAAGSCP4HuAH+DwAA/H8AAAIL7gfuB+ID7gPgA+oD6gfiBw4LAAAAgAAE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tAK0Av4PtAK0CvQHEAC4hJIEkgZaADsBCg1qARoFOwlqAKIEEgkAALyEBAAkDOQD1g/wC+gL8AvUC/YL5A8kACAAxISQAJQAtAfWB9QH1Af0B/QH1gfUBtQAkADJhAAANAIUAVYPlAlUCVQJVAmWCVQPVAMAAcuEBABECNQO1grUDvQK0A7UCtYK1AxECUQA3YQEAAQIZA8OCWQPBAk8Dx4J1AmUDwQIAADmhEABRAX8BP4G/Ab8BvwG/gv8CvwGRAAAAOyEFAhUBMQHDgjkC9QLtAu0C7YLtAs0CkQA7oQACLQE8gMDBPoJWAtaC/4LXwtaC/oLAAIRhQQAdAzUA9YB9ArUCNQJ9gbUBtQI9AiABBOFAAjEC3wLfgv8D3wHfAf+B3wLfAvECQAIGoUED/QAVAzWAdQP8AEEBKQBJgj0DyQAAAAhhSQJpAiUBd4BtAmUCYQP9gHUBbQMFAkAACOFBAl0B0QB7g8EAFQFkAV0CVYJNA8UAQABLIUEBJQH9AeWBAQAVA90AFYPVgB0B3QIhAQ1hcQPNAD0D3YFdAd0BdQNfgSUB/QINAgABjqFBADEBxQAxgPUA9QD1APWB1QGFAT0AwAAPYUUANQPxAfuD8QD1A+ECO4EJAPkBSQIAABDhUACSgJKD+sLSgt4D0oLRgvnC1YPQgEAAkmFJAgkBvQAdgF0DXAB9AF0DXYBdAEUDQAAaYVECFQMBAKOAIQF9AXwA/QF9gP0CYQHBABthQAAJAh0B3YHcA/wB3QCdg90B3QHJA8EAHKFBADkAfQB5gf8AewBBAz+A0wAzA9EAAAAdIVCCmIJ0gpHBSINAgj6D6sPqg+qCfoPAgh+hQAAZAAsD+4LLAt4DywL7AuuCywPZAAAAISFJARMB0QAFgH0AfQD9AH+BfQH9AH0AQABh4UAATQBhA8GALQOsAC0DoQA3ggsB+QFIAibhQAA9A9UBVYFdAcEAJQC3gKUD9QClAKAAKaFBA70AbQItgP0C7QDtAv0A7YHtAv0BwQAqYUAAPoPOgDDDeoDKAiqCq4Kvw+qCqoKIAiqhQQEVAFcCd4HdAEEDPQDXgBUANQPVABAAKyFhACUCEQFBgX0A7QPtAH0AwYFRAWUCJQAr4UAAnQD1APWD/QP1A/QD/QP1g9UD3QBAACwhQIIig3+BdsB3gX+Ad4F/gXfAf4FigUAAMmFtAS0AvQPtgGUAgQA1A/+CtwK9ArUDwAAzYUAAPQE9Af2BfQH8AUEB1wFXgVUB1QEAADPhQAJdAdEAfQP9gO0BvQGHg/8BBQH1AgQBN2FBANcB1wH/gv8C5gLQAc2BxQHdAqEAkQA5IUEDPQDVAn2DwQBdAX0AH4PZAL0BWQJAADlhQAItAXkBQYF9AGwD7QB1AN+A2wFBAUAAOmFIgRqAwIBNwCyD/IKsgqzD6oK6g+iAAAA+4UCACoMSgMLBeIDvgN2D5cPdgO+BeIFAgUHhiQM5AF8Df4BdA3kBAACVAH2D0wBTAYEAAuGRABkC0QI7gVkAnAI9Av2CvQC9Ab0BwAILYYAAAAA/g//B/4C4AfAAv4D/wU+AP4HAABOhgAAAAzwAxAIUAd+AdQBtAeUCLQIsAQQAE+GAAAADPgDCAgoCT4HXAFcBUwJXA1YAwgAUIYAAMAPOACID6gKvgrcCtwKzArcCkgIKABRhgAAAA/wABAGUAB+BtQItAq0CJQCsAYAAFSGAAz4AwgIKAkoCz4NbAVsC0wLXAlYCQgAVYYADPgDCAuoBqgGPglcCNwL3AjcC1gKCABahgAAAA/wABAKUAh+DrQItA6UCLQKkAhQAFuGAACAD3AAEAtQCn4PVAi0DpQKtAowCAAAXoYAAAAM/AMECJQLfwe2A7YDtgfmBywKAABfhiAA7gSqBKoDJgbwARgMOANfAFoHSgQYAmeGAAz4AxgB3g+8D4wLGAjyAJIIkgiSBwAAa4YAAAAE+ASIBIgE/geIBIgEiAb4BAAIAAB5hgAA+ASIBP4D+AIABAQEBAT8BwQEBAQABH2GAAAACNwLVAlUCfQHVAVUBVQF3AUACAAIgIYgABQIyg8IBBgC8AiICIgE/geIBIgF+AeBhgAI+AmIBP4H+A4ACHgEggUMA+AEHAgACIqGAAD4Cf4Hjgf4BgAIGAjqDAoHiAN4BAgIjIYAAPgEiAT+B/gGAAQoASgB/g8kASQBAAGVhogASgjqCVoJTgnqB0oFSgVaB+oHSgxICMeGAAD4BP4HiATwBggA6AcKCYwIiAhYCAAGy4YAABIEygVKBVIF3gdWBVYFVgfWBRIIAADZhgAA+Az+B/4H+AYACCQJJAm/DyQJJAkgCNuGAAj4Bf4HiAT4BgAAXgZIAf4PSAFIAgAE7oYABBQE1AVEBVwFxgdEBVwFRAXUBRQIAAAAh0AAXAD0BXQFfAX0B3QFfAX0DTQI/AcAAAKHAAj4Cf4Hjgf4ClAASAVuBdQPbAVEBUAEHIcAABQEpAekBrQGtge0BqwGjAaUBxQIAAAhhwAA+ARIAv4DeAMABtQHXgVUBV4F1AcQAEeHAAD4CfgEjgf4BgAI/AO0AvQHtAr8DQAEZocACPgE/geIBHAC/g+SAg4IYAliB94IAAh0h/gJiAT+B4gEeACAB38CgA/+AxII/gcAAHaHAAj4Bf4H+AYAAHwNSAP8D2gDfAVICQAAgocACPgF/geIBnAE/AdWBTwC+A8EAPwDAACNhwQA/A/sBOwCfAmAB3gAiAj+B4gE+AYACJ6HAAD4BM4D/gNIAjABfgaqAv4BqgmCBwAAoocAAGIE6AfuBuQG4AfyBugG7gboB3QIAAi6hwAA+AmOB/4HiATwBR4J6g1+DyoBvgsACtGHAAj4Bf4H+AYACPQDdAN0A3YP9AMQAgAA8ocAAKALrAqsB6wHPgisA6wKvAesBqAHAAj5h4QEfAQ3Bb4FtgV4B8oHtgWyBboHNggAAPuHAAT8Av8DRAJ+ATsL2g9+A+oHKwdqCwAJDYgACPgF/gfwBnwPPAO8B+ADMAf+AAgDOAQfiAAA+An+B4gEcAImD3gLdAD6D1AEfgMADCGIAADUBdwFvge/BbcJPwCXBa0HrAWkBQAAIogAAKoFngX+B/4F/gn/AP4F/geeBaoHIAg7iCwAFwTeBUAFdgX/B34FcAVkBb8HNAgSAECIAAT4BwgECAT8BwoECAT4BwgECAT4BwAERogACCAJvAQkBLwApg98ASQCJAW8BCAIAABMiIgASADkDxIAAAAkACQAJAgkCOQPJAAgAE2IiABEAPMPCAAiDCIChAEgCCII4g8iAAAAU4hAAEQA8w8JAMgB/wcIAMMFEATyBxIAAABUiAAAzADyDxgAhgj1B5QEAAAkCOQPJAAAAFeIQABEAPIPGQJQAt4DVAJUBgAE8gcSAAAAWYgAAMgA5A8CAFQPfAV0B2QAJAAkCOQHIABbiAQAQgD5DwgA+gPfAtoH/gICAPIHEgAAAF2IAAAkAPIPCAB6CVoJ/gf6BQkEIADkDyAAYYgAAEQA8g8ICfgFrgP8A6wN+AEACOQPIABiiAAAjADgDxwAvAecB5gHvAe8BAAA5A8gAGOIgACIAEgIyA8oCBoEPATIAIgDSAQoCAAIZYgAAAgBigDqD5gASAEAAP4PIABAAMAAgABoiCABNAm0BLQHdAQ+BPQENAG0ArQEIAgAAGuICAGIAO4PnABIAQAIiARIBEQCMgIQAQAAbIgIAYgA7g+cAEgBAADQABAJEAj+BxAAAABwiBQBFAV8BVwH3AReBNwEXAFcA3wFFAUQBHeIAAAEAnQCVA5UCfYIVAlUAlQGdAkECQAAgYgAAhAC9AK0DrQJvgS0AbQCtAZ0BRAJAAiLiJACiAK8CoIOiAnICI4JmAKqBsoKygqoCI2IAAGMAOwPWAEAAPAHLAkoCegLCAr4CQAElogIAYgA6g/YAAAA+A+IBIgE/weIBIgE+A+ciAABigDqD9gAAARIAkgB/g9IAUgCSAQAAKuICAGIAMoPuAEADPgDyAhICX4GSAbICRgIrYiEAqQCpAqUDowJpgi8CdYC1gbUBcQFtAixiAABiADqD/AAIAD8DwIAEAf+AJADFgwAALSICAGIAOwPmAAAAKgAuAOsAqgKmAqoBqAAwYgAAVQL1AdeBFQBVAMQDP4CEAPSBBQIAAbCiNYC1gLeCq4OngnGBIABngLABsAF/gkACMWIoAKsApAKvA6ACagEqAG8AqgGqASoCAAAz4gABEQFfA18D3wJ/gl8A3wFfAV8C0QLAAjUiBQA1A90APQHbAVkBWYFzAbUAKQPJAAAANWICAGIAO4PWACIAAABxA+yCIgIsgjED4gB2IiABKwCrAqsDoQJ3gSEAaYCrgasBKQIAADZiAABiADrD9gAgAIqAeoHvgSqBKoEvgcIANyICAEIAc4PuAAAAOgPqAKoAv4PqAKqCuoH3YiQAr4CmAqYDr4JgASoBKgBvgKoBqgEiAjhiAgBiADsD9gAAAB8CVQJVAn8D1QJfAkAAOSIAAGKAOoP2AAADPwDRAC2ApQPlAKUAgAA84gAApwEhQK2DrQJ9gS0AbQCtgaFBJwIAAD4iAgBigDqD9AAgAT8BNQC1A/8D9QB/AKABPmIgAJEAnwBfAf8BP4EfAF8AnwCfAXEBAAA/YgIAr4CnAq+BpwF/ASAAZwCwAbABb4JAAQHiYAASADuB3gAAAU+Bf4FvAK8ArwFvAQEBBCJCAGJAMoPuAAAAb4HqgSqBaoGqgi+BwAAMokAAZQA1AewAAAE+APoA+wD+AfoA+gD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/AP0A/QFHAQAALiMAAAICOQL6gblBuQC5gLsBvYG9gcECAAIu4wACFQI3Av8B94H3APcA94H3Af8CxwIAAi8jAAI/A1UAVQB/AUAAIAPgAT/BJgEmA8YAL+MAAQQBPwF9APsA/AB9AHsA+QD1AUMBAAAwIwAABQIzAvmCvQK7ALgAv4K8gryCx4IAAjDjBAACADcA8QL4AvqA+oD/gvqC+kDKgAAAMSMAAj8DVQFVAH8BUAA+A+sAqgCqAroBwAAx4wQCBII9Av0BuQG9AL2AuwG9Ab0CxQIAADKjAAI/A1UAVQF/AFIAOgJSAR+AogFbAgIBtOMIAAsCOwH/AbsAv4C7AL8AvwG/AcMCAAI24wAABwIzAXuBewF7AHgAfwF7gX8BRwIIADcjAAI/A1UAVQF/AUAAb4C6gmqBKoDvgiAB96MAAAcCMYP9g30DfYF9AX0DfYNxQ8cCAAA4IwACPwFVAVUAfwFIAC0B6QEpgSkBLQHJADijAAIPgj6B/4H+gf6A+AD4gfaB5oHJgggAOOMAAQ6CO4H7gf+B+8D7gP+B+4H7gc+CAIA5IwACPwFVAVUAfwDqAjsBBgH2ga8CbgJEATmjAAI/A1UAfwFAAjUDxQI0AeQBP4DEAwUBuqMIAAcCMwL7Ab6BvgC7gLqBuoG2gsKCAgA7YwABPwHVAFUA/wFAAGkB/4FpAW8BaYHIAD0jAAEeAJYAfwPWAE4AMAL7ArkAvQG7AcACPqMAAD8DVQB/AIICGwF+A9oAfgPbgPoBUAI/IwACPwNVAFUA/wGwA/sAv4C7Av+CuwHIAL9jAAArAh8BPwH/AP+A/wD/AP8B7QEpAQAAAiNAAj8BVQB/AUAAPwP5wrkCvwK5ArnD3wACo0AACgI/g9eDVwFXAV8BV4FXgXsDxwICAgPjQAMggO2CjoHugm7A7oFOgC6B7oPCgQAAB2NAAAACPwJBAQEBAQC9AEEBAQE/AkACAAAHo0ACAAI8AsQCBAEHgLUARQEFAT0BQQIAAAfjSAIEAj4CRQIFgQUAtQBHAQQBPAJAAgAACGNAAAUCNQLVAhUBlwBVARUBFQI1AsUCAAAIo0ACP4JAgT6AwIA/g4AAAgDiAhoCP8HCAAjjRAAFAjcC1wIXARcA14AXARcBNwFFAgAACSNAAAeCMAFQAReAkABZgRaBFoI1gsSACAAJY0ACP4IAgb6Af4MAABwCI4EiAN4BAgIAAAmjQAEfwf5AAEC/wIACP8HIAToACYDIQQAACeNAAAICMQLXghBBkQBTwRUBFQI0gsKCAAAKI0AAPAHDADsCSwELAK8ASoEKgTqBQgIAAApjQAAfA/0AAQC/AAADvwBNAzUAhQD8gQECCqNCAAICNQLVAhSBFoDUgB0BFQE1AUECAgAK40IACgI7AtqCFoESANoAGoEXATEBQgICAAsjQAI/g3yAwIC/gAADCQCIgYqCeIIIQgACC2NAAj8DeQDBAD8DhAAzAEKAcgJCAj4BwAALo0AAPwJBAT0AwQA/A4QAAgEDgQIBAgEOAQvjQAACAj8C2oIagZ+AWoEagRqCP4LCAgAADGNAAj8CAQG9AH8AgAIUAT+BFAHVAlQCQAENI0ACPwN9AMEAPwGAACAD/4EiASIBIgPAAA1jQAAIAj8C3QIdAR0A34AdAR0BPwFIAgAADeNEAAICNwLQghIBEgDTgBYBGoI4gsUAAAAOI0AAAAI3AtSCFsEQANSAE4EYgTiBR4IAAA5jQAIQAjeC3YIXwRWA1YAXwRWBNYFFggAADqNAAAUCNQLTghkBlwBQARcBFQI1AscAAAAPI0ABPwC9AEEBPwAAAboAQgIfgSIB+oICAY+jQIIOgjqBWoEfgRqA2oAfgJqBOoFOggCAD+NAAD8DfQDBAD8BcAA+A+uAqgCqAroDwgAQY0IAAQI3wVABGoDagBqAn4CagTpBSoIAABEjRAIEgjUBUAEaAJmA1YATAJUBNQFDAgAAEuNAAD8DeQD/AAACNQPFAjUBxAA/gMQDBYGTI0AAPwP9AEEBPwFgADUD34FVAVYBdQPEABPjQAAHAiGC7QItAS2ArQAtAS2BIUFHAgAAFCNAAj8CQQE9AMEAPwOAAC+AOoLqgaqCb4HVI0ACPwH5AEEBPwFAACoD6QEpgS0BKQHIABWjQAI9ASUAv4PlAH0CgAI+AfWAxwI9AsACFqNAAj8DeQD/AAACFoF/A9YAfgPXgX4CUAAW40AAKwIvAj8BbwEvgK8ALwE/AW0BCQJAABejSAALgicC04IfARAA24AXAROBJwFLAgoAGCNAAB+BAID+gACAn4AmAd/BXwFfwX8BwAAYo0ADOIDvgr+B94MPwP+DN4HPgH+DwYEAABkjSACpAGkCCQG5AE+CCQI5A8kAKQAIAMAAmaNgAkkBOQDPgjkByQAgAk0BMoCiAN4BAgIa42ACSQE5AM+COQHpACAB+QBPgjkByQAgANwjSAIKASoAygEKAT8DygJKAkoCSgJIAgAAHSNEAbUARQC/gNUBFQEUAQABP4FCAQQBCAEdY0QBtQBFAH+A1QEVAQABcwEMARMBIIFAAR2jSAMpAMkBP4HpAikCAAIJAj8CyQIJAgAAHeNEAjUBxQC/geUCJQIAAjkCSQKJAo8CoAJgY0QBtQBFAH+A1QEUAQEBVIFIgWkBIgECASFjQAI2AcYBPwHmAgQCNQLTApkCmQK3AsACIqNIAyoA/wHqAgACPgJiAgICn4JyAoqCgAIi40gBqgBKAL+A4gEIAQYBVYFVAVcBfQFAASVjSAGqAEoAvwDqAUABVwE3ATcBdwE3AQABJmNIAyoAygC/AeoCAAI9AswCLwIkAr0CQAIn40ACKQHJAL/B6QIBAj0C5AIXgmQCPYLAAijjRQAFASeA/QDEAT+BKoE/gUABOQFHAUABKiNEAzUAxQC/geUCKQI7wteCUoJbgjeCwAAs40AAAAIPASkAyQEJAjkDyQJJAk8CQAIAAC0jQAI3gcSBPIHngAADvwBAAAEAPwAAAcACMONAAjeB/IHkgSeBAAAJAwiA/4AIgMiBCAIzI0ABN4HEgTyA14CAAhOBEgD/gBIA0gESAjRjQAE3gcSBPIHngQAAPoHtAj0CgQK/AkABN2NAATcBxQE9AOcAgAA/A8UBRQFFAX0BQAE340ACN4HEgTyB54AAAj8D1QI1AFUBnwFAAnhjQAEngfyB5IEDgLgDPgDDgj4BwgA6AEAAOiNAASeB/IH8geOBCAAuAOoCqwKuAqoBqgA6o0AAB4H8geSBD4M+AcWANQHVAhcCtAJEATvjQAI3gcSBPIHngSQAIgP1gikCLwIxA+AAPONAAjeB/IHngQAAAgN/gMAAP4HQAiYCAQF9Y0ABN4H8geSBB4CgAhIBP8ESAMqBaoJgAQKjgAAAAQeD/IHngQAAOQPpAL0D6wC5A8AAA+OAADeDxIE8geeBAAAuA+ACv4KkAqsDyQAEI4ABN4H8geSBB4IQAnoBS8HGAWpC00LJAkijgAE3gfyB5IEngKAAL4C6gmqBqoBvg8AACmOAACeD/IHngQABJQApA6EAdQPggK6BIIIKo4ABN4HEgT+B4AA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7AXsBfwLQAm5jwAIIgTsAwgEAAgIC8gIPggICggK+AkABLqPQghGBMgHAAQECMQLPAgECgQKBAr8CQAIu49ICFIE1gMEBBAIEAgQCP8LEAgQCBAIAAi8j0IIQgTMBwAIAAqCCWIIPgjACAAJAAoAAL2PAAgkBOgDAAQECAQKBAr0CxQIDAgECAAAvo8gCCIE7AMABAgICAvICD4ISAiICAgLAAjBjyAIJgToAwAEJAgkCCQI/AsiCCIIIggABMSPIAgkBOgDAAQwBAgJrApoCigKKAoICQAAxY8kCCQE6AcABCQIJAj0CyQIBAj8CQAKgAnHjyAIIgTsAwAECAgoCMgICAoICv4JCAgICMiPJAgkBOgHAAgEC8QIPAgUCBQKFAr0CQQEzo8ACEYMyAMABPwJBAkACPwLBAgECfwIAADQjyAIJAToBwAIEArUCTQJFAlUCZQJFAoACNGPQghCBMQHAAgAC/4IEggSCPILEggSCAAA1I8ACEIEzAcACAAL/ggyCtIKEgnSCjIKAgrYjwAIIgTsAwgEgAhECCQI/AsECCQIxAiACNmPAAgkBOgHAAgoCigJyghMCLgICAkICgAA248gCCIE7AMABEgISAv+CEgISAj+C0gISAjcjyAIJAToBwAIEAoUCfQIFAj0CxQKkAkAAN2PAAQiBOwDAARUBFQEVAT+BVQEVATEBQAA3o8ACCIE7AcABBQJLAkmCfQLJAkkCQQJAADfjyAIJAToAwAEAAn8CCQIZAjkCCQJPAoACOaPAAhOBMAHBAX8BAYI/AsACPwLBAr8CwAI6o8ACCQE6AcACPgLSApICv4LSApICvgLAADrj0QIRATIBwAEAAj4C0gKTgpICkgK+AsACPCPQghCBMwHAASICWgICAj+CwgIagiKCQAI9I+QCNQEtAMABPwJBAr0CpQK9AoECvwLAAD3j0IIRgTIBwAIJAuoCGAI/gtgCKgIJAsACvmPAAgkBOgDCARgCAgL+ggMCvgLCAjoCAAA/Y9CCEIExAMABPwJVApWClUKVApcCsALAAgAkEAIQgTMBwQIAAr+CyoKagiqCV4KQAoAAAGQQghCBMwHAARICE4KSAn4CEoJSgpICgAIApAgCCYE6AcABBQI1AtUCnwKUgpSCtILEAgDkAAIRAjIBwAEnAhACv4JAAj+CUAKnAqACgaQAAhODMADCATqCI4KiAr4CYgIjgjqCAgICZAACCQI6AcACCAKrAloCD4I6AsoCigKIAkKkAAIIgTsBwAEIgj6C0YIMAr+CwAIOAjAAA2QAACSCPQGlAUACPYLEAheCRAJlAryCwAID5AACCQI6AcABCwILAvcCFwInAqqCqoJIAgQkAAIIgTsAwAEEgWqCK4KUgriCVIIiggABBKQIAQiBOwDAAR0BVcF1AT8BVYEVQXcBAAEFJAACE4EwAcQBEgJVAhUCvIJVAhICVAJEAgXkAAIJAzIAxAEBAh0CtQKVArUC/QKBAoACBmQAABUBHwC2AMABPgFeAV8BXgF+AUIBAAEGpAgCCIE5AMABPoJrgiuCPoLrgiuCvoJAAAbkAAIJAToB0AILgv0CAAKJAr8CyQKJAoAAB2QAAgmCOgHAAhICv4JCAj8CxII8gsSCAAAHpAAANIIvAaYBQAIvAq0CvQLtAq8CgAKAAAfkEIIQgTMBwAIdApUCdQI/gvUCFQJdAoECiCQAAgkCOgHAAQgCKwLqAq8CqgKqAsgCAAAIpAACCYE4AcECJQKkgqvCuoLrgqqCggKEAgjkAIIJgTkAwAEfAlcCVwJ/gtcCVwJfAkECS6QAAhOCMAHEAiUClQKVAj+C1QJfAoQCgAIMZAACEIMzAMABP4JAgjqCXoJ6gkCCv4JAAgykAAIRgjIBwAEEAj+C6gK/AuqCqgKCAoACDiQQghEBMQHEAh4ClYJ1gh0CNwLUApwCgABO5AgCCQE6AMABJwIVAp8ClQJXAnUCBwIAAA8kCQIKAToB4ALfAVsDewPbA1sDfwPAAgAAD6QAAgiDOIDCAToBfwI/AsLCOoIBAzoDwgAQpAACEYEyAMABCgJbgnYCKgKyAmuCKgICAlFkEAIRATYAwAF/AgUCNQJ1AnUC/QJ3AkACEeQAAgkBOwHAAj+C2oI/gl+CWoLfgzADwAASpAACEYMwAMEBfwIFwrkCQwIRgr0C1QIRAhLkAAIIgzkAwAEegl6CXoJ+gt6CXoJegkAAU2QAAgiBOwDAAX8CNQLtAj2C7QI9Au8COALTpAACEIIzAcACOALPgjiCXoJ6gk+COALAABPkAAEIgLsA4AC3AU8BbwFvAU8BTwH/AcAAlOQIAgkBOgHAAQICPoLvgq4Cr4K+gsICAAAVJAACEYEyAMABNQJ9AnUCd4L1An0CdQJEAhVkAAIRAjIBwAI/ArcC9wK3grcC/wKiAoACFeQAAgiBOwDAATuCGoKagl/CGoK6gouCCAEWZCQCPYGkAUACLgOpA68DvYPrA6sDqQOgAhckAAA0Qy2AhAFQgT6CQYKXAj2C0IIwQoAAF6QkAjzBBQDgAR+CAIL8gg+Cn4IdQl1CjABYJACCEIIwgcIBHwJXAncCN4LXAn8CYgKAAhjkAIIQgzEAxAE/An8CvwK/gr8CvwKkAsACGWQAAgkDOgDAARMCXwKZArsC2QKYgpqC0AAaJCACNYIMAcEBvQJfg1UDUQLEAiOC3gKCAppkAAIRgzIAwAE9Ak0CPwJdgn8CTQK9AkACG2QAAgRBPYDAAT+Cb4Kvwq+Cr8K/gseCAAEbpAABCYC6AOAAnwEFAV0BFYGVAV0BBQFAABykJAI1AS0BwAG/AkMCLQKjArcC4wKvAoACnWQAAgmCOgHAAR8CW4LbAlsCXwN/g98CQQBd5CACNQEtAMABfwI7Av8DOwO/A/sDHwJAAl4kAEIJgTkA4AErgruCq4IoAjuCq4KrgoICHqQBAhEBMQDEAT8DfwL/An+CfwL/AsQCAAIf5AAAEQMyAMABfwLVArcCwgIuAjsC7QIqAiAkAIILAzgB0wG/Al+CVwLEAgOC+gIGAsACIGQkAjWBLAHAAiEC/QJ/gn0CfQJ/gj0CwAIhJACCEQIxAcQBH4Jegn+CPoLfgn6CZ4KEAiKkJAI1gSwB8AI/A38C34LfA/8D/wLwAgACI+QAACkDOgDAAT8D1QLnAvUC9wL1AvcCwAKkZAAAAAA3AdUCVQJ1AlUCVQJVAncCQAEAACTkAAAFAQkAsQBNAEMAgAA/A8EAHQCjAEAAJWQAAAEAPoH0ArUCtoL0ArUCtoK+gsACAAAl5BAAEQARAD8D0QARAAAAPwPBAB0AowBAAChkAgICAf4AC4IKAjoBwAA/A8EAHQCjAEAAKKQAAhEDvwBRABEAPwHRAAAAPwPBAB0AowBo5AkACQN/AMkCSQJ/AcAAPwPBAD0AgwBAACmkIAApAykA/8ApACkAAAA/g8CAHoChgEAAKqQAAAEBjQBpAj8DyQAAAD8DwQAdAKMAQAArpAAAPgHSAL+A0gC+AcAAPwPBAB0AowBAACvkAgA/g9IBEgESAT+DwAA/A8EAHwChAEAALGQAAT8ByQEJALkAyQC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rgWiBUAE6pJQC1gE9gdIBFgFCADoD6gC/g+oAuoPAADtklAJWAVUBPIHVAQAAXoMzANIAMwPeggABvySAABQC1wI8gdUB/wLDASkA+QDDAv8BwAABJNQCFgJ9gdUBEQFAATYAlYI1A90AEwFQAUik1AIWAX2B1QEVAEACCgJngUYB1oHKguoCCaTKAQuBfkDKgYqB4AHvgDrD6oAqgS+AwAAK5NQCFgJVATyB0QHAAS+BOoDqgaqCb4HAAAvk1gIVAnyB1QEBAUkAP4HZAVkBX4F5AcAADKTUAhYCfYHVAQABaIEKgDqD6oBKgK+AqAENpNIC1wI8gdUBEQBFABUD9QIfgjUA1QFQAlKk1gIVAnyB1QEBAX0BLQClAH+D7QB9AIEBEuTUAlYCPYHVAUEAOAPPgCyA6oCPgngBwAAdZNICFwJ8gfEBzAMLgPgBKoG/wuqCr4KCAh+k2gIbAlqBPkHagcCDP4Irgr+D64K/QoACIyTSATOBPkHSgXsBa0C/g+sAPwPrwL8BAAAlpNQCFgIVAnyB1QEAAn0C7AKvgKwAvYLAAiuk0AIUAtcCPIH1AUAAPwL7AruAuwK/AsACuGTUAhYCFYJ8QdSBAoN6ghuB2sBbg/qCQgEGJRQCFwF8gdUBQAA8gt6C3ML8w9yC34L8gs1lDAIWgr8BxwHdAC0B74HVAz+BRAH1ggABlGUUAhcCfIHBAd+AKoP7gm6DwAJTg9ICUgPcJQICFwJ8gdEBQgA6A/EB5IC9A+EAmgPAAB9lFAIXAXyB1QNAAgYCN4F3APcC94LrAsoAIiUmACGCPUPlASEBCAAIAAgAP4PIAAgACAAiZQAAJgAhgj1D5QElAQAAAQIBAj8BwQABACTlAAAmACGCPQPlASgAhwASgCICQgI+AcAAJ6UmACGCPUPlASEDIAIOAgABP4DgAEIADAAn5SYAIYI9Q+UBAQE8AGQAJAA/g+QAJAA8AGilJgAhgD1D5QEAAD+DwICMgH6AQII/gcAAKWUuACGCOUPpASkAAAM/AMkASQJJAn8DwAAppQAAJgAhgj0D5QEhAwwCA4G6AEIAzgECAinlJgAhAj2B5QEhAIQAE4CSAlICQgM+AMAAKmUmACGAPUPlAQEBBAB7gEICcgLCAj4BwAArpSYAIYI9A+UBIQMAAhCDv4JQghCDv4JAAixlJgAhgj1B5QE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OgDGAAAI6AquCpQPrAqkCqAIAACKlgAA/g8yAM4EgASqAnwKSAm4B08AqQMoAouWAAD+D3IAjgEgAJQP3APWA/QD1AvUB0AAjpYAAP4PAgD+AQAA3gdUBUAFXgVkBeQHEACPlgAA/g8KAPYLAAjoBwAI/AtWCVQJ9AsACJCWAAD+DwoA9gAABqwAqwWqCa4KqgD4DgAIlJYAAP4PCgH0AAAAvA+sAKwCrA6sArwIhAeZlgAA/g8CADoBxgQABP4C0AjeB9AA9gIABJuWAAD/DxkA7wBsBrcArgSgB6cAuAKuAiIAnJYAAP4PAgA6AcYAEAL0AvwC9g/8AvQCEAKglgAA/g8yAM4JBARsAWQNbAlkC3IJ6gEADKOWAAD+DzIAzgAACe4FmAO/AJgD6g+oAgAAp5YAAP4PMgDMCEAEtgeABKoJ+AzIC84IKAmolgAA/g8yAMwI4gcUBNQL7AjuCXwN7A8ECKqWAAD+DzoBxghQBLgC9AATCPQGuAToDAgAsZYAAP4PAgH+AMAN9gHyB/oL8g35AfUNoAi2lhAEVAVUBVQCVAr+B1QBVAJUA7wEkAQAALuWEAgQCXgJfAl4B3gFfAV4BXgHeAlICAAIvpYAABQGpAHkABwDIAD+D6gE+geoBKgEAADAlgAAUABYAMQP4AreCvAK8A/ECsQK2AoQAMGWAAb+AUIA+gcCACIA+gdSBfoHUgVSBQAAxJYIDOgDHgjIBwgEIAP8B6oEqAT8B6oEqATFliQGvAFkCPwHJADwD64EqAT+B6oEqAQAAMaWCAgIBXwFXgNcA9wPfgFdA1wFXAVECQABx5YAAAQO/AGsAOwP7ArsCuwP7ArsCvwKBAjMlgAA8A8ABP4HAAT+BzAC/g+oBPoHqAQIBNGWJAC0BI4ChA+8AkAEMAD+B0gF/AdKBUgF1ZaAD3wANAe0AjQJ/AcwAPwPqgT0B6gECATWlgAA7gSqBPoDrgLgBjAA/g+oBPoHqASoBNmWAAAICL8EvAS+BbwGiAK+ArwFvgW8BCQE3JYgAKQGlADGD7QCAAD+D6gEqgT6B6gEqATelgQIfAl8BaoDUg04AfwPqgSoBP4HqAQIBOKWgA/0ANQD1gLECPQHIAD+DygF/AcqBQAE45YAAPQJ1gX0A9YF9AUgAP4PqAT8B6oEqATolgQA9A8UAFQBFAD8DxQAVAFUChQI9A8EAOqWGADKCsoKygqKCr4KigrKCsoKyg8YAAAA75YACJgIygjqCcoGngTKBIoG2gnKCJgIAAjwlgAKGAmaBboFCgM+ARoJOgmKBxgBAAIAAPKWAAEMBWUFZQdFBV8FRQVlB2UHBQ0cCQAA9paAAJgAmgG6BUoF3gXKBVoNuguKAZgAgAD3lhgAyg/KCsoKigq+D4oKygrKCsoPGAAAAPuWAAAYANoH+gLKAt4H2gr6CsoLGAgABgAA/pYAAVgLXAtcC8wG3ALcAnwLTAtcBwAAAAAAlwAAWABaD3oBSg/eAVoPegFKCVgHQAAAAASXAAAeAA4IrgeGAd4FhgbWAt4KhgceAAAABpcACEwJ5gV2CyYIPg1GDfYPdg1mDQwNAAAHlxgM2gN6CfoHygXeBcoH+gX6BcoHWAsACQmXAAAMAWYF5gbmBsYH3gbGDuYO5gdMBQAACpcACDgJiguqCYoPvgmKD6oPqgkKCzgLAAgNlwABDAGmD7YLhgveD4YLtgumC4wIAAAAAA6XGAJaC0oLagvKD24PSg9aB/oHSgtaCxgIE5cAAA4ADgjWC64KrgYGAq4GvgrmCw4IAAQWlwAAmASKAroPigI+AIoGugG6D4oCmAQABByXAACYBLoCug+6Aj4Avgf6BfoF+gXIBwAAHpcYAMoP+gX6BcoF3gwKCPoL+gXKBdgLAAgnlwAAAAxMA+YP9gFGAx4KxgZ2A+YLTAcAATKXGAjKDXoJeg/KC54Cig56C/oKSg9YAgAAOJcAAEwH5gf2D8YHXgMGDPYD9gLmCswHAAA5lwAG7AF1B20FbQUFBy8C5QKlD60C7QKgAEKXAA7sAWUE/QT9BnUE5wdlBv0G9Qb1BCAASJcACAwJ5gv+C0YJrg+mCeYNTgu2COQIAABSlxAAFAD8D7wCvAK+ArwCvAq8CvwHFAAQAFaXCALoAg4C6AEAAPwPvAK+ArwKvAr8DxQAWZcQANwP3ALeCtwPEABYCVYJ9AdcAfABQABclxAI3AfcAt4K3AcAAIgCpArqB6IC6gOAAF6XAAEoASgBKAH+DwAAAAD+DygBKAEoAQABYJcABAgHfAdeB1wPXABeAFwPXAd8BwgHAARilwAA8g8SBPIHXgVSBfIHEgQSBPIPAgAAAGmXAAAEAuQCvgK0AvQPtAK0Ar4C5AIEAgAAi5cAAOQCrgL8D+4CBAogCCQJvw8kCSQJAACNlwQA7gKsA/4O5AIAAEgJxgl0BkQF6ARACJGXBALuAvwPrgJkCOAHBAiQC34I0AgQCwAAmJcEAP4CtAL0D74CQAj0BxAAXgEQCfQHAACtlwQC7gL8D24A/g98CawH/ASsCPwIBAgAANOX/AKsAq4PrAb8BgAE7AeuBawPrAXsBQgE5pcAAJIAkgCSAJIA/w+SAJIAkgSSBIADAADplwAA9ALUAt4P1AL0AgAAqAD+D6gAqASIA/OXEAAUANQHVAVUBVYFVAVUBVwF1AcUABAA9ZcgAOgHZgV0BeQHIAAQAS4FqAgICPgHAAD2lxAA3AdWBVwF1AcEALAHjgSiBKIEngcAAPuXEADcB1UFWgXUBwQA+A9UA1QDVAP8DwAI/5eUAL4A1QfgB/4H7gfOB8AH3gfGB5oAAAABmAAIBAj8C6wGrAasAqwCrAasBvwLBAgAAAKYBAgECPwPBAAACPwLrAqsAqwGrAb8CwAABZgEAQQB/AEEAQQI/AesBqwCrAasBvwLAAgGmAAI/AcAAPgDAAD+DwAA/AesBqwCrAr8CwiYSAjIBCQEEAMECPwLrAqsAqwCrAr8CwAIEJgkCCQI9A88AOQIAAj8C6wCrAKsCvwLAAARmAAAFAf0ABQC9AMACPwHrAasAqwC/AsACBOY6ACIAPwPiAToAgAI9Ae0BrwCtAr0CwAAF5gADvgBKAy8AqgDWAj8C6wKrAKsBvwHAAgYmAAAWADUB1IAxAkMBPwHrAKsAqwG/A8AAC2YAAB8CEwFTAR8BwAM/AmsCqwCrAb8BwAIO5gQAN4FEAR/AhQBkAD+DVYDVgNWAf4FAAQ8mAAAeAZYAfwPWAE4CvwJrAasAqwG/AcACEaYAAS8BKwC/A+sApwI+AmsCqwCrAb8BwAITJhADFwDXATcB1wJAAz8DVwJXAlcCfwNAAxNmCABrA+0BVYFpAcMAPwHrAasAqwK/AsAAE+YAAzsAzwIrgksBSQC/AusCqwCrAb8BwAIVJgADOQDLAimCiwFJAD8C6wKrAKsCvwLAAhYmAAP/AB8BqwArA/8AQAI/AesBqwC/AsACFuYBAr8C9wK3gL8CwAA/AesBqwCrAb8CwAAXpgAAKwEmALeAZwCiAj8C6wGrAKsAvwHAAhnmAAO+gEqD6oH2geABwII+guuBqoC+gcCDG+YAAH8DdoBGgn6A7wDAAn8B6wGrAL8CwAIdZgAAAQI9AsUCBQEFALcARQEFAj0CwQIAAB2mAAABAgECPwHBAAACPoJCgTuAwoI+gkAAHeYAAAAAPwDEAIQAQAI9AUUBNwDFAT0CQQIeZgEAQQB/AGEAAAI+gUKBAoD7gAKAgoE+gV6mAAM/AMAAPgDAAD+DwAA/AgMBuwBDAL8DHuYAARIBCYCkAECCPoECgLuAQoACgL6BAIIfZgAABIG8gESAPIHAAL6CAoG7gEKAPoOAAB+mPwPAgD6BwoE+gIACPoECgbuAQoA+g4AAH+YAAD0AIQA/w+EBGAC+ggKBu4BCgD6DgAIgZgwDAwC4gkgCO8HEAD6CQoE7gMKCPoJAACCmDAEDAPiAgAC3gcAAPoMCgLuAQoA+g0ABISYIgAqCOoHNgDiAAAI+gQKBu4BCgD6DgAAhpgQAFABTAJqDdAAAAj0BBQG3AEUAPQOAAiHmAAO/AEkDD4D5AYMAPAEFAbcARQA9A4ACIiYAACiCJIIige2BAAM+gkKBO4DCgj6CwAAiphIBFgESAP+AHgDSAjgBBQC3AEUAvQEAACRmCAAuAsgCPwFKAMgCPQJFATcAxQE9AkAAJaYAATPAtQB1A+yAQAK8ggaBtYBEgTyBQAIl5gABPwE1AL8D9QB/ADgCRQE3AMUCPQJAACYmEAMXANcBNwHXAkADPQMFAvcCBQK9AwEDJyYAAjyBxoBswSqAhII+gQKAu4BCgD6DgAAnZisABQGXgV0BZQOHAD0CRQG3AEUAPQNAASgmAQK/AvsCu4C/AsAAPQJFATcAxQI9AsAAKSYAAj8C/wL/gvMCzwD8AgKBO4DCgj6CQAAqJgAAAAO/AEEBOwFLAX8BywFxAz8BwAIAASxmAAO/gFCBPoDQgL+AAAD2ARWCVAJ3A0AAMSYBAD0DfwB/AekD/4HZgT2A/oD+gcECAAExphABsoBagBnBusBYgz/A2EE/QNhB/8BAAbOmAAAAA7+AQIEGgKiAeIAGgcCAP4HAAgABtiYdA3UAfwJ1Af8A9QBJA38AxQG5AH8BwAM25hQCFIG+gFCAEIA+g9CAEIAzgMUBSoJSAXemAAABAAEAAQABAAEAAQA/AAgB1AIiAiIBt+YAAAQABAI+A+0CLIJtAK0BvgJkAgQCAAA75gIBOQH0gTSBPQGAA7+AWIMogUiA+IEAAjymAgE9AeyBLIE9AYgABwMigP4AAgDOAQICPyYEAT8B7IEsgT0BgAA7AMsAewJBAj8BwAA/ZgIAAgE/Ae6BLoC9AYAAPgDlgT0BAQE/AT+mBAE/AeyBLoE8gY0BOgBJgD8DyQA5AMAAAWZBADyD1oJWgXyCQAAigz6A4gA/w+JAAAACpmAAJQAXAj+D9wJ3AncB9wF/g1cCJQIAAAQmRAAkACoCO4P3AuAA7YH1geWBa4IogAAABOZBAjyB3EGdQMhBIkE/wNYAB8C+APbBhAAGJkICOwPWglWBfQNBACUApQI8weUAIQCiAQomRAE+Ae0BLIE7AYcAPQPlAWWBZQF/AcAAFKZAADwD74EsgT0DkAAag16A28BKg/6DSgFZZkwAAwI6g8IBDgAAA78AQQABAD8DwAIAAZtmTAADAjKBxgAAA78ATQM1AIUA/IEEggAAG6ZcAAMCOoPCAQ4AgAIMAQOA+gACAMoBBgIcJkgABQAyg8YAgAA6AMnACQA/A8kACQC5AFxmWAAFADKDxgEQADwBywJKAnoCwgK+AkABHKZMAAMCMoHGAIIAOIDKgEqAeoJAgj+BwAAdpkgABQIygcYAggIoASuA7gApA/UCJQIAAR8mSAAFAjKDwgEuAKBCPoHiACIAPwPiwCAAH+ZIAAQAM4PGASAApQI/A8QBP4CkAVWCAAGgJkgABwAyg8IBBgAkAaYAJQI8g+UAJgCkASGmSAAFATKBxACBAD8B/QHVQVWBWQFDAcAAJaZAAAEAPQPVwVUBVwFVAVUBVcF9A8EAAAAmZmQAFQAVA+0CpQKvAqUCrIK0grSD1AAkAComQAAvAK8Av4O/A/0D/gO9g7yD/4O2AIAAqyZAAgADPwBVAFUBVQB/A1UAVQLVAkABwAAs5kABv4Aqgf+AqoKAAf8BxAI/gkQCPgIAAbBmQAG/gCqAv4JqguqBwAA1gwIAw4F0QQQCMWZAAb+AKoD/guqDoAN/gMiAOIAIgM+DAAAxpkABv4Aqgb+AqoLAAf+DwIEogVyBIoFAAXQmQAO/gCqBv4OqgmqBwAAigj6D4wIiAgACNKZAAb+AKoH/gKCChAHzAEqAegJCAj4BwAA1ZkAABQIzAXmAeQF7AHgA/4B8gPyBR4DAADbmQADfwDVA38DVQXBAxwMJAP/AiQEPAQACN2ZAAb+AKoH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\"\n    }\n}\n",
            "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
            "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage, ValType::Object)\n\nvoid RefImage::destroy(RefImage *t) {}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p size=%d x %d\", t, t->width(), t->height());\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((height() * 4 + 31) >> 5);\n}\n\nvoid RefImage::makeWritable() {\n    if (buffer->isReadOnly()) {\n        buffer = mkBuffer(data(), length());\n    }\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), buffer(buf) {\n    if (!buf)\n        oops(21);\n}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return sizeof(ImageHeader) + ((h + 7) >> 3) * w;\n    else\n        return sizeof(ImageHeader) + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ allocImage(const uint8_t *data, uint32_t sz) {\n    auto buf = mkBuffer(data, sz);\n    registerGCObj(buf);\n    Image_ r = NEW_GC(RefImage, buf);\n    unregisterGCObj(buf);\n    return r;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 2000 || height > 2000)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = allocImage(NULL, sz);\n    auto hd = r->header();\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = bpp;\n    hd->width = width;\n    hd->height = height;\n    hd->padding = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 9)\n        return false;\n\n    auto hd = (ImageHeader *)(buf->data);\n    if (hd->magic != IMAGE_HEADER_MAGIC || (hd->bpp != 1 && hd->bpp != 4))\n        return false;\n\n    int sz = byteSize(hd->width, hd->height, hd->bpp);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\nbool isLegacyImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf) - 4;\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True if the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    }\n}\n\nstatic int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\n/**\n * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n */\n//%\nvoid getRows(Image_ img, int x, Buffer dst) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    uint8_t *sp = img->pix(x, 0);\n    uint8_t *dp = dst->data;\n    int n = min(dst->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = *sp & 0xf;\n        *dp++ = *sp >> 4;\n        sp++;\n    }\n}\n\n/**\n * Copy row(s) of pixel from buffer to image.\n */\n//%\nvoid setRows(Image_ img, int x, Buffer src) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    img->makeWritable();\n\n    uint8_t *dp = img->pix(x, 0);\n    uint8_t *sp = src->data;\n    int n = min(src->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = (sp[0] & 0xf) | (sp[1] << 4);\n        sp += 2;\n    }\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid mapRect(Image_ img, int x, int y, int w, int h, Buffer map) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    if (img->bpp() != 4 || map->length < 16)\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    auto m = map->data;\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        auto ptr = p;\n        unsigned shift = y & 1;\n        for (int i = 0; i < h; i++) {\n            if (shift) {\n                *ptr = (m[*ptr >> 4] << 4) | (*ptr & 0x0f);\n                ptr++;\n                shift = 0;\n            } else {\n                *ptr = (m[*ptr & 0xf] & 0xf) | (*ptr & 0xf0);\n                shift = 1;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _mapRect(Image_ img, int xy, int wh, Buffer c) {\n    mapRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n//% argsNullable\nbool equals(Image_ img, Image_ other) {\n    if (!other) {\n        return false;\n    }\n    auto len = img->length();\n    if (len != other->length()) {\n        return false;\n    }\n    return 0 == memcmp(img->data(), other->data(), len);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    auto r = allocImage(img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src0 = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto sbh = img->byteHeight();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        auto src = src0 + i * sbh;\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    registerGCObj(tmp);\n    Image_ r = doubledY(tmp);\n    unregisterGCObj(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    // DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\",\n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n#define LOOPHD                                                                                     \\\n    for (int xx = 0; xx < w; ++xx, ++x)                                                            \\\n        if (0 <= x && x < sw)\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n            y = y0;\n\n            auto fdata = (uint32_t *)fromBase + wordH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            // DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n            //    (uint8_t*)fdata - from->pix());\n\n            auto cnt = wordH;\n            auto bot = min(sh, y + h);\n\n#define COLS(s) ((v >> (s)) & 0xf)\n#define COL(s) COLS(s)\n\n#define STEPA(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETLOW(s);                                                                                 \\\n    y++;\n#define STEPB(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETHIGH(s);                                                                                \\\n    y++;                                                                                           \\\n    tdata++;\n#define STEPAQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETLOW(s);\n#define STEPBQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETHIGH(s);                                                                                \\\n    tdata++;\n\n// perf: expanded version 5% faster\n#define ORDER(A, B)                                                                                \\\n    A(0);                                                                                          \\\n    B(4);                                                                                          \\\n    A(8);                                                                                          \\\n    B(12);                                                                                         \\\n    A(16);                                                                                         \\\n    B(20);                                                                                         \\\n    A(24);                                                                                         \\\n    B(28)\n//#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n#define LOOP(A, B, xbot)                                                                           \\\n    while (cnt--) {                                                                                \\\n        auto v = *fdata++;                                                                         \\\n        if (0 <= y && y <= xbot - 8) {                                                             \\\n            ORDER(A##Q, B##Q);                                                                     \\\n            y += 8;                                                                                \\\n        } else {                                                                                   \\\n            ORDER(A, B);                                                                           \\\n        }                                                                                          \\\n    }\n#define LOOPS(xbot)                                                                                \\\n    if (y & 1)                                                                                     \\\n        LOOP(STEPB, STEPA, xbot)                                                                   \\\n    else                                                                                           \\\n        LOOP(STEPA, STEPB, xbot)\n\n            if (color >= 0) {\n#define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n#define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                LOOPS(sh)\n            } else if (color == -2) {\n#undef COL\n#define COL(s) 1\n                LOOPS(bot)\n            } else {\n#undef COL\n#define COL(s) COLS(s)\n#undef SETHIGH\n#define SETHIGH(s)                                                                                 \\\n    if (*tdata & 0xf0)                                                                             \\\n    return true\n#undef SETLOW\n#define SETLOW(s)                                                                                  \\\n    if (*tdata & 0x0f)                                                                             \\\n    return true\n                LOOPS(sh)\n            }\n        }\n    } else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n            y = y0;\n\n            auto data = fromBase + fromH * xx;\n            auto off = imgBase + imgH * x;\n            auto off0 = off + left;\n            auto off1 = off + right;\n\n            int shift = (y & 7);\n\n            int y1 = y + h + (y & 7);\n            int prev = 0;\n\n            while (y < y1 - 8) {\n                int curr = *data++ << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = (curr >> 0) | (prev >> 8);\n\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n                off++;\n                prev = curr;\n                y += 8;\n            }\n\n            int left = y1 - y;\n            if (left > 0) {\n                int curr = *data << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n            }\n        }\n    } else if (tbp == 4 && fbp == 1) {\n        if (y < 0) {\n            fromBase = from->pix(0, -y);\n            imgBase = img->pix();\n        }\n        // icon mode\n        LOOPHD {\n            auto fdata = fromBase + fromH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            unsigned mask = 0x01;\n            auto v = *fdata++;\n            int off = (y & 1) ? 1 : 0;\n            if (y < 0) {\n                mask <<= -y & 7;\n                off = 0;\n            }\n            for (int i = off; i < len + off; ++i) {\n                if (mask == 0x100) {\n                    mask = 0x01;\n                    v = *fdata++;\n                }\n                if (v & mask) {\n                    if (i & 1)\n                        *tdata = (*tdata & 0x0f) | (color << 4);\n                    else\n                        *tdata = (*tdata & 0xf0) | color;\n                }\n                mask <<= 1;\n                if (i & 1)\n                    tdata++;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format (legacy)\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\nImage_ convertAndWrap(Buffer buf) {\n    if (isValidImage(buf))\n        return NEW_GC(RefImage, buf);\n\n    // What follows in this function is mostly dead code, except if people construct image buffers\n    // by hand. Probably safe to remove in a year (middle of 2020) or so. When removing, also remove\n    // from sim.\n    if (!isLegacyImage(buf))\n        return NULL;\n\n    auto tmp = mkBuffer(NULL, buf->length + 4);\n    auto hd = (ImageHeader *)tmp->data;\n    auto src = buf->data;\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = src[0] & 0xf;\n    hd->width = src[1];\n    hd->height = src[2];\n    hd->padding = 0;\n    memcpy(hd->pixels, src + 4, buf->length - 4);\n\n    registerGCObj(tmp);\n    auto r = NEW_GC(RefImage, tmp);\n    unregisterGCObj(tmp);\n    return r;\n}\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    img->makeWritable();\n\n    auto iconImg = convertAndWrap(icon);\n    if (!iconImg || iconImg->bpp() != 1)\n        return;\n\n    drawImageCore(img, iconImg, XX(xy), YY(xy), c);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid blitRow(Image_ img, int x, int y, Image_ from, int fromX, int fromH) {\n    if (!img->inRange(x, 0) || !img->inRange(fromX, 0) || fromH <= 0)\n        return;\n\n    if (img->bpp() != 4 || from->bpp() != 4)\n        return;\n\n    int fy = 0;\n    int stepFY = (from->width() << 16) / fromH;\n    int endY = y + fromH;\n    if (endY > img->height())\n        endY = img->height();\n    if (y < 0) {\n        fy += -y * stepFY;\n        y = 0;\n    }\n\n    auto dp = img->pix(x, y);\n    auto sp = from->pix(fromX, 0);\n\n    while (y < endY) {\n        int p = fy >> 16, c;\n        if (p & 1)\n            c = sp[p >> 1] >> 4;\n        else\n            c = sp[p >> 1] & 0xf;\n        if (y & 1) {\n            *dp = (*dp & 0x0f) | (c << 4);\n            dp++;\n        } else {\n            *dp = (*dp & 0xf0) | (c & 0xf);\n        }\n        y++;\n        fy += stepFY;\n    }\n}\n\n//%\nvoid _blitRow(Image_ img, int xy, Image_ from, int xh) {\n    blitRow(img, XX(xy), YY(xy), from, XX(xh), YY(xh));\n}\n\nvoid fillCircle(Image_ img, int cx, int cy, int r, int c) {\n    int x = r - 1;\n    int y = 0;\n    int dx = 1;\n    int dy = 1;\n    int err = dx - (r << 1);\n\n    while (x >= y) {\n        fillRect(img, cx + x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx + y, cy - x, 1, 1 + (x << 1), c);\n        fillRect(img, cx - x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx - y, cy - x, 1, 1 + (x << 1), c);\n        if (err <= 0) {\n            ++y;\n            err += dy;\n            dy += 2;\n        } else {\n            --x;\n            dx += 2;\n            err += dx - (r << 1);\n        }\n    }\n}\n\n//%\nvoid _fillCircle(Image_ img, int cxy, int r, int c) {\n    fillCircle(img, XX(cxy), YY(cxy), r, c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    return ImageMethods::convertAndWrap(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = NEW_GC(RefImage, icon);\n    registerGCObj(r);\n    auto t = ImageMethods::doubled(r);\n    unregisterGCObj(r);\n    return t->buffer;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif\n",
            "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Replace colors in a rectangle\n     */\n    //% helper=imageMapRect\n    mapRect(x: number, y: number, w: number, h: number, colorMap: Buffer): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Returns true if the provided image is the same as this image,\n     * otherwise returns false.\n     */\n    //% shim=ImageMethods::equals\n    equals(other: Image): boolean;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
            "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% snippet='img` `'\n//% pySnippet='img(\"\"\" \"\"\")'\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a circle\n     */\n    //% helper=imageDrawCircle\n    drawCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Fills a circle\n     */\n    //% helper=imageFillCircle\n    fillCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n\n    /**\n     * Scale and copy a row of pixels from a texture.\n     */\n    //% helper=imageBlitRow\n    blitRow(dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void;\n}\n\ninterface ScreenImage extends Image {\n    /**\n     * Sets the screen backlight brightness (10-100)\n     */\n    //% helper=setScreenBrightness\n    setBrightness(deg: number): Image;\n\n    /**\n     * Gets current screen backlight brightness (0-100)\n     */\n    //% helper=screenBrightness\n    brightness(): number;\n}\n\n// pxt compiler currently crashes on non-functions in helpers namespace; will fix\nnamespace _helpers_workaround {\n    export let brightness = 100\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_mapRect\n    function _mapRect(img: Image, xy: number, wh: number, m: Buffer): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillCircle\n    declare function _fillCircle(img: Image, cxy: number, r: number, c: color): void;\n\n    //% shim=ImageMethods::_blitRow\n    declare function _blitRow(img:Image, xy: number, from: Image, xh: number): void;\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageBlitRow(img:Image, dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void {\n        _blitRow(img, pack(dstX, dstY), from, pack(fromX, fromH))\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageMapRect(img: Image, x: number, y: number, w: number, h: number, m: Buffer): void {\n        _mapRect(img, pack(x, y), pack(w, h), m)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    export function imageDrawCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        cx = cx | 0;\n        cy = cy | 0;\n        r = r | 0;\n        // short cuts\n        if (r < 0) \n            return;\n        else if (r == 0) {\n            img.setPixel(cx, cy, col);\n            return;\n        } else if (r == 1) {\n            img.setPixel(cx + 1, cy, col);\n            img.setPixel(cx, cy + 1, col);\n            img.setPixel(cx - 1, cy, col);\n            img.setPixel(cx, cy - 1, col);\n            return;\n        }\n\n        const fcx = Fx8(cx);\n        const fcy = Fx8(cy);\n        const fr = Fx8(r);\n        const fr2 = Fx.leftShift(fr, 1);\n\n        let x = Fx.sub(fr, Fx.oneFx8)\n        let y = Fx.zeroFx8;\n        let dx = Fx.oneFx8;\n        let dy = Fx.oneFx8;\n        let err = Fx.sub(dx, fr2);\n        while (Fx.compare(x, y) >= 0) {\n            const cxpx = Fx.toInt(Fx.add(fcx, x));\n            const cxpy = Fx.toInt(Fx.add(fcx, y));\n            const cxmx = Fx.toInt(Fx.sub(fcx, x));\n            const cxmy = Fx.toInt(Fx.sub(fcx, y));\n            const cypy = Fx.toInt(Fx.add(fcy, y));\n            const cymy = Fx.toInt(Fx.sub(fcy, y));\n            const cypx = Fx.toInt(Fx.add(fcy, x));\n            const cymx = Fx.toInt(Fx.sub(fcy, x));\n\n            img.setPixel(cxpx, cypy, col);\n            img.setPixel(cxmx, cypy, col);\n            img.setPixel(cxmx, cymy, col);\n            img.setPixel(cxpx, cymy, col);\n            img.setPixel(cxpy, cypx, col);\n            img.setPixel(cxpy, cymx, col);\n            img.setPixel(cxmy, cymx, col);\n            img.setPixel(cxmy, cypx, col);\n\n            if (Fx.compare(err, Fx.zeroFx8) <= 0) {\n                y = Fx.add(y, Fx.oneFx8);\n                err = Fx.add(err, dy);\n                dy = Fx.add(dy, Fx.twoFx8);\n            } else {\n                x = Fx.sub(x, Fx.oneFx8);\n                dx = Fx.add(dx, Fx.twoFx8);\n                err = Fx.add(err, Fx.sub(dx, fr2));\n            }\n        }\n    }\n    export function imageFillCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        _fillCircle(img, pack(cx, cy), r, col);\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n    //% shim=pxt::setScreenBrightness\n    function _setScreenBrightness(brightness: number) { }\n\n    export function setScreenBrightness(img: Image, b: number) {\n        b = Math.clamp(10, 100, b | 0);\n        _helpers_workaround.brightness = b\n        _setScreenBrightness(_helpers_workaround.brightness)\n    }\n\n    export function screenBrightness(img: Image) {\n        return _helpers_workaround.brightness\n    }\n}\n\nnamespace image {\n    /**\n    * Get the screen image\n    */\n    //% blockNamespace=\"images\" group=\"Create\"\n    //% blockId=imagescreen block=\"screen\"\n    //% help=images/screen-image\n    export function screenImage(): Image {\n        return screen;\n    }\n}\n",
            "imagesoverrides.jres": "{\n  \n}",
            "imagesoverrides.ts": "// replace with built-in images",
            "ns.ts": "\n//% color=\"#a5b1c2\"\nnamespace images {\n\n}",
            "panic.cpp": "// potentially overriden in targets",
            "pxt.json": "{\n  \"name\": \"screen\",\n  \"description\": \"The screen library\",\n  \"files\": [\n    \"screen.cpp\",\n    \"panic.cpp\",\n    \"image.cpp\",\n    \"image.ts\",\n    \"text.ts\",\n    \"frame.ts\",\n    \"shims.d.ts\",\n    \"fieldeditors.ts\",\n    \"targetoverrides.ts\",\n    \"ns.ts\",\n    \"image.d.ts\",\n    \"pxtparts.json\",\n    \"imagesoverrides.jres\",\n    \"imagesoverrides.ts\",\n    \"font12.jres\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n  \"screen\": {\n    \"simulationBehavior\": \"screen\",\n    \"visual\": {\n      \"builtIn\": \"screen\",\n      \"width\": 158.43856811523438,\n      \"height\": 146.8025665283203,\n      \"pinDistance\": 14.91,\n      \"pinLocations\": [\n        {\n          \"x\": 4.227952701380444,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 18.170226805137037,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 46.05478386015504,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 59.99706238766404,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 73.93934976267785,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 87.88161944268204,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 101.82389797019104,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 32.11250533264604,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 117.68761950246274,\n          \"y\": 3.1650031792503945\n        }\n      ]\n    },\n    \"numberOfPins\": 9,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_DC\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_CS\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MOSI\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_SCK\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MISO\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_RST\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8\n        ]\n      }\n    ]\n  }\n}",
            "screen.cpp": "// overriden in targets",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True if the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n     */\n    //% shim=ImageMethods::getRows\n    getRows(x: int32, dst: Buffer): void;\n\n    /**\n     * Copy row(s) of pixel from buffer to image.\n     */\n    //% shim=ImageMethods::setRows\n    setRows(x: int32, src: Buffer): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(160, 120) as ScreenImage\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
            "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        multiplier?: number;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 6,\n        charHeight: 8,\n        data: hex`\n2000000000000000 210000005e000000 2200000e000e0000 230028fe28fe2800 24004c92ff926400 250002651248a640\n26006c92926ca000 270000000e000000 280000007c820000 29000000827c0000 2a00543810385400 2b0010107c101000\n2c00000090700000 2d00101010101000 2e00000060600000 2f00006010080600 3000003c42423c00 310000447e400000\n3200004462524c00 330000424a4e3200 34003028247e2000 3500004e4a4a3200 3600003c4a4a3000 3700000262120e00\n380000344a4a3400 3900000c52523c00 3a0000006c6c0000 3b00000096760000 3c00102828444400 3d00282828282800\n3e00444428281000 3f00000259090600 40003c425a560800 4100781412147800 42007e4a4a4a3400 4300003c42422400\n4400007e42423c00 4500007e4a4a4200 4600007e0a0a0200 4700003c42523400 4800007e08087e00 490000427e420000\n4a002040423e0200 4b00007e08146200 4c00007e40404000 4d007e0418047e00 4e00007e04087e00 4f003c4242423c00\n5000007e12120c00 5100003c5262bc00 5200007e12126c00 530000244a522400 540002027e020200 5500003e40403e00\n5600001e70701e00 57007e2018207e00 5800422418244200 5900060870080600 5a000062524a4600 5b00007e42420000\n5c00000608106000 5d000042427e0000 5e00080402040800 5f00808080808000 6000000002040000 6100003048487800\n6200007e48483000 6300003048484800 6400003048487e00 6500003068585000 660000107c120400 67000018a4a47800\n6800007e08087000 690000487a400000 6a000040847d0000 6b00007e10284000 6c0000427e400000 6d00780830087000\n6e00007808087000 6f00003048483000 700000fc24241800 710000182424fc00 7200007810081000 7300005058682800\n740000083e482000 7500003840407800 7600001860601800 7700384030403800 7800004830304800 7900005ca0a07c00\n7a00004868584800 7b00000836410000 7c000000fe000000 7d00004136080000 7e00000804080400 a000000000000000\na10000007a000000 a200003048fc4800 a30090fc92928400 a400542844285400 a5002a2c782c2a00 a6000000ee000000\na7000094aaaa5200 a800000200020000 a9003e414955413e aa0000242a2e0000 ab00102854284400 ac00001010107000\nad00001010101000 ae003e415d45413e af00000202020200 b000000814140800 b1008888be888800 b2000024322c0000\nb30000222a140000 b400000004020000 b50000f840207800 b6000c1e7e027e00 b700000010000000 b800000080400000\nb90000243e200000 ba0000242a240000 bb00442854281000 bc00025f70f84000 bd00021f90c8b000 be0011557af84000\nbf000030484d2000 c000601916186000 c100601816196000 c200601a151a6000 c300601a151a6100 c400601914196000\nc500601a151a6000 c6007c0a7e4a4200 c700001ea1611200 c800007c55564400 c900007c56554400 ca00007c56554600\ncb00007c55544500 cc0000457e440000 cd0000447e450000 ce0000467d460000 cf0000457c450000 d000087e4a423c00\nd100007e09127d00 d200003845463800 d300003846453800 d400003846453a00 d500003a45463900 d600003845443900\nd700442810284400 d80000fc724e3f00 d900003c41423c00 da00003c42413c00 db00003c42413e00 dc00003c41403d00\ndd00040872090400 de00007e24241800 df00007c025a2400 e0000030494a7800 e10000304a497800 e20000304a497a00\ne3000032494a7900 e40000304a487a00 e50000304a4d7a00 e600304878685000 e7000018a4642400 e8000030695a5000\ne90000306a595000 ea0000306a595200 eb0000306a585200 ec0000497a400000 ed0000487a410000 ee00004a79420000\nef00004a78420000 f00000304a4b3d00 f100007a090a7100 f2000030494a3000 f30000304a493000 f40000304a493200\nf5000032494a3100 f60000304a483200 f700101054101000 f800007068583800 f900003841427800 fa00003842417800\nfb00003842417a00 fc00003842407a00 fd0000b84241f800 fe0000ff24241800 ff00005ca1a07d00 0001601915196000\n010100304a4a7a00 0201611a16196000 030100314a4a7900 04013c0a094abc00 050100182464bc00 0601003846452800\n070100304a494800 0801003846452a00 090100304a494a00 0a01003844452800 0b010030484a4800 0c01003845462900\n0d010030494a4900 0e01007c45463900 0f0100314a497e00 1001087e4a423c00 110130484c7e0400 1201007d55554500\n130100326a5a5200 1401007d56564500 150100316a5a5100 1601007c55544400 170100306a585000 1801003f65a52100\n1901001874ac2800 1a01007c55564500 1b010030695a5100 1c01003846553600 1d0100304a49f200 1e01003946563500\n1f0100314a4af100 2001003844553400 21010018a4a57800 2201001ea1691a00 23010018a6a57800 2401007812117a00\n25017e080a710200 2601047e147e0400 2701047e0c087000 28010002457e4500 29010002497a4100 2a0100457d450000\n2b01004a7a420000 2c0100014a7a4900 2d0100014a7a4100 2e0100217fa10000 2f0100247da00000 300100447d440000\n3101004878400000 32017e0022423e00 33013d0040847d00 34012040463d0600 350100800af90200 360100bf440a3100\n370100bf48142000 3801007810284800 3901007c40424100 3a0100467d400000 3b01003fa0602000 3c0100a17f200000\n3d01007c41424100 3e0100457e410000 3f01007e40484000 400100427e400800 4101107e48404000 420100527e480000\n4301007c0a117c00 440100780a097000 450100bf42043f00 460100bc44043800 4701007c09127d00 480100790a097000\n49010a0678087000 4a01003f02847f00 4b01003c04847800 4c01394545453900 4d0100324a4a3200 4e01394646463900\n4f0100314a4a3100 50013a4544463900 5101324948320100 52013c427e4a4200 5301304830685000 5401007c16354800\n5501007812091000 560100bf49093600 570100bc48040800 5801007d16354800 5901007912091000 5a01004856552400\n5b0100505a692800 5c01004856552600 5d0100505a692a00 5e010012a5691200 5f010028ac741400 6001004855562500\n61010050596a2900 62010101bf410100 630100049f641000 640104057e050400 650100083d4a2100 660102127e120200\n670100183e582000 6801003a41423900 6901003a41427900 6a01003d41413d00 6b01003a42427a00 6c01003942423900\n6d01003942427900 6e01003a45453a00 6f01003a45457a00 70013a41403a0100 71013a41407a0100 7201001f60a01f00\n7301001c60a03c00 7401782211227800 7501384231423800 7601081261120800 770100b84241fa00 7801040970090400\n79010064564d4400 7a0100486a594800 7b010064544d4400 7c010048685a4800 7d010064554e4500 7e010048695a4900\n7f0100087c020400 8f01003452523c00 920100887e090200 a0013c42423c0806 a101003048483008 af01003e403e0806\nb001003840781008 b501006a5a4a4e00 b601005878585800 d101003845463900 d2010030494a3100 e601003845563500\ne7010030494af100 fa0100742a750000 fb0100304c4a7d00 fc0178147e554400 fd0130487a695000 fe010078744e3d00\nff0100706a593800 18020012a5691200 19020028ac741400 1a020101bf410100 1b0200049f641000 bb0200000c0a0000\nbc0200000a060000 bd020000060a0000 c602000201020000 c702000102010000 c902000202020000 d802000102020100\nd902000002000000 da02000205020000 db02000040800000 dc02000201020100 dd02020100020100 7403000002010000\n7503000080400000 7a030000c0800000 7e03000096760000 8403000003000000 8503020003000200 8603037c12127c00\n8703000010000000 880303007e4a4200 890303007e087e00 8a030300427e4200 8c03033c42423c00 8e0303000e700e00\n8f03035c62625c00 900302003b400200 9103781412147800 92037e4a4a4a3400 9303007e02020200 9403605846586000\n9503007e4a4a4200 96030062524a4600 9703007e08087e00 98033c4a4a4a3c00 990300427e420000 9a03007e08146200\n9b03601806186000 9c037e0418047e00 9d03007e04087e00 9e0300424a4a4200 9f033c4242423c00 a003007e02027e00\na103007e12120c00 a30300665a424200 a40302027e020200 a503060870080600 a60318247e241800 a703422418244200\na8030e107e100e00 a9035c6202625c00 aa0300457c450000 ab03040970090400 ac030030484a7900 ad030030685a5100\nae0378100a09f000 af03003a41200000 b0033a4043403a00 b103003048487800 b20300fe25251a00 b3030c30c0300c00\nb403344a4a4a3000 b503003068585000 b603021aa6a24200 b7033c080404f800 b803003c4a4a3c00 b903003840200000\nba03007820504800 bb03641212227c00 bc03fc2020103c00 bd03182040201800 be03112d2ba94100 bf03003048483000\nc003087808780800 c103f82424241800 c2031824a4a44800 c303304848582800 c403000838482800 c503384040403800\nc6031c20f8241800 c703c4281028c400 c8031c20fc201c00 c903304820483000 ca03000238422000 cb03384240423800\ncc0330484a493000 cd03384042413800 ce03304822493000 d0033c52525c2000 d10310344a3c0800 d203067804020400\nd303120a7c020400 d4030d7009040800 d5031824ff241800 d603384828483800 d70348302221d800 da031c2221a14200\ndb031824a4a44200 dc037e1212020200 dd0300fc24240400 de033e2010087c00 df030c0ac9281800 e003700c621c7000\ne10301092516f800 e2039ea0bea07e00 e30398a0b8a07800 e4030c1214107e00 e503001028207800 e603be9088887000\ne70348544e443800 e803245252524c00 e903285454544800 ea0364524c526400 eb03086458640800 ec03385454542200\ned03306848682400 ee03184a7e4a1800 ef031848ff0a0800 f003483020205800 f10378a4a4a49800 f203304848485000\nf303006080847d00 f4033c4a4a4a3c00 f503003058584800 0004007c55564400 0104007c55544500 020401013f857900\n0304007c06050400 04043c4a4a422400 050400244a522400 060400427e420000 070400457c450000 08042040423e0200\n09047c027e483000 0a047e087e483000 0b0402027e0a7200 0c04007c102a4500 0d047c2112087c00 0e040c5152523d00\n0f043f20e0203f00 1004781412147800 11047e4a4a4a3000 12047e4a4a4a3400 1304007e02020200 1404c07c427ec000\n1504007e4a4a4200 160476087e087600 170424424a4a3400 1804007e08047e00 1904007d120a7d00 1a04007e08146200\n1b04403c02027e00 1c047e0418047e00 1d04007e08087e00 1e043c4242423c00 1f047e0202027e00 2004007e12120c00\n2104003c42422400 220402027e020200 23040e5050503e00 240418247e241800 2504422418244200 26043f2020bf6000\n27040e1010107e00 28047e407e407e00 29043f203fa07f00 2a04027e48483000 2b047e4848307e00 2c04007e48483000\n2d0424424a4a3c00 2e047e183c423c00 2f04006c12127e00 3004304848784000 3104003c4a4a3100 3204007868502000\n3304007808080800 3404c0704878c000 3504306868500000 3604483078304800 3704004058683000 3804784020107800\n3904794222127900 3a04007820304800 3b04403008087800 3c04781020107800 3d04781010107800 3e04304848483000\n3f04780808087800 4004fc2424241800 4104304848485000 4204080878080800 43041ca0a0a07c00 44041824ff241800\n4504004830304800 46043c2020bc6000 4704182020207800 4804784078407800 49043c203ca07c00 4a04087850502000\n4b04785050207800 4c04007850502000 4d04485868300000 4e04783030483000 4f04502828780000 50040030696a5000\n51040032686a5000 5204023f0a887000 530400780a090800 5404003068584800 5504005058682800 560400487a400000\n5704004a78420000 5804004080847d00 5904700878502000 5a04781078502000 5b04047e14106000 5c04007822314800\n5d04784122107800 5e0418a1a2a27900 5f043c20e0203c00 6204027f4a483000 6304087e58502000 70040e107e100e00\n7104182078201800 72043c4a4a4a3c00 7304306858683000 7404001e70180c00 7504001860301000 9004007e02020300\n9104007808080c00 9204087e0a0a0200 9304207828080800 96043b043f043be0 970424183c1824c0 9a04003f040a31c0\n9b04003c101824c0 ae04060870080600 af040c10e0100c00 b004161870181600 b1042c30e0302c00 b20421120c1221c0\nb3040024181824c0 ba047e0808087000 bb04007e08087000 d804003452523c00 d904002868583000 e20400457d450000\ne304004a7a420000 e8043c4a4a4a3c00 e904003058583000 ee04003d41413d00 ef04003a42427a00 d005681020285000\nd105484848784000 d205004830600000 d305080808780800 d405680808087800 d505000008780000 d605080818680800\nd705087808087800 d805784050487800 d905000008180000 da0504040404fc00 db05484848483800 dc050e4848281800\ndd05087848487800 de05582010487000 df05000004fc0000 e005004040487800 e105000878483800 e205487840281800\ne305041c0404fc00 e405485848483800 e50504f820140800 e605485060685000 e705f40424241c00 e805080808087000\ne905785058403800 ea05487808087800 f005087800087800 f105081800087800 f205081800081800 f305000010080000\nf405100800100800 021e7c5455542800 031e007e48493000 0a1e007c45443800 0b1e003049487e00 1e1e007c15140400\n1f1e001079140800 401e7e0419047e00 411e780832087000 561e007c15140800 571e00fc25241800 601e004854552400\n611e0050586a2800 6a1e04047d040400 6b1e00083d482000 801e7c2112207c00 811e384132403800 821e7c2012217c00\n831e384032413800 841e7c2110217c00 851e384230423800 f21e040972080400 f31e00b84142f800 a3207e0a7a120a00\na420a8fcaa828400 a720087e2a1c0800 ab200098a4a6bf02 ac20183c5a5a4200 af20627f22443800 9021103854101000\n912108047e040800 9221101054381000 932110207e201000 9421103810103810 95212844fe442800 \n`,\n\n    }\n\n    // A unicode 12x12 pixel font based on https://github.com/adobe-fonts/source-han-sans\n    //% whenUsed jres\n    export const font12: Font = {\n        charWidth: 12,\n        charHeight: 12,\n        data: hex``\n    }\n\n    export function getFontForText(text: string) {\n        for (let i = 0; i < text.length; ++i) {\n            // this is quite approximate\n            if (text.charCodeAt(i) > 0x2000)\n                return image.font12\n        }\n        return image.font8\n    }\n\n    //% deprecated=1 hidden=1\n    export function doubledFont(f: Font): Font {\n        return scaledFont(f, 2)\n    }\n\n    export function scaledFont(f: Font, size: number): Font {\n        size |= 0\n        if (size < 2)\n            return f\n        return {\n            charWidth: f.charWidth * size,\n            charHeight: f.charHeight * size,\n            data: f.data,\n            multiplier: f.multiplier ? size * f.multiplier : size\n        }\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\nnamespace texteffects {\n    export interface TextEffectState {\n        xOffset: number;\n        yOffset: number;\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.getFontForText(text)\n        let w = text.length * font.charWidth\n        let x = (img.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]) {\n        x |= 0\n        y |= 0\n        if (!font)\n            font = image.getFontForText(text)\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let mult = font.multiplier ? font.multiplier : 1\n        let dataW = Math.idiv(font.charWidth, mult)\n        let dataH = Math.idiv(font.charHeight, mult)\n        let byteHeight = (dataH + 7) >> 3\n        let charSize = byteHeight * dataW\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        let imgBuf: Buffer\n        if (mult == 1) {\n            imgBuf = control.createBuffer(8 + charSize)\n            imgBuf[0] = 0x87\n            imgBuf[1] = 1\n            imgBuf[2] = dataW\n            imgBuf[4] = dataH\n        }\n        while (cp < text.length) {\n            let xOffset = 0, yOffset = 0;\n            if (offsets && cp < offsets.length) {\n                xOffset = offsets[cp].xOffset\n                yOffset = offsets[cp].yOffset\n            }\n\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            let l = 0\n            let r = lastchar\n            let off = 0 // this should be a space (0x0020)\n            let guess = (ch - 32) * dataSize\n            if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == ch)\n                off = guess\n            else {\n                while (l <= r) {\n                    let m = l + ((r - l) >> 1);\n                    let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                    if (v == ch) {\n                        off = m * dataSize\n                        break\n                    }\n                    if (v < ch)\n                        l = m + 1\n                    else\n                        r = m - 1\n                }\n            }\n\n            if (mult == 1) {\n                imgBuf.write(8, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x + xOffset, y + yOffset, color)\n                x += font.charWidth\n            } else {\n                off += 2\n                for (let i = 0; i < dataW; ++i) {\n                    let j = 0\n                    let mask = 0x01\n                    let c = fontdata[off++]\n                    while (j < dataH) {\n                        if (mask == 0x100) {\n                            c = fontdata[off++]\n                            mask = 0x01\n                        }\n                        let n = 0\n                        while (c & mask) {\n                            n++\n                            mask <<= 1\n                        }\n                        if (n) {\n                            img.fillRect(x + xOffset * mult, y + (j + yOffset) * mult, mult, mult * n, color)\n                            j += n\n                        } else {\n                            mask <<= 1\n                            j++\n                        }\n                    }\n                    x += mult\n                }\n            }\n        }\n    }\n}\n"
        },
        "screen---st7735": {
            "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.filter=\"!tile !dialog\"\n    //% weight=100 group=\"Create\" duplicateShadowOnDrag\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8;20,15;40,15\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tile_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"16,16;32,32;8,8\"\n    //% img.fieldOptions.filter=\"tile\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileImage(img: Image) {\n        return img\n    }\n\n    //% blockId=dialog_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"15,15;18,18;21,21;24,24;9,9;12,12\"\n    //% img.fieldOptions.filter=\"dialog\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _dialogImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n\n    /**\n     * A position picker\n     */\n    //% blockId=positionPicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"position\" color=\"#ffffff\" colorSecondary=\"#ffffff\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __positionPicker(index: number) {\n        return index;\n    }\n}\n",
            "font12.jres": "{\n    \"image.font12\": {\n        \"mimeType\": \"font/x-mkcd-b26\",\n        \"data\": \"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1Ad0AMwGAAD4CQAI/gcAAGNSEAjwBLwG8gG0AuQMAAD8AQAIAAj+BwAAZFIAACQIrAeWAqwCpA8kAAAA/AEACP4PAABlUqACKgoqCeoPKgG+AqAGAAD8CQAI/gcAAGdSwAc+AKoHqgT6BKoErgcAAPwAAAj/BwAAaVKICGwEbAIMAfwPDAFqAigEAAD8CQAI/gdqUgAFfAU8BT4FvAP8AQQBdAUGBXQFBAMAAG9SAgDeD1YF1gdWBVYF3g8AAPwJAAj+BwAAcFIAAKwE/AKsAfwPqgL6BgAA+AEACP4HAAByUowAvA+0BbQF9gW0B7QHjAcAAPwBAAj+B3VSEAAQDtAD+AX0BeQF6AcAAPgBAAj8BwAAf1IACHYFcAV0A/oPeANwA3YFAAD4CQAI/geDUkgE/Af8B/4H/Af8B/wH/AcABPgBAAj8B4dSAA74ARgE2AZ+A2wPbAIIBPABAAj8DwAAiFKAAHwI9Am0CbQF+ANUAVwJ9glcCVQHAACJUgAAnAnKC8kJsAfOBUIFDgT4AQAI/gcAAI1SCAjoBKwC6gBLCKIG5AQAAPwBAAj+BwAAkVI4AEgM9AOMApYCvALMDyAA/AEACP4HAACbUgAAEAgQBBACkAF+ABAAEAgQCBAM8AMAAJ1SAAQUAmQB5AAcCQAEiAN+AAgICAj4BwAAnlIAAIgJaAQIAogBfggICAgM+AMAAOABAACfUgQCBAL8AQQJBAkQBBAD/ggQCBAM8AMAAKBSCAgIBv4BCAgICPgHAAD8DwQEBAT8DwAAoVJACFAJSAksBTYDpAEkCTQJTAlEB0AAAACjUigIqAikCKIEoAOeAJAIiAiCCIQHCAAAAKhSAAAkBOQDJAKkAiQDAAgQB/4AEAjwBwAAqVIABP4DkgSSAv4LAAQQA/AIHwgQCPAHAACqUgAIRAlcCWYFJANcAUQBNAkkCVwHRAAAAKtSAABIB8gEfgJIAkAHEAAQD/4AEAjwBwAAsVIADvwBFAz0A1QI1AcEABAH/AAQCPAHAACyUgAApAikBJQHrASkBDAAEA7+ARAI8AcAALNSAAi0CJQElgSUA9QAlAiUCJYIlAc0AAAAtFIACLgIigSKBIgC6wGICIgIjAiKBzgAAAC5UigIqASoAgwBqAIICFAEEAP+CBAI8AcAAL9SAAAUCFQJfgUUBcADNAEeCQQJPAdAACAAwVIAALQEhAS0B4QEtAwEBBAD/ggQCPAHAADDUgAANAIUCV4HlAE0CQAEEAP+CBAI8AcAAMdSAAgCCvoKqgaqAvoCqgKuCqoK+gYAAAAAyVIQCPgElgP0AJwH8AgYCpgJfggICvgJAATLUgAI7gkqBKoDKgjuCwAAEAf+ABAI8AcAANJSAADkAr4C9A++AuQIBAQQA/4IEAjwBwAA1VIAAHwJfAn8B3oNCAQYApABfggQCPAHAADYUoAAggf/BaoEqgT/BYIMCAL/AQgE+AMAANlSAAAqA6oI6gc2AOAJSAcuATQJNAksB0QB3VIADP4Dkgj+B4ABagk4B64BOAluCaoHAAHeUhIIkgioBK4EoAKiAaQIqAimCCgHcgAAAN9SAAJEAfwFfgN8A3wBfAV+BfwDfAFEAgAA4lIAAKwJrAnuBawFgAP4ARgJDgl4BoAAYADkUgAI9AnWBfQH1gX0BQAMEAP+CBAI8AcAAOdSAAAgAewPuAfoB6gHqA4ABvwBEAjwBwAA8lIAAf4N/gH+Af4N/gEIC5gIfgAIAfgMAADzUgQIfQVtAf8E7AL8AgAGiAF/BAgE+AMAAPVSAAz8A8wP/AHsA/wLzA8ADP4DEAjwBwAA+FIAAfoPuweAB7sHugcADAgD/wAIBPgDAAD+UkAAYAAQA84CKAIIAUgJiAkICggI+AcAAP9SQAAgBhgBjgB4CAgGiAF4CAgICAz4AwAAAFMAAGAAEARMAkoCSAJICQgJCAgIDPgDAAAFUyAAEADIBy4JKAkoCegJCAgICvgJAAQAAAZTQABgBBACzgFoCJgEiAN4CQgJCAz4AwAACFMAAHAA6AMGAuUChAL0AgQCxAsECPwHAAAVUwAAAAD8ByAIIAggCCAIIAggCCAIAAYAABZTQAAgAPgPBgACAAAA/gcgCCAIEAgICAAGF1MAABAEEAIQAv4PAAAAAP4HIAgQCAgICAcZUyAGvAE8AvwDvAS8BAAE/AUQBhAGCAaIBSBTAAD+DwIIAgr6CUoISghKCMoLSghCCAIIKlMAAP4HAgQqBSoF+gUCBPoFqgSqBIoEAAAvUwAA/g8SCIYLIgj6C6oKqgr6C6oKqgoAADlTAAD8DwQExAQ8BAQEBAR8BIQEhARkBAAAOlMAAPwPBAQUBSQFpAREBKQElAQEBQQEAAA7UwAA/g8CBCIFKgWqBHoE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AAD8AwQB/AkABP4DEgDSB5IIkgheBgAAZlQAAPwDBAH8ABAD7gIgCQgG/gEICPgHAABoVAAAAA7+AQIAqgeqAroCqgsqCAII/gcAAHNUAAD8AwQB/AEABEgCSAH+D0gBSAJIBAAAdVQAAPwDBAH8AQAA9AMUARQB9AkECPwHBAB7VAAA/AMEAfwBAAD8AyQBJAH/DyQBJAH8A3xUAAD8AwQB/AEAALQIhAj8B4IAsgCKAAAAfVQAABAA0AdYAlgC1AMSANQPWABIAtABEACLVAAA/AMEAfwBEAAIAA4A+A8oASgBKAEAAIxUAAKUAVQA/AdSAAAA/AcEAgQCBAL8BwAAkFQAAPwDBAH8AWAA/A8CANAAEAkQCP4HEACSVAAIHAgUBNQDXABAAFwAVADUBxwIAAgABpVUAAD8AwQB/AEAAJAPkASQBP4EkASQDxAAllQAAPwHBAH8DAAC/gkIDPAD/A8EBPwPAACaVAAA/AMEAfwBUABIAi4CtQQ0BUwJRABAAKZUAAD8AwQB/AEACOwErAL+AawCrAS8CQAIp1QAAPwDBAH8AUAIvASUA2AA+AkACP4HAACoVCAAEQCKD6AErASjBJIEjgSSBKIPLgAAAKpUAAD8BwQC/AMACKwHIAD+DyAAqAMkDAAArFQAAPwDBAH8AQAIKAioBAoDzAUIBGgIQAivVAAA/AMEAfwBEAGID1YJZQl0CVwJhA+AALFUAAD8AQQB/AEAAPgHqAKsAqoCqAL4BwAAslQAAPwDBAH8CQAITgRMAvgBTAJOBEoIAACzVAAA/AMEAfwBAAgkBbQEbwIkApQFRAgAALhUAAz4AwgAqAeoAqgKCAv+CAgHyggsCAAGvVQAAPwDBAH4AP4PAgQiBfoEogUCBP4PAADAVAACBAF0AVQP1ARVBNYEVAFUAnQFBAUACMFUAADAD0AEXgTSBxIA0g9SBF4EQATADwAAxFQAAPwDBAH8AQAIiAT+AogAiAD+AogMgAjHVAAA/AMEAfwBAAgkCSQJvg8kCSQJIAkAAMhUAAD8AwQB/AFgADAPqASmBKgEMA9gAEAAyVQQANQHVAJeAlQC1AkQDP4CEAOSBFQIAAfNVAAA/AMEAfwBAAD4DwgA6AMuAegJCAj4B85UAAD8AwQB/AEACCQIzgQEAwQFzgQkCAQI0VQAAPwDBAH8BUAEBAT8BwQE/AcEBOQEAADXVAAA/AMEAfwBAAB8AQIBkA8+AUgBRAEkAN9UAAD8AwQB/AEABPwFggQQAs4ICAj4BwAA4VQAAAAI/wutBq0GrQKtAq0GrQb/CwAIAADlVAAARAB8B2wFbAVsBWwHfABECPwPRAAAAOZUAAD8AwQB/AEACPwPkgAQDP4DkAVWCAAG6FQAAPwDBAH8AQAA9g9QAV4BUAlQCfYHAADpVPwDBAH8AQAAfAlUCVQJ/A9UCVQJfAkAAOpUAAD8AwQB+AwCAv4Jkgj+B/wPAgD+AwAA7VSACJ4IkgiSBJ4DwACcA5QE1ATcCIAIAADyVAAAEgCyD78EigSgBJ4EiQSJBLkHCQAIAPpU/AMEAfwBAADoD6gCqAL+D6gCqgrsBwAA/FQAAPwBhAD8AAAAvAisCK4OrAGsAbwABAAGVQAA/AMEAfwJQAgoCZ4GiAT8BswFWAhACAdVAAAAD/4AIg7qCqoKagqqCqoKKg0iAQAACVUAAPwDBAH8AQAIKAkuBeoDKAUuCSgJAAAQVQAG/AEEAFwHXAVcBf4FXAVcBXwHFAAAABRVAAD8AwQB/AEAAKoHugSuBKoEugSiByAAJFX8AwQB/AEACPgElAKWAfQBnAKUBPQEgAgsVQAA/AMEAfwBAAz4AygIPgdsAGwHTAgABC5VCAAIAHwPXgVcBVwFfgVcBVwFXA9EAAAAL1UAAPwDBAH8AQAA/A+qBKgE/geoBKgEAAAxVQAA/AMEAfwBAAD+B2oFagVqBWoF/gcAADdVAAD8AwQB/AEACPQH7ADmAmUKZAr0ByQAOFUAAPwDBAH8CAAGKACkBLIJNAr0ACQGCAg+VQAA/AMEAfwBAAjUChQK/A8UCtIKUAoQCEZVAAAAAPQPFAB8BxYFNAVUBVwHFAD0DwAASlUAAPwDBAH4AP4PMgDMAeQDFAHkCPwHBABPVQAA/g8qAKoHvgKAAr4CqgMqCCoI/gcAAFNVwgA6AKoHqgSqBLoEkATOBLQENAdMAIQAX1UABvwBqgeqAqoCugMgBH4CiAHoAhgEAABhVQAA/AMEAfwBAAAoAf4PAAD+DygBKAEAAGRV/AMEAfwBAAB8AtQC1AJ+AlQPVAJ8AgAAZVUAAPwDBAH8ARAASAdEBfIFVAVEBUgHUABmVQAA/AMEAfwBAAz+AwgIYAiJCQoO6AkAAGpVAAD8AwQB/AGACP4HQAD4D4wEigT4DwAAeFX8AwQB/AEADKwDLAYsAf4PLAEsArwPCAB8VQAA/AMEAfwBAABsB6QApg+0AKQEpAMAAIBVAAD8BwQC/AMAAKQPtAlWCVQJpA6MAAAAglX8AwQB/AEAAPwA1A/UCPwJ1ALUB/wJAACDVQAA/AMEAfwA4A8UALQCngfUAhQI9AcAAIRVAAFEAVQPVgtUC/wLVAtUC9YL1A9EAQAAh1UAAPwDBAH8DGQCng/0AZQCYAj4CP4HAACJVQAA/AMEAfwBYAD4DwYAUAlUBdQDXAVQCYpVAAD8AwQB/AzwAwgHqAIIDX4CiAVqCAAGlFUAAPwDBAH8DAAC/Ak0CPQKtA+0CrwKAACYVfwDBAH8AQAAvA+wALAP/gCwD7AAvA8AAJpVAAD8AYQAfAjwBVgFNgOUAzwFUAXwCQABnFUAAQQBfA/cC1wLXgtcC1wL3At8DwQBAAGdVQAA/AMEAfwBAAC+BqoEqgWqCKoIvgcAAKdVAAD8AwQB/AEICPQLtAq2CrQK1AscCAAAqlUAAIQIvAisD7wIhAj+CYQCvASsCrwKhAirVQAA/AMEAfwJAAg+BTQDwAM8BQQJfAkAAKxVKAAsAJwP/ADcB9wF3AXcBfwHmgioDyAArlUAAAAE/gVaBVoF/g9QBV4FWgX6BQ4EAACyVQAA/gMCAf4BGAznApAAUAaOAAgI+AcAALVV/gGCAP4AAADwD5IElwTyB5AElwTyBwIAtlUAABgACgd8BVgF3gVYBVgFfAUKBxgAAAC3VfwDBAH8AQAI1AtUCFQGVgFUBFQI1AsACLtVAAD8AwQB/AEYANgPtALyD5QBGAjIBxAAxVUAAPwDBAH8AQAIfAVcBV4DXgPcBXwFAAnOVQAA/AMEAfwBAAz+AKoGqgD+BKoBgg8AANNVAAD8AwQB/AEACFIFdgOGD5YDUgUwBQAI2lUAAPwDBAH8CQAE/ADUDtYA1AXcCMAHAADcVQAA/AMEAfwBQAA0B34H1AfcB9QH1AcAAOFV/AMEAfwBAATIAlQKogcQAFICdArkBwgA41UAANwP1AfUD9wPhAFUAtQLBAj8BwAAAADkVfwBBAH8AQAE4AdsBngG7gdoBmgG7A8gCOhVAAD8AwQB/AAADkQAkAPMAqgLqAroBwAC71UAAPwDBAH4AD4BYgJqBFoFWgRCAX4DAAL9VQAA/AMEAfwEJAL+D1QBdAkQBs4BCAY4CAZW/AMEAfwBAAj0CtQK1gb0A9QG1gr0CgAACVYAAIIOvgLuCq4KrwauDO4Krgq+CoIOAAAOVgAA+AMIAfAFBAV8BfwDfAN8BfwFfAcEAxdWAAAMAEYP1gv0C/YL9Av0C/YLxQ+cAAAAG1YAAPwDBAH8CPgHBAH0DyYChAH0D6QABAMfVgAA/AMEAfwAgA9+BVAFiA/8BwQA/AMAADFWAAD8AYQAfAgAB/wOtAHcBfwH1AHcDwAAMlYAAPwDBAH8A3wCrg98Av4HkgD+DwAAAAA0VgAA/AMEAfwBEATYA+4C9AfwAu4C1AcQADZWAAD8AwQB+AAEDf4BVAH+DfwDJADiDyIAO1YAAPwDBAH8AQAAfA/cC14LXAvcC3wPBAE/VvwBhAD8AAAIXgVWAVIF/glaAVIFXgAADkFWAAD8AwQB/AAgDVQB3AcEC9wLVAl0AQANYlYAAPwDBAH4CXwIDAVkA3YBJANEBXwJAABoVgAAQAJcD1QJ1Al8D2AATA/0CXQJXA9AAmpWAAD8AwQB/AnABbwF9AOUD/QPvAPgBQAIdFYAAPwBhAD8BBAE9Af0AvYC9ALUBvQHEAiHVgAA/AMECfwH5As/COQPJA3kA/8PJACgA7RWAA7gAbwE9Af0B+wPuAHUCXQG/AVgCAAAt1YAAPwDBAH8BQAM/A/sCf4B9AfsBfwJAAC8VgAA/AMEAfwBAAD0D/IF+gwyAbkItQeAAMJWAAAIAv4H/gf+B/4G+AD+Bv4H/gcIBQAByVYAAP4BggB8AfcGpQIHA/0PVwX1B1cFAADKVgAFtAP8C/wH/AWeBfwB/AP8BdwHlAcAANpWAAD+DwIEAgWCBEIEOgTCBAIFAgT+DwAA21YAAPwPBATEBTwEBAQEBHwEhAQEBPwPAADeVgAA/g8CBPIEkgSSBJIE8gQCBAIE/g8AAOBWAAD+DwIEIgUiBaIEegSiBCIFAgT+DwAA4lYAAP4HAgSSBFIEUgUyBfoFEgQCBP4HAADjVgAA/gcCBAoEagQKBQoF+gQKBAIE/gcAAO1WAAD+BwIEKgXqBCoE6gUqBSoFAgT+BwAA8FYAAP4PAgSiBWIE+gViBKIEIgUCBP4PAADyVgAA/g8CBJIE+gWSBJIE+gWSBAIE/g8AAPNWAAD+DwIGWgdCBcoEwgQyBQoFAgT+DwAA9FYAAP4PAgSqBKoE+gWqBKoEigUCBP4PAAD6VgAA/g8CBBIE0gVSBXoFUgXSBQIE/g8AAP1WAAD+DwIEKgUqBfoFKgVqBSoFAgT+DwAA/lYAAP8PAQQpBS0FFQWVBa0GJQYBBP8PAAAGV/4HAgbeBlYGVgVWBVYEXgbCBgIE/gcAAAhXAAD+BwIEPgT+BToGugZ6BjoFAgT+BwAAC1cAAP4HAgTqBaoFSgR6BYoFbgYCBP4HAAANVwAA/gcCBP4FfgV+Bf4FfgV6BQIE/gcAAA9XAAD+BwIEagTqBfoG6gb6BmoEAgT+BwAAElcAAP4PAgzqDWoLegtqC2oL6gsCDP4PAAATVwAA/g8CCMIL+gvqC+oL6gv6CwII/g8AABZXAAD+BwIE/gf2B/YH9gd+BuIHAgT+BwAAGFf+DwIE/gT+Bf4E/gT+Bv4H/gQCBP4PAAAfVwAEIAQgBCAEIAT+ByAEIAQgBCAEAAQAACNXQAhECEwJLAk0CaQPNAk0CUwJRAhACAAAJ1cAAAAM/AMECEQIRAj0D0QIRAhECAQIAAAoVwgBiADIDzgAjgiICIgI6A+ICIgIiAgAAC1XAAgkCSQJJAkkCb8PJAkkCSQJJAkgCAAAMFcAAhAC/gEQAUAA/AcgCCAI/gkQCBAJ+AQzVwAEEAL+AxABAAz+AwAAAAD8BwAAAAD+DzpXAAIQAv4DEAEAASIJ8gQqAuYJIgzgAwAAPlcABBAC/gMQCgAEhAN8CIQEJAc8BeAEAAhAVxACEAL+ARABAAjwDwAIAAj+DyAIIAggCEJXAAIQAv8BkAQABv4BMgzSAhIDkgJyBAIIR1cAAhAC/gEQATAADAIqASgJqAgIDPgDAABKVxACEAL+ARAJAAwIAvgBSghICEgIyAcIAE5XAAIQAv4BEAFACDQICgboAQgCSAQ4CAAAT1cAAhAC/gEQAUQBRAAkAPwPBAAkAMQAgABQVyAIkAiOCLAIgAj+D6AIkAiOCJAIIAgAAFFXAAIQAv4BEAEADOgDKgAqAOgHCAgIBgAAV1cAAhAB/gGQAIAICARIA/4AyAFIAngEQAhaVwAIPggACQAJfglGDyoJEgkqCSYJQAgAAFtXAAIQAv4BEAEABCQGpAVkBCQEpAUkDgAIXVcAAhAC/gEQAQAI/gkCBAIC+gECBAIE/glfVwACEAL+ARABgAkIBHgEigOMAngECAgIBGBXAAR+BQIFPgUCBaAHMAUOBRAFIAVABAAAYVcAAhAC/gMQCQAM+APICX4GSAbICVgIAABkVxAC/gEQAQAA/AMkASQB/w8kASQB/AMAAGZXgAAQAf4AkAAABP4EkgSSBJIEkgT+BAAEalcAABAC/gMQAQIAugCCAP4PggCyAIoAAACCVwAAQAJUCvQLVApUCvwPVAryC1IKQAAAAINXAAIQAv4BEAEABCgEyAUKBAgH6AQIBAAAhFeICIgKaAoYCkwKSA94CqwKrAqICkgIAACLVwAAQATKBD4ECgV+BQoHAAUeBUAFfgQABJJXQAhoCUgJbAkKCQgPaAlMCUgJKAlACAAAo1cAAhAC/gMQCQQI9AtUClQKVApUCvQLBAimVwAAAAj+CqoKKgoqD2oKqgqqCt4KgAqACKtXJASUBf4FFAUABdQHNAUeBQQFfASABEAArlcABBAC/AMQAoAAqAK4A6wKqAqYCqgGqADDVwAEEAL+AxABQAgoCS4F6AMsBSwJIAkAAMtXAAIQAv4BEAEACHwJVAlUCfwPVAlUCXwJzlcAABAC/gEADPgDKAAoCsgJfgSIB24ICAbUVwACEAL+ARABAADoD6gCqAL+D6gCqgrqB99XAAAQAv4BEAFAAKgC6AoIBH4CiAVqCAwG4FcAAhAC/gEQAQAC/AK0ArYPtAK0AvwCAAL3VwAAlALUAp4P9AIQCEgG/gEIAQgA+AcADPlXAAEQAv4BAAEkAKQHtASmBKQEvASsByQA+lcAAEgBSAX8BHgFeAd4BXgF/ARIBUgBAAD8VwACEAH+ARABAAC0B7QCrgs2CDQI9A80AABYAAAIAf8AAAb/AQUOdQRFBPUHRQR3BwAAAlgAADgICgrsCqgKrg+oCqgK7AoKCjgIAAAFWAAEfgVWBXYFVgVeBwAFSgUyBToFRgRAAAZYEAIQAf4BgAAwAPwPqgSoBP4HqASoBAAAFVgACP4KCgp2CgAKfA8+CjwKvAr8CgQIAAAhWBAAEAR+BQAFXgU6BxoFegU6BV4FUAQAACRYEAQQBP4DEAqACL4GqgSqD6oKqgq+CoAIKlgAABAE/gMQAwQP/glUC1QLVAn+DQQJAAAvWAAAmAmcCXwFXAMOAVwBXAd8CVwJWAUAADBYAAIQAf4BEAD8DwQE/AZ8B3wF/AV8BEAAMVgAAFQBdAHeB3QBAAD+D2IIsgQyA+4MAAQ0WAACCAL+AQgAQAn+BWoDagVqA2oJfgcAADVYAAIQAf4BEAHUAFQA3gd0BVAFWAXWBxAAOlgAAQgB/gCACb4EqgTqAz4AKgDqD74BAAFBWAAIQAl+C2oLKgo+DyoKqgpqC34LQAkAAEpYAAQQAv4DEAEAAXwIVgfVAPwHVAhUC3wLTFgIAQgB/wEIAUAA3wFVBdUHlQFVCd8PAABRWAAAaAjMCngKTAooD4AKfApUClQK/AgAAFRYAAIQAv4BEAFEACQHJgVUBVQFJgUkB0QAV1jaCAIKigqoCiwKrA6qCvoKLAqsCqgICABYWAACCAH/AQgBAAb8ARwGXQX6BVwFfAcUAFpYAAIQAv4BkAUGBaoCegqKCToGygAmBwAAXlgAAIQKtAq0CfQKtAq2DvQKtAm0CoQKAABpWAABEAH+ARAFOAT2B9QH1ATUB/QEhAcABGtYAAQQAv4DEAEACPwLvAq+ArwK/AsECgAAdVgAAAAM/gfqBP4FagVrB34F6gXqBfoEAAB+WEQIfAl8C/4LfAoAD4gKaAoeCvgIAAnACINYAAIIAv8BiAgICPoFXgNbAV4P+gkIBAAAhVgACH4Lagv+C2oLfg8QCpIK+goWCnIIAACKWAAArAisCu4LvAqID+gKPApICvgIAAnACJNYAAFEBfwEfgV8BXwFfAd8BX4E/AREBQABl1gAAhAC/gEAAXwA1w/UCvwK1ArXCvwPAACZWAAAEAP+AZAABADsB+QH/gbkBmwF5AcAAJxYAAB+BIoGdgYABlYHPAW0BfQFFgVkBIAAnlgAABAD/wGAADwA5g90BXwFZAXnDzwAAACoWAAEIAR+BToFegU+B3oFPgU6BX4FIAQAAK5YAAD+CAIKfgoACvYPOwp+Cn4K3gp+CAgIs1gAAhAC/gEQAQQI1AfcB94D1APUB9QLEAjBWEAAfgRqBWoFagVuBzQFPAV2BTQFPAUABMdYAAAQAf4BAAF8BMwH/Af+B/wHzAd8BAQEylgAABAC/gEAA/QK1A70Cd4F9ALUBvQIAAjTWAAM/gPKAf4G/ga+B8IHEgf6BvIGtAQAAdhYAARwBX4FfgV+BX4HLgV+BX4FfgVwBAAA3lgAABAC/gEAAFwCrA48CW4JPALsBvwIAADiWAAAEAT8AwAI/AcEAPQOZAgEDvQKpAoAAORYAAAQAv4BAAV8BOwN/gvGAfwH7AX8CQQB61ggACAEIAQgBCAE/gcgBCAEIAQgBCAAAADuWAACGAIAAf4PAAAgCCAI/g8gCCAIIAgAAO9YgAieB5AA/g8AACAIIAggCP4PIAggCCAI8FgAAAQM1ANUAVQB3gFUAVQBVAHUAwQAAADyWAAIxAhUCFQGVAFeAFQAVAdUCFQIxAQAAPNYAAjECFQIVATUA94A1ADUB1QIVAjECAAE9lgAAMQIVApUCFQPVAheCFQPVAhUCsQIAAD5WAAANAS8BXwFfAV+BXwFfAf8BdwFFAQAAPpYAABkCDQLtAr0Dj4I9A60CrQKNAtkCAAA/ViUANwG/Ab8BvwG/gD8BPwC/ArcD9QCgAAEWYAIYAjeBAgD6AIYBAAI/gsgCEAIgAgAAAdZQABQAEgPrAq2CqQPtAqsCswKxA9AAEAACVkECkQKNAmEBaQGngTEBvwGhAmUCCQIAAANWQAACAgICnYJ3gdcBVwFXAVcC3wJBAgACA9ZAAgECnwJfAX8B3wFfAV8B3wJfAkECAAIFVkAAEAAIAgQCEgETgSKAggBiABoABgAAAAWWUAAYAhQBI4CiAFoABAAIAD+D4AAAAEAAhpZAABQCEgJRAk0BaYElAZMAkQBwABAAAAAHFmEAEQA9A8EAEQIZgS0AxQDlAR0BBQIAAAfWSAA8AMsCegJCAj4BwAAqAiWBFQCTAHAACBZCAmoBHYFVALMARAAzAMqAegJCAj4BwAAIlnEAHwKbApuC/wLbAVsBXYDbAF8AMQAAAAlWQAI/ATUAvwP1AL8ABAISAnWBrQEjAOAACdZEAgQBBACEAHQAD4AUACQARACEAQQCAAAKVlACEQIRAREAkQD/ABEAUQCRARECEAIAAAqWRAIEAQQBBAD0AI+BFAIkAEQAhAEEAgAACtZQAhIBEgESAJIAf4ASAFIAkgESARACAAALVkAAEAIRAhEBEQERAP8AEQDRARCBEIIQAguWQAAgAj4CIgEiAP+AIgBiAaIBPgIgAgAADFZYAhwBE4ESALIAX4AyAFIAkgESARACAAANFlABEgIUgRUBEQCwAF+AEACQAJABEAIAAA3WQAABAjsBKwErAL+AawDrASsCrwKhAkAADhZAAAoAKgAqAK4A6wCqAqoCrgKqAaoACgAOVkAAIAIiAioCIgEiAP+AIgDiASoBIgIgAg6WQAAqACoAKgAmAaMAIoImAiYD6gAqACoAD5ZCAmICGgECAQIA/wACAOIBGgIiAgICQAAR1kAADQAtAe0ArQCrAKuAywINAj0BzQAIABIWSgEqAyoApgIrAiqB6gAmAKoAqgMKAAAAElZAACgAKwCbAIsArwCrg+sAiwCbAKsAqAAS1lAAEQA5A9UBUwFxgdMBVQFZAXkD0QAQABOWRQEVARMBVwFVgV1B1QFXAVMBVQFFAQAAE9ZkABUCFwFfAVcA94BXANcBXwFXAlcCJAAUVkAAFQJVAl+CVQFQANCAyIFHglCCT4JAABUWSABJAkUBawDJAEmAXUBJAGMDxQBJAEgAVVZJAlUCUQJJAUcBQYDBgF8BQQFFAUkCQAIVlkgCSQJEAl+CQAFSANEAyYFJAkcCQQJAABXWSAAJAEUBfwHdAV2BXQFdAV8BRQNJAkgAFpZAAmECawFZAW0A6oBYgNSA0IFSgUACQAAYFkAAAQF/AXuBe4F3APcA+4F7gX8BQQFAABiWSgBKgGqAK4P6gq7CqoKugqmCqYPKgAqAGVZAAAACXwJDAVkBXYDJANMBQQFfAkACQAAZ1kACXwJBAVsBWwFLAN+ASwDLAOEBfwFAAloWQAALgkgCX4FAAUkA5IBFgORBf0FFQkQCWpZAABUATQB/AP0B/YB9AX0BfQD/AGUARQBblkAABoAmg/+Cv4K+w/6CvoK/gr6D0oAAABzWQAAEAgQCdAIMAkeBRICEAKQBXAEEAgQCHRZiAj4BA4DyAE4CAAMNATEA8QCPAQACAAAdlkICPgMDgOIA3AIBAf8AAQEPAgkCOAHAAB4WQAA+AgOBYgDeAwAAEQARAD8D0QARABAAHlZAAj4DA4DiAF4BgAA/AcQCP4JCAj4CAAGfVkACOgMHgOIA3gEAABECEQI9A9MAEQAQACCWQAACAj4CA4F6AMQAPwPBAQEBAQE/A8AAINZAAj4CA4FiAN4BAAAxAdECEQIRAj8CAAGhFmACIQIvAqkC6QKpgSkBKQHpAikCIQIAACGWQAAGAOAAP4PAACQCHAJHgYQA/AEEAgQCIdZCAj4BA4DiAF4AAAERAREBEQERAT8DwAAiFkACPgMDgPoAhgEcAFEAUQJZAlcDMADAACSWQAI+AwOA+gDGAzwA0gASgBKAEgA+AAAAJNZCAj4BI4CyAE4AgAIaASoBT4CqAVoBAgIllkABPwEBwPEAjwAAAwiAqIBfgChASECIASZWQAA6AieBsgBOAIACDwEgAT+AgACjAEwAJ5ZEAjwBA4DiAN4AAgI4A9cCEQI/A9ACAAApVkAAEQIVAbEB2QGbAJEAmIF8gRKBEAIAACoWQgA+AkOBYgDcAQAAAgP+ABOCEgIyAcIAK5ZAAj4DA8D+AgADP4DEgDSB5IIkgheCAAGs1kAANAIPgUQA/gEAADUAwoI+A8IANgBCAK5WQAI+AgOBYgDeAAADEgCSAH+D0gBSAJIBLtZFAlcCVwLXAvcBX4FXAVcB1wFfAkUCQAAxlkACPgJDAb4BQAA/AdEBFQFVAxEDPwHQATJWQAA6AgfB8gBOAbAASQAJAD+DyQA5AMAAMpZCAj4CA4H6AEQBngARA/EAP4PRADEBwAAy1kAAOgNHgOIAXgCAACwD64EoASsBDAHQADQWQAA+AkOBugDEAj8DyQJJAkkCfwPAAgAANFZAAD4DA4DiAN4BAAAkA+QBP4EkASQDwAA01kAAOgIHgXIAzgAIAicCJAI/g+QCJAIAAjUWagIrAisC5wKzAb8BIwCmgWqBKoIqAgAANpZAAj4BA4D8AgMCYAE/gMAAP4HQAicCIQG3FmgCKwIrQquC6wGvASsBq4FrQSsCKQIAADlWRAI8AQeA5ADeAQAAagHfgkoCTgJKAUkAOhZAAj4DI4DcAQEAOwMrAL+AawCrAS8CQAI61kAAPQMjwLkARgA/g+SBJIEngeSBPIEAATsWQAI+AQPA+gBEAD+BwIE8gSeB5IE8gQCBPtZAAD4DA8D6AEQAv4PAgXiBLoFAgT+DwAA/1kAAKIIlArUC8AGpgSUBIwGlAWkCKwIAAABWgAO+AEIBNgFeALYAwgI/gQIA8oEKggABgNaAAj4CA4H+AQAACQJJAm+DyQJJAkgCQAABFrICMgIrgqYC9gG/gSYBpwFqgTqCMgIAAAHWgAI+AQOA8gBOAZQADQPHAAUADIPUgCAABhaAAj4BA4D+AYAAPwPVARWBNQBVAO8BIAEG1oAAPANHgP4AAQIcAlcB+QBZAN8BcAJAAkcWgAA+AyOA3gIAgb+AZII/gf8DwIA/gMAAB9aCAj4CA4F6AMYAMAPvAK0ArQKtAr8DwAAJVoACPgM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XgmcB5wAXAFEAhwEAAS5WwAALAIkAZQPRAkmCSQJRAmUDyQBDAIAAL1bAAAMCNwLXAh8BF4DXAR8CFwI3AscCAAGvlsAAAwJBAX0BVQFTgFMAcwFTAVEBQwJAAC/W4AATADkBxQABADWB1QFdAVUBVQF1AcAAMJbAABMA0QI9A9UAEYLFAh0BJQD1AQ0CAAIxFsAAIwAxAfUBbQFtgW0B9QA1AjED4wAAADFWwAIDAjkC7QGtAb2A7QCtAa0BuQLDAgAAMZbAAAMAaQHhATkBE4HpASUBEQEFA9kAAAAx1tACFQE1ANUANQHVggECHQLVAvUCFQIAATMWwAADACEB/wF3AXeB9wF3AX8BYQHDAAAANJbAACMBLwCvAH8BL4IvAr8CLwJvAKMBAAA01sAAIQP9AD0AvQC9gP0AvQC9Ab0BIQHAADbWwAIDAjEC9QL9AfWA9QD9AfUC8QLDAgAAN1bAAAsAQQB/APECX4IfAt8BXwFfAvMCQAI3lsAAAwK5Ar0CvQG9gP0AvQG9ArkCgwKAADfWwAATAlkBbQB9AmGD5QBpAPUAzQFnAgAAOFbAACMAIQF/AX8A/wD/gH8BfwH/AGMAoAA4lsACWwHRAH0DwQA9gn0C/QF9Af0CKwJAADlWwABXAlcCbwKnAt+B0QGvAR8BXwBDAEAAOZbAAAUCNQH/Af8A/4D/AP8B/wH3AcUCAAA51sAAAwBxANUA9QLagvsD2QDRAPUAwwDAADoW4AEtAK0CrQL9AK2DrQC9Aq0C7QKhAIAAOlbAAFMAWQP9AtUC3YPVAtUC/QLVA9EAQAB61sAAAQB9AT0AvQA5gLEAfQA9AX0BIQDAADsWwAIDAjEC9QH1AfWA8QD1AfUC8QPDAgAAO5bAACMCEQI1AP0CtYO1AL0AtQLRAiMCAAA9VsAAFQI9AfUAfQK1AcGAPQHdAt0C3QOAAT2WwAEFgjWB94H1gPHA+4D7gP+B+4HLggAAPhbAAAIACgAaACIAQgICAgICP8HCAAIAAgA+VsACCQMRAKEAXwCAALQABAJEAj/BxAAAAD6W6AAqACoAKgGqAS8AKgIqAjoB6gAqACgAPtbAAAAAUQBVANUA1QBVAlUCVQHfAEAAQAB/FsAAAABPAFUA1QFVAFUCVQJVAdcAUABAAH+WwAIKAxIAo4BaAYIBFAA0AEQCP4PEAAAAP9b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/gMAAvgHwACmD5IIsAjGD4gA8FwAAPgH/wcABPwHAAAkBVcF2g9WBVIFEAT2XAAAAA78BFwFXAdeBVwFXAVcAVwJQAcAAPtcAAD4A/4D+AMAACgFjAXKAogCLgVoBAAAA10AAPAD/gPwAwAAVAPEAP4HxABUAUQCAAAHXQAJfAUYAVgJWAlcD1gBWAFYBRgFfAkAAA5d+AcAAv4DAAL4AwAAtAOsAq4LNAj0ByAAFF1AACwA6A9YBVgFXgX4B1gFWAVYBVwFAAQWXQAM/gMMCKwKrAquCuwOrAqsCqwKrgoICBddAAAAAPYPFABUBnYG1gd0BnQGFAj2BwAAKV0AAAwM7AOoCegPDgAICOgHqAKoCuwHAABKXQAA8AP8A/ADDADsBgwB/A8MAWwCqgQABEtd/AMAAv4DAALwBf4Dyg+qCq4KqgruDwAATF0gAOwPKAUoBegPDgDIDCgCqAEoBqwIYABQXQAA5g8cANwJXAn+D1wNXA2MCPwHBggABmldEACWD/QA9AD0B/QF9gX0BfQH9AiWDxAAi10AAAAA8Af+A/AJ/ARcDV4DXAtcCUAHAAC6XSAAkwCqAqoEsgcHAP4FrgWuAa4F/wUACM1dIAl8C3gFeAV4Cw4A+ATYA/gD3AbQBvAC3V0ACAAM/AMAAAAAAAD4BwAAAAAAAPwPAADeXQAAcAgABv4BIAAAAP4HAABwAAAA/g8AAOFdAAhECMgHAAT4CAQLcAiMCSAK2AgECwAI4l0AAAAF+wWoA6oD/Q+oAaoDrgX9BQAFAADjXQAAAAn+BagFqgP8D6gBqAOsBfoFAAkAAOVdAAQEBAQEBAQEBPwHBAQEBAQEBAQABAAA5l0AAAgMCAPICHwISghICMgPSAhICEgICAjnXQQCBAL8AwQBAAEEAHwERAhECEQMxAMAAOhdAAAAAP4PkgSSBJIEkgSSBJIE8gUCBAAA6V0EAgQC/AEECQAE/AMEAHQABAD8DwAIAAbrXQAFhAR0BIQEBAT8BwQFhAR0BIQEBAUAAO5dgAioBKoDrgioCfgJqA+uCaoJqAmACAAA8V0AAAAA5AckCCQIJAgkCCQIJAh8CAAHAAHyXQAABAD0B0QIRAhECEQIRAhECPwIAAYAAvRdAAAAAPwHRAhECHwIRAhECEQI/AgABgAA910AACABKAHoB74KqAqoCr4K6AuoCCAF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SAAAAP4PEAAgAMAAgABTYogAiAj+D0gASAAAAAQIBAj8BwQABAAAAFRiiACICP4PSABADAQD/AAEADwIJAjgBwAAVWKICIgI/g9IAEgIAAf4BAYEQASABwAMAABYYogAiAj+D0gAAABEAEQA/AdCCCIIIgggBltiiACICP4PSABIAAAEBAQEBPwHBAQEBAQEY2IIAYgI/geIAAAA/A8EBAQEBAQEBPwHAABnYoAAiAj/D0gAAAxIA/8AiAAIAPgHAAgABmligACICP4PSAAADPgDCAAKAAwACAAIAAAAa2KIAIgI/g+IAEgAAAREBEQERAREBPwPAABsYogAiAj/B4gAAAqiCXIEKgPmCCIO4AEAAG1iiACICP8HiABACAIIQg7+CUIIQg7+CQAIbmIIAYgI/g+IACAIUAROA8AAQghOCPAHYABvYpgAmAj+D1gAAAj4DwAIAAj/DyAIIAggCHBiiACICP4PiABACBAE0AM+AJAHFggQCBAGcWKIAIgI/g9IAAAH/ADEBAQFPAOQBHAIAABzYogAiAz+A4gIAA78AWQEpAUkAqQFZAgACHZigACICP4PSAAACEgESAP+AEgDSARICAAAeWKIAIgI/g+IAAAA/g8gBAAA/gcgCBgIEAZ+YogAiAj+D0gAAAgQBD4C0AMSBdQIFAgQBn9iAAAQBBAD9AAECqQK9AesAgwC5AAgAxAEgGKIAIgI/g9IAAAIaASoBT4CKAXoBCgIAACEYogAiAj+D0gAAAh4CAAE/gQAAowBUAAAAIpigACICP4HSAAAAPwHRAhECHwIRAhECPwIkWKAAIgI/gcAAPwHAgICAPwPBAAEBPwDAACSYogAiAj/D0gAAAAiCCoI6g82AKYAYgAAAJNigACICP4PSAAADvwBBAD8DwIA/gACDwAIlWKIAIgI/gdIAAAI3gRCBUIC3gVQCAgIAACWYogAiAj+D0gASAAAASIBTAEAAf4PgACAAJdiAACIAIgI/gdIAAAM6AMuACgA6AcICAAGmGKIAIgI/gdIAAAO/gEiACIAIgDiDyIAIgCaYoAAiAj+D0gAQAgEBKQDfADkByQIJAggBJtiAACICP4HSAAAD/8A+AcACfgIDgr4CQAEnGKIAIgI/g9IAAAMiAN+CKgFKALoBSgICAieYggJiAj+D4gAAAz8A0QARADEAUQCfAwACKJiiACICP4PSABAABAAyAcnCCUJyAgQBhAApGKIAIgI/gdIAAAM+ANIAEoASgBIAPgAAAClYogIiAj+D0gAAAD+DyIA8gwyAzIF7gQACKtiCAGIDP4DiAgADvgByAV+BkgFyARYCAAArGKAAIgI/g9IAAAAsA+sBKIEoASkBJgPIACxYpAAkAj8B1AAAACwB64IqAjoCQgJ+AgABrViiACICP4PSAAAAPwPJAQiAD4M4gciCCAGuWKIAIgI/g+IAEAECAJIAf4PyABIA0gEAAC8YoAAiAj+B4gAAAD8AaQApAD8D6QApAD8Ab1iiACICP4HCADgD5AEkAT+B5AEkATwDwAAwmIAAJAI/AdAAOgMqAL+AagA/g+oALgHAADFYogAiAj+D0gAAAj8CSQJJAkkCSQJ/AkACMZiiACICP4HiAAADPwDIgCiAOIPIgEiAgAAyWKAAIgI/g9IAAAEKATIBQoECAfoBAgEAADLYgAAiAj+B0gAAA/+AMgHAAn+CggK+AkABM1iCAGICP4HiAAAAPgPiASOBIoEiAT4DwAA0GKIAIgI/AdIAAAIvASkAqQBpAikCLwHAADSYogASAj/D0gAAAD+D5IEkgSSBJIE8gQCBNNiiACICP4PSAAIAYAA5A9cBEQERATEDwAA1GKIAIgI/g9IAAAMiAN+CKgFKgKqBWoICAjWYoAAiAj+B4gAIACQAM4HSAjoC0gI6AsICNhigACICP4PQAAQAMgDLgEoAegJCAj4BwAA2WKAAIgI/gdIAAAAvAcgBP4HIAQgBLwPAADaYgABGAn+B5gAAAiYBNQDkgCQANQPmACgANtigACICP8HSAAAAKIPmgSGBKIEogSeBwAA3GIAAJQMlAL8AZIAAwAoASoB/g8qASoBAAHdYogAiAj+B0gAQAEUAVQB/A9UAVQBBAEAAN9igACICP4PSAAABP4DAAG8DAACwAE+AQAO4GKAAEgI/gdgAP4MiANwBPwJBAj8CwAKgAnhYogAiAj+D0gAAA74AQgEiAduBAgFCAUIDuJigACICP8PiAAADpABfgwQBPIHlAhUCBAE42KAAJAI/AeQAAAE6AK4CqwI6A+IAIgCCATlYoAAiAj+B0gAAAz+A5IAkgD+D5IAkgj+B+ZigACICP4HiAAABJIElgSQBJgElgQQBAAA6GKAAIgI/geIAAACHAnQBH4FUALUBVQIEAjpYogAiAj+D0gAAAKkApwC1A+cAqQCJAIAAOxigABICP4PSAAAAJIPkgj+CJIIkgiRDxAA7WKAAIgI/g9IAAAEUATQBxAE/AEQBhQMAADvYoAAiAj/D0gAAAnSCCIK+gsmCNIIEgkAAPFigACICP4PSAAACIgE/gKIAIgA/gKIBIAI82KgAKgCagJsC3gL7gcoAygDbgKoAqAAAAD3YgABEAn8B5AAAAAoAagD/AqoCrgKqAYkAPxiAAEICf4HyAAACIkE+gOIAIgA/A+LAIAA/mKIAIgI/gdIAAAAmA+EBKIEogSkBIgHMAD/YggByAH4AfwF+gX6A/oB/AH4AfgBiAEIAQFjkACQCPwHUAAAAKgCqAK8CKgI6AeoACAAAmOAAIgI/g9IAAAIJAkkCb4PJAkkCSAJAAAHY4gASAj+D0gAAADeB2QFZAVkBWIF4gcYAAljCAEIDf4DCAhACFwIxAV3BkQDxARcCAAAEWOAAIgI/g9IAAAJiAT+AwAA/gdACJwIhAYWY4AASAj+D0AABABUBFQLRgnUCFQIBAYAABljiAJKAiwCuAqqCuwHqAKIAj4CSgJIAgAAH2MAAQgJ/gfIAAAIqAiIBv4BiAOoBIgIAAAgYwAAiAj+B0gAAAikBKYDvAC0D8wIrAiABCFjiAGICP4HSAAABC4FIAU+BSAFKAXmDwAAI2OAAIgI/g9IABAAWAlWCfQHXAFUAfABQAAkYwAAiAj+B0gAAAhEBEwDNgAkAFwPRABEACVjAACICP8HAACWAtICsgKaAtIPkgKWAgACKGOAAIgI/gdIAEAJLAUrA+gDKgMuBSgJAAgqYwAAiAz/AwAIkgb+AZII/gf8DwIA/gMAACtjgACICP4HSAAgCBwJYAn+DyAJHAkgCUAAL2OAAIgM/wOICAAO/gHCD1IE0gVSAVIOAAg6YwAAiAj/D0gAAgw+A+IEAAgiCf4JIgkiCT1jgACICP4HQAAQCPgIlASWAvQBnAeUCPAIRmOAAIgI/wcAAP4PAgRSBPoFUgQCBP4PAABJY4AAiAj+D0gAAAy8AyQE5A+kCKQIvAgACE1jiACICP4PSAAAAX4BagFqAeoPagF+AQABT2OIAEgI/g9IAAAEvgSqBKoHqgSqBL4EAARQY4gAiAj+B0gAAADuD6oCqgKqCqoK7g8AAFVjCAGICP4HiAAAAOgPqAKoAv4PqAKsCuwHXGOIAEgM/gMACLwErAWsBv4ErAasBbwIAAReY4AAiAj+D0gAAAiUBJYC1AGUCJYMNAMAAF9jgACICP4HSAAACOAJLgQqAqoBKgQuCOALYWOAAIgI/g+IACAEmAUkBKIFJAQIB9AEAABiY4gM/gNACBAI+ASUApYB9AGcApQE9ASACGNjAAEICf4HiAAABvwEhAaWBIQGvAiABwAAZ2OAAEgI/wdIAAAAagK+AqsPqgLqAqoCAABoY4gAiAj+B0gAEABMB1IFegVSBUQFSAdQAG5jQABICP4PSAAAB/4AMgeyBPIEsgS+BwAAcmMAARAJ/A+QAAQC1AdwCVwNUA1UDtQIQAN3Y4AAiAz/A0gIAgiqBqoEqgT/D6oK+goiCIBjAACICP4HAAD8DxQA9A8AABQO6gEIBjgIg2OAAEQI/wcEAGAAtQe1APUPtQC/BOADAACIY4AAiAj+B8gAYAhoCKQEqgeiBLoGagUACIljiAj+B0gAAAL4AqgCqAKuD6wCrAL8AgQCjGMAABwCzQL/AvwK/gf8AvwC/wKNApwCAACPYwABCAn+BxgAjAKqAugDqAKoCogI+AcAAJJjiACICP4PSABAAAgBKAHWDvwHKAEoAQAAmGOAAIgI/gcAAP4PCgDqDooI6g+KCO4OAACZYwABCAn+B4gAAAKsCqQK6geiAqoC6gOAAJtjgACQCPwHAAAoBb4HKAUAAPwPQADAAAAAoGOAAIgI/g+IAAAE9AKUCJYHlACUAvQCBAShY4AAiAj+B0gAAASUAoQB1A+CAbICigQAAKJjAAEICf4HwAAMBKQClAHED5QBpAKsBAAApWOAAIgI/gdIAAAIpAqsC6YEpAa0BaQIoACnYwABiAj+D0gADAikCJQIhg+UCKQIDAgAAKhjSABICP4PQAAwAPwPqgSoBP4HqASoBAAEqWOAAJAI/AdQAAAA6AO4AqwC6geoCrgK6AuqY4gASAj+D0gAAADUB14FVAVUBV4F1AcAALBjAACUCPwHsgA4BuYB/AMQCJII/geSAIAAsmMIAQgJ/gcIAAABvgPqBaoEqgKqCL4HAAC3YwAAiAj+B0gAAg74AU4HAAD+DwIA/gMAAMljgACICPwHSAAACXQFHANcD3wDFAU0CRAAz2NAAEQE/wMkAAAA9A+UBJcE9AeUBJcE9A/QYwABCAn+B4gAAAy+AqoEqg+qCqoKvgqACNJjAABEBP8DRAAAAOoPqgQKBP4HCQTpDwAA2mMEAYQM/wfEAAAG3wNVCVUFVQNVCV8HAADbY4AAiAj+B4gACAh4CTYFlAM8A1AFcAkACOFjAACQDvwBAAz8AzQItAr0CrQPtAq8CgAI42MAAIgI/gdAABwPsACwD/4AsA+wALwPAADqY0AAiAj+B0AAEgH+D0IAGgwAA/4AAAM4DO1jAAEICf4HiAAAAP4G6gSqBaoIqgi+BwAA7mMgAEgI/gdIAAAC+gK6AroC+g+6AroC+gL0Y4AAiAj+D4gAAgRWAvIJ1gbSBNkHVQhACPpjiACICP4HSADAAIwOpASsBOwHogSyBKoO/WMAAIgM/wNACB4IwAteCEAHVgjUCwQIAAQBZAAASAj+BwAA8g9CAFgHqgLaAgIL/gcAAAJkQACICP4PSAAACKoKmAveBJgGqgWqCIAABWQAAIgI/gdAABoI/AU4BLoHOAjuCQoIAAYNZIgAiAj+D0gAAAjsBewD7AHsAewF7AkACA9kgABQCPwHkAAAAHgDeAN4AX4JeAl8B3gBE2SAAIgM/gNICAAM1QNWCHwJVA9XCVQJAAAWZAAACAn+B4gAAAJUCsQKpgqeD4wKhAoAABxkiAj+B0gAAAi8CLQJoAb+BKAGtAm8CAAIHmSAAIQI/wckAIAPWgBaB1sFWgdaAMIPAAAsZAAAEA78AYAM+AN+CfgHAADeDUICngUgCC1kAACICP4HSABAAG4HVgVcBWQFTgdEAAQANmRAAEgI/A8gAJAPaAB4B3QFcgV0BWgHEAA6ZAABBA3/B4QADAj/BasDqgH/BasDqg6CAERkAACIDPwDKAiABLwGvAG8BbwGvAakCQAARmSAAIgI/gdAABwFVA1cC9QJXAVUBVwJAABHZIAAiAj+B0gAAAasBKQE6geiBKoEqg4AAEpkAABICP4POALIATgBMAD+D6gE/gesBAAEVGQAAIgI/geAAIgCBAK0Au4OxAIEArQCgABYZIAAiAj+BwgA4A8UAFwH9gVcBxQI9AcAAGdkAABICP4PSABMAOgHaAVuBegHaAVsBQAAaWQADPwDBAC0A7QLtguEB7QDtAN0A3QDVAJ4ZIAASAj+D0gAAAl0CXYH9AF0A3YFdAkECYNkAAL8A/wD/gv8C7wH2APWA1IDdgNUAoACh2QAAIgH/gDwD14A/AdwAPQHOgbFATwGAASQZJAAkAj8B5AAGAj8C9gG3gbYAv4PmAIAApFkgACQCPwHAACYA/wL2AvcB9gD/AMYAwAAkmSICP4HSAAQAPQPvgK0Cv4PEAjuBogDeAyVZAAAkAj8BwAA/A1YAfwFAAD4DyQA5A8kAJ5kSAj+B1gAAAj0CvQK9Ar2D/QK9Ar0ChAIpGRAAEQM/wcAAPIPvwLaDxAIOATHA3wMAAClZAAACAn8BwgAoAu8CuQOQAsoBfwHqAkAAKtkAAGQCPwHUAAADfwBKgHoDSgB6A0oAegNrWSAAIgI/gdYANQAVAe8BbwHlAW6BdIHkACuZIAAhA7/AWAE4Ae/BrUG9Q91BHUD/wVgBLBkAACICP4HoABOCfYFVgVAAU4F9gVWBUAJsmRAAEgI/g9IAAIJeAVuA+gBbgN4BWoJAAi8ZAAASAf+AAAO/AEsAdwHrAN/AqQDFQQAA79kAACICP4HCADoDLQC9AQSAPIMtALkBAgIwWRAAEgI/gcAALQMZAMEAPoHVAX8B1QFAATFZAAAiAj+B0AAfATMB/wH/gf8B8wHfAQABMdkAABICP4HIAC+AvoCvgK6D74C+gK+AgAAymRABPwE/Af+B/wO+A+QB+4GogbmBqgECAHLZIAASAj+B0gAAACaB/wF2AXeB9gF/gWKB81kAACQDPwDEAjABbwF9AOUD/QDvAXgCQAAzmQUADwCvgO4A84LvAuED6gDtgOUAywDRALSZAABiAj+B4gACA7EAZIH2gXyA7QJxA8AANRkgACICP4PSAAYDvgBrgy8D8wPvA/IDwAA2mSAAEgI/g8ABPgDGADYBf4DfA9sAWwGAATgZAAAiAj+BwgAYAzUA+QCvgK8ArwC7A8EAOZkAAAIDf4DCAksCZQB1Am+D7QB9AEcDQAA7GQAAIgI/AcAAF4N1ANUDAADLAT0DzwJZAj0ZIAAiA7+AQAM/ANECPQL9Av2A/QL1AsAAPpkAACIDP4DwAh2B8oM7gcKAG4GqgquCgAA/mQAAYgI/gcIAMIIfgreB14HXgf+C8IKAAgAZVQAzAJeAkwD4AvmC9QHwgNIA14CzAJUAA9lAACYDP4DAAjoB2YC9A8AAN4H1Av0CgAAFGUAAIgI/gcAAP4H9gR+A/AH7gP2CP4HAAAcZUAAJAT/AyAAiw9+AfoCewb6AXoE+wcgAB1lAACQCPwHUADEA/wC/A88APwD/APkByACJGUAAAAASAj+D/4L9Af+DvQPrgT6B6gEAAAvZQgIKARoBKgEKAM+AigDqARoBCgECAgAADZlAAD8AwABAAH+DwAAMARuBIgD6AIYBAgIOWUAAOQBJAIkAXwFYAwwBM4CCAHoAhgECAg7ZQQBBAH8AQQJZAkQBG4CiAOIAngECAgAAD5lAAgIBvgBKgjIByAAEAzuAogDeAQICAAAP2UEBPQDBAL8AyQCZAgwBO4CCAPoBBgIAAhFZQgAyA9IBH4EyA9gCDwEygKIA3gECAgAAEhlCAioBIoCjAMoBEAAMAzOAogDeAQICAAATGUAAJIPkgT+BJIEgg8gABQM6gKIA3gECAhPZUAA+AFWAfQFVAX0A2AJHgTlAsQDPAQECFFlCAJoCQgJ/g/IAAoJYAh+BIkD6AIYDAAAVmUABFQC1AH+BNQE1ANAAH4GiAFoAhgGAARXZQAI/AVUBVQB/AVgADgMzAKIA3gECAgAAFhlUAJYCVQI8gdEAGQLMAjuBAgD6AQYCAAIWWUAAlQCVAneD/QBWAk2CHwEiwPIAjgMCAhdZQAA9g/QAf4P0AH2DwAIPgTJA+gEGAgAAF5lAADuD+ABfgKgCe4PQAh+BIgD6AQYCAAAYmUAAAgC+gOqAqoC/g8AADAM7gKIA3gECAhjZQAA6g+vAqoCrwrKByAAGgx1AsQDPAQECGZlCAL4CtgK3A7YA3gKYAj+BAgD+AQICAAAbGVEAPQDVgHUCRYM9AMwCG4GiAHoAhgMAAhwZaAIqgqYB/4EmAeKCCAIPgTJA4gCeAQICHJlAAD0D/QD9gJ0CfQHAADgDD4DKAPoDAAIdGVAAFwIPAi+DrwI3A/YCrYKtApMCEQIAAB1ZQAA+g8OA/sCDgn6BxAAPwzEA3wGBAgAAHdlAAS/AqsB/wWrBb8DmAg/BMIDcgIODAIEeGUICXwLfAv+BXwFfAtgCTAE7gN4BAgIAACDZQAAXQl+Bf8HVANeAWgA5gNWBVwFZAVABIdlAAAICAgIGARoBIgCCgGIAmgEGAQICAgIiWUiBBIM0gNWAVoBSwFKAVYBVgHSBxIAEgCLZWQAZA9kAVQBXA/WAVQBXA9kAWQJZAdgAIxlCAhoBI4DfAIACNQP9AcQAP4D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/g8oAIwARAAkACQA/A8EADQAxABwZ4gIiAZIACgAGAL+DBgAKAxIAIgGiAgIAHFnAAAEBPwErAKsAf4PrAGsAqwC/AQEBAAAfmeIAUgA/wdIAIAEOASGB2AEAQSOBTAGAAB/ZwgDiAD+D4gAAAz8A2QIpAUkBqQFZAgAAIFniANIAP4PSAAADIQDfAiEBTQCLAXgCAAIhGeIAUgA/g9IAAAAnAFqAQgJyAkIDPgDAACJZ4gDSAD+D0gAiAAACEQIRAj8D0QIRAhECJBniANIAP8PSACIAAAM/AMiACIA4g8iACAAlWeIA0gA/g9oAIAIOASIA34A6AcICDgIAAaXZwAAiAFIAP8PKAAoAoABSAD/D2gAiAMAAZpniANIAP8PSACgCBAEbgSIA8gCOAQICAAAnGcAAIAEvgSqAqoBqgH+D6oBqgK+BIAEAACdZ4gBSAD/D0gAiAggBKgEKAU+AigF6AQICJ5ngAFIAP8HSAAAB/4AAASAA34AgAMABAAAoGeIA0gA/g9IAAABJAEcAQYBhA88ASABEAGiZ4gDSAD+D0gAAAD8DwQIFAvkCLQJBAoACKNnAAAEAbQAlARUBH4JVApUCpQKtAAEAQAAqmeIA0gA/w9AABAAyAckCCMJJAnICBAGEACrZ4ABSAD+DygAQA/8AAQG9AEEAvwHAAwAAK9niAFIAP4PSABAABAPkAT+BJAEkASQBxAAtmcAAKQIlASOAoQB3A+AAbwCpAKkBLwEAATEZ4ABSAD+DygAAAD0DxQAlAF8AJQJFAj0B89nCAGIAP4PSAAAAPgPiASOBIoEiAT4DwAA0GcAAIQEhAS+AqwB7AesAKwBvgKEBIQEAADTZ4gEqgSqAoACpAG0D44BhAL8AsAEwASwBNRnAAlQCVQFNAN8A9wPdAMcAxQFNAkQCQAA2GeIAUgA/g8oACgBgAD0D0wERAREBMQPBADcZwgDiAD+D0gAAAD8DyQJJAkkCSQJ5AkECOVnAABICCgIqA9YDVwNSA1YDagPKAhICAAA72eIA0gA/g9IAAAA9AMUAfQJBAj8BwQAAADxZwAAiANIAP8PyAAICQAIigj6D4wIiAgICPNngANIAP4PAAD8CQIF+gIAAPwPBAD8AwAA9GegBL4EoAK/AqQBgA+fAaQCpAKkBKIEkAT7ZwAAJAgUCNQPrAquCqQKrArUDxQIJAgAAANoiAFIAP8PSAAAD/wAFA70AVIIUgjSBwAABGgABFAEXAJQAdIA1A/QAFABWAJUAlAEAAQHaIgBSAD+D0gAiAQgAqQJJAjkDyQApAEgBgtokANQAP8PUAAEBnwBRwjkD0QARAMEBAAAD2iIAUgA/g9IAEAEEgSWBJAEmASWBBAEAAARaAADiAD+D0gAAAbkARwDQADQCRAI/gcQABZoiAFIAP4PaAD6D4oFfgQKBH4EigT6DwAAF2gECXQJVAVUBXwD1A9UAXwDVAVUBXQJBAkhaIgBSAD/D0gACAhgBBgE2AIOAcgCKARICCpoiANIAP4PaACABBAETgPIAP4PyAFIAkAEN2gIAYgA/g9IAAABSgFKAfgPSAFOAQgBAAA4aIgBSAD/D0gAiAggBGgFmAROAigDqASICDloiANIAP8PSAAAAP4PUgjSCFIBUgZ+BQAJPGjEASQA/w8EAEwA5A9nBFsEWgRmBOIHQAA9aBAEVAJUAd4PVAFUCRAE/gIQA9IEFAgABj5oQAhkCRQFBAU8AwYPRAE8AwQFFAUkCQAIQmiIA0gA/g9IAAAIJAkkCb4PJAkkCSAJAABDaIADSAD+D0AADAmABP4DAAD+B0AInAgEBUZoiANIAP4PKABAAPwPBAhUCvQLVApUCgAISGgAAJQJlAW0BVQDVg9UAXQDlAWUBRQJAAhMaAAAAAl4BVgFWAPeD1wBXANcBXwFBAkAAFBoCAOIAP4PAAD8DwQA1ANUAtQDBAj8BwAAUWiQCZgFXgV+AxYBhg9WAVoDWgWwBYAJAABTaMQBJAD/DyQAAAT9BSUFJQUlBSUF/QUBAFxoiANIAP8PSADKCEIIxAVxBlYCQAXcBEIIY2iIA0gA/w9IAAIELAUgBT8FIAUoBeYPAABlaIgBSAD+DygAgAhUBDQDHAAUADIPUgCAAGZoiAFIAP4PSAAAAXwBAgGQDz4BSAFGASQAaWjEASQA/wcUAAAO/AEEBCUE9QckBCQEAAB2aIABSAD+BwgA4g9SAVoB+g9WAVIJ8gcAAH9oiAFIAP4HSAAAAX4BagFqAeoHagF+AQABgWhMCWAJEgVYA0IDMg8OAUIDQgU+BQwJMAmFaBABkAD8D5AAoATYA6wCqALoC6gK6AeAApNoCAOIAP4PSAAAAFQBRAHGD3QBRAFEAQAAnWgAACAA/A8CAPgDAACoBq4AlA+0AKwCpASiaIQBRAD+DyQABADxB1YBUAFeAVAF9gcAAKZoAAASCYoEXwRGBWoCSAJKAd8ARgAKABAAp2iIAUgA/gcoACAAqge+BKoEqgS6BKIHAACoaEAIKgkaBX4FGQOqDwABHgNABUAFfwkACa1ogANIAP4PSABAClgJHgXKBpgGngmoCAAIr2iIAUgA/g9IAAAE6gSsAvgPqACuBLgDAACwaAADiAD/D0gAgAzoA4gA6A/+BAgH6gggBLNogAFIAP4PSAAADLQDLACnDyQAtA8gBAAAtWgAADQIDATeA0wBVAFAAkwA3gcMCBQIJAa2aIgDSAD/D0gAAA/+AAoCqgLqB0oJTgkABMBoCAGIAP4PQAAQBQgFJASiBAwGkAVQBAAAxGhECVQF1AXMA8wB7g/MAcwDzAPMBVQFVAnJaIQDRAD/DyQAQACeB6oAqgDrD6oAvgSAA8toiAFIAP4PaABACQgF/gVYAVgB/gEIDQAAzWiQA1AA/g9QAAAA/A9UCVQA1Ad8CQAFAADSaIgBSAD+D0gAAABsAjwCrg+sAjwCbAKgANVohAFEAP8PZABMBkQBVATXB1QARAFMAgAA2miAA0gA/g8ABP4Dkgj+BwAM/gOSCP4HAADfaIgBSAD/D0gAAAT8BKwCrAH+D6wBrAL8BOBoAAgYCQoFfAVYA94PWANYA34FCgUYCQAA42gIA4gA/g9IAIAIFAZUAP4PVABUBXwFEAjuaAAApASUAtQPjAKMBD4EjALUD5QBpAKABPVoAADEASQA/w8kAAAD3wD1B/8H1QBfA0AC+miIAUgA/gdAABwA/Af0B1YFVAVkBQwHAAAFaYgDSAD+DwgAIAC0B6wCrgssCOQHIAAAAA1pyAAoAP8HCADgDwQE/AVcBV4FXAX8BQQEDmmIAUgA/g8AADAA/A+qBKgE/geoBKgEAAASaYABSAD+DwgAIA3+AygIgAkcBOQDdAYMCBxpkANQAP4PEADwCTgJNAXyAzQDOAX4CRAIMGmAA0gA/g8AAPwDVAL8DwAA/g8CAP4DAABKaRADkAD8D5AAAAj8B9QB1AXUA9QJ/AcAAFNpgAFIAP4DAAz+A0IAqgT6B6oEQgT+AwAMWmkAAFQITAZeA1QEwA9UCUwJXglMCNQIAAheaQADiAD+D0AAHAhUBNwDVAFcCVQJXAdAAGNpwAEkAP8PFACAA38A5Q9VBVcFVQX1DwcAbWkICWoFbAV4A24B6A9oAX4DbAVqBQgJAAB1aYgDSAD/DwgA4gmiCO4I+gtCCJIJcgoAAHxpgAFIAP4PKACICKoKmAfeBJgGqgWqCAAAfWkAAKQEpASAAvwB1gfUAfwBgAKsBKIEAACCaQADiAD+DwAA/AdUAnwJIATEA3wPRAhEBIZpgAFIAP4PCADwB7gC9A8WANYDBAjoBwgAnGmIAUgA/g8IAEAIXAbcAVYJVAlUCVQHAACuaQAE4gTsBK4CogCgD7IAqAKmAqgEogQAALRpAAOIAP4PyAAAALwPogqQCqQPnAqECrwPy2kAAMgDKAD/DwAA/A++ArwC/AO+CvwHEALNacgAKAD/BygACAboAXwHewV8BXQFdAcAANBpgAFIAP4PCAB8AFQIVgf8ANQHVAl8CwAI2GkIA4gA/g+IAAAEVgVUAPwPVAJWBVQFAAD9aYgDSAD+D0gAegDaD/8K2gr/CtoK+g8AAAJqwATsBNoCwAK8ANYH1gD8AogC9gTgBAAAEWqIB0gA/w9IAYQBJgkMDbgPDgF+BRAJAAATaoABSAD+D2gAAAh8C3wL/AV+BXwHfAl8CRlqiANIAP8PSAAcBWwBfAlsD3wBbAV8BQAFHmoAA5AA/g8AAPwHBAn0CtQLVAm0CoQLAAAfaoABUAD+D1AAAAL0AvwC9g/0AvQC9AIQAiFqgAFIAP4PaAAACXQFdgP0AXQDdgV0BQQJI2qEAUQA/w9EAAANKwOqCD4HagIrBaIMAAApajgDuAD8B7gAKACAAOwHuAeoB6gHqAcAACpqiAFIAP8PSAAICPoJXwVaBfoBXwVaBfoJMWqIA0gA/g8AAF4JOguODRwFQgV6C0IJXgk5agADiAD/D8gA4Ai0Cr4M9AYABJAA/g8QAEtqkANQAP4PEAAyD7IA8gf+BfIH0QCwDyAAX2qIA0gA/w9AAOYMuAO0Ct8IpAe4CrQIoARhaoABSAD+D0gACAS4BWwD7gq8CawHrAE4AmtqiAFIAP8PSAASCPIFfwV6BfoBfwVyBfIJlGqIA0gA/w9AABoH/AXYBd4H2AX+BYgHAACiaoABSAD+DwgA2Ay4AvQEFgDEDKgC6AQACMNqgAFIAP4HAAD+BwIE/gX+Bf4F/gX+BRIE+2qAA0gA/g8IAH4JLgv+DQAFXgUuC14JAAAEa4ABSAD+DwAA/gfuBOYD8A/mA+4M/gcAAAprCAOIAP4PiAEwAdQPNg+ADzYPVA90CQAAIGtACDAIDAQKAogBeACIAQgCSAQ4CAgIAAAhawAABAaEAQgIYAgeBAoD6AAIA0gEOAQACCJrFAQkAsQBPAMECDAEDgPoAAgDKAQYCAAAI2sABPwDFAAUAPIHAgAwDA4D6AAIATgGCAgnawAA/A8EBaQE1AQEDWAMHgf4AAgDeAwICDJriADED6IEkASSBOQHsAwOA/gACAM4BAAIOmsAAAgJ/AVYAfwFAAEwDA4D6AAIAzgMCAA9a1AIWAtUCPIHVA0ACDAEDgPoAAgDOAQICD5rAASqAqoIrweqAKICMAgOBugBCAM4DAgIR2sAAf4HqgSqBaoIvgcAABwOygEIAjgMAABJayQErQL+B/wDrgH9BDgMBwPkAAwDBAQAAExrgAC8B6wFvAeECLwHsAgOBvgBCAN4DAAAUGsAAP4DggTaBaoE2gUADBAD7gAIAygMGABTayAB7A+sB7gHqAfgDGAEHAPwARAC8AwAAGFrAAG6D7sHgAe7B5oHMAAPDuQBBAN8DAAAYmsABAAE8AcABAAEAAT+ByAEIAQgBCAEAABjawAEBATkBwQEBAQEBPwHRAREBEQERAQABGRrAAjwDwAIAAj+ByAEAAD+ByAIIAgQCBAGZWsgCCALvAigCCAIIAT+ByQCJAKkAaQAIABmawAAEAjUBxQE1AeUBBAE/gAQBxQIFAgQBmdrAAjwBwAE/gcgAggKaAioBT4CKAXoBAgIaWugAKAFfAhgCCAFIAX+BCQCpAEkAKQAIAFqayQIpAikDpQIlAi8CIQPlAqUCqQKpAoACG9rEADQBxwE0AWQBd4FngW0BRQE9AfwBxAAcmsIDOgDKABsC+gHaAIuCXwErAO8BKgIKAZzaxAO0AFQBNwC0A/QAF4J9AxUA3QFVAkQBHRrAAz8AwQIVAh0DxQIhA9UCvQKNArUCAAAd2sADPwDBAhsCPwObAgED2wK/ApsCqQIAAB4awAIfAdUBNYHPAVAADwHvAD8D7wAqAcAAHlrAACEAEQIJARUBJwCFAGUAHQAFAAEAAAAe2sAAMQIZAScBhQB9AAEAPwHRAgkCDQIJAZ8a8AAIgieBBID8gAAAEQARAD+D0IAQgBAAIprgABiCB4GkgFyBBAETgPIAP4PSAFIAkAEi2uAAOIIngSSA3IAAAioBP8EaANlBVUJQASWa0AAYgxeApIBcADkDwQE/AVuBWwF/AUEBJhrgABiCF4GkgFyCAIJqAUvBxgFXQsVC6AItGsAAPwPFAXkBBQNQAzeCEIHQgb+CWAIGAi1awAAAAL8D1ICUgIRCUAI3gVCAl4FoAgYCLdrAAz+A1UJVQk9B0AA4AheB0IG/gVgCAAAumsAAFIGVAHMD1MBAAjeBEIFQgJ+BeAEGAi8awAAbAxsA+4A7AcEAmAI3gRCA14DwAQACL9rAAf/APUOpQD1AqcEAASvAqECLwHoAgAEwGsAAHwJUglAB1QFPA1ACH4JQgb+CWAIAADBawAA/ATSBMAH1AQ8AkAI/gVCAv4FYAgAAMVrAABUATQL1goUB8QCEAjOBUIC3gVQCAAAy2sAACAA4Ak8BSQDpAF8CSQJJAf8ASABAADNawAAIADwAy4CogKqAqoKIgoiDv4DIAIAAM5rAABIAMQHcwJKAsoDegpKCkoO+gNCAkAAz2vAAMgC6AOmApQDlAPUA5QKlAr0B8QCwADSayABIgHqB2oFagX/B2oFag1qDeoHIgUAAdNrEAD4B7YFlAz0BwAAtA8sAKYPJAC0ByAI1GsAAAAA/g8gBCAEAAD+B0AIIAgQCBAHAADVawAAQAF+AUgBKAGADz4BSAFIAUQBJAEAANlrAABACn4L5AdkBVQDXgDkB2QKZAlQCUAE22sAACgBKAEoASQB/AckCaQIkgiSCJAIgAbrawAAxAT8BewF7APuB+wL7ArsCnwKxAoAAO9rJAEkAfwHkgiCCCgKZAoQCc4JEArMCgAED2wAAAAI/AckBCIEIgR+AKIDIgQhCCIIIAYRbAAAAAj8B6QEpASkBOQEpAGkBrwIgAgABhNsCAD4AQoCCAIACP4PkgiSBPIBkgaeCAAEFGwgABgARgBVAFQAVABUAFQA1AMUBAQIAAQXbAAIWAlGBVQCVALUBdQEVADUAxQMBAgABBtsEAAYCYQFIwMqCSoJqgeqACoB6gMKDAAGImwIAKgEtgW+BXwHfAW8BbwFHAD8AwQMAAYjbBAAGAlEBSMBqg8qASoBag0qAOoHAggABidsEADIAsQC3gLcD9wC3ALcAhwA/AcECAAGNGwAABAEEAKQAXAIAAj+ByAAwAAgARgC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AAF/BNUH9wTdB4AErgelBKQHBATubwAAEgakASAA/g9jBXgD7gF+BXgFKgkAAP5vAACBB0EAAAP+DPoBXgXrB1sHUwH3AwAEEXAQACQPJACABbwE/A68DLwO/AK8BLwJgAIfcBEEpgMAAAIAEwy6AzoD+A86AbsHugO6DyxwEAyiA4QANgZUAf4HJgHyBG4FagH6BQAETHAAACIIRAYEA3QO1A82D4QPdg9UD3QPAABRcAAAIgasAQAE6gPqB/oF4gHqA/oF6gUABGNwEAAmD0AAFwJNA6ADnAO2C/oLXAcSAkAAa3AACGAIGAQAAoABfgCAAQACQAQ4CAAIAABtcAAAAghCBDIEAgLCAT4AwgACA2ICEgQABG9wQAhwBAAC/gEQAgQABAgECPwHBAAEAAAAcHAEAoQBdAAOCOQEJAIEAfQABAFkAiQMAAB1cAAIAAmqCCoEKgKqASoCKgQqBb4IAAgAAHZwcAQADv4BAAEYBQAEIAQgBP4HIAQgBCAEfXAACAwJ0gQABAgD1gACAwgEDAXSCAAIAAB+cAAAmAiICGgECAIKAewACAMIBMgEGAgAAH9wOAgABv4BAAMIAPAHAAQABP4HAAQABPgPiXBwCAAG/gEAAjgIAgzyA5IAkgCSAPIBAACOcAAAQAgoCaQEIAQYA8YBGAIgBKQFJAhACJJwQAAwDv4BAAEYCkAIOAQABP4CAAKYASAAlXA4CAAG/gEQAgAI6AcqACoA6AcICAgGAACrcDgIAAb+AQADCABIBGgG2gVIBCgHCAQAAK1wAAzsAygIqAmoBC4GqAEoAigEKAmsCCAIrnBwCAAE/AMwBgAA+AcuCSgJ6AsICvgJAASzcBgIAAb+AQACGADgDxQAnAF8AJQJFAj0B7hwcAgADv4BAAIoBDAADgD4DygBKAEoAQgAuXAAAAAM4AKgAKAGvgCkAqQEpADkAgQEAAC6cAABiAyKAsoAuAasAKoCqAi4CuAIgAcAALxwOAgABv4BCAEQBHQDXgj0D0QARANEBAAAwXB4CAAG/gEIAxAAPAekACQI9A8kAKIDIATCcHgIAAb+AQABGAEABJYEkASYBJYEEAQAAMhwIAkSBw4DygBqDBoAAAR8CQABAAX+BQAIz3AACAAM/AFUAVQFVAFWBVQBVAtcCUAHAADYcDgIAAb+ARACgAiIBP4CiACIAP4CiAwACNtwQAgwBv4BEAYABPgIiAj+B4gE+AYACAAA33B4CAAO/gEQAP4PAgQiBfoEogUCBP4PAADkcPAIAAz8AwAEEAUAAagD/AqoCrgKqAYkAOZwIAQYBAAD/wAIAwAI+QQJAu8BCQT5BQAI53B4CAAG/gEAApAIhASmA7wAtA/ECKQIgATrcAAIighiChQJAAQqA1oELgSaCIoKeAgAAO1wAAAkBCQDfwAUBoAAZAA/BwQAfAKABkAICXEAABAIFAT0AVQJXANcAVwDXAlcCRQHAAAVcSAIEA7+ARACgAj4BJYC9AGcAvQEgAgAABpxAAAkChQLvgQMBKQDMAIMBH4FDAUUCCAEIXEoCCgN/gElAfwNJAH8BSQJ/AEkBSAIAAAmcRAIEAz4AV4BWA1YAfwBWg1YAVgBCA0ACDBxeAgABv4BAAI4ANAPSAUGBUQEXAXEDwAANnGICKgGbgJuABQFDAGAAGgGHgBoAooOgAg8cUAIOAQAAv4BEAikBPQDpgCkD/QIpAgABExxeAgABv4BAAKQCPwK1ArWD9QK1Ar8CAAATnEECfwEXQReAVwN/AAEAHYMBQH8AQQMAABVcQAAAAj+BLIAzgK6DAAA/gQSCRIDng8ACFlx8AgADPwDIAj0CpQK/AqUDvwKlAr0CgAAXnEAABgJVgVUAVwN9AEAABwN6gjIAjgFCAlkcTgEAAb+AQABEASEBL4CrAHsB74BhAIABGdxAAj8DZQAlADsDBQAzAFEBVQJVAHMDQAIaXE4CAAG/AEQAgAI/AusCqwCrAasBvwLAAhucQAAMA40APQBdAV+AXQFdAV4AfQBEgwAAH1xAAAQDv4BEA78A6wEbADqB6oEagL6DwAAhHE8CAAG/wEIAgAM/gCqBqsIqgqqAP4GAASKcQQEfAc/ALwAvgb8AAACZwSqAIkCRAwAAJRxGAAgDP4DEAQkAZQPRAkmCUQJlA8kAQAAmXEABAAG/gCSAO4GugAAAH4GkgSSAJ4CQASfcQQIvAy8Af4BvAwYAIgFfggIAPgEAAmAAKxxAAGcCHwEXgFcDdwAEAAIBb4MyAC4BAgJsXEAAEwJXAXOAVwNLAEIAZgMfggIAPgFgAjDcTgIAAb+AQgJMASuAHQODADIDj4AaA6KAMhxGAQAB/4AKAFSBLoFugS1BLYH+gUYBCgA0nEYCCAG/gEQAgwI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/g8SAPIDAABOc1AJPgUYBX8FEAO0AToDHwPaA3YFEgUQCWhzAACUC0gI8AdMAPQFfAX0B3wN9Az8BwAAcnMAAJYJWAjmBwAA9An+C/QF/AX+C5QJBAh1cwAAMgmMCPIH5A/aC9AAvg/SCZAO/gwAAHhzAAD+B/oF/gX0BeoPBgwQA/4AkAMWDAAAe3PQDygAvg/+B+wP3AcADBAO/gEQAxQMAACEcwgIKAhICKgGGAWOBEgEKAUoBggECAgAAIdzgAK0AgQClALsAqYOlALEAhQClAKEAgAAiXMACEQIRAhECEQI/A9ECEQJRAlECgAIAACLcwAERAREBEQERAT8B0QERAREBEQEAAQAAJFzAAAkBCQC/AMkAgAI/AcEAAQA/AcACAAGm3MABiQC/AMkAQAABAF0AUQBRAl8DMADAACpcwQEJAL8AyQKAAkkBOQDJADkDyQIJAggBqtzBAIkAvwDJAEECTAEbgSIA4gCeAQICAAIr3MABCQC/AMkAoAAxAAkAPwPBABkAIQAAACwcwQEJAL8AyQCAAj+BAIC+gECB34IAAgABrJzAAIkAvwBJAEAADAASAJUAkYNyAhQABAAu3MABCQC/AMkAAAM+APICX4GSAbICRgIAADCcwAEJAT8AyQCAAD0AxQB9AkECPwHBAAAAMpzAAAkBPwDBAJACP4HQgD+B/wPQgD+D0AAzXMEAiQC/AMkARABSAgkBZIExARIAhABAADgcwQEJAL8AyQCAABcBkgB/g9IAUgCQAQAAO1zAABEBPwHRAQAAvAIAAT+AwAI/A9ECAQI8nMAACQE/AMgAgwAjAL0ApQC1A+UApQCAAL+cyQEJAL8AyQKAAj8BVQDVAFUD1QJ/AkABAN0AAIkAvwDJAEMA2gCCAj+B4gACgNqBAAEBnQABCQC/AMkAgAJfAhUCdQP/A9UCVQJfAkJdAAEJAL8AyQCAAi0BywApg8kALQHJAgAABB0AAQkAvwDJAIACPQJFAQQAt4BEAQUCPQLInQABCQC/AMkAoAA1ALUCbwIxAdkAJQDAAQmdAACJAL8ASQBAAC0B7QCrAMuCPQPNAAAACp0AAQkAvwDJAIACAgF/gVYAVgB/gUIBQAIM3QAACQC/AEgA4gA/g9IAAADyAD+D0gAiAM0dAAAWgBaAV4BegFaAVgBegVeA1oBWgCQADx0AAhEBPwH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8gMAAFIBfgJTAlIN0gASADB4hAD0DywE5AcAALQAhAD8D4QAtACAAAAAMniCAPoHJgQiBPIDOAecCJgI+AgICPgJAAQ0eIQA9A8sBOQDAAz4A8gISAl+BkgHyAgYCDh4AACEAPQPLATAA/wP5AgUCPQLFAj0CQAAQHiEAPQPLATkBwAAvAcgBCAE/gcgBDwEgA9VeAAAQgD6BxYC8gMACPoECgLuAQoE+gUABF14AAAEAfQPTASED/AHHABQAV4BEAn0DwAAa3gAAIQA9AcsBOQHAAC0DywApg8kALQPIARseIQA/A8kBOQHAAD8CKwKrAb8BawIrAj8CG54hAD0DywExAcQAPgPVgH0D1wBVAnwBwAAjHiCAPoHJgIiAuIDAABqAioJ6g8qAb4CoASNeIIA+gcmAiIC4gMAAV8DVQNVCdUPXwEAAY54hAD0DywE5AcAAGQBFAEkAcYPNAEkAUQBkXiEAPQHLAIkAuQDfADUAX4BVAHUB3wBAAGXeIQA9AcsBOAHxAA0DKQDRgD0BxQI9AkABJ94hAD0D0wEwAcIAHwNSAP8D2gDfAVICQAAp3gAAMoE6gL+D+oKgAr8CtQK1grUDvwAAACpeAAAhAD8ByQC5AsACPwHrAKsAqwG/A8ACLB4hAD8DyQE4AeIAA4J/A8ICPwPCgjICQAAs3iEAPwHJALkAwAIrAdoAC4NqAMoBKwJIAC6eIQA9A9MBMQHTADkD1wJVgn0D1QJVAlMCbx4AACCAP4HIgLAB34DqgSqAP4GqgGCDwAAwXiEAfwPJATkAwwIaA+OCOgOSAioD84IKA7KeAAAUgLSB3oFbgVqB2oC6gdqBXoFQgdAANB4UAVQBTwDVA8WC3wLCAtmC1ILvg+YAYAB1XgAAEQA9A8sBOADyA/8D84IzA/sCMgPAAjaeIQB9A8sBCQExAf8AtwG3A7+CtwP/AIEA+h4AA78AQQEtAS0DrQLlgqECrQKtAq0DpQA9HhEAPQPLATEByAAmgnaD9YI1gyaCiAIAAAOeYQA/AckAsQLFAhMBF4H0A9MCV4JVAkQCBl5AAAEAfwD5AsOCFQH1AFACAwH7A8sCWQAOnkAACAEJAKkASQIJAjkDyQAJACkASQCIAQ8eQAAiAGKAO4PWACIAQAA/gcACAAIAAgABj55AAAIAYgAzg+4AAgJIAggCP4PIAggCCAIQXkAAIgASgDsD1gAiAAAAPwPBAB0AowBAABCeQABiADKD3gAiAAgAPwHIAj+CRAI+AgABkh5CAGIAM4PeACICQAE/AMkACIA4g8iACAASXkIAYgA7g9YAIgIAAjwDwAI/g8gCCAIAAhQeYgAiADuD1gACAGAAPgPTgRIBEgEyA8AAFV5iACIAM4PfAAICOAMAALyB8QIMAhsBoAAVnkIAYgAyg+4AAAI/A8kCSQJJAkkCfwPAAhdeYgBSADuD1gAgAg8BCQD5AAkAOQPPAgABl55iAGIAO4PXACAAPgDKAEoAf4PKAH4AQAAX3kAAIAElgS0ArQAvge0ALQCtAKWBIAEAABleQgBiADOD3gACABAAUoBSgH4D0oBSgEIAWh5BAl0BdQF1AH8CdQJ1Af8AdQF1AV0DQQJbXkQABABmAhuBEwBdAlICUYPWAFkA1QDjAx3eQgBiADKD7gAAARUAtQBfgNUCVQPRAEAAHh5CAGKAOoPmAAAANwPVAH0AFQLVAjcDwAAenkIAYgA6g9YAEAICAn+BVgBWAH+BQgJAACAeQAABAr8C4wD/AvcC94P/AOMB/wHBAoAAIF5AAAUCUwFXgFMCUQJUA9MAV4FDAU0CSAAhHmIAIgAzg98AAgAQgQqAioJ6gcqAb4CoASFeYQARADmD1wABAHwAaoB+AesAaoB+AEAAI15gACIAOwPGADAD3wAxAf0AtQDVAj8BwAAj3mIAEgA7gdYAIIA+g9qBWoF6gdqBXoFwgemeQAAJAWzBYAF6wH+AdoHgAG+A4IDPgUABad5AAGKAOoPkAAEAHwP3AteC1wL3At8DwQBqnnEACQA9Q8tAEAC/wKtAv8PqgKtAv8CAAKueYgBSgDqD5gAAAj+C/8K6gr/CuoK/gsACLF5AAGKAOoPkADED/wF/Af+BvwC/A/cAgAAuXkAAIQPvACsBKwE/AesBKwCrAq6CIIHAAC6eQAAgA/8ANQC1AL8A9QC1ALUCPwIgA8AALt5BAAED3QBZAVkB9YFVAVUA0QJdAkEBwQAvXkQAAgP6AHEAZQFsge6BbIHhAnoDwgAAAC+eSAEJAIkAaQAZAD8D2IAogAiASICIAQAAL95AACQCFQIVAQ0A3wANAA0B1IIUgiQBIAAwHmICEwILAScA4wAvACKCpoJKglKB0gAAADBeQACkgFSAP4PUgBSBAAH+AQGBMAEAA8ACMN5AABQCFQIVAQ0A7wAlAA0B1IIVAhQBgAAyXkAACgEugS6AroBugH+D7oBugL5AigEAADLeQAAkgNSAP4PUgAACDgEgAN+AIADMAQICM15lANSAP4PUgACAPgBiACIAP4PiACIAPgB0XkAAJQDUgD+D1IAEAFCAUwBAAH+DwABAAHSeQAAlAFSAP4PEgCACDgEgAR+AgAB2AAAANh5EgOSAP4PUgCACWAE+geCCGAIHgjgBgAA33kUA5QA/A9UAJQJAAj8DyQJJAn8DwAIAADkeQAAFAOUAPwPkACEALQAhAD8D4QAtACEAOZ5IAGsCGwErAO8A64PbAEsA2wErAggAQAA6XmUA1QA/A9SAJIIEAROAkgB/gBIA0gEQAjveQAAlANUAPwPUgAACHwGRAFEAEQBfA4ACPB5kgNSAP4PUgCSAhACzwEECPwPBADsAQQC+3kAAJQBVAD8D1IAAgmoBKwEVgV0AswBQAAAehADkgD+DxIAAAHqB6wAvACkD6wAqgSoAwV6EgOSAP4PQgAICPQEkgOQAJIP5AgICBAEC3oAABgDmAD8DwABPAikCqQKpA+kCrwKAAgNepIBUgD+D1IAAADyB1QBUAFeAVAF9gcAAA56AACUA1IA/g8CADgMygNIAMwPTgh6CAAGGnoAAJQBVAD8D1IAEAD+D6gE/AeqBKgEAAAjehAA+AVWBfQFXAX0BiAHpAD8D6QAIgcAAC56AADKASoA/wMACP4Krgr+D64K/QoACAAAMXoUA5IA/g+SAAAC6A+kAqQC6gOiCroK4gcyehQDkgD+D1IAEgDADxIAwg9aBUIF2g8AADN6JAIkAfwPogAABlgAVgVWC1QJXAHwBQAIN3qUA1QA/A9SAAAJfgmWBdYGvgZWBVYIXgA7eooBSgD+D0kAAADKB6oEgQQtBKEE7QcAADx6FAOUAPwPUgBABVwFtAJ2CbQG1ABcA0AEPXoUA5IA/geSABAAdAesB64HtAe2B5YHVAA/eooDSgD+D0kAgA9eAFYPVgVXB14Awg8CAEJ6FAOSAP4PUgCABnwArAysCf4KrAKsBvwIRnoSA5IA/g9SAIAIvAwsBSwF7gYsArwCgABMehAM+AFWDfQBXA3wAgQGpAH8D6QAIgcAAk16mAFYAPwHVAAQBPwF/AX+AfwB/AX8BRAETnoABM4C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SAduANAPTADgCggIOATIAg4DyAQ4BAgIDX1IB24A0A9MAAAB+A8IAcgAPgDICPgHAAAQfRAOnADyDsgAgAIECEQM/AtECPwPQAgAABR9SAduANAPTAEAAOgDCAEIAf4HBAnkCQAEGX1IB3YA0A9MAGQBAAT+ByIE/gEiBiEMAAAafUgHWAD2D2AAQAsEB/wAhAQkBTwD4AQgCBt9SAd2ANAPTAAAC3AITgbAAUIITgjQByAAIH0gACoJagVqA+oL/wlqByoBqgWqCSALIAghfUgHfgDQD0wAxAoACAgH+AAuCCgI6AcIACJ9AAA0CBQFVAX0AV4JVA80AbQFFAU0CQAAJ30ACB4JgAXeAcAJogmSD14BUgUeBSIJIAArfRAJHAlQBV4FtAGQD04BFAWUBRIJCAoAAC99AAAACD4FagXqAX4Jag8qAaoFPgUACAAIMH1IB3YA0A9MAcAA/A9EBEQE/AdEBEQE/A85fUgHbgDQD0wAAAMgAKIPngSCBKIEng8AAEJ9SAduANAPTACAAogATgQ1BTQFTAlAAAAAQ30QDtwAsgZIAEAHSABoBloFzAQoBggMAABEfUgHbgDQD0wAAAMACPwPJAkkCSQJ/A8ACEx9SAduANAPTAAAA0IIJgkqCZIPKgkmCUAIUH1IB24A0A9MAKADBACkD6QEvwSkBKQPJABVfbAN7ACiBJgCAAD0BzQJLAnkCTQJLAngBV59SAd4ANYPUAAACygImAQYA84DCAQoCCgAYX1IB24A0A/MAMQDkADID9YEpATcBEQPgABmfUgHbgDQD2wBIACQD4wEogSkBIgEkA8gAG59AAAsCCwFlgHUCcwJgA9eAVIFEgUeCQAAcX1ID3YA0Q9MAAAJBAS8AycALAC8DwQIAARyfQAAkA78AJIGSAIAAFgDdgjQD0wA4AIABHV9SAd2ANAPTAAACxAIiAamBaQEiAawDBAAdn1IB24A0A9MAQAA+AeWCJYI/AicCJQI8AaTfZAMvAHiDNgAAAo6CEIJEgnqD4IJPglGCJl9QAduANAPTAAAAf4PAASoBP4FoAQsBQAEmn0AAEgHfgDQD6wDgAlUBFQDXgBUBtQIBAScfTAO7ACiDJgCAACMDKQCpwCkD6QArAKADKB9MA7sAKICmAQABNoCVAjUD3QATAKABAAArX1IB24A0A9MAEADEAD+D6gE/AeqBKgEAACxfU4HcADsD0AB/A/sA+QDJAKsCyQI/AcAALJ9SAd4ANYPgAL8DwwAvAPkBLQEBAD8DwAAv31IB24A0A9sAQAAvgeqAKoA6w+qAL4EgAPKfQABPgUuBb4F7gGuB6IBWgMaAyYFQgUAAM99SAd2ANAPTAAAAV4EQAD8D2QJcQhGA4gE0X1IB24A0A9MAAAFIASqAioI6gc+AaAGAADSfUgDdgDQD0wA4AOEAJQHfgVUBVwF1gcQANp9SAduANAPzADABZwCrAksCO4PLAO8BAAE4H1IB3gA1g9IAQgAoAeUAJwA1g+cALQHAADjfSAIvAziAtgCgAQgBH4DtAq0B7wBIAYAAOh9SAduANAPTAAAD/wHrAKsD6wCrA+8AoQP6X1IB24A0A9MAEAJFARcA/QJ1AbSBtwFVAjvfUgHWAD2D2ACAAT0BbwHtgW0D7wF8AUABPR9SAd4ANYPSAAAAvwErAKsAf4PrAH8AgQE+32QDtwAsgTAAZwE1AeUBAQA8AwOA/gEAAgBfkgHXgDwD2wAgAIgBGoDqgpqB74AIAcAAAR+RANfAOgPJgAAAfwHvAK8AvwHvAq8CvwNI35AAnwBfAD8B/wASAIYAXwE1ANUANACgAAmfkgHbgDQD8wAQAL2D5gHFgTwD5YIEAgAACt+EA7eAHEEbAMBCHYG4AksCLsK+wsmCgAILn5AB34A0A9MAUAA7A8EANYHdAVUBdQHAAAxfhAO3gCxDMwCAAD3DwAEzgMBBOgHhgiYCD1+kA7cALIMiAIADPwChAaWCaQLhAD8BgAAPn5IB24A0A9MAAAK/Aj8Bf4F/AH8BfwJEAhBfgAIMAq+CjwL/AM8D4gCXgZkB1wKhAoAAEp+QAdOAPAP7AHAB/QHHgT0A5AG/geQDBYCVH6gAy4A8Ae8ABAA/Ae2AtgPPwPQBBYOAABefpAO3ACyBIgCAAiqCeoHrwEKD+oJqgmABWp+AAd4AJQGUgEIADQH8gX6BdIF9AX0BwQAa34AAH4Kfgd/B/4PfgsYB/YC0gp+CpgKgAhwfkgHbgDQD0wBAATwAt4B+gfqAdYC8AQAAHN+kA7cALICCAk+DOsD6wm+BzQMiwN4DAAAfH4QDtwAsgZIAv4PNAi6DzgJPgisDxALAAiMfpgO9gCRBkgBEgjuB/4H7wP+A+4H+gcACI9+gA7cAKIGWAEADPwD9An+C/4O/Av8C4QJln5QB3wAagIACXYE9QcQBPYPMAT+B9AMFgKgfqAEsAVsBSIFkAQAAPwBAAEAAQAB/g8AAKJ+AAAwCewEogSYBgAABAQEBPwHBAQEBAQEpH4AADAJqAVmBRAFQABEAEQA/A9EAEIAQACmfqAEuAXkBJIEgAIwAI4AiAgICQgM+AMAAKd+IAW4BeYEkAIQDIQDfAiEBTQCrAVgCAAIqn4AACAFuAVmBRAFAADEB0QIRAhECPwIAAasfiAFuAVmBRAEAAKoAKgA/g+oAKgEiAMAAK9+IAW4BWcFEAUABPQBBAEEAf8HBAn0DQQEsX4AADAF6AWmBJACAAh4CAAE/gQAApgBIACyfgAAmAXXBLEEAAD+DwIAsgHaAQII/g8AALN+AAAwBc4FIgUAAPAPEAPwAJ4IEAjwDwAAtX4AADAF7AWiBJAAAA7+AQAMAAP+AAAHAAi3fgAAIAW4BWYFAAFgCFgExANACEYI2AdgALh+IAW4BWYFMAUAAPwPRAhEBPwBRAZCCEAGuX4AADAF7ASiApgKAAg4BMoCDgPoBBgECAi6fgAAMAWsBWIFGAEACAgH+ABOCEgIyAcIAL1+AAAwCawFYwUYAQIIQgz+C0IIQg7+CQAIv34AALgF5ASSAoAKEAhQBH4EyAMqBaoIAATDfrgE5ASyAgAAVAZ8AVYI9A9EAEQBBAYAAMR+AAAgBbgFZgUQAQAI/A8kCSQJ/A8ACAAAxX4AACAJuAVmBQAA+AMoASgB/g8oAfgBAADGfiAFsAVuBSIFAAD8D0QERAT8B0QE/A8AAMd+IAW4BOYEkAIACHwGRAFEAEQARAF8DgAIyH4AADAF6AWmBJAEEABIAlYEJAVUBUwIgADNfjAFnATyAogCIACiD5oEhgSiBKIEngcAAM9+IA24BeYEkAAACKQIpAiUD6wIpAggCAAA0X4AADgL5gmQAQAIKA3+AwAA/A8EAHwChAHSfiAAmATkArICCABABugBCAh+BIgHaggIBtN+MAXsBKICmAIAAKQHpASkBL8EpASkBwAA1X4gBbwE4gSYAgAIpASmA7wAtA/ECKQIAATYfjAF7AWiBIACIAiQDqwJpgSIBpAEoAgAANl+IAW4BOYCgAIgAKAPsA+uBKgEsA8gAEAA234gBLgFZgUSAkAAqAKoAq4ClA+sAqQCIALcfgAAMAXsBKICkAIQAEgPtgSkBLQETA9AAN1+IAWcBOIEmAQAAPgHlgiWCPQInAjwCAAG3n4gCbgFZgUQAUAIOAiYBQoCyAUoCEgIAADffiAFuAVmBZIEEAJACGgHXgBID2gISAhIBuJ+AAAgCbgFZAUAAOAPvAK0ArQKtAr8DwAA434wBawE4gSYAgAIrAScA4wAvACaCSoHAADlfjAF6ASmAqACCAhEBeQGagLCBVoMQAQAAOd+IAC4BeYEsAIAAPgHBASgBP4FYASsBQAA6X4wBZwE8gKYCgAI3AVcBF4DXABcBNwJEADqfgAAmAT2ApICAAJUANQHfgVUBVwF1AcSAO1+IAW4BOYEkAIAALQIFAUeA9QBFAVwBRAI7n4AALAF7ASiBDgAoAe0AqwCrgs0CNQHNADzfgAAsAVsBSIFAAD8A7QC9Ae0CrQK/AsAAPR+sATsBKICmAIgAPwPqgSoBPoHqASoBAAA9X4gAJgF1gSxAgAAvgeqAOsPqgCqBL4DAAD4fgAAsAXsBKICAAj8BwQA1Af0AgQJ/AcAAPx+AAAgBbgFZgUABRgAiAKqCKwPqACoAoAE/X4AADAF6AUkBQABKAyoAygE7g8oCSgJAAD/fgAAuAVkBRIFiABABCoCKgnqByoBvgKgBAV/AAC8BeIEmQIIAOIHEgTyB14F8gfyBwAABn8AANgCTgJ5AQAE7wQ/AqABKAMmBOwFBAQTfyAFvATjBJgCwAxUAvIJ1gbRBt0FVQgACBR/EAWsBWIFGAUAALQHnADWD5wAlAS0AwAAFX8AADgF5ASyBAgCoAiqC5gG3gSYB5oEqAgWfwAAuALkApIAAAb8AZQH1gPUB1QB3AcAABh/IAS8BWMFGQAABWwFawWqCqoHvgEgBiAEGX+QBNwCowKYAgIA6g9iBX4FfgViBeoPIAAafyAFsARuBSAFAAB4AXgFfAF4CfwP+AEAAR1/AADcBbMEiAAiCOAHBAivCuoLrgqiCgAIIH8AADgF5AUSAQAM/AN0CK4K/g+sCvwKAAgpfyABuATmAgACjADkDxQA1gd0BVQF1AcAADR/EAS8BOMCGAC+DOsD6gm+BzQMywN4DAAANn8AAFAASA9HBEQE/AdEBEQERARED0AAAAA4fwAAqAcmBPwDJAKkBwAABAT8BwQEBAQAADp/AACoByYE/AckBAQHwADIDv4ByAL4BMAIUH8QAAgH/gckBwQBNA/+DxQP5A8+DzQPBABRfwAA/A8EACQD5AAEBCQGxAE0CwQI/AcAAFV/AAAEAVQBVAFUAcQPTAFMAVQBVAEEAQAAV38AAB4JkghSCH4FUgZSAl4CUgHSAB4AAABafwAAngCyCLIPHgQSBBIA3gMSCBII3g8AAGJ/AABcCVQNVAtcCdQJVAlcCVQFVAVcCQAAaX8AABwC1APUA9wD9Af0A/wD9AP0AzwCAAJqfwACvAq0CrQG7AEUABQA7A+0ArQCvAIAAm5/IADcBzQENAT8B/QH9Af8B/QH9Ac8BAAEcH8gAP4H+gX6Bf4F+gcKAO4BCggKCO4PAAByfyABrgC6ALoHfgV6BXoFfgV6BfoHPgAgAHV/AAgOBPoA+gH+B/oA+gL+APoC+gSeAwAAd38AAFwI9Af0AfwKlAd0BrwKtAq0CrwKAACFfwAAbg3aAUoNDgVKAPoPrgqqCuoPrgqgCop/AAFIAUoBTAFIAfgPSAFMAUoBSAEAAQAAjn9ACFgJWglcBVgD+AFYA1wFWgVYCUAJAACefyABuAS4BHwEeAX4B3gFeAV8BfgHKAQAAKF/UARcApwCHgCcBVwEXANeAl4E3AVQBAAApH8AAagB+g+uBKoEvgcIAUoB+A9IAUsBAACofyAJLAyuAi4ILAn8BKwErAOuBKwIpAsACKl/QAPEC9QL1g/UA/wLVAlWB9YFVAtACQAEr38AACgBKg34Ay4BAAG+A2oEagVqCX4IwAe9fxQCJAEkCYQI/AcAABQCZAEECYQI/AcAAMF/SATEBFICWgrYDxAAWATaAlIKRArIDwgAxX8oCOgEPwPoBAAIkgqCCv4LCAhCDP4PAAjMf0QILAkkCQQNPAmACSwJLA1UCUQJfAkAANJ/QAAoAKQP5ArECvwKgAqsCqQKhA98AAAA1H8oCSoH+AGrAAECMAkCCP4HEAGCCP4HAADgfwACKgKuAq4C6gImD7ADZAKqAqoCLgIAAul/AAj8D+wH6g/qB/gOsgH+B5gB/g8AAAAA8H/8AqwCrg+sAvwCAAJYCvQPQgAUCvgHEAD5fwAJqAfsAQ4HbAkECZAL/AkACFQK/AkABPt/QADUD7IFvge6BZMHAAGSCP4HuAH+DwAA/H8AAAIL7gfuB+ID7gPgA+oD6gfiBw4LAAAAgAAE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tAK0Av4PtAK0CvQHEAC4hJIEkgZaADsBCg1qARoFOwlqAKIEEgkAALyEBAAkDOQD1g/wC+gL8AvUC/YL5A8kACAAxISQAJQAtAfWB9QH1Af0B/QH1gfUBtQAkADJhAAANAIUAVYPlAlUCVQJVAmWCVQPVAMAAcuEBABECNQO1grUDvQK0A7UCtYK1AxECUQA3YQEAAQIZA8OCWQPBAk8Dx4J1AmUDwQIAADmhEABRAX8BP4G/Ab8BvwG/gv8CvwGRAAAAOyEFAhUBMQHDgjkC9QLtAu0C7YLtAs0CkQA7oQACLQE8gMDBPoJWAtaC/4LXwtaC/oLAAIRhQQAdAzUA9YB9ArUCNQJ9gbUBtQI9AiABBOFAAjEC3wLfgv8D3wHfAf+B3wLfAvECQAIGoUED/QAVAzWAdQP8AEEBKQBJgj0DyQAAAAhhSQJpAiUBd4BtAmUCYQP9gHUBbQMFAkAACOFBAl0B0QB7g8EAFQFkAV0CVYJNA8UAQABLIUEBJQH9AeWBAQAVA90AFYPVgB0B3QIhAQ1hcQPNAD0D3YFdAd0BdQNfgSUB/QINAgABjqFBADEBxQAxgPUA9QD1APWB1QGFAT0AwAAPYUUANQPxAfuD8QD1A+ECO4EJAPkBSQIAABDhUACSgJKD+sLSgt4D0oLRgvnC1YPQgEAAkmFJAgkBvQAdgF0DXAB9AF0DXYBdAEUDQAAaYVECFQMBAKOAIQF9AXwA/QF9gP0CYQHBABthQAAJAh0B3YHcA/wB3QCdg90B3QHJA8EAHKFBADkAfQB5gf8AewBBAz+A0wAzA9EAAAAdIVCCmIJ0gpHBSINAgj6D6sPqg+qCfoPAgh+hQAAZAAsD+4LLAt4DywL7AuuCywPZAAAAISFJARMB0QAFgH0AfQD9AH+BfQH9AH0AQABh4UAATQBhA8GALQOsAC0DoQA3ggsB+QFIAibhQAA9A9UBVYFdAcEAJQC3gKUD9QClAKAAKaFBA70AbQItgP0C7QDtAv0A7YHtAv0BwQAqYUAAPoPOgDDDeoDKAiqCq4Kvw+qCqoKIAiqhQQEVAFcCd4HdAEEDPQDXgBUANQPVABAAKyFhACUCEQFBgX0A7QPtAH0AwYFRAWUCJQAr4UAAnQD1APWD/QP1A/QD/QP1g9UD3QBAACwhQIIig3+BdsB3gX+Ad4F/gXfAf4FigUAAMmFtAS0AvQPtgGUAgQA1A/+CtwK9ArUDwAAzYUAAPQE9Af2BfQH8AUEB1wFXgVUB1QEAADPhQAJdAdEAfQP9gO0BvQGHg/8BBQH1AgQBN2FBANcB1wH/gv8C5gLQAc2BxQHdAqEAkQA5IUEDPQDVAn2DwQBdAX0AH4PZAL0BWQJAADlhQAItAXkBQYF9AGwD7QB1AN+A2wFBAUAAOmFIgRqAwIBNwCyD/IKsgqzD6oK6g+iAAAA+4UCACoMSgMLBeIDvgN2D5cPdgO+BeIFAgUHhiQM5AF8Df4BdA3kBAACVAH2D0wBTAYEAAuGRABkC0QI7gVkAnAI9Av2CvQC9Ab0BwAILYYAAAAA/g//B/4C4AfAAv4D/wU+AP4HAABOhgAAAAzwAxAIUAd+AdQBtAeUCLQIsAQQAE+GAAAADPgDCAgoCT4HXAFcBUwJXA1YAwgAUIYAAMAPOACID6gKvgrcCtwKzArcCkgIKABRhgAAAA/wABAGUAB+BtQItAq0CJQCsAYAAFSGAAz4AwgIKAkoCz4NbAVsC0wLXAlYCQgAVYYADPgDCAuoBqgGPglcCNwL3AjcC1gKCABahgAAAA/wABAKUAh+DrQItA6UCLQKkAhQAFuGAACAD3AAEAtQCn4PVAi0DpQKtAowCAAAXoYAAAAM/AMECJQLfwe2A7YDtgfmBywKAABfhiAA7gSqBKoDJgbwARgMOANfAFoHSgQYAmeGAAz4AxgB3g+8D4wLGAjyAJIIkgiSBwAAa4YAAAAE+ASIBIgE/geIBIgEiAb4BAAIAAB5hgAA+ASIBP4D+AIABAQEBAT8BwQEBAQABH2GAAAACNwLVAlUCfQHVAVUBVQF3AUACAAIgIYgABQIyg8IBBgC8AiICIgE/geIBIgF+AeBhgAI+AmIBP4H+A4ACHgEggUMA+AEHAgACIqGAAD4Cf4Hjgf4BgAIGAjqDAoHiAN4BAgIjIYAAPgEiAT+B/gGAAQoASgB/g8kASQBAAGVhogASgjqCVoJTgnqB0oFSgVaB+oHSgxICMeGAAD4BP4HiATwBggA6AcKCYwIiAhYCAAGy4YAABIEygVKBVIF3gdWBVYFVgfWBRIIAADZhgAA+Az+B/4H+AYACCQJJAm/DyQJJAkgCNuGAAj4Bf4HiAT4BgAAXgZIAf4PSAFIAgAE7oYABBQE1AVEBVwFxgdEBVwFRAXUBRQIAAAAh0AAXAD0BXQFfAX0B3QFfAX0DTQI/AcAAAKHAAj4Cf4Hjgf4ClAASAVuBdQPbAVEBUAEHIcAABQEpAekBrQGtge0BqwGjAaUBxQIAAAhhwAA+ARIAv4DeAMABtQHXgVUBV4F1AcQAEeHAAD4CfgEjgf4BgAI/AO0AvQHtAr8DQAEZocACPgE/geIBHAC/g+SAg4IYAliB94IAAh0h/gJiAT+B4gEeACAB38CgA/+AxII/gcAAHaHAAj4Bf4H+AYAAHwNSAP8D2gDfAVICQAAgocACPgF/geIBnAE/AdWBTwC+A8EAPwDAACNhwQA/A/sBOwCfAmAB3gAiAj+B4gE+AYACJ6HAAD4BM4D/gNIAjABfgaqAv4BqgmCBwAAoocAAGIE6AfuBuQG4AfyBugG7gboB3QIAAi6hwAA+AmOB/4HiATwBR4J6g1+DyoBvgsACtGHAAj4Bf4H+AYACPQDdAN0A3YP9AMQAgAA8ocAAKALrAqsB6wHPgisA6wKvAesBqAHAAj5h4QEfAQ3Bb4FtgV4B8oHtgWyBboHNggAAPuHAAT8Av8DRAJ+ATsL2g9+A+oHKwdqCwAJDYgACPgF/gfwBnwPPAO8B+ADMAf+AAgDOAQfiAAA+An+B4gEcAImD3gLdAD6D1AEfgMADCGIAADUBdwFvge/BbcJPwCXBa0HrAWkBQAAIogAAKoFngX+B/4F/gn/AP4F/geeBaoHIAg7iCwAFwTeBUAFdgX/B34FcAVkBb8HNAgSAECIAAT4BwgECAT8BwoECAT4BwgECAT4BwAERogACCAJvAQkBLwApg98ASQCJAW8BCAIAABMiIgASADkDxIAAAAkACQAJAgkCOQPJAAgAE2IiABEAPMPCAAiDCIChAEgCCII4g8iAAAAU4hAAEQA8w8JAMgB/wcIAMMFEATyBxIAAABUiAAAzADyDxgAhgj1B5QEAAAkCOQPJAAAAFeIQABEAPIPGQJQAt4DVAJUBgAE8gcSAAAAWYgAAMgA5A8CAFQPfAV0B2QAJAAkCOQHIABbiAQAQgD5DwgA+gPfAtoH/gICAPIHEgAAAF2IAAAkAPIPCAB6CVoJ/gf6BQkEIADkDyAAYYgAAEQA8g8ICfgFrgP8A6wN+AEACOQPIABiiAAAjADgDxwAvAecB5gHvAe8BAAA5A8gAGOIgACIAEgIyA8oCBoEPATIAIgDSAQoCAAIZYgAAAgBigDqD5gASAEAAP4PIABAAMAAgABoiCABNAm0BLQHdAQ+BPQENAG0ArQEIAgAAGuICAGIAO4PnABIAQAIiARIBEQCMgIQAQAAbIgIAYgA7g+cAEgBAADQABAJEAj+BxAAAABwiBQBFAV8BVwH3AReBNwEXAFcA3wFFAUQBHeIAAAEAnQCVA5UCfYIVAlUAlQGdAkECQAAgYgAAhAC9AK0DrQJvgS0AbQCtAZ0BRAJAAiLiJACiAK8CoIOiAnICI4JmAKqBsoKygqoCI2IAAGMAOwPWAEAAPAHLAkoCegLCAr4CQAElogIAYgA6g/YAAAA+A+IBIgE/weIBIgE+A+ciAABigDqD9gAAARIAkgB/g9IAUgCSAQAAKuICAGIAMoPuAEADPgDyAhICX4GSAbICRgIrYiEAqQCpAqUDowJpgi8CdYC1gbUBcQFtAixiAABiADqD/AAIAD8DwIAEAf+AJADFgwAALSICAGIAOwPmAAAAKgAuAOsAqgKmAqoBqAAwYgAAVQL1AdeBFQBVAMQDP4CEAPSBBQIAAbCiNYC1gLeCq4OngnGBIABngLABsAF/gkACMWIoAKsApAKvA6ACagEqAG8AqgGqASoCAAAz4gABEQFfA18D3wJ/gl8A3wFfAV8C0QLAAjUiBQA1A90APQHbAVkBWYFzAbUAKQPJAAAANWICAGIAO4PWACIAAABxA+yCIgIsgjED4gB2IiABKwCrAqsDoQJ3gSEAaYCrgasBKQIAADZiAABiADrD9gAgAIqAeoHvgSqBKoEvgcIANyICAEIAc4PuAAAAOgPqAKoAv4PqAKqCuoH3YiQAr4CmAqYDr4JgASoBKgBvgKoBqgEiAjhiAgBiADsD9gAAAB8CVQJVAn8D1QJfAkAAOSIAAGKAOoP2AAADPwDRAC2ApQPlAKUAgAA84gAApwEhQK2DrQJ9gS0AbQCtgaFBJwIAAD4iAgBigDqD9AAgAT8BNQC1A/8D9QB/AKABPmIgAJEAnwBfAf8BP4EfAF8AnwCfAXEBAAA/YgIAr4CnAq+BpwF/ASAAZwCwAbABb4JAAQHiYAASADuB3gAAAU+Bf4FvAK8ArwFvAQEBBCJCAGJAMoPuAAAAb4HqgSqBaoGqgi+BwAAMokAAZQA1AewAAAE+APoA+wD+AfoA+gD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/AP0A/QFHAQAALiMAAAICOQL6gblBuQC5gLsBvYG9gcECAAIu4wACFQI3Av8B94H3APcA94H3Af8CxwIAAi8jAAI/A1UAVQB/AUAAIAPgAT/BJgEmA8YAL+MAAQQBPwF9APsA/AB9AHsA+QD1AUMBAAAwIwAABQIzAvmCvQK7ALgAv4K8gryCx4IAAjDjBAACADcA8QL4AvqA+oD/gvqC+kDKgAAAMSMAAj8DVQFVAH8BUAA+A+sAqgCqAroBwAAx4wQCBII9Av0BuQG9AL2AuwG9Ab0CxQIAADKjAAI/A1UAVQF/AFIAOgJSAR+AogFbAgIBtOMIAAsCOwH/AbsAv4C7AL8AvwG/AcMCAAI24wAABwIzAXuBewF7AHgAfwF7gX8BRwIIADcjAAI/A1UAVQF/AUAAb4C6gmqBKoDvgiAB96MAAAcCMYP9g30DfYF9AX0DfYNxQ8cCAAA4IwACPwFVAVUAfwFIAC0B6QEpgSkBLQHJADijAAIPgj6B/4H+gf6A+AD4gfaB5oHJgggAOOMAAQ6CO4H7gf+B+8D7gP+B+4H7gc+CAIA5IwACPwFVAVUAfwDqAjsBBgH2ga8CbgJEATmjAAI/A1UAfwFAAjUDxQI0AeQBP4DEAwUBuqMIAAcCMwL7Ab6BvgC7gLqBuoG2gsKCAgA7YwABPwHVAFUA/wFAAGkB/4FpAW8BaYHIAD0jAAEeAJYAfwPWAE4AMAL7ArkAvQG7AcACPqMAAD8DVQB/AIICGwF+A9oAfgPbgPoBUAI/IwACPwNVAFUA/wGwA/sAv4C7Av+CuwHIAL9jAAArAh8BPwH/AP+A/wD/AP8B7QEpAQAAAiNAAj8BVQB/AUAAPwP5wrkCvwK5ArnD3wACo0AACgI/g9eDVwFXAV8BV4FXgXsDxwICAgPjQAMggO2CjoHugm7A7oFOgC6B7oPCgQAAB2NAAAACPwJBAQEBAQC9AEEBAQE/AkACAAAHo0ACAAI8AsQCBAEHgLUARQEFAT0BQQIAAAfjSAIEAj4CRQIFgQUAtQBHAQQBPAJAAgAACGNAAAUCNQLVAhUBlwBVARUBFQI1AsUCAAAIo0ACP4JAgT6AwIA/g4AAAgDiAhoCP8HCAAjjRAAFAjcC1wIXARcA14AXARcBNwFFAgAACSNAAAeCMAFQAReAkABZgRaBFoI1gsSACAAJY0ACP4IAgb6Af4MAABwCI4EiAN4BAgIAAAmjQAEfwf5AAEC/wIACP8HIAToACYDIQQAACeNAAAICMQLXghBBkQBTwRUBFQI0gsKCAAAKI0AAPAHDADsCSwELAK8ASoEKgTqBQgIAAApjQAAfA/0AAQC/AAADvwBNAzUAhQD8gQECCqNCAAICNQLVAhSBFoDUgB0BFQE1AUECAgAK40IACgI7AtqCFoESANoAGoEXATEBQgICAAsjQAI/g3yAwIC/gAADCQCIgYqCeIIIQgACC2NAAj8DeQDBAD8DhAAzAEKAcgJCAj4BwAALo0AAPwJBAT0AwQA/A4QAAgEDgQIBAgEOAQvjQAACAj8C2oIagZ+AWoEagRqCP4LCAgAADGNAAj8CAQG9AH8AgAIUAT+BFAHVAlQCQAENI0ACPwN9AMEAPwGAACAD/4EiASIBIgPAAA1jQAAIAj8C3QIdAR0A34AdAR0BPwFIAgAADeNEAAICNwLQghIBEgDTgBYBGoI4gsUAAAAOI0AAAAI3AtSCFsEQANSAE4EYgTiBR4IAAA5jQAIQAjeC3YIXwRWA1YAXwRWBNYFFggAADqNAAAUCNQLTghkBlwBQARcBFQI1AscAAAAPI0ABPwC9AEEBPwAAAboAQgIfgSIB+oICAY+jQIIOgjqBWoEfgRqA2oAfgJqBOoFOggCAD+NAAD8DfQDBAD8BcAA+A+uAqgCqAroDwgAQY0IAAQI3wVABGoDagBqAn4CagTpBSoIAABEjRAIEgjUBUAEaAJmA1YATAJUBNQFDAgAAEuNAAD8DeQD/AAACNQPFAjUBxAA/gMQDBYGTI0AAPwP9AEEBPwFgADUD34FVAVYBdQPEABPjQAAHAiGC7QItAS2ArQAtAS2BIUFHAgAAFCNAAj8CQQE9AMEAPwOAAC+AOoLqgaqCb4HVI0ACPwH5AEEBPwFAACoD6QEpgS0BKQHIABWjQAI9ASUAv4PlAH0CgAI+AfWAxwI9AsACFqNAAj8DeQD/AAACFoF/A9YAfgPXgX4CUAAW40AAKwIvAj8BbwEvgK8ALwE/AW0BCQJAABejSAALgicC04IfARAA24AXAROBJwFLAgoAGCNAAB+BAID+gACAn4AmAd/BXwFfwX8BwAAYo0ADOIDvgr+B94MPwP+DN4HPgH+DwYEAABkjSACpAGkCCQG5AE+CCQI5A8kAKQAIAMAAmaNgAkkBOQDPgjkByQAgAk0BMoCiAN4BAgIa42ACSQE5AM+COQHpACAB+QBPgjkByQAgANwjSAIKASoAygEKAT8DygJKAkoCSgJIAgAAHSNEAbUARQC/gNUBFQEUAQABP4FCAQQBCAEdY0QBtQBFAH+A1QEVAQABcwEMARMBIIFAAR2jSAMpAMkBP4HpAikCAAIJAj8CyQIJAgAAHeNEAjUBxQC/geUCJQIAAjkCSQKJAo8CoAJgY0QBtQBFAH+A1QEUAQEBVIFIgWkBIgECASFjQAI2AcYBPwHmAgQCNQLTApkCmQK3AsACIqNIAyoA/wHqAgACPgJiAgICn4JyAoqCgAIi40gBqgBKAL+A4gEIAQYBVYFVAVcBfQFAASVjSAGqAEoAvwDqAUABVwE3ATcBdwE3AQABJmNIAyoAygC/AeoCAAI9AswCLwIkAr0CQAIn40ACKQHJAL/B6QIBAj0C5AIXgmQCPYLAAijjRQAFASeA/QDEAT+BKoE/gUABOQFHAUABKiNEAzUAxQC/geUCKQI7wteCUoJbgjeCwAAs40AAAAIPASkAyQEJAjkDyQJJAk8CQAIAAC0jQAI3gcSBPIHngAADvwBAAAEAPwAAAcACMONAAjeB/IHkgSeBAAAJAwiA/4AIgMiBCAIzI0ABN4HEgTyA14CAAhOBEgD/gBIA0gESAjRjQAE3gcSBPIHngQAAPoHtAj0CgQK/AkABN2NAATcBxQE9AOcAgAA/A8UBRQFFAX0BQAE340ACN4HEgTyB54AAAj8D1QI1AFUBnwFAAnhjQAEngfyB5IEDgLgDPgDDgj4BwgA6AEAAOiNAASeB/IH8geOBCAAuAOoCqwKuAqoBqgA6o0AAB4H8geSBD4M+AcWANQHVAhcCtAJEATvjQAI3gcSBPIHngSQAIgP1gikCLwIxA+AAPONAAjeB/IHngQAAAgN/gMAAP4HQAiYCAQF9Y0ABN4H8geSBB4CgAhIBP8ESAMqBaoJgAQKjgAAAAQeD/IHngQAAOQPpAL0D6wC5A8AAA+OAADeDxIE8geeBAAAuA+ACv4KkAqsDyQAEI4ABN4H8geSBB4IQAnoBS8HGAWpC00LJAkijgAE3gfyB5IEngKAAL4C6gmqBqoBvg8AACmOAACeD/IHngQABJQApA6EAdQPggK6BIIIKo4ABN4HEgT+B4AAqAaoAK4IqA+IAJgCgAQ0jgAAng8SBPIHDgjwCmoGegNuCvoKAAYAAESOAAjeB/IHkgQOAmAAJAeUAKYPlACkBwAASI4AAB4P8geSBAwAsA9ECRQJQghSCcoPAABfjgAA3g8WBPYHngwACPwLfA1+BXwN/AsQCGSOAAieB/IHngSAAPYPAATcAwoG4A+OCJAIZo6eDxII/geADOwHqALoDw4A6AeoAuwPAAByjgAIng8SCPIHjgDkA5YHvAe8A9YP9AMAAoGOAACeB/IHkgLuBtAC3gH6B+oH1gHwAgAEjY4ACN4H8geSBJ4EgAH+D6YK8A+uCq4KAACrjgAJAAn8CVQFVAVWA1QLVAn8B0AAIAAAAKyOgAT+BKoCqwn+BwAA8gCSCJIIkgieBwAAr46ABP4EqwKqCf4HAAD+DwIKmgliCJoLAgiyjgAJ/AlWBVUD/A8AALAMjgLCD4ICngQgCLqOgAT+BKsD/g8AAPcHEADQA14BkAT3AwAAyo4AAAQC/AKsAqwC/g+sAqwCrAL8AgQCAADMjgAA/AKsAv4PrAL8CgAG/wEIAPgPAAgABs2OAAAGAvoCugK6Av4HugK6AroC8gIGAgAA0o4AAPwCrAL+D6wC/AJAAEQA/A9EAEQAAADfjgAA/AKsAv4PrAL8CBAEDgP4AAgDOAQICOKOAAD8AswC/g/MAvwCAAgkB+QEJAQkByAI+I4AAPwCrAL+D/wCAAD4D4gE/weIBPgPAAD9jgAA/AKsAv4PrAL8CkAIJgmaDxoJJglCCAOPAAD8AqwC/g/8AgAAFAhUBIYClANUBBAICY8QAvQD9APuB+4H9AMQBn4CkAPSBBQIAAYUjwAA/AKsAv4P/AIAAOgPqAL+D6gC6g8AABWPAAD8Av4Prg/8AhAIagkCCXoPAgl6CUIIG48AAPQC/g/UAnQA4A8UAJQB/A+UAfQPAAAdjwwM4AM+AOgHIAIKAvoCugL6D7oC+gIAAimPEABcBNwH/AfMB+APwAfcB9wH3AccBAAAKo8AAPwCrALeD/wCHADED+IH4Q/GDwgAEAAvj/wCrAKuD/wC/AIABi4E6gdqBWoF7g8gBDiPAAD8AqwC/g/8AhgAxA+zAvIPhAHoDwAAO48AAPwCrAL+D6wCfAAUD6wKrA+sCrwPAABJjwAA/AKsAv4PrAL8ApwGvAr+CrwP/AMAAF+P4gfiB/4P/gf+B34Avgf+B/4P/gfiBwAEZo8AAAgCaAJYAk4CSgLoD0gCSAJIAggCAABoj0QCdAJOAuQPRAEACAgH/gAIAPgHAAgABmmPBAJ0Ak4C5A9EAQABRABEAPwPRABEAAAAbI8AAHwCRgL0D0QBAACkAPQCrgSkC6QAIABuj0QAdAJOAuQPRAEQAMgHhgiFCIgIMAYAAG+PBAJ0Ak4C5Q9EASQJMAQOA+gACAM4BAgIcI8ACKQItAa8ArYBNgk0CLQFtAa0BqQFIAh0jwAAfAJGAfQPQAD4D4gE/wePBIgE+A8AAHuPAAB8AkYC9A9EAQAJJAikCJQPrAikCCAIfY8QAFQF1AVeBVQPVAMQCP4EEAOWBVAIAAZ/jwAAfAJGAvQPBADQDDQDHAAUADIPUgCAAIOPAAB0Ak4C5A9EAQAJaASIBA4DqAUoCEAIhY8AADoBJwHyByIBAAD0D1QB/wdUAfUHAACGj3wCRAL2DwQA8A8UAfwAHAP8CBQJ9AcAAIiPUARcBdwFXAVeBUAFQA9eBVwFXAVcBBAEiY8ADPQDHgDwBxQBQgFOAXoB6gdKAUoBAACQjzwCRAL2D0QAAA+8CqwKrA+sCqwKvA8EAJGPAAB4AkwC6A9IAQAE/Ad0BXQFdAX8DyAEk48AAHwCRgL0DyAA+A+0AvIPlAEYCPAHAACWjwAAfAFGAfQHQAEUALQHtAX2BbQFlAeAAJuPIAAkASwBPAEkAecPJAE0ASQBJAEgAAAAnI8AAEIFXgVWBdYFVgV3D1YF1gVeBQIFAACejwQAkg+SBP4EkgcQAEQBdAHGD3QBRAFAAJ+PAAT8A6QPpAS8BwAAWAFIAc4PaAFIAUAAo48AAEQJVAnHB3QBBAjwBJQC/g+UAvQEAAimjxAIzAfoAUAIEAf+AOAPCABaAcYPaAEAAKiPRABVCcYHdAEACHAG/gEAAFQBxw90AUAAqY9EAFUJxgd0AUAADgjkBwAAVAHHD3QBQACrjwgAWgnsB0ABHATyBIgEAARVAccPdAEAAK2PBADMD1IBegfWANYPAABUAccPdAFEAQAAr48IAFoJ7AdIAUgPawVoBwwAXQHvD0wBAACwjwAAAAz8A0QA1A9UCFQE1AFUAlQFVAlACLGPAACAAn4CIgbqBqoCKgpqCqoG6gJiAwACso8ADPwDbAnsCf4H7AnsBf4H7AXsBfwLQAm5jwAIIgTsAwgEAAgIC8gIPggICggK+AkABLqPQghGBMgHAAQECMQLPAgECgQKBAr8CQAIu49ICFIE1gMEBBAIEAgQCP8LEAgQCBAIAAi8j0IIQgTMBwAIAAqCCWIIPgjACAAJAAoAAL2PAAgkBOgDAAQECAQKBAr0CxQIDAgECAAAvo8gCCIE7AMABAgICAvICD4ISAiICAgLAAjBjyAIJgToAwAEJAgkCCQI/AsiCCIIIggABMSPIAgkBOgDAAQwBAgJrApoCigKKAoICQAAxY8kCCQE6AcABCQIJAj0CyQIBAj8CQAKgAnHjyAIIgTsAwAECAgoCMgICAoICv4JCAgICMiPJAgkBOgHAAgEC8QIPAgUCBQKFAr0CQQEzo8ACEYMyAMABPwJBAkACPwLBAgECfwIAADQjyAIJAToBwAIEArUCTQJFAlUCZQJFAoACNGPQghCBMQHAAgAC/4IEggSCPILEggSCAAA1I8ACEIEzAcACAAL/ggyCtIKEgnSCjIKAgrYjwAIIgTsAwgEgAhECCQI/AsECCQIxAiACNmPAAgkBOgHAAgoCigJyghMCLgICAkICgAA248gCCIE7AMABEgISAv+CEgISAj+C0gISAjcjyAIJAToBwAIEAoUCfQIFAj0CxQKkAkAAN2PAAQiBOwDAARUBFQEVAT+BVQEVATEBQAA3o8ACCIE7AcABBQJLAkmCfQLJAkkCQQJAADfjyAIJAToAwAEAAn8CCQIZAjkCCQJPAoACOaPAAhOBMAHBAX8BAYI/AsACPwLBAr8CwAI6o8ACCQE6AcACPgLSApICv4LSApICvgLAADrj0QIRATIBwAEAAj4C0gKTgpICkgK+AsACPCPQghCBMwHAASICWgICAj+CwgIagiKCQAI9I+QCNQEtAMABPwJBAr0CpQK9AoECvwLAAD3j0IIRgTIBwAIJAuoCGAI/gtgCKgIJAsACvmPAAgkBOgDCARgCAgL+ggMCvgLCAjoCAAA/Y9CCEIExAMABPwJVApWClUKVApcCsALAAgAkEAIQgTMBwQIAAr+CyoKagiqCV4KQAoAAAGQQghCBMwHAARICE4KSAn4CEoJSgpICgAIApAgCCYE6AcABBQI1AtUCnwKUgpSCtILEAgDkAAIRAjIBwAEnAhACv4JAAj+CUAKnAqACgaQAAhODMADCATqCI4KiAr4CYgIjgjqCAgICZAACCQI6AcACCAKrAloCD4I6AsoCigKIAkKkAAIIgTsBwAEIgj6C0YIMAr+CwAIOAjAAA2QAACSCPQGlAUACPYLEAheCRAJlAryCwAID5AACCQI6AcABCwILAvcCFwInAqqCqoJIAgQkAAIIgTsAwAEEgWqCK4KUgriCVIIiggABBKQIAQiBOwDAAR0BVcF1AT8BVYEVQXcBAAEFJAACE4EwAcQBEgJVAhUCvIJVAhICVAJEAgXkAAIJAzIAxAEBAh0CtQKVArUC/QKBAoACBmQAABUBHwC2AMABPgFeAV8BXgF+AUIBAAEGpAgCCIE5AMABPoJrgiuCPoLrgiuCvoJAAAbkAAIJAToB0AILgv0CAAKJAr8CyQKJAoAAB2QAAgmCOgHAAhICv4JCAj8CxII8gsSCAAAHpAAANIIvAaYBQAIvAq0CvQLtAq8CgAKAAAfkEIIQgTMBwAIdApUCdQI/gvUCFQJdAoECiCQAAgkCOgHAAQgCKwLqAq8CqgKqAsgCAAAIpAACCYE4AcECJQKkgqvCuoLrgqqCggKEAgjkAIIJgTkAwAEfAlcCVwJ/gtcCVwJfAkECS6QAAhOCMAHEAiUClQKVAj+C1QJfAoQCgAIMZAACEIMzAMABP4JAgjqCXoJ6gkCCv4JAAgykAAIRgjIBwAEEAj+C6gK/AuqCqgKCAoACDiQQghEBMQHEAh4ClYJ1gh0CNwLUApwCgABO5AgCCQE6AMABJwIVAp8ClQJXAnUCBwIAAA8kCQIKAToB4ALfAVsDewPbA1sDfwPAAgAAD6QAAgiDOIDCAToBfwI/AsLCOoIBAzoDwgAQpAACEYEyAMABCgJbgnYCKgKyAmuCKgICAlFkEAIRATYAwAF/AgUCNQJ1AnUC/QJ3AkACEeQAAgkBOwHAAj+C2oI/gl+CWoLfgzADwAASpAACEYMwAMEBfwIFwrkCQwIRgr0C1QIRAhLkAAIIgzkAwAEegl6CXoJ+gt6CXoJegkAAU2QAAgiBOwDAAX8CNQLtAj2C7QI9Au8COALTpAACEIIzAcACOALPgjiCXoJ6gk+COALAABPkAAEIgLsA4AC3AU8BbwFvAU8BTwH/AcAAlOQIAgkBOgHAAQICPoLvgq4Cr4K+gsICAAAVJAACEYEyAMABNQJ9AnUCd4L1An0CdQJEAhVkAAIRAjIBwAI/ArcC9wK3grcC/wKiAoACFeQAAgiBOwDAATuCGoKagl/CGoK6gouCCAEWZCQCPYGkAUACLgOpA68DvYPrA6sDqQOgAhckAAA0Qy2AhAFQgT6CQYKXAj2C0IIwQoAAF6QkAjzBBQDgAR+CAIL8gg+Cn4IdQl1CjABYJACCEIIwgcIBHwJXAncCN4LXAn8CYgKAAhjkAIIQgzEAxAE/An8CvwK/gr8CvwKkAsACGWQAAgkDOgDAARMCXwKZArsC2QKYgpqC0AAaJCACNYIMAcEBvQJfg1UDUQLEAiOC3gKCAppkAAIRgzIAwAE9Ak0CPwJdgn8CTQK9AkACG2QAAgRBPYDAAT+Cb4Kvwq+Cr8K/gseCAAEbpAABCYC6AOAAnwEFAV0BFYGVAV0BBQFAABykJAI1AS0BwAG/AkMCLQKjArcC4wKvAoACnWQAAgmCOgHAAR8CW4LbAlsCXwN/g98CQQBd5CACNQEtAMABfwI7Av8DOwO/A/sDHwJAAl4kAEIJgTkA4AErgruCq4IoAjuCq4KrgoICHqQBAhEBMQDEAT8DfwL/An+CfwL/AsQCAAIf5AAAEQMyAMABfwLVArcCwgIuAjsC7QIqAiAkAIILAzgB0wG/Al+CVwLEAgOC+gIGAsACIGQkAjWBLAHAAiEC/QJ/gn0CfQJ/gj0CwAIhJACCEQIxAcQBH4Jegn+CPoLfgn6CZ4KEAiKkJAI1gSwB8AI/A38C34LfA/8D/wLwAgACI+QAACkDOgDAAT8D1QLnAvUC9wL1AvcCwAKkZAAAAAA3AdUCVQJ1AlUCVQJVAncCQAEAACTkAAAFAQkAsQBNAEMAgAA/A8EAHQCjAEAAJWQAAAEAPoH0ArUCtoL0ArUCtoK+gsACAAAl5BAAEQARAD8D0QARAAAAPwPBAB0AowBAAChkAgICAf4AC4IKAjoBwAA/A8EAHQCjAEAAKKQAAhEDvwBRABEAPwHRAAAAPwPBAB0AowBo5AkACQN/AMkCSQJ/AcAAPwPBAD0AgwBAACmkIAApAykA/8ApACkAAAA/g8CAHoChgEAAKqQAAAEBjQBpAj8DyQAAAD8DwQAdAKMAQAArpAAAPgHSAL+A0gC+AcAAPwPBAB0AowBAACvkAgA/g9IBEgESAT+DwAA/A8EAHwChAEAALGQAAT8ByQEJALkAyQC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rgWiBUAE6pJQC1gE9gdIBFgFCADoD6gC/g+oAuoPAADtklAJWAVUBPIHVAQAAXoMzANIAMwPeggABvySAABQC1wI8gdUB/wLDASkA+QDDAv8BwAABJNQCFgJ9gdUBEQFAATYAlYI1A90AEwFQAUik1AIWAX2B1QEVAEACCgJngUYB1oHKguoCCaTKAQuBfkDKgYqB4AHvgDrD6oAqgS+AwAAK5NQCFgJVATyB0QHAAS+BOoDqgaqCb4HAAAvk1gIVAnyB1QEBAUkAP4HZAVkBX4F5AcAADKTUAhYCfYHVAQABaIEKgDqD6oBKgK+AqAENpNIC1wI8gdUBEQBFABUD9QIfgjUA1QFQAlKk1gIVAnyB1QEBAX0BLQClAH+D7QB9AIEBEuTUAlYCPYHVAUEAOAPPgCyA6oCPgngBwAAdZNICFwJ8gfEBzAMLgPgBKoG/wuqCr4KCAh+k2gIbAlqBPkHagcCDP4Irgr+D64K/QoACIyTSATOBPkHSgXsBa0C/g+sAPwPrwL8BAAAlpNQCFgIVAnyB1QEAAn0C7AKvgKwAvYLAAiuk0AIUAtcCPIH1AUAAPwL7AruAuwK/AsACuGTUAhYCFYJ8QdSBAoN6ghuB2sBbg/qCQgEGJRQCFwF8gdUBQAA8gt6C3ML8w9yC34L8gs1lDAIWgr8BxwHdAC0B74HVAz+BRAH1ggABlGUUAhcCfIHBAd+AKoP7gm6DwAJTg9ICUgPcJQICFwJ8gdEBQgA6A/EB5IC9A+EAmgPAAB9lFAIXAXyB1QNAAgYCN4F3APcC94LrAsoAIiUmACGCPUPlASEBCAAIAAgAP4PIAAgACAAiZQAAJgAhgj1D5QElAQAAAQIBAj8BwQABACTlAAAmACGCPQPlASgAhwASgCICQgI+AcAAJ6UmACGCPUPlASEDIAIOAgABP4DgAEIADAAn5SYAIYI9Q+UBAQE8AGQAJAA/g+QAJAA8AGilJgAhgD1D5QEAAD+DwICMgH6AQII/gcAAKWUuACGCOUPpASkAAAM/AMkASQJJAn8DwAAppQAAJgAhgj0D5QEhAwwCA4G6AEIAzgECAinlJgAhAj2B5QEhAIQAE4CSAlICQgM+AMAAKmUmACGAPUPlAQEBBAB7gEICcgLCAj4BwAArpSYAIYI9A+UBIQMAAhCDv4JQghCDv4JAAixlJgAhgj1B5QE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OgDGAAAI6AquCpQPrAqkCqAIAACKlgAA/g8yAM4EgASqAnwKSAm4B08AqQMoAouWAAD+D3IAjgEgAJQP3APWA/QD1AvUB0AAjpYAAP4PAgD+AQAA3gdUBUAFXgVkBeQHEACPlgAA/g8KAPYLAAjoBwAI/AtWCVQJ9AsACJCWAAD+DwoA9gAABqwAqwWqCa4KqgD4DgAIlJYAAP4PCgH0AAAAvA+sAKwCrA6sArwIhAeZlgAA/g8CADoBxgQABP4C0AjeB9AA9gIABJuWAAD/DxkA7wBsBrcArgSgB6cAuAKuAiIAnJYAAP4PAgA6AcYAEAL0AvwC9g/8AvQCEAKglgAA/g8yAM4JBARsAWQNbAlkC3IJ6gEADKOWAAD+DzIAzgAACe4FmAO/AJgD6g+oAgAAp5YAAP4PMgDMCEAEtgeABKoJ+AzIC84IKAmolgAA/g8yAMwI4gcUBNQL7AjuCXwN7A8ECKqWAAD+DzoBxghQBLgC9AATCPQGuAToDAgAsZYAAP4PAgH+AMAN9gHyB/oL8g35AfUNoAi2lhAEVAVUBVQCVAr+B1QBVAJUA7wEkAQAALuWEAgQCXgJfAl4B3gFfAV4BXgHeAlICAAIvpYAABQGpAHkABwDIAD+D6gE+geoBKgEAADAlgAAUABYAMQP4AreCvAK8A/ECsQK2AoQAMGWAAb+AUIA+gcCACIA+gdSBfoHUgVSBQAAxJYIDOgDHgjIBwgEIAP8B6oEqAT8B6oEqATFliQGvAFkCPwHJADwD64EqAT+B6oEqAQAAMaWCAgIBXwFXgNcA9wPfgFdA1wFXAVECQABx5YAAAQO/AGsAOwP7ArsCuwP7ArsCvwKBAjMlgAA8A8ABP4HAAT+BzAC/g+oBPoHqAQIBNGWJAC0BI4ChA+8AkAEMAD+B0gF/AdKBUgF1ZaAD3wANAe0AjQJ/AcwAPwPqgT0B6gECATWlgAA7gSqBPoDrgLgBjAA/g+oBPoHqASoBNmWAAAICL8EvAS+BbwGiAK+ArwFvgW8BCQE3JYgAKQGlADGD7QCAAD+D6gEqgT6B6gEqATelgQIfAl8BaoDUg04AfwPqgSoBP4HqAQIBOKWgA/0ANQD1gLECPQHIAD+DygF/AcqBQAE45YAAPQJ1gX0A9YF9AUgAP4PqAT8B6oEqATolgQA9A8UAFQBFAD8DxQAVAFUChQI9A8EAOqWGADKCsoKygqKCr4KigrKCsoKyg8YAAAA75YACJgIygjqCcoGngTKBIoG2gnKCJgIAAjwlgAKGAmaBboFCgM+ARoJOgmKBxgBAAIAAPKWAAEMBWUFZQdFBV8FRQVlB2UHBQ0cCQAA9paAAJgAmgG6BUoF3gXKBVoNuguKAZgAgAD3lhgAyg/KCsoKigq+D4oKygrKCsoPGAAAAPuWAAAYANoH+gLKAt4H2gr6CsoLGAgABgAA/pYAAVgLXAtcC8wG3ALcAnwLTAtcBwAAAAAAlwAAWABaD3oBSg/eAVoPegFKCVgHQAAAAASXAAAeAA4IrgeGAd4FhgbWAt4KhgceAAAABpcACEwJ5gV2CyYIPg1GDfYPdg1mDQwNAAAHlxgM2gN6CfoHygXeBcoH+gX6BcoHWAsACQmXAAAMAWYF5gbmBsYH3gbGDuYO5gdMBQAACpcACDgJiguqCYoPvgmKD6oPqgkKCzgLAAgNlwABDAGmD7YLhgveD4YLtgumC4wIAAAAAA6XGAJaC0oLagvKD24PSg9aB/oHSgtaCxgIE5cAAA4ADgjWC64KrgYGAq4GvgrmCw4IAAQWlwAAmASKAroPigI+AIoGugG6D4oCmAQABByXAACYBLoCug+6Aj4Avgf6BfoF+gXIBwAAHpcYAMoP+gX6BcoF3gwKCPoL+gXKBdgLAAgnlwAAAAxMA+YP9gFGAx4KxgZ2A+YLTAcAATKXGAjKDXoJeg/KC54Cig56C/oKSg9YAgAAOJcAAEwH5gf2D8YHXgMGDPYD9gLmCswHAAA5lwAG7AF1B20FbQUFBy8C5QKlD60C7QKgAEKXAA7sAWUE/QT9BnUE5wdlBv0G9Qb1BCAASJcACAwJ5gv+C0YJrg+mCeYNTgu2COQIAABSlxAAFAD8D7wCvAK+ArwCvAq8CvwHFAAQAFaXCALoAg4C6AEAAPwPvAK+ArwKvAr8DxQAWZcQANwP3ALeCtwPEABYCVYJ9AdcAfABQABclxAI3AfcAt4K3AcAAIgCpArqB6IC6gOAAF6XAAEoASgBKAH+DwAAAAD+DygBKAEoAQABYJcABAgHfAdeB1wPXABeAFwPXAd8BwgHAARilwAA8g8SBPIHXgVSBfIHEgQSBPIPAgAAAGmXAAAEAuQCvgK0AvQPtAK0Ar4C5AIEAgAAi5cAAOQCrgL8D+4CBAogCCQJvw8kCSQJAACNlwQA7gKsA/4O5AIAAEgJxgl0BkQF6ARACJGXBALuAvwPrgJkCOAHBAiQC34I0AgQCwAAmJcEAP4CtAL0D74CQAj0BxAAXgEQCfQHAACtlwQC7gL8D24A/g98CawH/ASsCPwIBAgAANOX/AKsAq4PrAb8BgAE7AeuBawPrAXsBQgE5pcAAJIAkgCSAJIA/w+SAJIAkgSSBIADAADplwAA9ALUAt4P1AL0AgAAqAD+D6gAqASIA/OXEAAUANQHVAVUBVYFVAVUBVwF1AcUABAA9ZcgAOgHZgV0BeQHIAAQAS4FqAgICPgHAAD2lxAA3AdWBVwF1AcEALAHjgSiBKIEngcAAPuXEADcB1UFWgXUBwQA+A9UA1QDVAP8DwAI/5eUAL4A1QfgB/4H7gfOB8AH3gfGB5oAAAABmAAIBAj8C6wGrAasAqwCrAasBvwLBAgAAAKYBAgECPwPBAAACPwLrAqsAqwGrAb8CwAABZgEAQQB/AEEAQQI/AesBqwCrAasBvwLAAgGmAAI/AcAAPgDAAD+DwAA/AesBqwCrAr8CwiYSAjIBCQEEAMECPwLrAqsAqwCrAr8CwAIEJgkCCQI9A88AOQIAAj8C6wCrAKsCvwLAAARmAAAFAf0ABQC9AMACPwHrAasAqwC/AsACBOY6ACIAPwPiAToAgAI9Ae0BrwCtAr0CwAAF5gADvgBKAy8AqgDWAj8C6wKrAKsBvwHAAgYmAAAWADUB1IAxAkMBPwHrAKsAqwG/A8AAC2YAAB8CEwFTAR8BwAM/AmsCqwCrAb8BwAIO5gQAN4FEAR/AhQBkAD+DVYDVgNWAf4FAAQ8mAAAeAZYAfwPWAE4CvwJrAasAqwG/AcACEaYAAS8BKwC/A+sApwI+AmsCqwCrAb8BwAITJhADFwDXATcB1wJAAz8DVwJXAlcCfwNAAxNmCABrA+0BVYFpAcMAPwHrAasAqwK/AsAAE+YAAzsAzwIrgksBSQC/AusCqwCrAb8BwAIVJgADOQDLAimCiwFJAD8C6wKrAKsCvwLAAhYmAAP/AB8BqwArA/8AQAI/AesBqwC/AsACFuYBAr8C9wK3gL8CwAA/AesBqwCrAb8CwAAXpgAAKwEmALeAZwCiAj8C6wGrAKsAvwHAAhnmAAO+gEqD6oH2geABwII+guuBqoC+gcCDG+YAAH8DdoBGgn6A7wDAAn8B6wGrAL8CwAIdZgAAAQI9AsUCBQEFALcARQEFAj0CwQIAAB2mAAABAgECPwHBAAACPoJCgTuAwoI+gkAAHeYAAAAAPwDEAIQAQAI9AUUBNwDFAT0CQQIeZgEAQQB/AGEAAAI+gUKBAoD7gAKAgoE+gV6mAAM/AMAAPgDAAD+DwAA/AgMBuwBDAL8DHuYAARIBCYCkAECCPoECgLuAQoACgL6BAIIfZgAABIG8gESAPIHAAL6CAoG7gEKAPoOAAB+mPwPAgD6BwoE+gIACPoECgbuAQoA+g4AAH+YAAD0AIQA/w+EBGAC+ggKBu4BCgD6DgAIgZgwDAwC4gkgCO8HEAD6CQoE7gMKCPoJAACCmDAEDAPiAgAC3gcAAPoMCgLuAQoA+g0ABISYIgAqCOoHNgDiAAAI+gQKBu4BCgD6DgAAhpgQAFABTAJqDdAAAAj0BBQG3AEUAPQOAAiHmAAO/AEkDD4D5AYMAPAEFAbcARQA9A4ACIiYAACiCJIIige2BAAM+gkKBO4DCgj6CwAAiphIBFgESAP+AHgDSAjgBBQC3AEUAvQEAACRmCAAuAsgCPwFKAMgCPQJFATcAxQE9AkAAJaYAATPAtQB1A+yAQAK8ggaBtYBEgTyBQAIl5gABPwE1AL8D9QB/ADgCRQE3AMUCPQJAACYmEAMXANcBNwHXAkADPQMFAvcCBQK9AwEDJyYAAjyBxoBswSqAhII+gQKAu4BCgD6DgAAnZisABQGXgV0BZQOHAD0CRQG3AEUAPQNAASgmAQK/AvsCu4C/AsAAPQJFATcAxQI9AsAAKSYAAj8C/wL/gvMCzwD8AgKBO4DCgj6CQAAqJgAAAAO/AEEBOwFLAX8BywFxAz8BwAIAASxmAAO/gFCBPoDQgL+AAAD2ARWCVAJ3A0AAMSYBAD0DfwB/AekD/4HZgT2A/oD+gcECAAExphABsoBagBnBusBYgz/A2EE/QNhB/8BAAbOmAAAAA7+AQIEGgKiAeIAGgcCAP4HAAgABtiYdA3UAfwJ1Af8A9QBJA38AxQG5AH8BwAM25hQCFIG+gFCAEIA+g9CAEIAzgMUBSoJSAXemAAABAAEAAQABAAEAAQA/AAgB1AIiAiIBt+YAAAQABAI+A+0CLIJtAK0BvgJkAgQCAAA75gIBOQH0gTSBPQGAA7+AWIMogUiA+IEAAjymAgE9AeyBLIE9AYgABwMigP4AAgDOAQICPyYEAT8B7IEsgT0BgAA7AMsAewJBAj8BwAA/ZgIAAgE/Ae6BLoC9AYAAPgDlgT0BAQE/AT+mBAE/AeyBLoE8gY0BOgBJgD8DyQA5AMAAAWZBADyD1oJWgXyCQAAigz6A4gA/w+JAAAACpmAAJQAXAj+D9wJ3AncB9wF/g1cCJQIAAAQmRAAkACoCO4P3AuAA7YH1geWBa4IogAAABOZBAjyB3EGdQMhBIkE/wNYAB8C+APbBhAAGJkICOwPWglWBfQNBACUApQI8weUAIQCiAQomRAE+Ae0BLIE7AYcAPQPlAWWBZQF/AcAAFKZAADwD74EsgT0DkAAag16A28BKg/6DSgFZZkwAAwI6g8IBDgAAA78AQQABAD8DwAIAAZtmTAADAjKBxgAAA78ATQM1AIUA/IEEggAAG6ZcAAMCOoPCAQ4AgAIMAQOA+gACAMoBBgIcJkgABQAyg8YAgAA6AMnACQA/A8kACQC5AFxmWAAFADKDxgEQADwBywJKAnoCwgK+AkABHKZMAAMCMoHGAIIAOIDKgEqAeoJAgj+BwAAdpkgABQIygcYAggIoASuA7gApA/UCJQIAAR8mSAAFAjKDwgEuAKBCPoHiACIAPwPiwCAAH+ZIAAQAM4PGASAApQI/A8QBP4CkAVWCAAGgJkgABwAyg8IBBgAkAaYAJQI8g+UAJgCkASGmSAAFATKBxACBAD8B/QHVQVWBWQFDAcAAJaZAAAEAPQPVwVUBVwFVAVUBVcF9A8EAAAAmZmQAFQAVA+0CpQKvAqUCrIK0grSD1AAkAComQAAvAK8Av4O/A/0D/gO9g7yD/4O2AIAAqyZAAgADPwBVAFUBVQB/A1UAVQLVAkABwAAs5kABv4Aqgf+AqoKAAf8BxAI/gkQCPgIAAbBmQAG/gCqAv4JqguqBwAA1gwIAw4F0QQQCMWZAAb+AKoD/guqDoAN/gMiAOIAIgM+DAAAxpkABv4Aqgb+AqoLAAf+DwIEogVyBIoFAAXQmQAO/gCqBv4OqgmqBwAAigj6D4wIiAgACNKZAAb+AKoH/gKCChAHzAEqAegJCAj4BwAA1ZkAABQIzAXmAeQF7AHgA/4B8gPyBR4DAADbmQADfwDVA38DVQXBAxwMJAP/AiQEPAQACN2ZAAb+AKoH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\"\n    }\n}\n",
            "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
            "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage, ValType::Object)\n\nvoid RefImage::destroy(RefImage *t) {}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p size=%d x %d\", t, t->width(), t->height());\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((height() * 4 + 31) >> 5);\n}\n\nvoid RefImage::makeWritable() {\n    if (buffer->isReadOnly()) {\n        buffer = mkBuffer(data(), length());\n    }\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), buffer(buf) {\n    if (!buf)\n        oops(21);\n}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return sizeof(ImageHeader) + ((h + 7) >> 3) * w;\n    else\n        return sizeof(ImageHeader) + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ allocImage(const uint8_t *data, uint32_t sz) {\n    auto buf = mkBuffer(data, sz);\n    registerGCObj(buf);\n    Image_ r = NEW_GC(RefImage, buf);\n    unregisterGCObj(buf);\n    return r;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 2000 || height > 2000)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = allocImage(NULL, sz);\n    auto hd = r->header();\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = bpp;\n    hd->width = width;\n    hd->height = height;\n    hd->padding = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 9)\n        return false;\n\n    auto hd = (ImageHeader *)(buf->data);\n    if (hd->magic != IMAGE_HEADER_MAGIC || (hd->bpp != 1 && hd->bpp != 4))\n        return false;\n\n    int sz = byteSize(hd->width, hd->height, hd->bpp);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\nbool isLegacyImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf) - 4;\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True if the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    }\n}\n\nstatic int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\n/**\n * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n */\n//%\nvoid getRows(Image_ img, int x, Buffer dst) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    uint8_t *sp = img->pix(x, 0);\n    uint8_t *dp = dst->data;\n    int n = min(dst->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = *sp & 0xf;\n        *dp++ = *sp >> 4;\n        sp++;\n    }\n}\n\n/**\n * Copy row(s) of pixel from buffer to image.\n */\n//%\nvoid setRows(Image_ img, int x, Buffer src) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    img->makeWritable();\n\n    uint8_t *dp = img->pix(x, 0);\n    uint8_t *sp = src->data;\n    int n = min(src->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = (sp[0] & 0xf) | (sp[1] << 4);\n        sp += 2;\n    }\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid mapRect(Image_ img, int x, int y, int w, int h, Buffer map) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    if (img->bpp() != 4 || map->length < 16)\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    auto m = map->data;\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        auto ptr = p;\n        unsigned shift = y & 1;\n        for (int i = 0; i < h; i++) {\n            if (shift) {\n                *ptr = (m[*ptr >> 4] << 4) | (*ptr & 0x0f);\n                ptr++;\n                shift = 0;\n            } else {\n                *ptr = (m[*ptr & 0xf] & 0xf) | (*ptr & 0xf0);\n                shift = 1;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _mapRect(Image_ img, int xy, int wh, Buffer c) {\n    mapRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n//% argsNullable\nbool equals(Image_ img, Image_ other) {\n    if (!other) {\n        return false;\n    }\n    auto len = img->length();\n    if (len != other->length()) {\n        return false;\n    }\n    return 0 == memcmp(img->data(), other->data(), len);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    auto r = allocImage(img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src0 = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto sbh = img->byteHeight();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        auto src = src0 + i * sbh;\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    registerGCObj(tmp);\n    Image_ r = doubledY(tmp);\n    unregisterGCObj(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    // DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\",\n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n#define LOOPHD                                                                                     \\\n    for (int xx = 0; xx < w; ++xx, ++x)                                                            \\\n        if (0 <= x && x < sw)\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n            y = y0;\n\n            auto fdata = (uint32_t *)fromBase + wordH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            // DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n            //    (uint8_t*)fdata - from->pix());\n\n            auto cnt = wordH;\n            auto bot = min(sh, y + h);\n\n#define COLS(s) ((v >> (s)) & 0xf)\n#define COL(s) COLS(s)\n\n#define STEPA(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETLOW(s);                                                                                 \\\n    y++;\n#define STEPB(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETHIGH(s);                                                                                \\\n    y++;                                                                                           \\\n    tdata++;\n#define STEPAQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETLOW(s);\n#define STEPBQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETHIGH(s);                                                                                \\\n    tdata++;\n\n// perf: expanded version 5% faster\n#define ORDER(A, B)                                                                                \\\n    A(0);                                                                                          \\\n    B(4);                                                                                          \\\n    A(8);                                                                                          \\\n    B(12);                                                                                         \\\n    A(16);                                                                                         \\\n    B(20);                                                                                         \\\n    A(24);                                                                                         \\\n    B(28)\n//#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n#define LOOP(A, B, xbot)                                                                           \\\n    while (cnt--) {                                                                                \\\n        auto v = *fdata++;                                                                         \\\n        if (0 <= y && y <= xbot - 8) {                                                             \\\n            ORDER(A##Q, B##Q);                                                                     \\\n            y += 8;                                                                                \\\n        } else {                                                                                   \\\n            ORDER(A, B);                                                                           \\\n        }                                                                                          \\\n    }\n#define LOOPS(xbot)                                                                                \\\n    if (y & 1)                                                                                     \\\n        LOOP(STEPB, STEPA, xbot)                                                                   \\\n    else                                                                                           \\\n        LOOP(STEPA, STEPB, xbot)\n\n            if (color >= 0) {\n#define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n#define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                LOOPS(sh)\n            } else if (color == -2) {\n#undef COL\n#define COL(s) 1\n                LOOPS(bot)\n            } else {\n#undef COL\n#define COL(s) COLS(s)\n#undef SETHIGH\n#define SETHIGH(s)                                                                                 \\\n    if (*tdata & 0xf0)                                                                             \\\n    return true\n#undef SETLOW\n#define SETLOW(s)                                                                                  \\\n    if (*tdata & 0x0f)                                                                             \\\n    return true\n                LOOPS(sh)\n            }\n        }\n    } else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n            y = y0;\n\n            auto data = fromBase + fromH * xx;\n            auto off = imgBase + imgH * x;\n            auto off0 = off + left;\n            auto off1 = off + right;\n\n            int shift = (y & 7);\n\n            int y1 = y + h + (y & 7);\n            int prev = 0;\n\n            while (y < y1 - 8) {\n                int curr = *data++ << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = (curr >> 0) | (prev >> 8);\n\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n                off++;\n                prev = curr;\n                y += 8;\n            }\n\n            int left = y1 - y;\n            if (left > 0) {\n                int curr = *data << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n            }\n        }\n    } else if (tbp == 4 && fbp == 1) {\n        if (y < 0) {\n            fromBase = from->pix(0, -y);\n            imgBase = img->pix();\n        }\n        // icon mode\n        LOOPHD {\n            auto fdata = fromBase + fromH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            unsigned mask = 0x01;\n            auto v = *fdata++;\n            int off = (y & 1) ? 1 : 0;\n            if (y < 0) {\n                mask <<= -y & 7;\n                off = 0;\n            }\n            for (int i = off; i < len + off; ++i) {\n                if (mask == 0x100) {\n                    mask = 0x01;\n                    v = *fdata++;\n                }\n                if (v & mask) {\n                    if (i & 1)\n                        *tdata = (*tdata & 0x0f) | (color << 4);\n                    else\n                        *tdata = (*tdata & 0xf0) | color;\n                }\n                mask <<= 1;\n                if (i & 1)\n                    tdata++;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format (legacy)\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\nImage_ convertAndWrap(Buffer buf) {\n    if (isValidImage(buf))\n        return NEW_GC(RefImage, buf);\n\n    // What follows in this function is mostly dead code, except if people construct image buffers\n    // by hand. Probably safe to remove in a year (middle of 2020) or so. When removing, also remove\n    // from sim.\n    if (!isLegacyImage(buf))\n        return NULL;\n\n    auto tmp = mkBuffer(NULL, buf->length + 4);\n    auto hd = (ImageHeader *)tmp->data;\n    auto src = buf->data;\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = src[0] & 0xf;\n    hd->width = src[1];\n    hd->height = src[2];\n    hd->padding = 0;\n    memcpy(hd->pixels, src + 4, buf->length - 4);\n\n    registerGCObj(tmp);\n    auto r = NEW_GC(RefImage, tmp);\n    unregisterGCObj(tmp);\n    return r;\n}\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    img->makeWritable();\n\n    auto iconImg = convertAndWrap(icon);\n    if (!iconImg || iconImg->bpp() != 1)\n        return;\n\n    drawImageCore(img, iconImg, XX(xy), YY(xy), c);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid blitRow(Image_ img, int x, int y, Image_ from, int fromX, int fromH) {\n    if (!img->inRange(x, 0) || !img->inRange(fromX, 0) || fromH <= 0)\n        return;\n\n    if (img->bpp() != 4 || from->bpp() != 4)\n        return;\n\n    int fy = 0;\n    int stepFY = (from->width() << 16) / fromH;\n    int endY = y + fromH;\n    if (endY > img->height())\n        endY = img->height();\n    if (y < 0) {\n        fy += -y * stepFY;\n        y = 0;\n    }\n\n    auto dp = img->pix(x, y);\n    auto sp = from->pix(fromX, 0);\n\n    while (y < endY) {\n        int p = fy >> 16, c;\n        if (p & 1)\n            c = sp[p >> 1] >> 4;\n        else\n            c = sp[p >> 1] & 0xf;\n        if (y & 1) {\n            *dp = (*dp & 0x0f) | (c << 4);\n            dp++;\n        } else {\n            *dp = (*dp & 0xf0) | (c & 0xf);\n        }\n        y++;\n        fy += stepFY;\n    }\n}\n\n//%\nvoid _blitRow(Image_ img, int xy, Image_ from, int xh) {\n    blitRow(img, XX(xy), YY(xy), from, XX(xh), YY(xh));\n}\n\nvoid fillCircle(Image_ img, int cx, int cy, int r, int c) {\n    int x = r - 1;\n    int y = 0;\n    int dx = 1;\n    int dy = 1;\n    int err = dx - (r << 1);\n\n    while (x >= y) {\n        fillRect(img, cx + x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx + y, cy - x, 1, 1 + (x << 1), c);\n        fillRect(img, cx - x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx - y, cy - x, 1, 1 + (x << 1), c);\n        if (err <= 0) {\n            ++y;\n            err += dy;\n            dy += 2;\n        } else {\n            --x;\n            dx += 2;\n            err += dx - (r << 1);\n        }\n    }\n}\n\n//%\nvoid _fillCircle(Image_ img, int cxy, int r, int c) {\n    fillCircle(img, XX(cxy), YY(cxy), r, c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    return ImageMethods::convertAndWrap(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = NEW_GC(RefImage, icon);\n    registerGCObj(r);\n    auto t = ImageMethods::doubled(r);\n    unregisterGCObj(r);\n    return t->buffer;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif\n",
            "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Replace colors in a rectangle\n     */\n    //% helper=imageMapRect\n    mapRect(x: number, y: number, w: number, h: number, colorMap: Buffer): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Returns true if the provided image is the same as this image,\n     * otherwise returns false.\n     */\n    //% shim=ImageMethods::equals\n    equals(other: Image): boolean;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
            "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% snippet='img` `'\n//% pySnippet='img(\"\"\" \"\"\")'\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a circle\n     */\n    //% helper=imageDrawCircle\n    drawCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Fills a circle\n     */\n    //% helper=imageFillCircle\n    fillCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n\n    /**\n     * Scale and copy a row of pixels from a texture.\n     */\n    //% helper=imageBlitRow\n    blitRow(dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void;\n}\n\ninterface ScreenImage extends Image {\n    /**\n     * Sets the screen backlight brightness (10-100)\n     */\n    //% helper=setScreenBrightness\n    setBrightness(deg: number): Image;\n\n    /**\n     * Gets current screen backlight brightness (0-100)\n     */\n    //% helper=screenBrightness\n    brightness(): number;\n}\n\n// pxt compiler currently crashes on non-functions in helpers namespace; will fix\nnamespace _helpers_workaround {\n    export let brightness = 100\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_mapRect\n    function _mapRect(img: Image, xy: number, wh: number, m: Buffer): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillCircle\n    declare function _fillCircle(img: Image, cxy: number, r: number, c: color): void;\n\n    //% shim=ImageMethods::_blitRow\n    declare function _blitRow(img:Image, xy: number, from: Image, xh: number): void;\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageBlitRow(img:Image, dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void {\n        _blitRow(img, pack(dstX, dstY), from, pack(fromX, fromH))\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageMapRect(img: Image, x: number, y: number, w: number, h: number, m: Buffer): void {\n        _mapRect(img, pack(x, y), pack(w, h), m)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    export function imageDrawCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        cx = cx | 0;\n        cy = cy | 0;\n        r = r | 0;\n        // short cuts\n        if (r < 0) \n            return;\n        else if (r == 0) {\n            img.setPixel(cx, cy, col);\n            return;\n        } else if (r == 1) {\n            img.setPixel(cx + 1, cy, col);\n            img.setPixel(cx, cy + 1, col);\n            img.setPixel(cx - 1, cy, col);\n            img.setPixel(cx, cy - 1, col);\n            return;\n        }\n\n        const fcx = Fx8(cx);\n        const fcy = Fx8(cy);\n        const fr = Fx8(r);\n        const fr2 = Fx.leftShift(fr, 1);\n\n        let x = Fx.sub(fr, Fx.oneFx8)\n        let y = Fx.zeroFx8;\n        let dx = Fx.oneFx8;\n        let dy = Fx.oneFx8;\n        let err = Fx.sub(dx, fr2);\n        while (Fx.compare(x, y) >= 0) {\n            const cxpx = Fx.toInt(Fx.add(fcx, x));\n            const cxpy = Fx.toInt(Fx.add(fcx, y));\n            const cxmx = Fx.toInt(Fx.sub(fcx, x));\n            const cxmy = Fx.toInt(Fx.sub(fcx, y));\n            const cypy = Fx.toInt(Fx.add(fcy, y));\n            const cymy = Fx.toInt(Fx.sub(fcy, y));\n            const cypx = Fx.toInt(Fx.add(fcy, x));\n            const cymx = Fx.toInt(Fx.sub(fcy, x));\n\n            img.setPixel(cxpx, cypy, col);\n            img.setPixel(cxmx, cypy, col);\n            img.setPixel(cxmx, cymy, col);\n            img.setPixel(cxpx, cymy, col);\n            img.setPixel(cxpy, cypx, col);\n            img.setPixel(cxpy, cymx, col);\n            img.setPixel(cxmy, cymx, col);\n            img.setPixel(cxmy, cypx, col);\n\n            if (Fx.compare(err, Fx.zeroFx8) <= 0) {\n                y = Fx.add(y, Fx.oneFx8);\n                err = Fx.add(err, dy);\n                dy = Fx.add(dy, Fx.twoFx8);\n            } else {\n                x = Fx.sub(x, Fx.oneFx8);\n                dx = Fx.add(dx, Fx.twoFx8);\n                err = Fx.add(err, Fx.sub(dx, fr2));\n            }\n        }\n    }\n    export function imageFillCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        _fillCircle(img, pack(cx, cy), r, col);\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n    //% shim=pxt::setScreenBrightness\n    function _setScreenBrightness(brightness: number) { }\n\n    export function setScreenBrightness(img: Image, b: number) {\n        b = Math.clamp(10, 100, b | 0);\n        _helpers_workaround.brightness = b\n        _setScreenBrightness(_helpers_workaround.brightness)\n    }\n\n    export function screenBrightness(img: Image) {\n        return _helpers_workaround.brightness\n    }\n}\n\nnamespace image {\n    /**\n    * Get the screen image\n    */\n    //% blockNamespace=\"images\" group=\"Create\"\n    //% blockId=imagescreen block=\"screen\"\n    //% help=images/screen-image\n    export function screenImage(): Image {\n        return screen;\n    }\n}\n",
            "imagesoverrides.jres": "{\n  \n}",
            "imagesoverrides.ts": "// replace with built-in images",
            "ns.ts": "\n//% color=\"#a5b1c2\"\nnamespace images {\n\n}",
            "panic.cpp": "#include \"pxt.h\"\n\n// This adds about 1.2k of binary size, but allows for displaying \n// panic codes regardless of heap state etc. with IRQs disabled.\n\n#define ST7735_NOP 0x00\n#define ST7735_SWRESET 0x01\n#define ST7735_RDDID 0x04\n#define ST7735_RDDST 0x09\n\n#define ST7735_SLPIN 0x10\n#define ST7735_SLPOUT 0x11\n#define ST7735_PTLON 0x12\n#define ST7735_NORON 0x13\n\n#define ST7735_INVOFF 0x20\n#define ST7735_INVON 0x21\n#define ST7735_DISPOFF 0x28\n#define ST7735_DISPON 0x29\n#define ST7735_CASET 0x2A\n#define ST7735_RASET 0x2B\n#define ST7735_RAMWR 0x2C\n#define ST7735_RAMRD 0x2E\n\n#define ST7735_PTLAR 0x30\n#define ST7735_COLMOD 0x3A\n#define ST7735_MADCTL 0x36\n\n#define ST7735_FRMCTR1 0xB1\n#define ST7735_FRMCTR2 0xB2\n#define ST7735_FRMCTR3 0xB3\n#define ST7735_INVCTR 0xB4\n\n#define ST7735_GMCTRP1 0xE0\n#define ST7735_GMCTRN1 0xE1\n\n#define MADCTL_MY 0x80\n#define MADCTL_MX 0x40\n#define MADCTL_MV 0x20\n#define MADCTL_ML 0x10\n#define MADCTL_RGB 0x00\n#define MADCTL_BGR 0x08\n#define MADCTL_MH 0x04\n\nnamespace _pxt_panic {\n\n// target_panic has been called\nstatic bool panicMode = false;\n\n#define DELAY 0x80\n\nclass ST7735 {\n    Pin *sck, *mosi, *dc, *cs;\n\n    void sendBytes(uint8_t *ptr, uint32_t len);\n    void sendCmd(uint8_t *buf, int len);\n    void sendCmdSeq(const uint8_t *buf);\n    void configure(uint8_t madctl, uint32_t frmctr1);\n\n  public:\n    uint16_t width, height;\n    void fill(int color, int numpixels);\n    void setAddrWindow(int x, int y, int w, int h);\n    void init();\n    void drawNumber(int idx, int x, int y, int color);\n};\n\n// clang-format off\nstatic const uint8_t initCmds[] = {\n    ST7735_SWRESET,   DELAY,  //  1: Software reset, 0 args, w/delay\n      120,                    //     150 ms delay\n    ST7735_SLPOUT ,   DELAY,  //  2: Out of sleep mode, 0 args, w/delay\n      120,                    //     500 ms delay\n    ST7735_INVOFF , 0      ,  // 13: Don't invert display, no args, no delay\n    ST7735_COLMOD , 1      ,  // 15: set color mode, 1 arg, no delay:\n      0x03,                  //     12-bit color\n\n    ST7735_NORON  ,    DELAY, //  3: Normal display on, no args, w/delay\n      10,                     //     10 ms delay\n    ST7735_DISPON ,    DELAY, //  4: Main screen turn on, no args w/delay\n      10,\n    0, 0 // END\n};\n// clang-format on\n\nstatic const uint8_t numbers[] = {\n    0x06, 0x09, 0x09, 0x09, 0x06, // 0\n    0x04, 0x06, 0x04, 0x04, 0x0e, // 1\n    0x07, 0x08, 0x06, 0x01, 0x0f, // 2\n    0x0f, 0x08, 0x04, 0x09, 0x06, // 3\n    0x0c, 0x0a, 0x09, 0x1f, 0x08, // 4\n    0x1f, 0x01, 0x0f, 0x10, 0x0f, // 5\n    0x08, 0x04, 0x0e, 0x11, 0x0e, // 6\n    0x1f, 0x08, 0x04, 0x02, 0x01, // 7\n    0x0e, 0x11, 0x0e, 0x11, 0x0e, // 8\n    0x0e, 0x11, 0x0e, 0x04, 0x02, // 9\n    0x11, 0x00, 0x0e, 0x1b, 0x11, // :(\n    // 0x11, 0x04, 0x04, 0x0a, 0x11, // :(\n};\n\nvoid ST7735::sendBytes(uint8_t *ptr, uint32_t len) {\n    uint8_t mask = 0, b;\n    for (;;) {\n        if (!mask) {\n            if (!len--)\n                break;\n            mask = 0x80;\n            b = *ptr++;\n        }\n        mosi->setDigitalValue((b & mask) ? 1 : 0);\n        sck->setDigitalValue(1);\n        mask >>= 1;\n        sck->setDigitalValue(0);\n    }\n}\n\nvoid ST7735::fill(int color, int numpixels) {\n    uint8_t cmd[20] = {ST7735_RAMWR};\n    sendCmd(cmd, 1);\n\n    dc->setDigitalValue(1);\n    cs->setDigitalValue(0);\n\n    cmd[0] = color >> 4;\n    cmd[1] = (color << 4) | (color >> 8);\n    cmd[2] = color;\n\n    int n = (numpixels + 1) >> 1;\n    while (n--) {\n        sendBytes(cmd, 3);\n    }\n\n    cs->setDigitalValue(1);\n}\n\nvoid ST7735::sendCmd(uint8_t *buf, int len) {\n    // make sure cmd isn't on stack\n    dc->setDigitalValue(0);\n    cs->setDigitalValue(0);\n    sendBytes(buf, 1);\n    dc->setDigitalValue(1);\n    len--;\n    buf++;\n    if (len > 0)\n        sendBytes(buf, len);\n    cs->setDigitalValue(1);\n}\n\nstatic void busy_wait_us(int ms) {\n    target_wait_us(ms);\n    /*\n    // this is for 120MHz\n    while (ms--) {\n        for (int i = 0; i < 30; ++i)\n            asm volatile(\"nop\");\n    }\n    */\n}\n\nvoid ST7735::sendCmdSeq(const uint8_t *buf) {\n    uint8_t cmdBuf[32];\n\n    while (*buf) {\n        cmdBuf[0] = *buf++;\n        int v = *buf++;\n        int len = v & ~DELAY;\n        // note that we have to copy to RAM\n        memcpy(cmdBuf + 1, buf, len);\n        sendCmd(cmdBuf, len + 1);\n        buf += len;\n        if (v & DELAY) {\n            busy_wait_us(1000 * *buf++);\n        }\n    }\n}\n\nvoid ST7735::setAddrWindow(int x, int y, int w, int h) {\n    w += x - 1;\n    h += y - 1;\n    uint8_t cmd0[] = {ST7735_RASET, 0, (uint8_t)x, (uint8_t)(w >> 8), (uint8_t)w};\n    uint8_t cmd1[] = {ST7735_CASET, 0, (uint8_t)y, (uint8_t)(h >> 8), (uint8_t)h};\n    sendCmd(cmd1, sizeof(cmd1));\n    sendCmd(cmd0, sizeof(cmd0));\n}\n\nvoid ST7735::init() {\n    mosi = LOOKUP_PIN(DISPLAY_MOSI);\n    sck = LOOKUP_PIN(DISPLAY_SCK);\n    cs = LOOKUP_PIN(DISPLAY_CS);\n    dc = LOOKUP_PIN(DISPLAY_DC);\n    auto bl = LOOKUP_PIN(DISPLAY_BL);\n    auto rst = LOOKUP_PIN(DISPLAY_RST);\n\n    cs->setDigitalValue(1);\n    dc->setDigitalValue(1);\n\n    if (bl) {\n        bl->setDigitalValue(1);\n    }\n\n    if (rst) {\n        rst->setDigitalValue(0);\n        busy_wait_us(20 * 1000);\n        rst->setDigitalValue(1);\n        busy_wait_us(20 * 1000);\n    }\n\n    uint32_t cfg0 = getConfig(CFG_DISPLAY_CFG0, 0x40);\n    uint32_t frmctr1 = getConfig(CFG_DISPLAY_CFG1, 0x000603);\n    auto madctl = cfg0 & 0xff;\n\n    sendCmdSeq(initCmds);\n    configure(madctl, frmctr1);\n\n    width = getConfig(CFG_DISPLAY_WIDTH, 160);\n    height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n}\n\nvoid ST7735::configure(uint8_t madctl, uint32_t frmctr1) {\n    uint8_t cmd0[] = {ST7735_MADCTL, madctl};\n    uint8_t cmd1[] = {ST7735_FRMCTR1, (uint8_t)(frmctr1 >> 16), (uint8_t)(frmctr1 >> 8),\n                      (uint8_t)frmctr1};\n    sendCmd(cmd0, sizeof(cmd0));\n    sendCmd(cmd1, cmd1[3] == 0xff ? 3 : 4);\n}\n\n#define SIZE 4\n\nvoid ST7735::drawNumber(int idx, int x, int y, int color) {\n    const uint8_t *src = &numbers[idx * 5];\n    for (int i = 0; i < 5; i++) {\n        uint8_t ch = *src++;\n        for (int j = 0; j < 5; j++) {\n            if (ch & (1 << j)) {\n                setAddrWindow(x + j * SIZE, y + i * SIZE, SIZE - 1, SIZE - 1);\n                fill(color, (SIZE - 1) * (SIZE - 1));\n            }\n        }\n    }\n}\n\nstatic void drawPanic(int code) {\n    if (!LOOKUP_PIN(DISPLAY_MOSI))\n        return;\n\n    ST7735 display;\n\n    display.init();\n    display.setAddrWindow(0, 0, display.width, display.height);\n    display.fill(0, display.width * display.height);\n\n    display.drawNumber(10, 70, 20, 0xf00);\n    int x = 50;\n    int y = 60;\n    display.drawNumber((code / 100) % 10, x, y, 0xff0);\n    x += 24;\n    display.drawNumber((code / 10) % 10, x, y, 0xff0);\n    x += 24;\n    display.drawNumber((code / 1) % 10, x, y, 0xff0);\n    x += 24;\n}\n\nextern \"C\" void target_panic(int statusCode) {\n    DMESG(\"*** CODAL PANIC : [%d]\", statusCode);\n\n    if (panicMode) {\n        // avoid recursive panic invocation\n        target_disable_irq();\n        while (1) {\n        }\n    }\n\n    gcFreeze();\n\n    // remember first panic code\n    panicMode = true;\n\n    target_disable_irq();\n    drawPanic(statusCode);\n\n    auto led = LOOKUP_PIN(LED);\n\n    const int unit = 100000;\n    const int dit = unit;\n    const int dat = 3 * unit;\n    const int intra = unit;\n    const int inter = 2 * unit;\n    const int word = 6 * unit;\n    while (1) {\n        if (led) {\n            // SOS\n            // . . .\n            for(int i = 0; i < 3; ++i) {\n                led->setDigitalValue(1);\n                busy_wait_us(dit);\n                led->setDigitalValue(0);\n                busy_wait_us(intra);\n            }\n            // inter character space\n            busy_wait_us(inter);\n            // - - - \n            for(int i = 0; i < 3; ++i) {\n                led->setDigitalValue(1);\n                busy_wait_us(dat);\n                led->setDigitalValue(0);\n                busy_wait_us(intra);\n            }\n            // inter character space\n            busy_wait_us(inter);\n            // . . .\n            for(int i = 0; i < 3; ++i) {\n                led->setDigitalValue(1);\n                busy_wait_us(dit);\n                led->setDigitalValue(0);\n                busy_wait_us(intra);\n            }\n            // inter character space\n            busy_wait_us(word);\n        }\n    }\n}\n\n} // namespace _pxt_panic",
            "pxt.json": "{\n  \"name\": \"screen---st7735\",\n  \"description\": \"The screen library\",\n  \"files\": [\n    \"screen.cpp\",\n    \"panic.cpp\",\n    \"image.cpp\",\n    \"image.ts\",\n    \"text.ts\",\n    \"frame.ts\",\n    \"shims.d.ts\",\n    \"fieldeditors.ts\",\n    \"targetoverrides.ts\",\n    \"ns.ts\",\n    \"image.d.ts\",\n    \"pxtparts.json\",\n    \"imagesoverrides.jres\",\n    \"imagesoverrides.ts\",\n    \"font12.jres\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n  \"screen\": {\n    \"simulationBehavior\": \"screen\",\n    \"visual\": {\n      \"builtIn\": \"screen\",\n      \"width\": 158.43856811523438,\n      \"height\": 146.8025665283203,\n      \"pinDistance\": 14.91,\n      \"pinLocations\": [\n        {\n          \"x\": 4.227952701380444,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 18.170226805137037,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 46.05478386015504,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 59.99706238766404,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 73.93934976267785,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 87.88161944268204,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 101.82389797019104,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 32.11250533264604,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 117.68761950246274,\n          \"y\": 3.1650031792503945\n        }\n      ]\n    },\n    \"numberOfPins\": 9,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_DC\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_CS\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MOSI\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_SCK\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MISO\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_RST\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8\n        ]\n      }\n    ]\n  }\n}",
            "screen.cpp": "#include \"pxt.h\"\n#include \"ST7735.h\"\n#include \"ILI9341.h\"\n\n#include \"SPIScreenIO.h\"\n#ifdef STM32F4\n#include \"FSMCIO.h\"\n#endif\n\nnamespace pxt {\n\nclass WDisplay {\n  public:\n    ScreenIO *io;\n    ST7735 *lcd;\n\n    uint32_t currPalette[16];\n    bool newPalette;\n    bool inUpdate;\n\n    uint8_t *screenBuf;\n    Image_ lastStatus;\n\n    uint16_t width, height;\n    uint16_t displayHeight;\n    uint8_t offX, offY;\n    bool doubleSize;\n    uint32_t palXOR;\n\n    WDisplay() {\n        uint32_t cfg2 = getConfig(CFG_DISPLAY_CFG2, 0x0);\n        int conn = cfg2 >> 24;\n\n        SPI *spi = NULL;\n        if (conn == 0) {\n            spi = new CODAL_SPI(*LOOKUP_PIN(DISPLAY_MOSI), *LOOKUP_PIN(DISPLAY_MISO),\n                                *LOOKUP_PIN(DISPLAY_SCK));\n            io = new SPIScreenIO(*spi);\n        } else if (conn == 1) {\n#ifdef CODAL_CREATE_PARALLEL_SCREEN_IO\n            io = CODAL_CREATE_PARALLEL_SCREEN_IO(cfg2 & 0xffffff, PIN(DISPLAY_MOSI), PIN(DISPLAY_MISO));\n#else\n            target_panic(PANIC_SCREEN_ERROR);\n#endif\n        } else {\n            target_panic(PANIC_SCREEN_ERROR);\n        }\n\n        int dispTp = getConfig(CFG_DISPLAY_TYPE, DISPLAY_TYPE_ST7735);\n\n        doubleSize = false;\n\n        if (dispTp == DISPLAY_TYPE_ST7735)\n            lcd = new ST7735(*io, *LOOKUP_PIN(DISPLAY_CS), *LOOKUP_PIN(DISPLAY_DC));\n        else if (dispTp == DISPLAY_TYPE_ILI9341) {\n            lcd = new ILI9341(*io, *LOOKUP_PIN(DISPLAY_CS), *LOOKUP_PIN(DISPLAY_DC));\n            doubleSize = true;\n        } else\n            target_panic(PANIC_SCREEN_ERROR);\n\n        auto rst = LOOKUP_PIN(DISPLAY_RST);\n        if (rst) {\n            rst->setDigitalValue(0);\n            fiber_sleep(20);\n            rst->setDigitalValue(1);\n            fiber_sleep(20);\n        }\n\n        auto bl = LOOKUP_PIN(DISPLAY_BL);\n        if (bl) {\n            bl->setDigitalValue(1);\n        }\n\n        uint32_t cfg0 = getConfig(CFG_DISPLAY_CFG0, 0x40);\n        uint32_t frmctr1 = getConfig(CFG_DISPLAY_CFG1, 0x000603);\n        palXOR = (cfg0 & 0x1000000) ? 0xffffff : 0x000000;\n        auto madctl = cfg0 & 0xff;\n        offX = (cfg0 >> 8) & 0xff;\n        offY = (cfg0 >> 16) & 0xff;\n\n        DMESG(\"configure screen: FRMCTR1=%p MADCTL=%p type=%d\", frmctr1, madctl, dispTp);\n\n        if (spi) {\n            auto freq = (cfg2 & 0xff);\n            if (!freq)\n                freq = 15;\n            spi->setFrequency(freq * 1000000);\n            spi->setMode(0);\n        }\n\n        lcd->init();\n        lcd->configure(madctl, frmctr1);\n        width = getConfig(CFG_DISPLAY_WIDTH, 160);\n        height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n        displayHeight = height;\n        setAddrMain();\n        DMESG(\"screen: %d x %d, off=%d,%d\", width, height, offX, offY);\n        int sz = doubleSize ? (width >> 1) * (height >> 1) : width * height;\n        screenBuf = (uint8_t *)app_alloc(sz / 2 + 20);\n\n        lastStatus = NULL;\n        registerGC((TValue *)&lastStatus);\n        inUpdate = false;\n    }\n\n    void setAddrStatus() {\n        lcd->setAddrWindow(offX, offY + displayHeight, width, height - displayHeight);\n    }\n    void setAddrMain() { lcd->setAddrWindow(offX, offY, width, displayHeight); }\n};\n\nSINGLETON_IF_PIN(WDisplay, DISPLAY_MOSI);\n\n//%\nvoid setScreenBrightness(int level) {\n    auto bl = LOOKUP_PIN(DISPLAY_BL);\n    if (!bl)\n        return;\n\n    if (level < 0)\n        level = 0;\n    if (level > 100)\n        level = 100;\n\n    if (level == 0)\n        bl->setDigitalValue(0);\n    else if (level == 100)\n        bl->setDigitalValue(1);\n    else {\n        bl->setAnalogPeriodUs(1000);\n        bl->setAnalogValue(level * level * 1023 / 10000);\n    }\n}\n\n//%\nvoid setPalette(Buffer buf) {\n    auto display = getWDisplay();\n    if (!display)\n        return;\n\n    if (48 != buf->length)\n        target_panic(PANIC_SCREEN_ERROR);\n    for (int i = 0; i < 16; ++i) {\n        display->currPalette[i] =\n            (buf->data[i * 3] << 16) | (buf->data[i * 3 + 1] << 8) | (buf->data[i * 3 + 2] << 0);\n        display->currPalette[i] ^= display->palXOR;\n    }\n    display->newPalette = true;\n}\n\n//%\nvoid setupScreenStatusBar(int barHeight) {\n    auto display = getWDisplay();\n    if (!display)\n        return;\n    if (!display->doubleSize) {\n        display->displayHeight = display->height - barHeight;\n        display->setAddrMain();\n    }\n}\n\n//%\nvoid updateScreenStatusBar(Image_ img) {\n    auto display = getWDisplay();\n    if (!display)\n        return;\n\n    if (!img)\n        return;\n    display->lastStatus = img;\n}\n\n//%\nvoid updateScreen(Image_ img) {\n    auto display = getWDisplay();\n    if (!display)\n        return;\n\n    if (display->inUpdate)\n        return;\n\n    display->inUpdate = true;\n\n    auto mult = display->doubleSize ? 2 : 1;\n\n    if (img) {\n        if (img->bpp() != 4 || img->width() * mult != display->width ||\n            img->height() * mult != display->displayHeight)\n            target_panic(PANIC_SCREEN_ERROR);\n\n        // DMESG(\"wait for done\");\n        display->lcd->waitForSendDone();\n\n        auto palette = display->currPalette;\n\n        if (display->newPalette) {\n            display->newPalette = false;\n        } else {\n            palette = NULL;\n        }\n\n        memcpy(display->screenBuf, img->pix(), img->pixLength());\n\n        // DMESG(\"send\");\n        display->lcd->sendIndexedImage(display->screenBuf, img->width(), img->height(), palette);\n    }\n\n    if (display->lastStatus && !display->doubleSize) {\n        display->lcd->waitForSendDone();\n        img = display->lastStatus;\n        auto barHeight = display->height - display->displayHeight;\n        if (img->bpp() != 4 || barHeight != img->height() || img->width() != display->width)\n            target_panic(PANIC_SCREEN_ERROR);\n        memcpy(display->screenBuf, img->pix(), img->pixLength());\n        display->setAddrStatus();\n        display->lcd->sendIndexedImage(display->screenBuf, img->width(), img->height(), NULL);\n        display->lcd->waitForSendDone();\n        display->setAddrMain();\n        display->lastStatus = NULL;\n    }\n\n    display->inUpdate = false;\n}\n\n//%\nvoid updateStats(String msg) {\n    // ignore...\n}\n} // namespace pxt",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True if the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n     */\n    //% shim=ImageMethods::getRows\n    getRows(x: int32, dst: Buffer): void;\n\n    /**\n     * Copy row(s) of pixel from buffer to image.\n     */\n    //% shim=ImageMethods::setRows\n    setRows(x: int32, src: Buffer): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\n//% whenUsed\nconst screen = _screen_internal.createScreen();\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    //% shim=pxt::updateScreenStatusBar\n    function updateScreenStatusBar(img: Image): void { return }\n    //% shim=pxt::setupScreenStatusBar\n    function setupScreenStatusBar(barHeight: number): void { return }\n\n    export function createScreen() {\n        const img = image.create(160, 120);\n        setupScreenStatusBar(8);\n\n        const status = image.create(160, 8)\n        updateScreenStatusBar(status) // clear the status area\n\n        control.__screen.setupUpdate(() => updateScreen(img))\n        control.EventContext.onStats = function (msg: string) {\n            status.fill(0)\n            status.print(msg, 2, 2, 1, image.font5)\n            updateScreenStatusBar(status)\n            updateStats(msg);\n        }\n\n        return img as ScreenImage;\n    }\n\n}\n",
            "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        multiplier?: number;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 6,\n        charHeight: 8,\n        data: hex`\n2000000000000000 210000005e000000 2200000e000e0000 230028fe28fe2800 24004c92ff926400 250002651248a640\n26006c92926ca000 270000000e000000 280000007c820000 29000000827c0000 2a00543810385400 2b0010107c101000\n2c00000090700000 2d00101010101000 2e00000060600000 2f00006010080600 3000003c42423c00 310000447e400000\n3200004462524c00 330000424a4e3200 34003028247e2000 3500004e4a4a3200 3600003c4a4a3000 3700000262120e00\n380000344a4a3400 3900000c52523c00 3a0000006c6c0000 3b00000096760000 3c00102828444400 3d00282828282800\n3e00444428281000 3f00000259090600 40003c425a560800 4100781412147800 42007e4a4a4a3400 4300003c42422400\n4400007e42423c00 4500007e4a4a4200 4600007e0a0a0200 4700003c42523400 4800007e08087e00 490000427e420000\n4a002040423e0200 4b00007e08146200 4c00007e40404000 4d007e0418047e00 4e00007e04087e00 4f003c4242423c00\n5000007e12120c00 5100003c5262bc00 5200007e12126c00 530000244a522400 540002027e020200 5500003e40403e00\n5600001e70701e00 57007e2018207e00 5800422418244200 5900060870080600 5a000062524a4600 5b00007e42420000\n5c00000608106000 5d000042427e0000 5e00080402040800 5f00808080808000 6000000002040000 6100003048487800\n6200007e48483000 6300003048484800 6400003048487e00 6500003068585000 660000107c120400 67000018a4a47800\n6800007e08087000 690000487a400000 6a000040847d0000 6b00007e10284000 6c0000427e400000 6d00780830087000\n6e00007808087000 6f00003048483000 700000fc24241800 710000182424fc00 7200007810081000 7300005058682800\n740000083e482000 7500003840407800 7600001860601800 7700384030403800 7800004830304800 7900005ca0a07c00\n7a00004868584800 7b00000836410000 7c000000fe000000 7d00004136080000 7e00000804080400 a000000000000000\na10000007a000000 a200003048fc4800 a30090fc92928400 a400542844285400 a5002a2c782c2a00 a6000000ee000000\na7000094aaaa5200 a800000200020000 a9003e414955413e aa0000242a2e0000 ab00102854284400 ac00001010107000\nad00001010101000 ae003e415d45413e af00000202020200 b000000814140800 b1008888be888800 b2000024322c0000\nb30000222a140000 b400000004020000 b50000f840207800 b6000c1e7e027e00 b700000010000000 b800000080400000\nb90000243e200000 ba0000242a240000 bb00442854281000 bc00025f70f84000 bd00021f90c8b000 be0011557af84000\nbf000030484d2000 c000601916186000 c100601816196000 c200601a151a6000 c300601a151a6100 c400601914196000\nc500601a151a6000 c6007c0a7e4a4200 c700001ea1611200 c800007c55564400 c900007c56554400 ca00007c56554600\ncb00007c55544500 cc0000457e440000 cd0000447e450000 ce0000467d460000 cf0000457c450000 d000087e4a423c00\nd100007e09127d00 d200003845463800 d300003846453800 d400003846453a00 d500003a45463900 d600003845443900\nd700442810284400 d80000fc724e3f00 d900003c41423c00 da00003c42413c00 db00003c42413e00 dc00003c41403d00\ndd00040872090400 de00007e24241800 df00007c025a2400 e0000030494a7800 e10000304a497800 e20000304a497a00\ne3000032494a7900 e40000304a487a00 e50000304a4d7a00 e600304878685000 e7000018a4642400 e8000030695a5000\ne90000306a595000 ea0000306a595200 eb0000306a585200 ec0000497a400000 ed0000487a410000 ee00004a79420000\nef00004a78420000 f00000304a4b3d00 f100007a090a7100 f2000030494a3000 f30000304a493000 f40000304a493200\nf5000032494a3100 f60000304a483200 f700101054101000 f800007068583800 f900003841427800 fa00003842417800\nfb00003842417a00 fc00003842407a00 fd0000b84241f800 fe0000ff24241800 ff00005ca1a07d00 0001601915196000\n010100304a4a7a00 0201611a16196000 030100314a4a7900 04013c0a094abc00 050100182464bc00 0601003846452800\n070100304a494800 0801003846452a00 090100304a494a00 0a01003844452800 0b010030484a4800 0c01003845462900\n0d010030494a4900 0e01007c45463900 0f0100314a497e00 1001087e4a423c00 110130484c7e0400 1201007d55554500\n130100326a5a5200 1401007d56564500 150100316a5a5100 1601007c55544400 170100306a585000 1801003f65a52100\n1901001874ac2800 1a01007c55564500 1b010030695a5100 1c01003846553600 1d0100304a49f200 1e01003946563500\n1f0100314a4af100 2001003844553400 21010018a4a57800 2201001ea1691a00 23010018a6a57800 2401007812117a00\n25017e080a710200 2601047e147e0400 2701047e0c087000 28010002457e4500 29010002497a4100 2a0100457d450000\n2b01004a7a420000 2c0100014a7a4900 2d0100014a7a4100 2e0100217fa10000 2f0100247da00000 300100447d440000\n3101004878400000 32017e0022423e00 33013d0040847d00 34012040463d0600 350100800af90200 360100bf440a3100\n370100bf48142000 3801007810284800 3901007c40424100 3a0100467d400000 3b01003fa0602000 3c0100a17f200000\n3d01007c41424100 3e0100457e410000 3f01007e40484000 400100427e400800 4101107e48404000 420100527e480000\n4301007c0a117c00 440100780a097000 450100bf42043f00 460100bc44043800 4701007c09127d00 480100790a097000\n49010a0678087000 4a01003f02847f00 4b01003c04847800 4c01394545453900 4d0100324a4a3200 4e01394646463900\n4f0100314a4a3100 50013a4544463900 5101324948320100 52013c427e4a4200 5301304830685000 5401007c16354800\n5501007812091000 560100bf49093600 570100bc48040800 5801007d16354800 5901007912091000 5a01004856552400\n5b0100505a692800 5c01004856552600 5d0100505a692a00 5e010012a5691200 5f010028ac741400 6001004855562500\n61010050596a2900 62010101bf410100 630100049f641000 640104057e050400 650100083d4a2100 660102127e120200\n670100183e582000 6801003a41423900 6901003a41427900 6a01003d41413d00 6b01003a42427a00 6c01003942423900\n6d01003942427900 6e01003a45453a00 6f01003a45457a00 70013a41403a0100 71013a41407a0100 7201001f60a01f00\n7301001c60a03c00 7401782211227800 7501384231423800 7601081261120800 770100b84241fa00 7801040970090400\n79010064564d4400 7a0100486a594800 7b010064544d4400 7c010048685a4800 7d010064554e4500 7e010048695a4900\n7f0100087c020400 8f01003452523c00 920100887e090200 a0013c42423c0806 a101003048483008 af01003e403e0806\nb001003840781008 b501006a5a4a4e00 b601005878585800 d101003845463900 d2010030494a3100 e601003845563500\ne7010030494af100 fa0100742a750000 fb0100304c4a7d00 fc0178147e554400 fd0130487a695000 fe010078744e3d00\nff0100706a593800 18020012a5691200 19020028ac741400 1a020101bf410100 1b0200049f641000 bb0200000c0a0000\nbc0200000a060000 bd020000060a0000 c602000201020000 c702000102010000 c902000202020000 d802000102020100\nd902000002000000 da02000205020000 db02000040800000 dc02000201020100 dd02020100020100 7403000002010000\n7503000080400000 7a030000c0800000 7e03000096760000 8403000003000000 8503020003000200 8603037c12127c00\n8703000010000000 880303007e4a4200 890303007e087e00 8a030300427e4200 8c03033c42423c00 8e0303000e700e00\n8f03035c62625c00 900302003b400200 9103781412147800 92037e4a4a4a3400 9303007e02020200 9403605846586000\n9503007e4a4a4200 96030062524a4600 9703007e08087e00 98033c4a4a4a3c00 990300427e420000 9a03007e08146200\n9b03601806186000 9c037e0418047e00 9d03007e04087e00 9e0300424a4a4200 9f033c4242423c00 a003007e02027e00\na103007e12120c00 a30300665a424200 a40302027e020200 a503060870080600 a60318247e241800 a703422418244200\na8030e107e100e00 a9035c6202625c00 aa0300457c450000 ab03040970090400 ac030030484a7900 ad030030685a5100\nae0378100a09f000 af03003a41200000 b0033a4043403a00 b103003048487800 b20300fe25251a00 b3030c30c0300c00\nb403344a4a4a3000 b503003068585000 b603021aa6a24200 b7033c080404f800 b803003c4a4a3c00 b903003840200000\nba03007820504800 bb03641212227c00 bc03fc2020103c00 bd03182040201800 be03112d2ba94100 bf03003048483000\nc003087808780800 c103f82424241800 c2031824a4a44800 c303304848582800 c403000838482800 c503384040403800\nc6031c20f8241800 c703c4281028c400 c8031c20fc201c00 c903304820483000 ca03000238422000 cb03384240423800\ncc0330484a493000 cd03384042413800 ce03304822493000 d0033c52525c2000 d10310344a3c0800 d203067804020400\nd303120a7c020400 d4030d7009040800 d5031824ff241800 d603384828483800 d70348302221d800 da031c2221a14200\ndb031824a4a44200 dc037e1212020200 dd0300fc24240400 de033e2010087c00 df030c0ac9281800 e003700c621c7000\ne10301092516f800 e2039ea0bea07e00 e30398a0b8a07800 e4030c1214107e00 e503001028207800 e603be9088887000\ne70348544e443800 e803245252524c00 e903285454544800 ea0364524c526400 eb03086458640800 ec03385454542200\ned03306848682400 ee03184a7e4a1800 ef031848ff0a0800 f003483020205800 f10378a4a4a49800 f203304848485000\nf303006080847d00 f4033c4a4a4a3c00 f503003058584800 0004007c55564400 0104007c55544500 020401013f857900\n0304007c06050400 04043c4a4a422400 050400244a522400 060400427e420000 070400457c450000 08042040423e0200\n09047c027e483000 0a047e087e483000 0b0402027e0a7200 0c04007c102a4500 0d047c2112087c00 0e040c5152523d00\n0f043f20e0203f00 1004781412147800 11047e4a4a4a3000 12047e4a4a4a3400 1304007e02020200 1404c07c427ec000\n1504007e4a4a4200 160476087e087600 170424424a4a3400 1804007e08047e00 1904007d120a7d00 1a04007e08146200\n1b04403c02027e00 1c047e0418047e00 1d04007e08087e00 1e043c4242423c00 1f047e0202027e00 2004007e12120c00\n2104003c42422400 220402027e020200 23040e5050503e00 240418247e241800 2504422418244200 26043f2020bf6000\n27040e1010107e00 28047e407e407e00 29043f203fa07f00 2a04027e48483000 2b047e4848307e00 2c04007e48483000\n2d0424424a4a3c00 2e047e183c423c00 2f04006c12127e00 3004304848784000 3104003c4a4a3100 3204007868502000\n3304007808080800 3404c0704878c000 3504306868500000 3604483078304800 3704004058683000 3804784020107800\n3904794222127900 3a04007820304800 3b04403008087800 3c04781020107800 3d04781010107800 3e04304848483000\n3f04780808087800 4004fc2424241800 4104304848485000 4204080878080800 43041ca0a0a07c00 44041824ff241800\n4504004830304800 46043c2020bc6000 4704182020207800 4804784078407800 49043c203ca07c00 4a04087850502000\n4b04785050207800 4c04007850502000 4d04485868300000 4e04783030483000 4f04502828780000 50040030696a5000\n51040032686a5000 5204023f0a887000 530400780a090800 5404003068584800 5504005058682800 560400487a400000\n5704004a78420000 5804004080847d00 5904700878502000 5a04781078502000 5b04047e14106000 5c04007822314800\n5d04784122107800 5e0418a1a2a27900 5f043c20e0203c00 6204027f4a483000 6304087e58502000 70040e107e100e00\n7104182078201800 72043c4a4a4a3c00 7304306858683000 7404001e70180c00 7504001860301000 9004007e02020300\n9104007808080c00 9204087e0a0a0200 9304207828080800 96043b043f043be0 970424183c1824c0 9a04003f040a31c0\n9b04003c101824c0 ae04060870080600 af040c10e0100c00 b004161870181600 b1042c30e0302c00 b20421120c1221c0\nb3040024181824c0 ba047e0808087000 bb04007e08087000 d804003452523c00 d904002868583000 e20400457d450000\ne304004a7a420000 e8043c4a4a4a3c00 e904003058583000 ee04003d41413d00 ef04003a42427a00 d005681020285000\nd105484848784000 d205004830600000 d305080808780800 d405680808087800 d505000008780000 d605080818680800\nd705087808087800 d805784050487800 d905000008180000 da0504040404fc00 db05484848483800 dc050e4848281800\ndd05087848487800 de05582010487000 df05000004fc0000 e005004040487800 e105000878483800 e205487840281800\ne305041c0404fc00 e405485848483800 e50504f820140800 e605485060685000 e705f40424241c00 e805080808087000\ne905785058403800 ea05487808087800 f005087800087800 f105081800087800 f205081800081800 f305000010080000\nf405100800100800 021e7c5455542800 031e007e48493000 0a1e007c45443800 0b1e003049487e00 1e1e007c15140400\n1f1e001079140800 401e7e0419047e00 411e780832087000 561e007c15140800 571e00fc25241800 601e004854552400\n611e0050586a2800 6a1e04047d040400 6b1e00083d482000 801e7c2112207c00 811e384132403800 821e7c2012217c00\n831e384032413800 841e7c2110217c00 851e384230423800 f21e040972080400 f31e00b84142f800 a3207e0a7a120a00\na420a8fcaa828400 a720087e2a1c0800 ab200098a4a6bf02 ac20183c5a5a4200 af20627f22443800 9021103854101000\n912108047e040800 9221101054381000 932110207e201000 9421103810103810 95212844fe442800 \n`,\n\n    }\n\n    // A unicode 12x12 pixel font based on https://github.com/adobe-fonts/source-han-sans\n    //% whenUsed jres\n    export const font12: Font = {\n        charWidth: 12,\n        charHeight: 12,\n        data: hex``\n    }\n\n    export function getFontForText(text: string) {\n        for (let i = 0; i < text.length; ++i) {\n            // this is quite approximate\n            if (text.charCodeAt(i) > 0x2000)\n                return image.font12\n        }\n        return image.font8\n    }\n\n    //% deprecated=1 hidden=1\n    export function doubledFont(f: Font): Font {\n        return scaledFont(f, 2)\n    }\n\n    export function scaledFont(f: Font, size: number): Font {\n        size |= 0\n        if (size < 2)\n            return f\n        return {\n            charWidth: f.charWidth * size,\n            charHeight: f.charHeight * size,\n            data: f.data,\n            multiplier: f.multiplier ? size * f.multiplier : size\n        }\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\nnamespace texteffects {\n    export interface TextEffectState {\n        xOffset: number;\n        yOffset: number;\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.getFontForText(text)\n        let w = text.length * font.charWidth\n        let x = (img.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]) {\n        x |= 0\n        y |= 0\n        if (!font)\n            font = image.getFontForText(text)\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let mult = font.multiplier ? font.multiplier : 1\n        let dataW = Math.idiv(font.charWidth, mult)\n        let dataH = Math.idiv(font.charHeight, mult)\n        let byteHeight = (dataH + 7) >> 3\n        let charSize = byteHeight * dataW\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        let imgBuf: Buffer\n        if (mult == 1) {\n            imgBuf = control.createBuffer(8 + charSize)\n            imgBuf[0] = 0x87\n            imgBuf[1] = 1\n            imgBuf[2] = dataW\n            imgBuf[4] = dataH\n        }\n        while (cp < text.length) {\n            let xOffset = 0, yOffset = 0;\n            if (offsets && cp < offsets.length) {\n                xOffset = offsets[cp].xOffset\n                yOffset = offsets[cp].yOffset\n            }\n\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            let l = 0\n            let r = lastchar\n            let off = 0 // this should be a space (0x0020)\n            let guess = (ch - 32) * dataSize\n            if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == ch)\n                off = guess\n            else {\n                while (l <= r) {\n                    let m = l + ((r - l) >> 1);\n                    let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                    if (v == ch) {\n                        off = m * dataSize\n                        break\n                    }\n                    if (v < ch)\n                        l = m + 1\n                    else\n                        r = m - 1\n                }\n            }\n\n            if (mult == 1) {\n                imgBuf.write(8, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x + xOffset, y + yOffset, color)\n                x += font.charWidth\n            } else {\n                off += 2\n                for (let i = 0; i < dataW; ++i) {\n                    let j = 0\n                    let mask = 0x01\n                    let c = fontdata[off++]\n                    while (j < dataH) {\n                        if (mask == 0x100) {\n                            c = fontdata[off++]\n                            mask = 0x01\n                        }\n                        let n = 0\n                        while (c & mask) {\n                            n++\n                            mask <<= 1\n                        }\n                        if (n) {\n                            img.fillRect(x + xOffset * mult, y + (j + yOffset) * mult, mult, mult * n, color)\n                            j += n\n                        } else {\n                            mask <<= 1\n                            j++\n                        }\n                    }\n                    x += mult\n                }\n            }\n        }\n    }\n}\n"
        },
        "screen---linux": {
            "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.filter=\"!tile !dialog\"\n    //% weight=100 group=\"Create\" duplicateShadowOnDrag\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8;20,15;40,15\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tile_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"16,16;32,32;8,8\"\n    //% img.fieldOptions.filter=\"tile\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileImage(img: Image) {\n        return img\n    }\n\n    //% blockId=dialog_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"15,15;18,18;21,21;24,24;9,9;12,12\"\n    //% img.fieldOptions.filter=\"dialog\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _dialogImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n\n    /**\n     * A position picker\n     */\n    //% blockId=positionPicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"position\" color=\"#ffffff\" colorSecondary=\"#ffffff\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __positionPicker(index: number) {\n        return index;\n    }\n}\n",
            "font12.jres": "{\n    \"image.font12\": {\n        \"mimeType\": \"font/x-mkcd-b26\",\n        \"data\": \"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1Ad0AMwGAAD4CQAI/gcAAGNSEAjwBLwG8gG0AuQMAAD8AQAIAAj+BwAAZFIAACQIrAeWAqwCpA8kAAAA/AEACP4PAABlUqACKgoqCeoPKgG+AqAGAAD8CQAI/gcAAGdSwAc+AKoHqgT6BKoErgcAAPwAAAj/BwAAaVKICGwEbAIMAfwPDAFqAigEAAD8CQAI/gdqUgAFfAU8BT4FvAP8AQQBdAUGBXQFBAMAAG9SAgDeD1YF1gdWBVYF3g8AAPwJAAj+BwAAcFIAAKwE/AKsAfwPqgL6BgAA+AEACP4HAAByUowAvA+0BbQF9gW0B7QHjAcAAPwBAAj+B3VSEAAQDtAD+AX0BeQF6AcAAPgBAAj8BwAAf1IACHYFcAV0A/oPeANwA3YFAAD4CQAI/geDUkgE/Af8B/4H/Af8B/wH/AcABPgBAAj8B4dSAA74ARgE2AZ+A2wPbAIIBPABAAj8DwAAiFKAAHwI9Am0CbQF+ANUAVwJ9glcCVQHAACJUgAAnAnKC8kJsAfOBUIFDgT4AQAI/gcAAI1SCAjoBKwC6gBLCKIG5AQAAPwBAAj+BwAAkVI4AEgM9AOMApYCvALMDyAA/AEACP4HAACbUgAAEAgQBBACkAF+ABAAEAgQCBAM8AMAAJ1SAAQUAmQB5AAcCQAEiAN+AAgICAj4BwAAnlIAAIgJaAQIAogBfggICAgM+AMAAOABAACfUgQCBAL8AQQJBAkQBBAD/ggQCBAM8AMAAKBSCAgIBv4BCAgICPgHAAD8DwQEBAT8DwAAoVJACFAJSAksBTYDpAEkCTQJTAlEB0AAAACjUigIqAikCKIEoAOeAJAIiAiCCIQHCAAAAKhSAAAkBOQDJAKkAiQDAAgQB/4AEAjwBwAAqVIABP4DkgSSAv4LAAQQA/AIHwgQCPAHAACqUgAIRAlcCWYFJANcAUQBNAkkCVwHRAAAAKtSAABIB8gEfgJIAkAHEAAQD/4AEAjwBwAAsVIADvwBFAz0A1QI1AcEABAH/AAQCPAHAACyUgAApAikBJQHrASkBDAAEA7+ARAI8AcAALNSAAi0CJQElgSUA9QAlAiUCJYIlAc0AAAAtFIACLgIigSKBIgC6wGICIgIjAiKBzgAAAC5UigIqASoAgwBqAIICFAEEAP+CBAI8AcAAL9SAAAUCFQJfgUUBcADNAEeCQQJPAdAACAAwVIAALQEhAS0B4QEtAwEBBAD/ggQCPAHAADDUgAANAIUCV4HlAE0CQAEEAP+CBAI8AcAAMdSAAgCCvoKqgaqAvoCqgKuCqoK+gYAAAAAyVIQCPgElgP0AJwH8AgYCpgJfggICvgJAATLUgAI7gkqBKoDKgjuCwAAEAf+ABAI8AcAANJSAADkAr4C9A++AuQIBAQQA/4IEAjwBwAA1VIAAHwJfAn8B3oNCAQYApABfggQCPAHAADYUoAAggf/BaoEqgT/BYIMCAL/AQgE+AMAANlSAAAqA6oI6gc2AOAJSAcuATQJNAksB0QB3VIADP4Dkgj+B4ABagk4B64BOAluCaoHAAHeUhIIkgioBK4EoAKiAaQIqAimCCgHcgAAAN9SAAJEAfwFfgN8A3wBfAV+BfwDfAFEAgAA4lIAAKwJrAnuBawFgAP4ARgJDgl4BoAAYADkUgAI9AnWBfQH1gX0BQAMEAP+CBAI8AcAAOdSAAAgAewPuAfoB6gHqA4ABvwBEAjwBwAA8lIAAf4N/gH+Af4N/gEIC5gIfgAIAfgMAADzUgQIfQVtAf8E7AL8AgAGiAF/BAgE+AMAAPVSAAz8A8wP/AHsA/wLzA8ADP4DEAjwBwAA+FIAAfoPuweAB7sHugcADAgD/wAIBPgDAAD+UkAAYAAQA84CKAIIAUgJiAkICggI+AcAAP9SQAAgBhgBjgB4CAgGiAF4CAgICAz4AwAAAFMAAGAAEARMAkoCSAJICQgJCAgIDPgDAAAFUyAAEADIBy4JKAkoCegJCAgICvgJAAQAAAZTQABgBBACzgFoCJgEiAN4CQgJCAz4AwAACFMAAHAA6AMGAuUChAL0AgQCxAsECPwHAAAVUwAAAAD8ByAIIAggCCAIIAggCCAIAAYAABZTQAAgAPgPBgACAAAA/gcgCCAIEAgICAAGF1MAABAEEAIQAv4PAAAAAP4HIAgQCAgICAcZUyAGvAE8AvwDvAS8BAAE/AUQBhAGCAaIBSBTAAD+DwIIAgr6CUoISghKCMoLSghCCAIIKlMAAP4HAgQqBSoF+gUCBPoFqgSqBIoEAAAvUwAA/g8SCIYLIgj6C6oKqgr6C6oKqgoAADlTAAD8DwQExAQ8BAQEBAR8BIQEhARkBAAAOlMAAPwPBAQUBSQFpAREBKQElAQEBQQEAAA7UwAA/g8CBCIFKgWqBHoE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AAD8AwQB/AkABP4DEgDSB5IIkgheBgAAZlQAAPwDBAH8ABAD7gIgCQgG/gEICPgHAABoVAAAAA7+AQIAqgeqAroCqgsqCAII/gcAAHNUAAD8AwQB/AEABEgCSAH+D0gBSAJIBAAAdVQAAPwDBAH8AQAA9AMUARQB9AkECPwHBAB7VAAA/AMEAfwBAAD8AyQBJAH/DyQBJAH8A3xUAAD8AwQB/AEAALQIhAj8B4IAsgCKAAAAfVQAABAA0AdYAlgC1AMSANQPWABIAtABEACLVAAA/AMEAfwBEAAIAA4A+A8oASgBKAEAAIxUAAKUAVQA/AdSAAAA/AcEAgQCBAL8BwAAkFQAAPwDBAH8AWAA/A8CANAAEAkQCP4HEACSVAAIHAgUBNQDXABAAFwAVADUBxwIAAgABpVUAAD8AwQB/AEAAJAPkASQBP4EkASQDxAAllQAAPwHBAH8DAAC/gkIDPAD/A8EBPwPAACaVAAA/AMEAfwBUABIAi4CtQQ0BUwJRABAAKZUAAD8AwQB/AEACOwErAL+AawCrAS8CQAIp1QAAPwDBAH8AUAIvASUA2AA+AkACP4HAACoVCAAEQCKD6AErASjBJIEjgSSBKIPLgAAAKpUAAD8BwQC/AMACKwHIAD+DyAAqAMkDAAArFQAAPwDBAH8AQAIKAioBAoDzAUIBGgIQAivVAAA/AMEAfwBEAGID1YJZQl0CVwJhA+AALFUAAD8AQQB/AEAAPgHqAKsAqoCqAL4BwAAslQAAPwDBAH8CQAITgRMAvgBTAJOBEoIAACzVAAA/AMEAfwBAAgkBbQEbwIkApQFRAgAALhUAAz4AwgAqAeoAqgKCAv+CAgHyggsCAAGvVQAAPwDBAH4AP4PAgQiBfoEogUCBP4PAADAVAACBAF0AVQP1ARVBNYEVAFUAnQFBAUACMFUAADAD0AEXgTSBxIA0g9SBF4EQATADwAAxFQAAPwDBAH8AQAIiAT+AogAiAD+AogMgAjHVAAA/AMEAfwBAAgkCSQJvg8kCSQJIAkAAMhUAAD8AwQB/AFgADAPqASmBKgEMA9gAEAAyVQQANQHVAJeAlQC1AkQDP4CEAOSBFQIAAfNVAAA/AMEAfwBAAD4DwgA6AMuAegJCAj4B85UAAD8AwQB/AEACCQIzgQEAwQFzgQkCAQI0VQAAPwDBAH8BUAEBAT8BwQE/AcEBOQEAADXVAAA/AMEAfwBAAB8AQIBkA8+AUgBRAEkAN9UAAD8AwQB/AEABPwFggQQAs4ICAj4BwAA4VQAAAAI/wutBq0GrQKtAq0GrQb/CwAIAADlVAAARAB8B2wFbAVsBWwHfABECPwPRAAAAOZUAAD8AwQB/AEACPwPkgAQDP4DkAVWCAAG6FQAAPwDBAH8AQAA9g9QAV4BUAlQCfYHAADpVPwDBAH8AQAAfAlUCVQJ/A9UCVQJfAkAAOpUAAD8AwQB+AwCAv4Jkgj+B/wPAgD+AwAA7VSACJ4IkgiSBJ4DwACcA5QE1ATcCIAIAADyVAAAEgCyD78EigSgBJ4EiQSJBLkHCQAIAPpU/AMEAfwBAADoD6gCqAL+D6gCqgrsBwAA/FQAAPwBhAD8AAAAvAisCK4OrAGsAbwABAAGVQAA/AMEAfwJQAgoCZ4GiAT8BswFWAhACAdVAAAAD/4AIg7qCqoKagqqCqoKKg0iAQAACVUAAPwDBAH8AQAIKAkuBeoDKAUuCSgJAAAQVQAG/AEEAFwHXAVcBf4FXAVcBXwHFAAAABRVAAD8AwQB/AEAAKoHugSuBKoEugSiByAAJFX8AwQB/AEACPgElAKWAfQBnAKUBPQEgAgsVQAA/AMEAfwBAAz4AygIPgdsAGwHTAgABC5VCAAIAHwPXgVcBVwFfgVcBVwFXA9EAAAAL1UAAPwDBAH8AQAA/A+qBKgE/geoBKgEAAAxVQAA/AMEAfwBAAD+B2oFagVqBWoF/gcAADdVAAD8AwQB/AEACPQH7ADmAmUKZAr0ByQAOFUAAPwDBAH8CAAGKACkBLIJNAr0ACQGCAg+VQAA/AMEAfwBAAjUChQK/A8UCtIKUAoQCEZVAAAAAPQPFAB8BxYFNAVUBVwHFAD0DwAASlUAAPwDBAH4AP4PMgDMAeQDFAHkCPwHBABPVQAA/g8qAKoHvgKAAr4CqgMqCCoI/gcAAFNVwgA6AKoHqgSqBLoEkATOBLQENAdMAIQAX1UABvwBqgeqAqoCugMgBH4CiAHoAhgEAABhVQAA/AMEAfwBAAAoAf4PAAD+DygBKAEAAGRV/AMEAfwBAAB8AtQC1AJ+AlQPVAJ8AgAAZVUAAPwDBAH8ARAASAdEBfIFVAVEBUgHUABmVQAA/AMEAfwBAAz+AwgIYAiJCQoO6AkAAGpVAAD8AwQB/AGACP4HQAD4D4wEigT4DwAAeFX8AwQB/AEADKwDLAYsAf4PLAEsArwPCAB8VQAA/AMEAfwBAABsB6QApg+0AKQEpAMAAIBVAAD8BwQC/AMAAKQPtAlWCVQJpA6MAAAAglX8AwQB/AEAAPwA1A/UCPwJ1ALUB/wJAACDVQAA/AMEAfwA4A8UALQCngfUAhQI9AcAAIRVAAFEAVQPVgtUC/wLVAtUC9YL1A9EAQAAh1UAAPwDBAH8DGQCng/0AZQCYAj4CP4HAACJVQAA/AMEAfwBYAD4DwYAUAlUBdQDXAVQCYpVAAD8AwQB/AzwAwgHqAIIDX4CiAVqCAAGlFUAAPwDBAH8DAAC/Ak0CPQKtA+0CrwKAACYVfwDBAH8AQAAvA+wALAP/gCwD7AAvA8AAJpVAAD8AYQAfAjwBVgFNgOUAzwFUAXwCQABnFUAAQQBfA/cC1wLXgtcC1wL3At8DwQBAAGdVQAA/AMEAfwBAAC+BqoEqgWqCKoIvgcAAKdVAAD8AwQB/AEICPQLtAq2CrQK1AscCAAAqlUAAIQIvAisD7wIhAj+CYQCvASsCrwKhAirVQAA/AMEAfwJAAg+BTQDwAM8BQQJfAkAAKxVKAAsAJwP/ADcB9wF3AXcBfwHmgioDyAArlUAAAAE/gVaBVoF/g9QBV4FWgX6BQ4EAACyVQAA/gMCAf4BGAznApAAUAaOAAgI+AcAALVV/gGCAP4AAADwD5IElwTyB5AElwTyBwIAtlUAABgACgd8BVgF3gVYBVgFfAUKBxgAAAC3VfwDBAH8AQAI1AtUCFQGVgFUBFQI1AsACLtVAAD8AwQB/AEYANgPtALyD5QBGAjIBxAAxVUAAPwDBAH8AQAIfAVcBV4DXgPcBXwFAAnOVQAA/AMEAfwBAAz+AKoGqgD+BKoBgg8AANNVAAD8AwQB/AEACFIFdgOGD5YDUgUwBQAI2lUAAPwDBAH8CQAE/ADUDtYA1AXcCMAHAADcVQAA/AMEAfwBQAA0B34H1AfcB9QH1AcAAOFV/AMEAfwBAATIAlQKogcQAFICdArkBwgA41UAANwP1AfUD9wPhAFUAtQLBAj8BwAAAADkVfwBBAH8AQAE4AdsBngG7gdoBmgG7A8gCOhVAAD8AwQB/AAADkQAkAPMAqgLqAroBwAC71UAAPwDBAH4AD4BYgJqBFoFWgRCAX4DAAL9VQAA/AMEAfwEJAL+D1QBdAkQBs4BCAY4CAZW/AMEAfwBAAj0CtQK1gb0A9QG1gr0CgAACVYAAIIOvgLuCq4KrwauDO4Krgq+CoIOAAAOVgAA+AMIAfAFBAV8BfwDfAN8BfwFfAcEAxdWAAAMAEYP1gv0C/YL9Av0C/YLxQ+cAAAAG1YAAPwDBAH8CPgHBAH0DyYChAH0D6QABAMfVgAA/AMEAfwAgA9+BVAFiA/8BwQA/AMAADFWAAD8AYQAfAgAB/wOtAHcBfwH1AHcDwAAMlYAAPwDBAH8A3wCrg98Av4HkgD+DwAAAAA0VgAA/AMEAfwBEATYA+4C9AfwAu4C1AcQADZWAAD8AwQB+AAEDf4BVAH+DfwDJADiDyIAO1YAAPwDBAH8AQAAfA/cC14LXAvcC3wPBAE/VvwBhAD8AAAIXgVWAVIF/glaAVIFXgAADkFWAAD8AwQB/AAgDVQB3AcEC9wLVAl0AQANYlYAAPwDBAH4CXwIDAVkA3YBJANEBXwJAABoVgAAQAJcD1QJ1Al8D2AATA/0CXQJXA9AAmpWAAD8AwQB/AnABbwF9AOUD/QPvAPgBQAIdFYAAPwBhAD8BBAE9Af0AvYC9ALUBvQHEAiHVgAA/AMECfwH5As/COQPJA3kA/8PJACgA7RWAA7gAbwE9Af0B+wPuAHUCXQG/AVgCAAAt1YAAPwDBAH8BQAM/A/sCf4B9AfsBfwJAAC8VgAA/AMEAfwBAAD0D/IF+gwyAbkItQeAAMJWAAAIAv4H/gf+B/4G+AD+Bv4H/gcIBQAByVYAAP4BggB8AfcGpQIHA/0PVwX1B1cFAADKVgAFtAP8C/wH/AWeBfwB/AP8BdwHlAcAANpWAAD+DwIEAgWCBEIEOgTCBAIFAgT+DwAA21YAAPwPBATEBTwEBAQEBHwEhAQEBPwPAADeVgAA/g8CBPIEkgSSBJIE8gQCBAIE/g8AAOBWAAD+DwIEIgUiBaIEegSiBCIFAgT+DwAA4lYAAP4HAgSSBFIEUgUyBfoFEgQCBP4HAADjVgAA/gcCBAoEagQKBQoF+gQKBAIE/gcAAO1WAAD+BwIEKgXqBCoE6gUqBSoFAgT+BwAA8FYAAP4PAgSiBWIE+gViBKIEIgUCBP4PAADyVgAA/g8CBJIE+gWSBJIE+gWSBAIE/g8AAPNWAAD+DwIGWgdCBcoEwgQyBQoFAgT+DwAA9FYAAP4PAgSqBKoE+gWqBKoEigUCBP4PAAD6VgAA/g8CBBIE0gVSBXoFUgXSBQIE/g8AAP1WAAD+DwIEKgUqBfoFKgVqBSoFAgT+DwAA/lYAAP8PAQQpBS0FFQWVBa0GJQYBBP8PAAAGV/4HAgbeBlYGVgVWBVYEXgbCBgIE/gcAAAhXAAD+BwIEPgT+BToGugZ6BjoFAgT+BwAAC1cAAP4HAgTqBaoFSgR6BYoFbgYCBP4HAAANVwAA/gcCBP4FfgV+Bf4FfgV6BQIE/gcAAA9XAAD+BwIEagTqBfoG6gb6BmoEAgT+BwAAElcAAP4PAgzqDWoLegtqC2oL6gsCDP4PAAATVwAA/g8CCMIL+gvqC+oL6gv6CwII/g8AABZXAAD+BwIE/gf2B/YH9gd+BuIHAgT+BwAAGFf+DwIE/gT+Bf4E/gT+Bv4H/gQCBP4PAAAfVwAEIAQgBCAEIAT+ByAEIAQgBCAEAAQAACNXQAhECEwJLAk0CaQPNAk0CUwJRAhACAAAJ1cAAAAM/AMECEQIRAj0D0QIRAhECAQIAAAoVwgBiADIDzgAjgiICIgI6A+ICIgIiAgAAC1XAAgkCSQJJAkkCb8PJAkkCSQJJAkgCAAAMFcAAhAC/gEQAUAA/AcgCCAI/gkQCBAJ+AQzVwAEEAL+AxABAAz+AwAAAAD8BwAAAAD+DzpXAAIQAv4DEAEAASIJ8gQqAuYJIgzgAwAAPlcABBAC/gMQCgAEhAN8CIQEJAc8BeAEAAhAVxACEAL+ARABAAjwDwAIAAj+DyAIIAggCEJXAAIQAv8BkAQABv4BMgzSAhIDkgJyBAIIR1cAAhAC/gEQATAADAIqASgJqAgIDPgDAABKVxACEAL+ARAJAAwIAvgBSghICEgIyAcIAE5XAAIQAv4BEAFACDQICgboAQgCSAQ4CAAAT1cAAhAC/gEQAUQBRAAkAPwPBAAkAMQAgABQVyAIkAiOCLAIgAj+D6AIkAiOCJAIIAgAAFFXAAIQAv4BEAEADOgDKgAqAOgHCAgIBgAAV1cAAhAB/gGQAIAICARIA/4AyAFIAngEQAhaVwAIPggACQAJfglGDyoJEgkqCSYJQAgAAFtXAAIQAv4BEAEABCQGpAVkBCQEpAUkDgAIXVcAAhAC/gEQAQAI/gkCBAIC+gECBAIE/glfVwACEAL+ARABgAkIBHgEigOMAngECAgIBGBXAAR+BQIFPgUCBaAHMAUOBRAFIAVABAAAYVcAAhAC/gMQCQAM+APICX4GSAbICVgIAABkVxAC/gEQAQAA/AMkASQB/w8kASQB/AMAAGZXgAAQAf4AkAAABP4EkgSSBJIEkgT+BAAEalcAABAC/gMQAQIAugCCAP4PggCyAIoAAACCVwAAQAJUCvQLVApUCvwPVAryC1IKQAAAAINXAAIQAv4BEAEABCgEyAUKBAgH6AQIBAAAhFeICIgKaAoYCkwKSA94CqwKrAqICkgIAACLVwAAQATKBD4ECgV+BQoHAAUeBUAFfgQABJJXQAhoCUgJbAkKCQgPaAlMCUgJKAlACAAAo1cAAhAC/gMQCQQI9AtUClQKVApUCvQLBAimVwAAAAj+CqoKKgoqD2oKqgqqCt4KgAqACKtXJASUBf4FFAUABdQHNAUeBQQFfASABEAArlcABBAC/AMQAoAAqAK4A6wKqAqYCqgGqADDVwAEEAL+AxABQAgoCS4F6AMsBSwJIAkAAMtXAAIQAv4BEAEACHwJVAlUCfwPVAlUCXwJzlcAABAC/gEADPgDKAAoCsgJfgSIB24ICAbUVwACEAL+ARABAADoD6gCqAL+D6gCqgrqB99XAAAQAv4BEAFAAKgC6AoIBH4CiAVqCAwG4FcAAhAC/gEQAQAC/AK0ArYPtAK0AvwCAAL3VwAAlALUAp4P9AIQCEgG/gEIAQgA+AcADPlXAAEQAv4BAAEkAKQHtASmBKQEvASsByQA+lcAAEgBSAX8BHgFeAd4BXgF/ARIBUgBAAD8VwACEAH+ARABAAC0B7QCrgs2CDQI9A80AABYAAAIAf8AAAb/AQUOdQRFBPUHRQR3BwAAAlgAADgICgrsCqgKrg+oCqgK7AoKCjgIAAAFWAAEfgVWBXYFVgVeBwAFSgUyBToFRgRAAAZYEAIQAf4BgAAwAPwPqgSoBP4HqASoBAAAFVgACP4KCgp2CgAKfA8+CjwKvAr8CgQIAAAhWBAAEAR+BQAFXgU6BxoFegU6BV4FUAQAACRYEAQQBP4DEAqACL4GqgSqD6oKqgq+CoAIKlgAABAE/gMQAwQP/glUC1QLVAn+DQQJAAAvWAAAmAmcCXwFXAMOAVwBXAd8CVwJWAUAADBYAAIQAf4BEAD8DwQE/AZ8B3wF/AV8BEAAMVgAAFQBdAHeB3QBAAD+D2IIsgQyA+4MAAQ0WAACCAL+AQgAQAn+BWoDagVqA2oJfgcAADVYAAIQAf4BEAHUAFQA3gd0BVAFWAXWBxAAOlgAAQgB/gCACb4EqgTqAz4AKgDqD74BAAFBWAAIQAl+C2oLKgo+DyoKqgpqC34LQAkAAEpYAAQQAv4DEAEAAXwIVgfVAPwHVAhUC3wLTFgIAQgB/wEIAUAA3wFVBdUHlQFVCd8PAABRWAAAaAjMCngKTAooD4AKfApUClQK/AgAAFRYAAIQAv4BEAFEACQHJgVUBVQFJgUkB0QAV1jaCAIKigqoCiwKrA6qCvoKLAqsCqgICABYWAACCAH/AQgBAAb8ARwGXQX6BVwFfAcUAFpYAAIQAv4BkAUGBaoCegqKCToGygAmBwAAXlgAAIQKtAq0CfQKtAq2DvQKtAm0CoQKAABpWAABEAH+ARAFOAT2B9QH1ATUB/QEhAcABGtYAAQQAv4DEAEACPwLvAq+ArwK/AsECgAAdVgAAAAM/gfqBP4FagVrB34F6gXqBfoEAAB+WEQIfAl8C/4LfAoAD4gKaAoeCvgIAAnACINYAAIIAv8BiAgICPoFXgNbAV4P+gkIBAAAhVgACH4Lagv+C2oLfg8QCpIK+goWCnIIAACKWAAArAisCu4LvAqID+gKPApICvgIAAnACJNYAAFEBfwEfgV8BXwFfAd8BX4E/AREBQABl1gAAhAC/gEAAXwA1w/UCvwK1ArXCvwPAACZWAAAEAP+AZAABADsB+QH/gbkBmwF5AcAAJxYAAB+BIoGdgYABlYHPAW0BfQFFgVkBIAAnlgAABAD/wGAADwA5g90BXwFZAXnDzwAAACoWAAEIAR+BToFegU+B3oFPgU6BX4FIAQAAK5YAAD+CAIKfgoACvYPOwp+Cn4K3gp+CAgIs1gAAhAC/gEQAQQI1AfcB94D1APUB9QLEAjBWEAAfgRqBWoFagVuBzQFPAV2BTQFPAUABMdYAAAQAf4BAAF8BMwH/Af+B/wHzAd8BAQEylgAABAC/gEAA/QK1A70Cd4F9ALUBvQIAAjTWAAM/gPKAf4G/ga+B8IHEgf6BvIGtAQAAdhYAARwBX4FfgV+BX4HLgV+BX4FfgVwBAAA3lgAABAC/gEAAFwCrA48CW4JPALsBvwIAADiWAAAEAT8AwAI/AcEAPQOZAgEDvQKpAoAAORYAAAQAv4BAAV8BOwN/gvGAfwH7AX8CQQB61ggACAEIAQgBCAE/gcgBCAEIAQgBCAAAADuWAACGAIAAf4PAAAgCCAI/g8gCCAIIAgAAO9YgAieB5AA/g8AACAIIAggCP4PIAggCCAI8FgAAAQM1ANUAVQB3gFUAVQBVAHUAwQAAADyWAAIxAhUCFQGVAFeAFQAVAdUCFQIxAQAAPNYAAjECFQIVATUA94A1ADUB1QIVAjECAAE9lgAAMQIVApUCFQPVAheCFQPVAhUCsQIAAD5WAAANAS8BXwFfAV+BXwFfAf8BdwFFAQAAPpYAABkCDQLtAr0Dj4I9A60CrQKNAtkCAAA/ViUANwG/Ab8BvwG/gD8BPwC/ArcD9QCgAAEWYAIYAjeBAgD6AIYBAAI/gsgCEAIgAgAAAdZQABQAEgPrAq2CqQPtAqsCswKxA9AAEAACVkECkQKNAmEBaQGngTEBvwGhAmUCCQIAAANWQAACAgICnYJ3gdcBVwFXAVcC3wJBAgACA9ZAAgECnwJfAX8B3wFfAV8B3wJfAkECAAIFVkAAEAAIAgQCEgETgSKAggBiABoABgAAAAWWUAAYAhQBI4CiAFoABAAIAD+D4AAAAEAAhpZAABQCEgJRAk0BaYElAZMAkQBwABAAAAAHFmEAEQA9A8EAEQIZgS0AxQDlAR0BBQIAAAfWSAA8AMsCegJCAj4BwAAqAiWBFQCTAHAACBZCAmoBHYFVALMARAAzAMqAegJCAj4BwAAIlnEAHwKbApuC/wLbAVsBXYDbAF8AMQAAAAlWQAI/ATUAvwP1AL8ABAISAnWBrQEjAOAACdZEAgQBBACEAHQAD4AUACQARACEAQQCAAAKVlACEQIRAREAkQD/ABEAUQCRARECEAIAAAqWRAIEAQQBBAD0AI+BFAIkAEQAhAEEAgAACtZQAhIBEgESAJIAf4ASAFIAkgESARACAAALVkAAEAIRAhEBEQERAP8AEQDRARCBEIIQAguWQAAgAj4CIgEiAP+AIgBiAaIBPgIgAgAADFZYAhwBE4ESALIAX4AyAFIAkgESARACAAANFlABEgIUgRUBEQCwAF+AEACQAJABEAIAAA3WQAABAjsBKwErAL+AawDrASsCrwKhAkAADhZAAAoAKgAqAK4A6wCqAqoCrgKqAaoACgAOVkAAIAIiAioCIgEiAP+AIgDiASoBIgIgAg6WQAAqACoAKgAmAaMAIoImAiYD6gAqACoAD5ZCAmICGgECAQIA/wACAOIBGgIiAgICQAAR1kAADQAtAe0ArQCrAKuAywINAj0BzQAIABIWSgEqAyoApgIrAiqB6gAmAKoAqgMKAAAAElZAACgAKwCbAIsArwCrg+sAiwCbAKsAqAAS1lAAEQA5A9UBUwFxgdMBVQFZAXkD0QAQABOWRQEVARMBVwFVgV1B1QFXAVMBVQFFAQAAE9ZkABUCFwFfAVcA94BXANcBXwFXAlcCJAAUVkAAFQJVAl+CVQFQANCAyIFHglCCT4JAABUWSABJAkUBawDJAEmAXUBJAGMDxQBJAEgAVVZJAlUCUQJJAUcBQYDBgF8BQQFFAUkCQAIVlkgCSQJEAl+CQAFSANEAyYFJAkcCQQJAABXWSAAJAEUBfwHdAV2BXQFdAV8BRQNJAkgAFpZAAmECawFZAW0A6oBYgNSA0IFSgUACQAAYFkAAAQF/AXuBe4F3APcA+4F7gX8BQQFAABiWSgBKgGqAK4P6gq7CqoKugqmCqYPKgAqAGVZAAAACXwJDAVkBXYDJANMBQQFfAkACQAAZ1kACXwJBAVsBWwFLAN+ASwDLAOEBfwFAAloWQAALgkgCX4FAAUkA5IBFgORBf0FFQkQCWpZAABUATQB/AP0B/YB9AX0BfQD/AGUARQBblkAABoAmg/+Cv4K+w/6CvoK/gr6D0oAAABzWQAAEAgQCdAIMAkeBRICEAKQBXAEEAgQCHRZiAj4BA4DyAE4CAAMNATEA8QCPAQACAAAdlkICPgMDgOIA3AIBAf8AAQEPAgkCOAHAAB4WQAA+AgOBYgDeAwAAEQARAD8D0QARABAAHlZAAj4DA4DiAF4BgAA/AcQCP4JCAj4CAAGfVkACOgMHgOIA3gEAABECEQI9A9MAEQAQACCWQAACAj4CA4F6AMQAPwPBAQEBAQE/A8AAINZAAj4CA4FiAN4BAAAxAdECEQIRAj8CAAGhFmACIQIvAqkC6QKpgSkBKQHpAikCIQIAACGWQAAGAOAAP4PAACQCHAJHgYQA/AEEAgQCIdZCAj4BA4DiAF4AAAERAREBEQERAT8DwAAiFkACPgMDgPoAhgEcAFEAUQJZAlcDMADAACSWQAI+AwOA+gDGAzwA0gASgBKAEgA+AAAAJNZCAj4BI4CyAE4AgAIaASoBT4CqAVoBAgIllkABPwEBwPEAjwAAAwiAqIBfgChASECIASZWQAA6AieBsgBOAIACDwEgAT+AgACjAEwAJ5ZEAjwBA4DiAN4AAgI4A9cCEQI/A9ACAAApVkAAEQIVAbEB2QGbAJEAmIF8gRKBEAIAACoWQgA+AkOBYgDcAQAAAgP+ABOCEgIyAcIAK5ZAAj4DA8D+AgADP4DEgDSB5IIkgheCAAGs1kAANAIPgUQA/gEAADUAwoI+A8IANgBCAK5WQAI+AgOBYgDeAAADEgCSAH+D0gBSAJIBLtZFAlcCVwLXAvcBX4FXAVcB1wFfAkUCQAAxlkACPgJDAb4BQAA/AdEBFQFVAxEDPwHQATJWQAA6AgfB8gBOAbAASQAJAD+DyQA5AMAAMpZCAj4CA4H6AEQBngARA/EAP4PRADEBwAAy1kAAOgNHgOIAXgCAACwD64EoASsBDAHQADQWQAA+AkOBugDEAj8DyQJJAkkCfwPAAgAANFZAAD4DA4DiAN4BAAAkA+QBP4EkASQDwAA01kAAOgIHgXIAzgAIAicCJAI/g+QCJAIAAjUWagIrAisC5wKzAb8BIwCmgWqBKoIqAgAANpZAAj4BA4D8AgMCYAE/gMAAP4HQAicCIQG3FmgCKwIrQquC6wGvASsBq4FrQSsCKQIAADlWRAI8AQeA5ADeAQAAagHfgkoCTgJKAUkAOhZAAj4DI4DcAQEAOwMrAL+AawCrAS8CQAI61kAAPQMjwLkARgA/g+SBJIEngeSBPIEAATsWQAI+AQPA+gBEAD+BwIE8gSeB5IE8gQCBPtZAAD4DA8D6AEQAv4PAgXiBLoFAgT+DwAA/1kAAKIIlArUC8AGpgSUBIwGlAWkCKwIAAABWgAO+AEIBNgFeALYAwgI/gQIA8oEKggABgNaAAj4CA4H+AQAACQJJAm+DyQJJAkgCQAABFrICMgIrgqYC9gG/gSYBpwFqgTqCMgIAAAHWgAI+AQOA8gBOAZQADQPHAAUADIPUgCAABhaAAj4BA4D+AYAAPwPVARWBNQBVAO8BIAEG1oAAPANHgP4AAQIcAlcB+QBZAN8BcAJAAkcWgAA+AyOA3gIAgb+AZII/gf8DwIA/gMAAB9aCAj4CA4F6AMYAMAPvAK0ArQKtAr8DwAAJVoACPgM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XgmcB5wAXAFEAhwEAAS5WwAALAIkAZQPRAkmCSQJRAmUDyQBDAIAAL1bAAAMCNwLXAh8BF4DXAR8CFwI3AscCAAGvlsAAAwJBAX0BVQFTgFMAcwFTAVEBQwJAAC/W4AATADkBxQABADWB1QFdAVUBVQF1AcAAMJbAABMA0QI9A9UAEYLFAh0BJQD1AQ0CAAIxFsAAIwAxAfUBbQFtgW0B9QA1AjED4wAAADFWwAIDAjkC7QGtAb2A7QCtAa0BuQLDAgAAMZbAAAMAaQHhATkBE4HpASUBEQEFA9kAAAAx1tACFQE1ANUANQHVggECHQLVAvUCFQIAATMWwAADACEB/wF3AXeB9wF3AX8BYQHDAAAANJbAACMBLwCvAH8BL4IvAr8CLwJvAKMBAAA01sAAIQP9AD0AvQC9gP0AvQC9Ab0BIQHAADbWwAIDAjEC9QL9AfWA9QD9AfUC8QLDAgAAN1bAAAsAQQB/APECX4IfAt8BXwFfAvMCQAI3lsAAAwK5Ar0CvQG9gP0AvQG9ArkCgwKAADfWwAATAlkBbQB9AmGD5QBpAPUAzQFnAgAAOFbAACMAIQF/AX8A/wD/gH8BfwH/AGMAoAA4lsACWwHRAH0DwQA9gn0C/QF9Af0CKwJAADlWwABXAlcCbwKnAt+B0QGvAR8BXwBDAEAAOZbAAAUCNQH/Af8A/4D/AP8B/wH3AcUCAAA51sAAAwBxANUA9QLagvsD2QDRAPUAwwDAADoW4AEtAK0CrQL9AK2DrQC9Aq0C7QKhAIAAOlbAAFMAWQP9AtUC3YPVAtUC/QLVA9EAQAB61sAAAQB9AT0AvQA5gLEAfQA9AX0BIQDAADsWwAIDAjEC9QH1AfWA8QD1AfUC8QPDAgAAO5bAACMCEQI1AP0CtYO1AL0AtQLRAiMCAAA9VsAAFQI9AfUAfQK1AcGAPQHdAt0C3QOAAT2WwAEFgjWB94H1gPHA+4D7gP+B+4HLggAAPhbAAAIACgAaACIAQgICAgICP8HCAAIAAgA+VsACCQMRAKEAXwCAALQABAJEAj/BxAAAAD6W6AAqACoAKgGqAS8AKgIqAjoB6gAqACgAPtbAAAAAUQBVANUA1QBVAlUCVQHfAEAAQAB/FsAAAABPAFUA1QFVAFUCVQJVAdcAUABAAH+WwAIKAxIAo4BaAYIBFAA0AEQCP4PEAAAAP9b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/gMAAvgHwACmD5IIsAjGD4gA8FwAAPgH/wcABPwHAAAkBVcF2g9WBVIFEAT2XAAAAA78BFwFXAdeBVwFXAVcAVwJQAcAAPtcAAD4A/4D+AMAACgFjAXKAogCLgVoBAAAA10AAPAD/gPwAwAAVAPEAP4HxABUAUQCAAAHXQAJfAUYAVgJWAlcD1gBWAFYBRgFfAkAAA5d+AcAAv4DAAL4AwAAtAOsAq4LNAj0ByAAFF1AACwA6A9YBVgFXgX4B1gFWAVYBVwFAAQWXQAM/gMMCKwKrAquCuwOrAqsCqwKrgoICBddAAAAAPYPFABUBnYG1gd0BnQGFAj2BwAAKV0AAAwM7AOoCegPDgAICOgHqAKoCuwHAABKXQAA8AP8A/ADDADsBgwB/A8MAWwCqgQABEtd/AMAAv4DAALwBf4Dyg+qCq4KqgruDwAATF0gAOwPKAUoBegPDgDIDCgCqAEoBqwIYABQXQAA5g8cANwJXAn+D1wNXA2MCPwHBggABmldEACWD/QA9AD0B/QF9gX0BfQH9AiWDxAAi10AAAAA8Af+A/AJ/ARcDV4DXAtcCUAHAAC6XSAAkwCqAqoEsgcHAP4FrgWuAa4F/wUACM1dIAl8C3gFeAV4Cw4A+ATYA/gD3AbQBvAC3V0ACAAM/AMAAAAAAAD4BwAAAAAAAPwPAADeXQAAcAgABv4BIAAAAP4HAABwAAAA/g8AAOFdAAhECMgHAAT4CAQLcAiMCSAK2AgECwAI4l0AAAAF+wWoA6oD/Q+oAaoDrgX9BQAFAADjXQAAAAn+BagFqgP8D6gBqAOsBfoFAAkAAOVdAAQEBAQEBAQEBPwHBAQEBAQEBAQABAAA5l0AAAgMCAPICHwISghICMgPSAhICEgICAjnXQQCBAL8AwQBAAEEAHwERAhECEQMxAMAAOhdAAAAAP4PkgSSBJIEkgSSBJIE8gUCBAAA6V0EAgQC/AEECQAE/AMEAHQABAD8DwAIAAbrXQAFhAR0BIQEBAT8BwQFhAR0BIQEBAUAAO5dgAioBKoDrgioCfgJqA+uCaoJqAmACAAA8V0AAAAA5AckCCQIJAgkCCQIJAh8CAAHAAHyXQAABAD0B0QIRAhECEQIRAhECPwIAAYAAvRdAAAAAPwHRAhECHwIRAhECEQI/AgABgAA910AACABKAHoB74KqAqoCr4K6AuoCCAF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SAAAAP4PEAAgAMAAgABTYogAiAj+D0gASAAAAAQIBAj8BwQABAAAAFRiiACICP4PSABADAQD/AAEADwIJAjgBwAAVWKICIgI/g9IAEgIAAf4BAYEQASABwAMAABYYogAiAj+D0gAAABEAEQA/AdCCCIIIgggBltiiACICP4PSABIAAAEBAQEBPwHBAQEBAQEY2IIAYgI/geIAAAA/A8EBAQEBAQEBPwHAABnYoAAiAj/D0gAAAxIA/8AiAAIAPgHAAgABmligACICP4PSAAADPgDCAAKAAwACAAIAAAAa2KIAIgI/g+IAEgAAAREBEQERAREBPwPAABsYogAiAj/B4gAAAqiCXIEKgPmCCIO4AEAAG1iiACICP8HiABACAIIQg7+CUIIQg7+CQAIbmIIAYgI/g+IACAIUAROA8AAQghOCPAHYABvYpgAmAj+D1gAAAj4DwAIAAj/DyAIIAggCHBiiACICP4PiABACBAE0AM+AJAHFggQCBAGcWKIAIgI/g9IAAAH/ADEBAQFPAOQBHAIAABzYogAiAz+A4gIAA78AWQEpAUkAqQFZAgACHZigACICP4PSAAACEgESAP+AEgDSARICAAAeWKIAIgI/g+IAAAA/g8gBAAA/gcgCBgIEAZ+YogAiAj+D0gAAAgQBD4C0AMSBdQIFAgQBn9iAAAQBBAD9AAECqQK9AesAgwC5AAgAxAEgGKIAIgI/g9IAAAIaASoBT4CKAXoBCgIAACEYogAiAj+D0gAAAh4CAAE/gQAAowBUAAAAIpigACICP4HSAAAAPwHRAhECHwIRAhECPwIkWKAAIgI/gcAAPwHAgICAPwPBAAEBPwDAACSYogAiAj/D0gAAAAiCCoI6g82AKYAYgAAAJNigACICP4PSAAADvwBBAD8DwIA/gACDwAIlWKIAIgI/gdIAAAI3gRCBUIC3gVQCAgIAACWYogAiAj+D0gASAAAASIBTAEAAf4PgACAAJdiAACIAIgI/gdIAAAM6AMuACgA6AcICAAGmGKIAIgI/gdIAAAO/gEiACIAIgDiDyIAIgCaYoAAiAj+D0gAQAgEBKQDfADkByQIJAggBJtiAACICP4HSAAAD/8A+AcACfgIDgr4CQAEnGKIAIgI/g9IAAAMiAN+CKgFKALoBSgICAieYggJiAj+D4gAAAz8A0QARADEAUQCfAwACKJiiACICP4PSABAABAAyAcnCCUJyAgQBhAApGKIAIgI/gdIAAAM+ANIAEoASgBIAPgAAAClYogIiAj+D0gAAAD+DyIA8gwyAzIF7gQACKtiCAGIDP4DiAgADvgByAV+BkgFyARYCAAArGKAAIgI/g9IAAAAsA+sBKIEoASkBJgPIACxYpAAkAj8B1AAAACwB64IqAjoCQgJ+AgABrViiACICP4PSAAAAPwPJAQiAD4M4gciCCAGuWKIAIgI/g+IAEAECAJIAf4PyABIA0gEAAC8YoAAiAj+B4gAAAD8AaQApAD8D6QApAD8Ab1iiACICP4HCADgD5AEkAT+B5AEkATwDwAAwmIAAJAI/AdAAOgMqAL+AagA/g+oALgHAADFYogAiAj+D0gAAAj8CSQJJAkkCSQJ/AkACMZiiACICP4HiAAADPwDIgCiAOIPIgEiAgAAyWKAAIgI/g9IAAAEKATIBQoECAfoBAgEAADLYgAAiAj+B0gAAA/+AMgHAAn+CggK+AkABM1iCAGICP4HiAAAAPgPiASOBIoEiAT4DwAA0GKIAIgI/AdIAAAIvASkAqQBpAikCLwHAADSYogASAj/D0gAAAD+D5IEkgSSBJIE8gQCBNNiiACICP4PSAAIAYAA5A9cBEQERATEDwAA1GKIAIgI/g9IAAAMiAN+CKgFKgKqBWoICAjWYoAAiAj+B4gAIACQAM4HSAjoC0gI6AsICNhigACICP4PQAAQAMgDLgEoAegJCAj4BwAA2WKAAIgI/gdIAAAAvAcgBP4HIAQgBLwPAADaYgABGAn+B5gAAAiYBNQDkgCQANQPmACgANtigACICP8HSAAAAKIPmgSGBKIEogSeBwAA3GIAAJQMlAL8AZIAAwAoASoB/g8qASoBAAHdYogAiAj+B0gAQAEUAVQB/A9UAVQBBAEAAN9igACICP4PSAAABP4DAAG8DAACwAE+AQAO4GKAAEgI/gdgAP4MiANwBPwJBAj8CwAKgAnhYogAiAj+D0gAAA74AQgEiAduBAgFCAUIDuJigACICP8PiAAADpABfgwQBPIHlAhUCBAE42KAAJAI/AeQAAAE6AK4CqwI6A+IAIgCCATlYoAAiAj+B0gAAAz+A5IAkgD+D5IAkgj+B+ZigACICP4HiAAABJIElgSQBJgElgQQBAAA6GKAAIgI/geIAAACHAnQBH4FUALUBVQIEAjpYogAiAj+D0gAAAKkApwC1A+cAqQCJAIAAOxigABICP4PSAAAAJIPkgj+CJIIkgiRDxAA7WKAAIgI/g9IAAAEUATQBxAE/AEQBhQMAADvYoAAiAj/D0gAAAnSCCIK+gsmCNIIEgkAAPFigACICP4PSAAACIgE/gKIAIgA/gKIBIAI82KgAKgCagJsC3gL7gcoAygDbgKoAqAAAAD3YgABEAn8B5AAAAAoAagD/AqoCrgKqAYkAPxiAAEICf4HyAAACIkE+gOIAIgA/A+LAIAA/mKIAIgI/gdIAAAAmA+EBKIEogSkBIgHMAD/YggByAH4AfwF+gX6A/oB/AH4AfgBiAEIAQFjkACQCPwHUAAAAKgCqAK8CKgI6AeoACAAAmOAAIgI/g9IAAAIJAkkCb4PJAkkCSAJAAAHY4gASAj+D0gAAADeB2QFZAVkBWIF4gcYAAljCAEIDf4DCAhACFwIxAV3BkQDxARcCAAAEWOAAIgI/g9IAAAJiAT+AwAA/gdACJwIhAYWY4AASAj+D0AABABUBFQLRgnUCFQIBAYAABljiAJKAiwCuAqqCuwHqAKIAj4CSgJIAgAAH2MAAQgJ/gfIAAAIqAiIBv4BiAOoBIgIAAAgYwAAiAj+B0gAAAikBKYDvAC0D8wIrAiABCFjiAGICP4HSAAABC4FIAU+BSAFKAXmDwAAI2OAAIgI/g9IABAAWAlWCfQHXAFUAfABQAAkYwAAiAj+B0gAAAhEBEwDNgAkAFwPRABEACVjAACICP8HAACWAtICsgKaAtIPkgKWAgACKGOAAIgI/gdIAEAJLAUrA+gDKgMuBSgJAAgqYwAAiAz/AwAIkgb+AZII/gf8DwIA/gMAACtjgACICP4HSAAgCBwJYAn+DyAJHAkgCUAAL2OAAIgM/wOICAAO/gHCD1IE0gVSAVIOAAg6YwAAiAj/D0gAAgw+A+IEAAgiCf4JIgkiCT1jgACICP4HQAAQCPgIlASWAvQBnAeUCPAIRmOAAIgI/wcAAP4PAgRSBPoFUgQCBP4PAABJY4AAiAj+D0gAAAy8AyQE5A+kCKQIvAgACE1jiACICP4PSAAAAX4BagFqAeoPagF+AQABT2OIAEgI/g9IAAAEvgSqBKoHqgSqBL4EAARQY4gAiAj+B0gAAADuD6oCqgKqCqoK7g8AAFVjCAGICP4HiAAAAOgPqAKoAv4PqAKsCuwHXGOIAEgM/gMACLwErAWsBv4ErAasBbwIAAReY4AAiAj+D0gAAAiUBJYC1AGUCJYMNAMAAF9jgACICP4HSAAACOAJLgQqAqoBKgQuCOALYWOAAIgI/g+IACAEmAUkBKIFJAQIB9AEAABiY4gM/gNACBAI+ASUApYB9AGcApQE9ASACGNjAAEICf4HiAAABvwEhAaWBIQGvAiABwAAZ2OAAEgI/wdIAAAAagK+AqsPqgLqAqoCAABoY4gAiAj+B0gAEABMB1IFegVSBUQFSAdQAG5jQABICP4PSAAAB/4AMgeyBPIEsgS+BwAAcmMAARAJ/A+QAAQC1AdwCVwNUA1UDtQIQAN3Y4AAiAz/A0gIAgiqBqoEqgT/D6oK+goiCIBjAACICP4HAAD8DxQA9A8AABQO6gEIBjgIg2OAAEQI/wcEAGAAtQe1APUPtQC/BOADAACIY4AAiAj+B8gAYAhoCKQEqgeiBLoGagUACIljiAj+B0gAAAL4AqgCqAKuD6wCrAL8AgQCjGMAABwCzQL/AvwK/gf8AvwC/wKNApwCAACPYwABCAn+BxgAjAKqAugDqAKoCogI+AcAAJJjiACICP4PSABAAAgBKAHWDvwHKAEoAQAAmGOAAIgI/gcAAP4PCgDqDooI6g+KCO4OAACZYwABCAn+B4gAAAKsCqQK6geiAqoC6gOAAJtjgACQCPwHAAAoBb4HKAUAAPwPQADAAAAAoGOAAIgI/g+IAAAE9AKUCJYHlACUAvQCBAShY4AAiAj+B0gAAASUAoQB1A+CAbICigQAAKJjAAEICf4HwAAMBKQClAHED5QBpAKsBAAApWOAAIgI/gdIAAAIpAqsC6YEpAa0BaQIoACnYwABiAj+D0gADAikCJQIhg+UCKQIDAgAAKhjSABICP4PQAAwAPwPqgSoBP4HqASoBAAEqWOAAJAI/AdQAAAA6AO4AqwC6geoCrgK6AuqY4gASAj+D0gAAADUB14FVAVUBV4F1AcAALBjAACUCPwHsgA4BuYB/AMQCJII/geSAIAAsmMIAQgJ/gcIAAABvgPqBaoEqgKqCL4HAAC3YwAAiAj+B0gAAg74AU4HAAD+DwIA/gMAAMljgACICPwHSAAACXQFHANcD3wDFAU0CRAAz2NAAEQE/wMkAAAA9A+UBJcE9AeUBJcE9A/QYwABCAn+B4gAAAy+AqoEqg+qCqoKvgqACNJjAABEBP8DRAAAAOoPqgQKBP4HCQTpDwAA2mMEAYQM/wfEAAAG3wNVCVUFVQNVCV8HAADbY4AAiAj+B4gACAh4CTYFlAM8A1AFcAkACOFjAACQDvwBAAz8AzQItAr0CrQPtAq8CgAI42MAAIgI/gdAABwPsACwD/4AsA+wALwPAADqY0AAiAj+B0AAEgH+D0IAGgwAA/4AAAM4DO1jAAEICf4HiAAAAP4G6gSqBaoIqgi+BwAA7mMgAEgI/gdIAAAC+gK6AroC+g+6AroC+gL0Y4AAiAj+D4gAAgRWAvIJ1gbSBNkHVQhACPpjiACICP4HSADAAIwOpASsBOwHogSyBKoO/WMAAIgM/wNACB4IwAteCEAHVgjUCwQIAAQBZAAASAj+BwAA8g9CAFgHqgLaAgIL/gcAAAJkQACICP4PSAAACKoKmAveBJgGqgWqCIAABWQAAIgI/gdAABoI/AU4BLoHOAjuCQoIAAYNZIgAiAj+D0gAAAjsBewD7AHsAewF7AkACA9kgABQCPwHkAAAAHgDeAN4AX4JeAl8B3gBE2SAAIgM/gNICAAM1QNWCHwJVA9XCVQJAAAWZAAACAn+B4gAAAJUCsQKpgqeD4wKhAoAABxkiAj+B0gAAAi8CLQJoAb+BKAGtAm8CAAIHmSAAIQI/wckAIAPWgBaB1sFWgdaAMIPAAAsZAAAEA78AYAM+AN+CfgHAADeDUICngUgCC1kAACICP4HSABAAG4HVgVcBWQFTgdEAAQANmRAAEgI/A8gAJAPaAB4B3QFcgV0BWgHEAA6ZAABBA3/B4QADAj/BasDqgH/BasDqg6CAERkAACIDPwDKAiABLwGvAG8BbwGvAakCQAARmSAAIgI/gdAABwFVA1cC9QJXAVUBVwJAABHZIAAiAj+B0gAAAasBKQE6geiBKoEqg4AAEpkAABICP4POALIATgBMAD+D6gE/gesBAAEVGQAAIgI/geAAIgCBAK0Au4OxAIEArQCgABYZIAAiAj+BwgA4A8UAFwH9gVcBxQI9AcAAGdkAABICP4PSABMAOgHaAVuBegHaAVsBQAAaWQADPwDBAC0A7QLtguEB7QDtAN0A3QDVAJ4ZIAASAj+D0gAAAl0CXYH9AF0A3YFdAkECYNkAAL8A/wD/gv8C7wH2APWA1IDdgNUAoACh2QAAIgH/gDwD14A/AdwAPQHOgbFATwGAASQZJAAkAj8B5AAGAj8C9gG3gbYAv4PmAIAApFkgACQCPwHAACYA/wL2AvcB9gD/AMYAwAAkmSICP4HSAAQAPQPvgK0Cv4PEAjuBogDeAyVZAAAkAj8BwAA/A1YAfwFAAD4DyQA5A8kAJ5kSAj+B1gAAAj0CvQK9Ar2D/QK9Ar0ChAIpGRAAEQM/wcAAPIPvwLaDxAIOATHA3wMAAClZAAACAn8BwgAoAu8CuQOQAsoBfwHqAkAAKtkAAGQCPwHUAAADfwBKgHoDSgB6A0oAegNrWSAAIgI/gdYANQAVAe8BbwHlAW6BdIHkACuZIAAhA7/AWAE4Ae/BrUG9Q91BHUD/wVgBLBkAACICP4HoABOCfYFVgVAAU4F9gVWBUAJsmRAAEgI/g9IAAIJeAVuA+gBbgN4BWoJAAi8ZAAASAf+AAAO/AEsAdwHrAN/AqQDFQQAA79kAACICP4HCADoDLQC9AQSAPIMtALkBAgIwWRAAEgI/gcAALQMZAMEAPoHVAX8B1QFAATFZAAAiAj+B0AAfATMB/wH/gf8B8wHfAQABMdkAABICP4HIAC+AvoCvgK6D74C+gK+AgAAymRABPwE/Af+B/wO+A+QB+4GogbmBqgECAHLZIAASAj+B0gAAACaB/wF2AXeB9gF/gWKB81kAACQDPwDEAjABbwF9AOUD/QDvAXgCQAAzmQUADwCvgO4A84LvAuED6gDtgOUAywDRALSZAABiAj+B4gACA7EAZIH2gXyA7QJxA8AANRkgACICP4PSAAYDvgBrgy8D8wPvA/IDwAA2mSAAEgI/g8ABPgDGADYBf4DfA9sAWwGAATgZAAAiAj+BwgAYAzUA+QCvgK8ArwC7A8EAOZkAAAIDf4DCAksCZQB1Am+D7QB9AEcDQAA7GQAAIgI/AcAAF4N1ANUDAADLAT0DzwJZAj0ZIAAiA7+AQAM/ANECPQL9Av2A/QL1AsAAPpkAACIDP4DwAh2B8oM7gcKAG4GqgquCgAA/mQAAYgI/gcIAMIIfgreB14HXgf+C8IKAAgAZVQAzAJeAkwD4AvmC9QHwgNIA14CzAJUAA9lAACYDP4DAAjoB2YC9A8AAN4H1Av0CgAAFGUAAIgI/gcAAP4H9gR+A/AH7gP2CP4HAAAcZUAAJAT/AyAAiw9+AfoCewb6AXoE+wcgAB1lAACQCPwHUADEA/wC/A88APwD/APkByACJGUAAAAASAj+D/4L9Af+DvQPrgT6B6gEAAAvZQgIKARoBKgEKAM+AigDqARoBCgECAgAADZlAAD8AwABAAH+DwAAMARuBIgD6AIYBAgIOWUAAOQBJAIkAXwFYAwwBM4CCAHoAhgECAg7ZQQBBAH8AQQJZAkQBG4CiAOIAngECAgAAD5lAAgIBvgBKgjIByAAEAzuAogDeAQICAAAP2UEBPQDBAL8AyQCZAgwBO4CCAPoBBgIAAhFZQgAyA9IBH4EyA9gCDwEygKIA3gECAgAAEhlCAioBIoCjAMoBEAAMAzOAogDeAQICAAATGUAAJIPkgT+BJIEgg8gABQM6gKIA3gECAhPZUAA+AFWAfQFVAX0A2AJHgTlAsQDPAQECFFlCAJoCQgJ/g/IAAoJYAh+BIkD6AIYDAAAVmUABFQC1AH+BNQE1ANAAH4GiAFoAhgGAARXZQAI/AVUBVQB/AVgADgMzAKIA3gECAgAAFhlUAJYCVQI8gdEAGQLMAjuBAgD6AQYCAAIWWUAAlQCVAneD/QBWAk2CHwEiwPIAjgMCAhdZQAA9g/QAf4P0AH2DwAIPgTJA+gEGAgAAF5lAADuD+ABfgKgCe4PQAh+BIgD6AQYCAAAYmUAAAgC+gOqAqoC/g8AADAM7gKIA3gECAhjZQAA6g+vAqoCrwrKByAAGgx1AsQDPAQECGZlCAL4CtgK3A7YA3gKYAj+BAgD+AQICAAAbGVEAPQDVgHUCRYM9AMwCG4GiAHoAhgMAAhwZaAIqgqYB/4EmAeKCCAIPgTJA4gCeAQICHJlAAD0D/QD9gJ0CfQHAADgDD4DKAPoDAAIdGVAAFwIPAi+DrwI3A/YCrYKtApMCEQIAAB1ZQAA+g8OA/sCDgn6BxAAPwzEA3wGBAgAAHdlAAS/AqsB/wWrBb8DmAg/BMIDcgIODAIEeGUICXwLfAv+BXwFfAtgCTAE7gN4BAgIAACDZQAAXQl+Bf8HVANeAWgA5gNWBVwFZAVABIdlAAAICAgIGARoBIgCCgGIAmgEGAQICAgIiWUiBBIM0gNWAVoBSwFKAVYBVgHSBxIAEgCLZWQAZA9kAVQBXA/WAVQBXA9kAWQJZAdgAIxlCAhoBI4DfAIACNQP9AcQAP4D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/g8oAIwARAAkACQA/A8EADQAxABwZ4gIiAZIACgAGAL+DBgAKAxIAIgGiAgIAHFnAAAEBPwErAKsAf4PrAGsAqwC/AQEBAAAfmeIAUgA/wdIAIAEOASGB2AEAQSOBTAGAAB/ZwgDiAD+D4gAAAz8A2QIpAUkBqQFZAgAAIFniANIAP4PSAAADIQDfAiEBTQCLAXgCAAIhGeIAUgA/g9IAAAAnAFqAQgJyAkIDPgDAACJZ4gDSAD+D0gAiAAACEQIRAj8D0QIRAhECJBniANIAP8PSACIAAAM/AMiACIA4g8iACAAlWeIA0gA/g9oAIAIOASIA34A6AcICDgIAAaXZwAAiAFIAP8PKAAoAoABSAD/D2gAiAMAAZpniANIAP8PSACgCBAEbgSIA8gCOAQICAAAnGcAAIAEvgSqAqoBqgH+D6oBqgK+BIAEAACdZ4gBSAD/D0gAiAggBKgEKAU+AigF6AQICJ5ngAFIAP8HSAAAB/4AAASAA34AgAMABAAAoGeIA0gA/g9IAAABJAEcAQYBhA88ASABEAGiZ4gDSAD+D0gAAAD8DwQIFAvkCLQJBAoACKNnAAAEAbQAlARUBH4JVApUCpQKtAAEAQAAqmeIA0gA/w9AABAAyAckCCMJJAnICBAGEACrZ4ABSAD+DygAQA/8AAQG9AEEAvwHAAwAAK9niAFIAP4PSABAABAPkAT+BJAEkASQBxAAtmcAAKQIlASOAoQB3A+AAbwCpAKkBLwEAATEZ4ABSAD+DygAAAD0DxQAlAF8AJQJFAj0B89nCAGIAP4PSAAAAPgPiASOBIoEiAT4DwAA0GcAAIQEhAS+AqwB7AesAKwBvgKEBIQEAADTZ4gEqgSqAoACpAG0D44BhAL8AsAEwASwBNRnAAlQCVQFNAN8A9wPdAMcAxQFNAkQCQAA2GeIAUgA/g8oACgBgAD0D0wERAREBMQPBADcZwgDiAD+D0gAAAD8DyQJJAkkCSQJ5AkECOVnAABICCgIqA9YDVwNSA1YDagPKAhICAAA72eIA0gA/g9IAAAA9AMUAfQJBAj8BwQAAADxZwAAiANIAP8PyAAICQAIigj6D4wIiAgICPNngANIAP4PAAD8CQIF+gIAAPwPBAD8AwAA9GegBL4EoAK/AqQBgA+fAaQCpAKkBKIEkAT7ZwAAJAgUCNQPrAquCqQKrArUDxQIJAgAAANoiAFIAP8PSAAAD/wAFA70AVIIUgjSBwAABGgABFAEXAJQAdIA1A/QAFABWAJUAlAEAAQHaIgBSAD+D0gAiAQgAqQJJAjkDyQApAEgBgtokANQAP8PUAAEBnwBRwjkD0QARAMEBAAAD2iIAUgA/g9IAEAEEgSWBJAEmASWBBAEAAARaAADiAD+D0gAAAbkARwDQADQCRAI/gcQABZoiAFIAP4PaAD6D4oFfgQKBH4EigT6DwAAF2gECXQJVAVUBXwD1A9UAXwDVAVUBXQJBAkhaIgBSAD/D0gACAhgBBgE2AIOAcgCKARICCpoiANIAP4PaACABBAETgPIAP4PyAFIAkAEN2gIAYgA/g9IAAABSgFKAfgPSAFOAQgBAAA4aIgBSAD/D0gAiAggBGgFmAROAigDqASICDloiANIAP8PSAAAAP4PUgjSCFIBUgZ+BQAJPGjEASQA/w8EAEwA5A9nBFsEWgRmBOIHQAA9aBAEVAJUAd4PVAFUCRAE/gIQA9IEFAgABj5oQAhkCRQFBAU8AwYPRAE8AwQFFAUkCQAIQmiIA0gA/g9IAAAIJAkkCb4PJAkkCSAJAABDaIADSAD+D0AADAmABP4DAAD+B0AInAgEBUZoiANIAP4PKABAAPwPBAhUCvQLVApUCgAISGgAAJQJlAW0BVQDVg9UAXQDlAWUBRQJAAhMaAAAAAl4BVgFWAPeD1wBXANcBXwFBAkAAFBoCAOIAP4PAAD8DwQA1ANUAtQDBAj8BwAAUWiQCZgFXgV+AxYBhg9WAVoDWgWwBYAJAABTaMQBJAD/DyQAAAT9BSUFJQUlBSUF/QUBAFxoiANIAP8PSADKCEIIxAVxBlYCQAXcBEIIY2iIA0gA/w9IAAIELAUgBT8FIAUoBeYPAABlaIgBSAD+DygAgAhUBDQDHAAUADIPUgCAAGZoiAFIAP4PSAAAAXwBAgGQDz4BSAFGASQAaWjEASQA/wcUAAAO/AEEBCUE9QckBCQEAAB2aIABSAD+BwgA4g9SAVoB+g9WAVIJ8gcAAH9oiAFIAP4HSAAAAX4BagFqAeoHagF+AQABgWhMCWAJEgVYA0IDMg8OAUIDQgU+BQwJMAmFaBABkAD8D5AAoATYA6wCqALoC6gK6AeAApNoCAOIAP4PSAAAAFQBRAHGD3QBRAFEAQAAnWgAACAA/A8CAPgDAACoBq4AlA+0AKwCpASiaIQBRAD+DyQABADxB1YBUAFeAVAF9gcAAKZoAAASCYoEXwRGBWoCSAJKAd8ARgAKABAAp2iIAUgA/gcoACAAqge+BKoEqgS6BKIHAACoaEAIKgkaBX4FGQOqDwABHgNABUAFfwkACa1ogANIAP4PSABAClgJHgXKBpgGngmoCAAIr2iIAUgA/g9IAAAE6gSsAvgPqACuBLgDAACwaAADiAD/D0gAgAzoA4gA6A/+BAgH6gggBLNogAFIAP4PSAAADLQDLACnDyQAtA8gBAAAtWgAADQIDATeA0wBVAFAAkwA3gcMCBQIJAa2aIgDSAD/D0gAAA/+AAoCqgLqB0oJTgkABMBoCAGIAP4PQAAQBQgFJASiBAwGkAVQBAAAxGhECVQF1AXMA8wB7g/MAcwDzAPMBVQFVAnJaIQDRAD/DyQAQACeB6oAqgDrD6oAvgSAA8toiAFIAP4PaABACQgF/gVYAVgB/gEIDQAAzWiQA1AA/g9QAAAA/A9UCVQA1Ad8CQAFAADSaIgBSAD+D0gAAABsAjwCrg+sAjwCbAKgANVohAFEAP8PZABMBkQBVATXB1QARAFMAgAA2miAA0gA/g8ABP4Dkgj+BwAM/gOSCP4HAADfaIgBSAD/D0gAAAT8BKwCrAH+D6wBrAL8BOBoAAgYCQoFfAVYA94PWANYA34FCgUYCQAA42gIA4gA/g9IAIAIFAZUAP4PVABUBXwFEAjuaAAApASUAtQPjAKMBD4EjALUD5QBpAKABPVoAADEASQA/w8kAAAD3wD1B/8H1QBfA0AC+miIAUgA/gdAABwA/Af0B1YFVAVkBQwHAAAFaYgDSAD+DwgAIAC0B6wCrgssCOQHIAAAAA1pyAAoAP8HCADgDwQE/AVcBV4FXAX8BQQEDmmIAUgA/g8AADAA/A+qBKgE/geoBKgEAAASaYABSAD+DwgAIA3+AygIgAkcBOQDdAYMCBxpkANQAP4PEADwCTgJNAXyAzQDOAX4CRAIMGmAA0gA/g8AAPwDVAL8DwAA/g8CAP4DAABKaRADkAD8D5AAAAj8B9QB1AXUA9QJ/AcAAFNpgAFIAP4DAAz+A0IAqgT6B6oEQgT+AwAMWmkAAFQITAZeA1QEwA9UCUwJXglMCNQIAAheaQADiAD+D0AAHAhUBNwDVAFcCVQJXAdAAGNpwAEkAP8PFACAA38A5Q9VBVcFVQX1DwcAbWkICWoFbAV4A24B6A9oAX4DbAVqBQgJAAB1aYgDSAD/DwgA4gmiCO4I+gtCCJIJcgoAAHxpgAFIAP4PKACICKoKmAfeBJgGqgWqCAAAfWkAAKQEpASAAvwB1gfUAfwBgAKsBKIEAACCaQADiAD+DwAA/AdUAnwJIATEA3wPRAhEBIZpgAFIAP4PCADwB7gC9A8WANYDBAjoBwgAnGmIAUgA/g8IAEAIXAbcAVYJVAlUCVQHAACuaQAE4gTsBK4CogCgD7IAqAKmAqgEogQAALRpAAOIAP4PyAAAALwPogqQCqQPnAqECrwPy2kAAMgDKAD/DwAA/A++ArwC/AO+CvwHEALNacgAKAD/BygACAboAXwHewV8BXQFdAcAANBpgAFIAP4PCAB8AFQIVgf8ANQHVAl8CwAI2GkIA4gA/g+IAAAEVgVUAPwPVAJWBVQFAAD9aYgDSAD+D0gAegDaD/8K2gr/CtoK+g8AAAJqwATsBNoCwAK8ANYH1gD8AogC9gTgBAAAEWqIB0gA/w9IAYQBJgkMDbgPDgF+BRAJAAATaoABSAD+D2gAAAh8C3wL/AV+BXwHfAl8CRlqiANIAP8PSAAcBWwBfAlsD3wBbAV8BQAFHmoAA5AA/g8AAPwHBAn0CtQLVAm0CoQLAAAfaoABUAD+D1AAAAL0AvwC9g/0AvQC9AIQAiFqgAFIAP4PaAAACXQFdgP0AXQDdgV0BQQJI2qEAUQA/w9EAAANKwOqCD4HagIrBaIMAAApajgDuAD8B7gAKACAAOwHuAeoB6gHqAcAACpqiAFIAP8PSAAICPoJXwVaBfoBXwVaBfoJMWqIA0gA/g8AAF4JOguODRwFQgV6C0IJXgk5agADiAD/D8gA4Ai0Cr4M9AYABJAA/g8QAEtqkANQAP4PEAAyD7IA8gf+BfIH0QCwDyAAX2qIA0gA/w9AAOYMuAO0Ct8IpAe4CrQIoARhaoABSAD+D0gACAS4BWwD7gq8CawHrAE4AmtqiAFIAP8PSAASCPIFfwV6BfoBfwVyBfIJlGqIA0gA/w9AABoH/AXYBd4H2AX+BYgHAACiaoABSAD+DwgA2Ay4AvQEFgDEDKgC6AQACMNqgAFIAP4HAAD+BwIE/gX+Bf4F/gX+BRIE+2qAA0gA/g8IAH4JLgv+DQAFXgUuC14JAAAEa4ABSAD+DwAA/gfuBOYD8A/mA+4M/gcAAAprCAOIAP4PiAEwAdQPNg+ADzYPVA90CQAAIGtACDAIDAQKAogBeACIAQgCSAQ4CAgIAAAhawAABAaEAQgIYAgeBAoD6AAIA0gEOAQACCJrFAQkAsQBPAMECDAEDgPoAAgDKAQYCAAAI2sABPwDFAAUAPIHAgAwDA4D6AAIATgGCAgnawAA/A8EBaQE1AQEDWAMHgf4AAgDeAwICDJriADED6IEkASSBOQHsAwOA/gACAM4BAAIOmsAAAgJ/AVYAfwFAAEwDA4D6AAIAzgMCAA9a1AIWAtUCPIHVA0ACDAEDgPoAAgDOAQICD5rAASqAqoIrweqAKICMAgOBugBCAM4DAgIR2sAAf4HqgSqBaoIvgcAABwOygEIAjgMAABJayQErQL+B/wDrgH9BDgMBwPkAAwDBAQAAExrgAC8B6wFvAeECLwHsAgOBvgBCAN4DAAAUGsAAP4DggTaBaoE2gUADBAD7gAIAygMGABTayAB7A+sB7gHqAfgDGAEHAPwARAC8AwAAGFrAAG6D7sHgAe7B5oHMAAPDuQBBAN8DAAAYmsABAAE8AcABAAEAAT+ByAEIAQgBCAEAABjawAEBATkBwQEBAQEBPwHRAREBEQERAQABGRrAAjwDwAIAAj+ByAEAAD+ByAIIAgQCBAGZWsgCCALvAigCCAIIAT+ByQCJAKkAaQAIABmawAAEAjUBxQE1AeUBBAE/gAQBxQIFAgQBmdrAAjwBwAE/gcgAggKaAioBT4CKAXoBAgIaWugAKAFfAhgCCAFIAX+BCQCpAEkAKQAIAFqayQIpAikDpQIlAi8CIQPlAqUCqQKpAoACG9rEADQBxwE0AWQBd4FngW0BRQE9AfwBxAAcmsIDOgDKABsC+gHaAIuCXwErAO8BKgIKAZzaxAO0AFQBNwC0A/QAF4J9AxUA3QFVAkQBHRrAAz8AwQIVAh0DxQIhA9UCvQKNArUCAAAd2sADPwDBAhsCPwObAgED2wK/ApsCqQIAAB4awAIfAdUBNYHPAVAADwHvAD8D7wAqAcAAHlrAACEAEQIJARUBJwCFAGUAHQAFAAEAAAAe2sAAMQIZAScBhQB9AAEAPwHRAgkCDQIJAZ8a8AAIgieBBID8gAAAEQARAD+D0IAQgBAAIprgABiCB4GkgFyBBAETgPIAP4PSAFIAkAEi2uAAOIIngSSA3IAAAioBP8EaANlBVUJQASWa0AAYgxeApIBcADkDwQE/AVuBWwF/AUEBJhrgABiCF4GkgFyCAIJqAUvBxgFXQsVC6AItGsAAPwPFAXkBBQNQAzeCEIHQgb+CWAIGAi1awAAAAL8D1ICUgIRCUAI3gVCAl4FoAgYCLdrAAz+A1UJVQk9B0AA4AheB0IG/gVgCAAAumsAAFIGVAHMD1MBAAjeBEIFQgJ+BeAEGAi8awAAbAxsA+4A7AcEAmAI3gRCA14DwAQACL9rAAf/APUOpQD1AqcEAASvAqECLwHoAgAEwGsAAHwJUglAB1QFPA1ACH4JQgb+CWAIAADBawAA/ATSBMAH1AQ8AkAI/gVCAv4FYAgAAMVrAABUATQL1goUB8QCEAjOBUIC3gVQCAAAy2sAACAA4Ak8BSQDpAF8CSQJJAf8ASABAADNawAAIADwAy4CogKqAqoKIgoiDv4DIAIAAM5rAABIAMQHcwJKAsoDegpKCkoO+gNCAkAAz2vAAMgC6AOmApQDlAPUA5QKlAr0B8QCwADSayABIgHqB2oFagX/B2oFag1qDeoHIgUAAdNrEAD4B7YFlAz0BwAAtA8sAKYPJAC0ByAI1GsAAAAA/g8gBCAEAAD+B0AIIAgQCBAHAADVawAAQAF+AUgBKAGADz4BSAFIAUQBJAEAANlrAABACn4L5AdkBVQDXgDkB2QKZAlQCUAE22sAACgBKAEoASQB/AckCaQIkgiSCJAIgAbrawAAxAT8BewF7APuB+wL7ArsCnwKxAoAAO9rJAEkAfwHkgiCCCgKZAoQCc4JEArMCgAED2wAAAAI/AckBCIEIgR+AKIDIgQhCCIIIAYRbAAAAAj8B6QEpASkBOQEpAGkBrwIgAgABhNsCAD4AQoCCAIACP4PkgiSBPIBkgaeCAAEFGwgABgARgBVAFQAVABUAFQA1AMUBAQIAAQXbAAIWAlGBVQCVALUBdQEVADUAxQMBAgABBtsEAAYCYQFIwMqCSoJqgeqACoB6gMKDAAGImwIAKgEtgW+BXwHfAW8BbwFHAD8AwQMAAYjbBAAGAlEBSMBqg8qASoBag0qAOoHAggABidsEADIAsQC3gLcD9wC3ALcAhwA/AcECAAGNGwAABAEEAKQAXAIAAj+ByAAwAAgARgC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AAF/BNUH9wTdB4AErgelBKQHBATubwAAEgakASAA/g9jBXgD7gF+BXgFKgkAAP5vAACBB0EAAAP+DPoBXgXrB1sHUwH3AwAEEXAQACQPJACABbwE/A68DLwO/AK8BLwJgAIfcBEEpgMAAAIAEwy6AzoD+A86AbsHugO6DyxwEAyiA4QANgZUAf4HJgHyBG4FagH6BQAETHAAACIIRAYEA3QO1A82D4QPdg9UD3QPAABRcAAAIgasAQAE6gPqB/oF4gHqA/oF6gUABGNwEAAmD0AAFwJNA6ADnAO2C/oLXAcSAkAAa3AACGAIGAQAAoABfgCAAQACQAQ4CAAIAABtcAAAAghCBDIEAgLCAT4AwgACA2ICEgQABG9wQAhwBAAC/gEQAgQABAgECPwHBAAEAAAAcHAEAoQBdAAOCOQEJAIEAfQABAFkAiQMAAB1cAAIAAmqCCoEKgKqASoCKgQqBb4IAAgAAHZwcAQADv4BAAEYBQAEIAQgBP4HIAQgBCAEfXAACAwJ0gQABAgD1gACAwgEDAXSCAAIAAB+cAAAmAiICGgECAIKAewACAMIBMgEGAgAAH9wOAgABv4BAAMIAPAHAAQABP4HAAQABPgPiXBwCAAG/gEAAjgIAgzyA5IAkgCSAPIBAACOcAAAQAgoCaQEIAQYA8YBGAIgBKQFJAhACJJwQAAwDv4BAAEYCkAIOAQABP4CAAKYASAAlXA4CAAG/gEQAgAI6AcqACoA6AcICAgGAACrcDgIAAb+AQADCABIBGgG2gVIBCgHCAQAAK1wAAzsAygIqAmoBC4GqAEoAigEKAmsCCAIrnBwCAAE/AMwBgAA+AcuCSgJ6AsICvgJAASzcBgIAAb+AQACGADgDxQAnAF8AJQJFAj0B7hwcAgADv4BAAIoBDAADgD4DygBKAEoAQgAuXAAAAAM4AKgAKAGvgCkAqQEpADkAgQEAAC6cAABiAyKAsoAuAasAKoCqAi4CuAIgAcAALxwOAgABv4BCAEQBHQDXgj0D0QARANEBAAAwXB4CAAG/gEIAxAAPAekACQI9A8kAKIDIATCcHgIAAb+AQABGAEABJYEkASYBJYEEAQAAMhwIAkSBw4DygBqDBoAAAR8CQABAAX+BQAIz3AACAAM/AFUAVQFVAFWBVQBVAtcCUAHAADYcDgIAAb+ARACgAiIBP4CiACIAP4CiAwACNtwQAgwBv4BEAYABPgIiAj+B4gE+AYACAAA33B4CAAO/gEQAP4PAgQiBfoEogUCBP4PAADkcPAIAAz8AwAEEAUAAagD/AqoCrgKqAYkAOZwIAQYBAAD/wAIAwAI+QQJAu8BCQT5BQAI53B4CAAG/gEAApAIhASmA7wAtA/ECKQIgATrcAAIighiChQJAAQqA1oELgSaCIoKeAgAAO1wAAAkBCQDfwAUBoAAZAA/BwQAfAKABkAICXEAABAIFAT0AVQJXANcAVwDXAlcCRQHAAAVcSAIEA7+ARACgAj4BJYC9AGcAvQEgAgAABpxAAAkChQLvgQMBKQDMAIMBH4FDAUUCCAEIXEoCCgN/gElAfwNJAH8BSQJ/AEkBSAIAAAmcRAIEAz4AV4BWA1YAfwBWg1YAVgBCA0ACDBxeAgABv4BAAI4ANAPSAUGBUQEXAXEDwAANnGICKgGbgJuABQFDAGAAGgGHgBoAooOgAg8cUAIOAQAAv4BEAikBPQDpgCkD/QIpAgABExxeAgABv4BAAKQCPwK1ArWD9QK1Ar8CAAATnEECfwEXQReAVwN/AAEAHYMBQH8AQQMAABVcQAAAAj+BLIAzgK6DAAA/gQSCRIDng8ACFlx8AgADPwDIAj0CpQK/AqUDvwKlAr0CgAAXnEAABgJVgVUAVwN9AEAABwN6gjIAjgFCAlkcTgEAAb+AQABEASEBL4CrAHsB74BhAIABGdxAAj8DZQAlADsDBQAzAFEBVQJVAHMDQAIaXE4CAAG/AEQAgAI/AusCqwCrAasBvwLAAhucQAAMA40APQBdAV+AXQFdAV4AfQBEgwAAH1xAAAQDv4BEA78A6wEbADqB6oEagL6DwAAhHE8CAAG/wEIAgAM/gCqBqsIqgqqAP4GAASKcQQEfAc/ALwAvgb8AAACZwSqAIkCRAwAAJRxGAAgDP4DEAQkAZQPRAkmCUQJlA8kAQAAmXEABAAG/gCSAO4GugAAAH4GkgSSAJ4CQASfcQQIvAy8Af4BvAwYAIgFfggIAPgEAAmAAKxxAAGcCHwEXgFcDdwAEAAIBb4MyAC4BAgJsXEAAEwJXAXOAVwNLAEIAZgMfggIAPgFgAjDcTgIAAb+AQgJMASuAHQODADIDj4AaA6KAMhxGAQAB/4AKAFSBLoFugS1BLYH+gUYBCgA0nEYCCAG/gEQAgwIrAnsB+4BjA/sCawJAAXVcQAAJAmkBOQBDgDsDSwB7gUECPQAJAWQCN9xAABuACQH5wXoBeQF4gXoBe4FKAd0AAAA5XHwCAAE/AMgCMAJvAX0A5QP9AO8BeAJAADmcRgIAAb+ARAGEACoBT4BxA8gAZQFLAUAAAZycAgABvwBEAKAALwF/AC8DvwAvAW8BYAAEHIwCAAG/gE4DvgHGADYD/4P/A/8CxwOAAgbchgAAA78AQAA/A/8BHwD8Ad8A/wM/A8AACpyAAgABvwBBAAEAPwPBAACAAIAfgCCAwAMLHIADPwDBAD8DwIA/gH4AiQFPAUkCbwIAAgtcoAApAKsAqQKpArsB6QCogKyAuoDgAAAADFyAAAUCFQE1ANUC1QLVAVUDVQLEggwCAAANXIABPoH6gXqBfoF7gWuCLoCqQjtD7kAAAA2chAIEAgMBGIEgAIAAYACcgQEBBgIEAgAADdyAAAkABQAUgBVANgPSABZBFYEkgMkACAAOHIgACgA5AdmCVYJWAnQCVoJVgmkCSgMIAA5chQAVAjUCrIKaAloBawEkAKSApQBFAAAADpyAABUBNQH1AbSBtgPCADaD1IA1AVUAhAAPXIAAAQJVAWUBCQChAF+AIQBJAKUBFQFBAg+cgAAFAD0DxQAVAL8DxQAVANUCxwI9A8UAEZynA6QAf4PAAC0B6wEpAe+B6QHrASkBwAAR3IACAAG/gGQAJAAkACeAJAAkA8QABAAAABIcgAM/gOQAJ4AkA8ABP4DMgzSBRID8gQCCExyAAj+B5AAng8AAXwBVAHUAX4B1AdUAXwBWXIAAAAEZARUAkQCRAHECEQI/A9EAEQAQABbcgAAoACQAI4AiACIAP4PiACIAIgAiACAAF9yAAAAAQgBaAFMAUoB6A9IAUwBSAFQAQABYHIwAY4AiAD+D4gAAAD8BxAI/gkICPgIAAZhcjABDgEIAf4PiACICCAIIAj+DyAIIAggCGJyAABMAUQBNAEkASUB9g8kASQBJAEMAQAAZ3KwAI4AiAD+D0gAQAgcBOoCCAPIAjgECAhpcrAAjgCIAP4PgAAQCM4MOALoCRgE+AMAAHJyMAEOAQgB/g+IACAInAiQCP4PkAiQCBAIdXIAADQCtAK0ArQCrAKuD6wCtAI0AmQCAAB5cjABDgH/D4QAEACSApICkgKfCPIHkgAAAHpykACOAPwPAAD6D4oFfgQKBH4EigT6DwAAfXIAABQCVAPcA3wDXgdcA3QDVAMUAzQCAACgcmACHAH+D4gAAAbUDtYHfAJUB1YGVAtACqdyEAEMAf4PiACgB7wO/g6cDdwFnga8CbQNrHIQCBAEEAIQAdAAPgBQAJIBEgIUBBAMAACvchIJlAhICPYHAgAAAPwHBAhECEQIfAgABrZyAAEcAYAA/w8AABAOkAF/AJABEgIUDAAEuXIgARYJmAjmBwAAEA/+ABAA0A8WCBAGAADAcoAMngOQAP8PAAgQBBAD/wCQARIGFAgAAMJyEAGWCEgI9gcAAEQERAREBPwHRAREBEQExHIQAZIITAjyBwAAOAyAA34AgAEgAhgMAADQchABNgmICPYHAA78AQQO/AUCBv4IAgMADNdyEAGWCVgI5gcQAMwDKgEoAegJCAj4BwAA2XIgAhQJmAjkBwAA/A8kCSQJJAn8DwAIAADgciABIgmcCOYHAAD+D1II0gRSA1IFvgWACOFyEAA0CZgI5gcAAGgIiAQKAwwFqAQICAAA7HIAABIJjAjyBwIA+ASIBP4HiASIBfgHAAjtciABFgmYCOYHAACoDIgC/gGIArgEmAgAAO5yAAASCYwI9gdwDv4B4AMUAPwPFAD0AwAA8XIAABIJjAjyBwAA7gcAAhAIEAf+AJADFgz4cgABlAlICPYHAAB8CVQJ/A9UCVQJfAkACPxyAAGSCUwI8gcAAPwPVARWBNQBVAK8BYAIDnMQAIoJTAjyBwAA1AdeBVQFVAVeBdQHAAAXcwAAkglMCPIHAAC0B7QCrgMsCOQHIAAAABtzAAAkC5gI5A8ADqQJpA90CSwPJAkgDwAIHHMQAZYISAj2BwAA/A+8Ar4CvAq8CvwPEAApcwABEgmMCPIHAAG+CKoKqg+qCqoKvgoACCpzEAGaCEwI8geAAFQA1Ad+BVQFXAXUBxIAK3MIAM0EJgT4AwIA8g+XBPIHkgSXBPIPAgAucwAA9A/0AJ4PtAD0DwAEEAP+AJADFgwAADRzAAA0CYgI9AcAAPwPAABUDdQDXAVUCQAANnMAAMkEJgT7A+APFwV8BRQFPAVXBfQHAAA/cwAAFgmYCOYHAAD0CrQPvgS0AbQGdAUQCURzEgnMCPIHAABYD1oFWAcAABAP/gCQAxQMRXMRCY4I8wf4D68EGAfiARIA/g8SAPIDAABOc1AJPgUYBX8FEAO0AToDHwPaA3YFEgUQCWhzAACUC0gI8AdMAPQFfAX0B3wN9Az8BwAAcnMAAJYJWAjmBwAA9An+C/QF/AX+C5QJBAh1cwAAMgmMCPIH5A/aC9AAvg/SCZAO/gwAAHhzAAD+B/oF/gX0BeoPBgwQA/4AkAMWDAAAe3PQDygAvg/+B+wP3AcADBAO/gEQAxQMAACEcwgIKAhICKgGGAWOBEgEKAUoBggECAgAAIdzgAK0AgQClALsAqYOlALEAhQClAKEAgAAiXMACEQIRAhECEQI/A9ECEQJRAlECgAIAACLcwAERAREBEQERAT8B0QERAREBEQEAAQAAJFzAAAkBCQC/AMkAgAI/AcEAAQA/AcACAAGm3MABiQC/AMkAQAABAF0AUQBRAl8DMADAACpcwQEJAL8AyQKAAkkBOQDJADkDyQIJAggBqtzBAIkAvwDJAEECTAEbgSIA4gCeAQICAAIr3MABCQC/AMkAoAAxAAkAPwPBABkAIQAAACwcwQEJAL8AyQCAAj+BAIC+gECB34IAAgABrJzAAIkAvwBJAEAADAASAJUAkYNyAhQABAAu3MABCQC/AMkAAAM+APICX4GSAbICRgIAADCcwAEJAT8AyQCAAD0AxQB9AkECPwHBAAAAMpzAAAkBPwDBAJACP4HQgD+B/wPQgD+D0AAzXMEAiQC/AMkARABSAgkBZIExARIAhABAADgcwQEJAL8AyQCAABcBkgB/g9IAUgCQAQAAO1zAABEBPwHRAQAAvAIAAT+AwAI/A9ECAQI8nMAACQE/AMgAgwAjAL0ApQC1A+UApQCAAL+cyQEJAL8AyQKAAj8BVQDVAFUD1QJ/AkABAN0AAIkAvwDJAEMA2gCCAj+B4gACgNqBAAEBnQABCQC/AMkAgAJfAhUCdQP/A9UCVQJfAkJdAAEJAL8AyQCAAi0BywApg8kALQHJAgAABB0AAQkAvwDJAIACPQJFAQQAt4BEAQUCPQLInQABCQC/AMkAoAA1ALUCbwIxAdkAJQDAAQmdAACJAL8ASQBAAC0B7QCrAMuCPQPNAAAACp0AAQkAvwDJAIACAgF/gVYAVgB/gUIBQAIM3QAACQC/AEgA4gA/g9IAAADyAD+D0gAiAM0dAAAWgBaAV4BegFaAVgBegVeA1oBWgCQADx0AAhEBPwH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8gMAAFIBfgJTAlIN0gASADB4hAD0DywE5AcAALQAhAD8D4QAtACAAAAAMniCAPoHJgQiBPIDOAecCJgI+AgICPgJAAQ0eIQA9A8sBOQDAAz4A8gISAl+BkgHyAgYCDh4AACEAPQPLATAA/wP5AgUCPQLFAj0CQAAQHiEAPQPLATkBwAAvAcgBCAE/gcgBDwEgA9VeAAAQgD6BxYC8gMACPoECgLuAQoE+gUABF14AAAEAfQPTASED/AHHABQAV4BEAn0DwAAa3gAAIQA9AcsBOQHAAC0DywApg8kALQPIARseIQA/A8kBOQHAAD8CKwKrAb8BawIrAj8CG54hAD0DywExAcQAPgPVgH0D1wBVAnwBwAAjHiCAPoHJgIiAuIDAABqAioJ6g8qAb4CoASNeIIA+gcmAiIC4gMAAV8DVQNVCdUPXwEAAY54hAD0DywE5AcAAGQBFAEkAcYPNAEkAUQBkXiEAPQHLAIkAuQDfADUAX4BVAHUB3wBAAGXeIQA9AcsBOAHxAA0DKQDRgD0BxQI9AkABJ94hAD0D0wEwAcIAHwNSAP8D2gDfAVICQAAp3gAAMoE6gL+D+oKgAr8CtQK1grUDvwAAACpeAAAhAD8ByQC5AsACPwHrAKsAqwG/A8ACLB4hAD8DyQE4AeIAA4J/A8ICPwPCgjICQAAs3iEAPwHJALkAwAIrAdoAC4NqAMoBKwJIAC6eIQA9A9MBMQHTADkD1wJVgn0D1QJVAlMCbx4AACCAP4HIgLAB34DqgSqAP4GqgGCDwAAwXiEAfwPJATkAwwIaA+OCOgOSAioD84IKA7KeAAAUgLSB3oFbgVqB2oC6gdqBXoFQgdAANB4UAVQBTwDVA8WC3wLCAtmC1ILvg+YAYAB1XgAAEQA9A8sBOADyA/8D84IzA/sCMgPAAjaeIQB9A8sBCQExAf8AtwG3A7+CtwP/AIEA+h4AA78AQQEtAS0DrQLlgqECrQKtAq0DpQA9HhEAPQPLATEByAAmgnaD9YI1gyaCiAIAAAOeYQA/AckAsQLFAhMBF4H0A9MCV4JVAkQCBl5AAAEAfwD5AsOCFQH1AFACAwH7A8sCWQAOnkAACAEJAKkASQIJAjkDyQAJACkASQCIAQ8eQAAiAGKAO4PWACIAQAA/gcACAAIAAgABj55AAAIAYgAzg+4AAgJIAggCP4PIAggCCAIQXkAAIgASgDsD1gAiAAAAPwPBAB0AowBAABCeQABiADKD3gAiAAgAPwHIAj+CRAI+AgABkh5CAGIAM4PeACICQAE/AMkACIA4g8iACAASXkIAYgA7g9YAIgIAAjwDwAI/g8gCCAIAAhQeYgAiADuD1gACAGAAPgPTgRIBEgEyA8AAFV5iACIAM4PfAAICOAMAALyB8QIMAhsBoAAVnkIAYgAyg+4AAAI/A8kCSQJJAkkCfwPAAhdeYgBSADuD1gAgAg8BCQD5AAkAOQPPAgABl55iAGIAO4PXACAAPgDKAEoAf4PKAH4AQAAX3kAAIAElgS0ArQAvge0ALQCtAKWBIAEAABleQgBiADOD3gACABAAUoBSgH4D0oBSgEIAWh5BAl0BdQF1AH8CdQJ1Af8AdQF1AV0DQQJbXkQABABmAhuBEwBdAlICUYPWAFkA1QDjAx3eQgBiADKD7gAAARUAtQBfgNUCVQPRAEAAHh5CAGKAOoPmAAAANwPVAH0AFQLVAjcDwAAenkIAYgA6g9YAEAICAn+BVgBWAH+BQgJAACAeQAABAr8C4wD/AvcC94P/AOMB/wHBAoAAIF5AAAUCUwFXgFMCUQJUA9MAV4FDAU0CSAAhHmIAIgAzg98AAgAQgQqAioJ6gcqAb4CoASFeYQARADmD1wABAHwAaoB+AesAaoB+AEAAI15gACIAOwPGADAD3wAxAf0AtQDVAj8BwAAj3mIAEgA7gdYAIIA+g9qBWoF6gdqBXoFwgemeQAAJAWzBYAF6wH+AdoHgAG+A4IDPgUABad5AAGKAOoPkAAEAHwP3AteC1wL3At8DwQBqnnEACQA9Q8tAEAC/wKtAv8PqgKtAv8CAAKueYgBSgDqD5gAAAj+C/8K6gr/CuoK/gsACLF5AAGKAOoPkADED/wF/Af+BvwC/A/cAgAAuXkAAIQPvACsBKwE/AesBKwCrAq6CIIHAAC6eQAAgA/8ANQC1AL8A9QC1ALUCPwIgA8AALt5BAAED3QBZAVkB9YFVAVUA0QJdAkEBwQAvXkQAAgP6AHEAZQFsge6BbIHhAnoDwgAAAC+eSAEJAIkAaQAZAD8D2IAogAiASICIAQAAL95AACQCFQIVAQ0A3wANAA0B1IIUgiQBIAAwHmICEwILAScA4wAvACKCpoJKglKB0gAAADBeQACkgFSAP4PUgBSBAAH+AQGBMAEAA8ACMN5AABQCFQIVAQ0A7wAlAA0B1IIVAhQBgAAyXkAACgEugS6AroBugH+D7oBugL5AigEAADLeQAAkgNSAP4PUgAACDgEgAN+AIADMAQICM15lANSAP4PUgACAPgBiACIAP4PiACIAPgB0XkAAJQDUgD+D1IAEAFCAUwBAAH+DwABAAHSeQAAlAFSAP4PEgCACDgEgAR+AgAB2AAAANh5EgOSAP4PUgCACWAE+geCCGAIHgjgBgAA33kUA5QA/A9UAJQJAAj8DyQJJAn8DwAIAADkeQAAFAOUAPwPkACEALQAhAD8D4QAtACEAOZ5IAGsCGwErAO8A64PbAEsA2wErAggAQAA6XmUA1QA/A9SAJIIEAROAkgB/gBIA0gEQAjveQAAlANUAPwPUgAACHwGRAFEAEQBfA4ACPB5kgNSAP4PUgCSAhACzwEECPwPBADsAQQC+3kAAJQBVAD8D1IAAgmoBKwEVgV0AswBQAAAehADkgD+DxIAAAHqB6wAvACkD6wAqgSoAwV6EgOSAP4PQgAICPQEkgOQAJIP5AgICBAEC3oAABgDmAD8DwABPAikCqQKpA+kCrwKAAgNepIBUgD+D1IAAADyB1QBUAFeAVAF9gcAAA56AACUA1IA/g8CADgMygNIAMwPTgh6CAAGGnoAAJQBVAD8D1IAEAD+D6gE/AeqBKgEAAAjehAA+AVWBfQFXAX0BiAHpAD8D6QAIgcAAC56AADKASoA/wMACP4Krgr+D64K/QoACAAAMXoUA5IA/g+SAAAC6A+kAqQC6gOiCroK4gcyehQDkgD+D1IAEgDADxIAwg9aBUIF2g8AADN6JAIkAfwPogAABlgAVgVWC1QJXAHwBQAIN3qUA1QA/A9SAAAJfgmWBdYGvgZWBVYIXgA7eooBSgD+D0kAAADKB6oEgQQtBKEE7QcAADx6FAOUAPwPUgBABVwFtAJ2CbQG1ABcA0AEPXoUA5IA/geSABAAdAesB64HtAe2B5YHVAA/eooDSgD+D0kAgA9eAFYPVgVXB14Awg8CAEJ6FAOSAP4PUgCABnwArAysCf4KrAKsBvwIRnoSA5IA/g9SAIAIvAwsBSwF7gYsArwCgABMehAM+AFWDfQBXA3wAgQGpAH8D6QAIgcAAk16mAFYAPwHVAAQBPwF/AX+AfwB/AX8BRAETnoABM4C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SAduANAPTADgCggIOATIAg4DyAQ4BAgIDX1IB24A0A9MAAAB+A8IAcgAPgDICPgHAAAQfRAOnADyDsgAgAIECEQM/AtECPwPQAgAABR9SAduANAPTAEAAOgDCAEIAf4HBAnkCQAEGX1IB3YA0A9MAGQBAAT+ByIE/gEiBiEMAAAafUgHWAD2D2AAQAsEB/wAhAQkBTwD4AQgCBt9SAd2ANAPTAAAC3AITgbAAUIITgjQByAAIH0gACoJagVqA+oL/wlqByoBqgWqCSALIAghfUgHfgDQD0wAxAoACAgH+AAuCCgI6AcIACJ9AAA0CBQFVAX0AV4JVA80AbQFFAU0CQAAJ30ACB4JgAXeAcAJogmSD14BUgUeBSIJIAArfRAJHAlQBV4FtAGQD04BFAWUBRIJCAoAAC99AAAACD4FagXqAX4Jag8qAaoFPgUACAAIMH1IB3YA0A9MAcAA/A9EBEQE/AdEBEQE/A85fUgHbgDQD0wAAAMgAKIPngSCBKIEng8AAEJ9SAduANAPTACAAogATgQ1BTQFTAlAAAAAQ30QDtwAsgZIAEAHSABoBloFzAQoBggMAABEfUgHbgDQD0wAAAMACPwPJAkkCSQJ/A8ACEx9SAduANAPTAAAA0IIJgkqCZIPKgkmCUAIUH1IB24A0A9MAKADBACkD6QEvwSkBKQPJABVfbAN7ACiBJgCAAD0BzQJLAnkCTQJLAngBV59SAd4ANYPUAAACygImAQYA84DCAQoCCgAYX1IB24A0A/MAMQDkADID9YEpATcBEQPgABmfUgHbgDQD2wBIACQD4wEogSkBIgEkA8gAG59AAAsCCwFlgHUCcwJgA9eAVIFEgUeCQAAcX1ID3YA0Q9MAAAJBAS8AycALAC8DwQIAARyfQAAkA78AJIGSAIAAFgDdgjQD0wA4AIABHV9SAd2ANAPTAAACxAIiAamBaQEiAawDBAAdn1IB24A0A9MAQAA+AeWCJYI/AicCJQI8AaTfZAMvAHiDNgAAAo6CEIJEgnqD4IJPglGCJl9QAduANAPTAAAAf4PAASoBP4FoAQsBQAEmn0AAEgHfgDQD6wDgAlUBFQDXgBUBtQIBAScfTAO7ACiDJgCAACMDKQCpwCkD6QArAKADKB9MA7sAKICmAQABNoCVAjUD3QATAKABAAArX1IB24A0A9MAEADEAD+D6gE/AeqBKgEAACxfU4HcADsD0AB/A/sA+QDJAKsCyQI/AcAALJ9SAd4ANYPgAL8DwwAvAPkBLQEBAD8DwAAv31IB24A0A9sAQAAvgeqAKoA6w+qAL4EgAPKfQABPgUuBb4F7gGuB6IBWgMaAyYFQgUAAM99SAd2ANAPTAAAAV4EQAD8D2QJcQhGA4gE0X1IB24A0A9MAAAFIASqAioI6gc+AaAGAADSfUgDdgDQD0wA4AOEAJQHfgVUBVwF1gcQANp9SAduANAPzADABZwCrAksCO4PLAO8BAAE4H1IB3gA1g9IAQgAoAeUAJwA1g+cALQHAADjfSAIvAziAtgCgAQgBH4DtAq0B7wBIAYAAOh9SAduANAPTAAAD/wHrAKsD6wCrA+8AoQP6X1IB24A0A9MAEAJFARcA/QJ1AbSBtwFVAjvfUgHWAD2D2ACAAT0BbwHtgW0D7wF8AUABPR9SAd4ANYPSAAAAvwErAKsAf4PrAH8AgQE+32QDtwAsgTAAZwE1AeUBAQA8AwOA/gEAAgBfkgHXgDwD2wAgAIgBGoDqgpqB74AIAcAAAR+RANfAOgPJgAAAfwHvAK8AvwHvAq8CvwNI35AAnwBfAD8B/wASAIYAXwE1ANUANACgAAmfkgHbgDQD8wAQAL2D5gHFgTwD5YIEAgAACt+EA7eAHEEbAMBCHYG4AksCLsK+wsmCgAILn5AB34A0A9MAUAA7A8EANYHdAVUBdQHAAAxfhAO3gCxDMwCAAD3DwAEzgMBBOgHhgiYCD1+kA7cALIMiAIADPwChAaWCaQLhAD8BgAAPn5IB24A0A9MAAAK/Aj8Bf4F/AH8BfwJEAhBfgAIMAq+CjwL/AM8D4gCXgZkB1wKhAoAAEp+QAdOAPAP7AHAB/QHHgT0A5AG/geQDBYCVH6gAy4A8Ae8ABAA/Ae2AtgPPwPQBBYOAABefpAO3ACyBIgCAAiqCeoHrwEKD+oJqgmABWp+AAd4AJQGUgEIADQH8gX6BdIF9AX0BwQAa34AAH4Kfgd/B/4PfgsYB/YC0gp+CpgKgAhwfkgHbgDQD0wBAATwAt4B+gfqAdYC8AQAAHN+kA7cALICCAk+DOsD6wm+BzQMiwN4DAAAfH4QDtwAsgZIAv4PNAi6DzgJPgisDxALAAiMfpgO9gCRBkgBEgjuB/4H7wP+A+4H+gcACI9+gA7cAKIGWAEADPwD9An+C/4O/Av8C4QJln5QB3wAagIACXYE9QcQBPYPMAT+B9AMFgKgfqAEsAVsBSIFkAQAAPwBAAEAAQAB/g8AAKJ+AAAwCewEogSYBgAABAQEBPwHBAQEBAQEpH4AADAJqAVmBRAFQABEAEQA/A9EAEIAQACmfqAEuAXkBJIEgAIwAI4AiAgICQgM+AMAAKd+IAW4BeYEkAIQDIQDfAiEBTQCrAVgCAAIqn4AACAFuAVmBRAFAADEB0QIRAhECPwIAAasfiAFuAVmBRAEAAKoAKgA/g+oAKgEiAMAAK9+IAW4BWcFEAUABPQBBAEEAf8HBAn0DQQEsX4AADAF6AWmBJACAAh4CAAE/gQAApgBIACyfgAAmAXXBLEEAAD+DwIAsgHaAQII/g8AALN+AAAwBc4FIgUAAPAPEAPwAJ4IEAjwDwAAtX4AADAF7AWiBJAAAA7+AQAMAAP+AAAHAAi3fgAAIAW4BWYFAAFgCFgExANACEYI2AdgALh+IAW4BWYFMAUAAPwPRAhEBPwBRAZCCEAGuX4AADAF7ASiApgKAAg4BMoCDgPoBBgECAi6fgAAMAWsBWIFGAEACAgH+ABOCEgIyAcIAL1+AAAwCawFYwUYAQIIQgz+C0IIQg7+CQAIv34AALgF5ASSAoAKEAhQBH4EyAMqBaoIAATDfrgE5ASyAgAAVAZ8AVYI9A9EAEQBBAYAAMR+AAAgBbgFZgUQAQAI/A8kCSQJ/A8ACAAAxX4AACAJuAVmBQAA+AMoASgB/g8oAfgBAADGfiAFsAVuBSIFAAD8D0QERAT8B0QE/A8AAMd+IAW4BOYEkAIACHwGRAFEAEQARAF8DgAIyH4AADAF6AWmBJAEEABIAlYEJAVUBUwIgADNfjAFnATyAogCIACiD5oEhgSiBKIEngcAAM9+IA24BeYEkAAACKQIpAiUD6wIpAggCAAA0X4AADgL5gmQAQAIKA3+AwAA/A8EAHwChAHSfiAAmATkArICCABABugBCAh+BIgHaggIBtN+MAXsBKICmAIAAKQHpASkBL8EpASkBwAA1X4gBbwE4gSYAgAIpASmA7wAtA/ECKQIAATYfjAF7AWiBIACIAiQDqwJpgSIBpAEoAgAANl+IAW4BOYCgAIgAKAPsA+uBKgEsA8gAEAA234gBLgFZgUSAkAAqAKoAq4ClA+sAqQCIALcfgAAMAXsBKICkAIQAEgPtgSkBLQETA9AAN1+IAWcBOIEmAQAAPgHlgiWCPQInAjwCAAG3n4gCbgFZgUQAUAIOAiYBQoCyAUoCEgIAADffiAFuAVmBZIEEAJACGgHXgBID2gISAhIBuJ+AAAgCbgFZAUAAOAPvAK0ArQKtAr8DwAA434wBawE4gSYAgAIrAScA4wAvACaCSoHAADlfjAF6ASmAqACCAhEBeQGagLCBVoMQAQAAOd+IAC4BeYEsAIAAPgHBASgBP4FYASsBQAA6X4wBZwE8gKYCgAI3AVcBF4DXABcBNwJEADqfgAAmAT2ApICAAJUANQHfgVUBVwF1AcSAO1+IAW4BOYEkAIAALQIFAUeA9QBFAVwBRAI7n4AALAF7ASiBDgAoAe0AqwCrgs0CNQHNADzfgAAsAVsBSIFAAD8A7QC9Ae0CrQK/AsAAPR+sATsBKICmAIgAPwPqgSoBPoHqASoBAAA9X4gAJgF1gSxAgAAvgeqAOsPqgCqBL4DAAD4fgAAsAXsBKICAAj8BwQA1Af0AgQJ/AcAAPx+AAAgBbgFZgUABRgAiAKqCKwPqACoAoAE/X4AADAF6AUkBQABKAyoAygE7g8oCSgJAAD/fgAAuAVkBRIFiABABCoCKgnqByoBvgKgBAV/AAC8BeIEmQIIAOIHEgTyB14F8gfyBwAABn8AANgCTgJ5AQAE7wQ/AqABKAMmBOwFBAQTfyAFvATjBJgCwAxUAvIJ1gbRBt0FVQgACBR/EAWsBWIFGAUAALQHnADWD5wAlAS0AwAAFX8AADgF5ASyBAgCoAiqC5gG3gSYB5oEqAgWfwAAuALkApIAAAb8AZQH1gPUB1QB3AcAABh/IAS8BWMFGQAABWwFawWqCqoHvgEgBiAEGX+QBNwCowKYAgIA6g9iBX4FfgViBeoPIAAafyAFsARuBSAFAAB4AXgFfAF4CfwP+AEAAR1/AADcBbMEiAAiCOAHBAivCuoLrgqiCgAIIH8AADgF5AUSAQAM/AN0CK4K/g+sCvwKAAgpfyABuATmAgACjADkDxQA1gd0BVQF1AcAADR/EAS8BOMCGAC+DOsD6gm+BzQMywN4DAAANn8AAFAASA9HBEQE/AdEBEQERARED0AAAAA4fwAAqAcmBPwDJAKkBwAABAT8BwQEBAQAADp/AACoByYE/AckBAQHwADIDv4ByAL4BMAIUH8QAAgH/gckBwQBNA/+DxQP5A8+DzQPBABRfwAA/A8EACQD5AAEBCQGxAE0CwQI/AcAAFV/AAAEAVQBVAFUAcQPTAFMAVQBVAEEAQAAV38AAB4JkghSCH4FUgZSAl4CUgHSAB4AAABafwAAngCyCLIPHgQSBBIA3gMSCBII3g8AAGJ/AABcCVQNVAtcCdQJVAlcCVQFVAVcCQAAaX8AABwC1APUA9wD9Af0A/wD9AP0AzwCAAJqfwACvAq0CrQG7AEUABQA7A+0ArQCvAIAAm5/IADcBzQENAT8B/QH9Af8B/QH9Ac8BAAEcH8gAP4H+gX6Bf4F+gcKAO4BCggKCO4PAAByfyABrgC6ALoHfgV6BXoFfgV6BfoHPgAgAHV/AAgOBPoA+gH+B/oA+gL+APoC+gSeAwAAd38AAFwI9Af0AfwKlAd0BrwKtAq0CrwKAACFfwAAbg3aAUoNDgVKAPoPrgqqCuoPrgqgCop/AAFIAUoBTAFIAfgPSAFMAUoBSAEAAQAAjn9ACFgJWglcBVgD+AFYA1wFWgVYCUAJAACefyABuAS4BHwEeAX4B3gFeAV8BfgHKAQAAKF/UARcApwCHgCcBVwEXANeAl4E3AVQBAAApH8AAagB+g+uBKoEvgcIAUoB+A9IAUsBAACofyAJLAyuAi4ILAn8BKwErAOuBKwIpAsACKl/QAPEC9QL1g/UA/wLVAlWB9YFVAtACQAEr38AACgBKg34Ay4BAAG+A2oEagVqCX4IwAe9fxQCJAEkCYQI/AcAABQCZAEECYQI/AcAAMF/SATEBFICWgrYDxAAWATaAlIKRArIDwgAxX8oCOgEPwPoBAAIkgqCCv4LCAhCDP4PAAjMf0QILAkkCQQNPAmACSwJLA1UCUQJfAkAANJ/QAAoAKQP5ArECvwKgAqsCqQKhA98AAAA1H8oCSoH+AGrAAECMAkCCP4HEAGCCP4HAADgfwACKgKuAq4C6gImD7ADZAKqAqoCLgIAAul/AAj8D+wH6g/qB/gOsgH+B5gB/g8AAAAA8H/8AqwCrg+sAvwCAAJYCvQPQgAUCvgHEAD5fwAJqAfsAQ4HbAkECZAL/AkACFQK/AkABPt/QADUD7IFvge6BZMHAAGSCP4HuAH+DwAA/H8AAAIL7gfuB+ID7gPgA+oD6gfiBw4LAAAAgAAE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tAK0Av4PtAK0CvQHEAC4hJIEkgZaADsBCg1qARoFOwlqAKIEEgkAALyEBAAkDOQD1g/wC+gL8AvUC/YL5A8kACAAxISQAJQAtAfWB9QH1Af0B/QH1gfUBtQAkADJhAAANAIUAVYPlAlUCVQJVAmWCVQPVAMAAcuEBABECNQO1grUDvQK0A7UCtYK1AxECUQA3YQEAAQIZA8OCWQPBAk8Dx4J1AmUDwQIAADmhEABRAX8BP4G/Ab8BvwG/gv8CvwGRAAAAOyEFAhUBMQHDgjkC9QLtAu0C7YLtAs0CkQA7oQACLQE8gMDBPoJWAtaC/4LXwtaC/oLAAIRhQQAdAzUA9YB9ArUCNQJ9gbUBtQI9AiABBOFAAjEC3wLfgv8D3wHfAf+B3wLfAvECQAIGoUED/QAVAzWAdQP8AEEBKQBJgj0DyQAAAAhhSQJpAiUBd4BtAmUCYQP9gHUBbQMFAkAACOFBAl0B0QB7g8EAFQFkAV0CVYJNA8UAQABLIUEBJQH9AeWBAQAVA90AFYPVgB0B3QIhAQ1hcQPNAD0D3YFdAd0BdQNfgSUB/QINAgABjqFBADEBxQAxgPUA9QD1APWB1QGFAT0AwAAPYUUANQPxAfuD8QD1A+ECO4EJAPkBSQIAABDhUACSgJKD+sLSgt4D0oLRgvnC1YPQgEAAkmFJAgkBvQAdgF0DXAB9AF0DXYBdAEUDQAAaYVECFQMBAKOAIQF9AXwA/QF9gP0CYQHBABthQAAJAh0B3YHcA/wB3QCdg90B3QHJA8EAHKFBADkAfQB5gf8AewBBAz+A0wAzA9EAAAAdIVCCmIJ0gpHBSINAgj6D6sPqg+qCfoPAgh+hQAAZAAsD+4LLAt4DywL7AuuCywPZAAAAISFJARMB0QAFgH0AfQD9AH+BfQH9AH0AQABh4UAATQBhA8GALQOsAC0DoQA3ggsB+QFIAibhQAA9A9UBVYFdAcEAJQC3gKUD9QClAKAAKaFBA70AbQItgP0C7QDtAv0A7YHtAv0BwQAqYUAAPoPOgDDDeoDKAiqCq4Kvw+qCqoKIAiqhQQEVAFcCd4HdAEEDPQDXgBUANQPVABAAKyFhACUCEQFBgX0A7QPtAH0AwYFRAWUCJQAr4UAAnQD1APWD/QP1A/QD/QP1g9UD3QBAACwhQIIig3+BdsB3gX+Ad4F/gXfAf4FigUAAMmFtAS0AvQPtgGUAgQA1A/+CtwK9ArUDwAAzYUAAPQE9Af2BfQH8AUEB1wFXgVUB1QEAADPhQAJdAdEAfQP9gO0BvQGHg/8BBQH1AgQBN2FBANcB1wH/gv8C5gLQAc2BxQHdAqEAkQA5IUEDPQDVAn2DwQBdAX0AH4PZAL0BWQJAADlhQAItAXkBQYF9AGwD7QB1AN+A2wFBAUAAOmFIgRqAwIBNwCyD/IKsgqzD6oK6g+iAAAA+4UCACoMSgMLBeIDvgN2D5cPdgO+BeIFAgUHhiQM5AF8Df4BdA3kBAACVAH2D0wBTAYEAAuGRABkC0QI7gVkAnAI9Av2CvQC9Ab0BwAILYYAAAAA/g//B/4C4AfAAv4D/wU+AP4HAABOhgAAAAzwAxAIUAd+AdQBtAeUCLQIsAQQAE+GAAAADPgDCAgoCT4HXAFcBUwJXA1YAwgAUIYAAMAPOACID6gKvgrcCtwKzArcCkgIKABRhgAAAA/wABAGUAB+BtQItAq0CJQCsAYAAFSGAAz4AwgIKAkoCz4NbAVsC0wLXAlYCQgAVYYADPgDCAuoBqgGPglcCNwL3AjcC1gKCABahgAAAA/wABAKUAh+DrQItA6UCLQKkAhQAFuGAACAD3AAEAtQCn4PVAi0DpQKtAowCAAAXoYAAAAM/AMECJQLfwe2A7YDtgfmBywKAABfhiAA7gSqBKoDJgbwARgMOANfAFoHSgQYAmeGAAz4AxgB3g+8D4wLGAjyAJIIkgiSBwAAa4YAAAAE+ASIBIgE/geIBIgEiAb4BAAIAAB5hgAA+ASIBP4D+AIABAQEBAT8BwQEBAQABH2GAAAACNwLVAlUCfQHVAVUBVQF3AUACAAIgIYgABQIyg8IBBgC8AiICIgE/geIBIgF+AeBhgAI+AmIBP4H+A4ACHgEggUMA+AEHAgACIqGAAD4Cf4Hjgf4BgAIGAjqDAoHiAN4BAgIjIYAAPgEiAT+B/gGAAQoASgB/g8kASQBAAGVhogASgjqCVoJTgnqB0oFSgVaB+oHSgxICMeGAAD4BP4HiATwBggA6AcKCYwIiAhYCAAGy4YAABIEygVKBVIF3gdWBVYFVgfWBRIIAADZhgAA+Az+B/4H+AYACCQJJAm/DyQJJAkgCNuGAAj4Bf4HiAT4BgAAXgZIAf4PSAFIAgAE7oYABBQE1AVEBVwFxgdEBVwFRAXUBRQIAAAAh0AAXAD0BXQFfAX0B3QFfAX0DTQI/AcAAAKHAAj4Cf4Hjgf4ClAASAVuBdQPbAVEBUAEHIcAABQEpAekBrQGtge0BqwGjAaUBxQIAAAhhwAA+ARIAv4DeAMABtQHXgVUBV4F1AcQAEeHAAD4CfgEjgf4BgAI/AO0AvQHtAr8DQAEZocACPgE/geIBHAC/g+SAg4IYAliB94IAAh0h/gJiAT+B4gEeACAB38CgA/+AxII/gcAAHaHAAj4Bf4H+AYAAHwNSAP8D2gDfAVICQAAgocACPgF/geIBnAE/AdWBTwC+A8EAPwDAACNhwQA/A/sBOwCfAmAB3gAiAj+B4gE+AYACJ6HAAD4BM4D/gNIAjABfgaqAv4BqgmCBwAAoocAAGIE6AfuBuQG4AfyBugG7gboB3QIAAi6hwAA+AmOB/4HiATwBR4J6g1+DyoBvgsACtGHAAj4Bf4H+AYACPQDdAN0A3YP9AMQAgAA8ocAAKALrAqsB6wHPgisA6wKvAesBqAHAAj5h4QEfAQ3Bb4FtgV4B8oHtgWyBboHNggAAPuHAAT8Av8DRAJ+ATsL2g9+A+oHKwdqCwAJDYgACPgF/gfwBnwPPAO8B+ADMAf+AAgDOAQfiAAA+An+B4gEcAImD3gLdAD6D1AEfgMADCGIAADUBdwFvge/BbcJPwCXBa0HrAWkBQAAIogAAKoFngX+B/4F/gn/AP4F/geeBaoHIAg7iCwAFwTeBUAFdgX/B34FcAVkBb8HNAgSAECIAAT4BwgECAT8BwoECAT4BwgECAT4BwAERogACCAJvAQkBLwApg98ASQCJAW8BCAIAABMiIgASADkDxIAAAAkACQAJAgkCOQPJAAgAE2IiABEAPMPCAAiDCIChAEgCCII4g8iAAAAU4hAAEQA8w8JAMgB/wcIAMMFEATyBxIAAABUiAAAzADyDxgAhgj1B5QEAAAkCOQPJAAAAFeIQABEAPIPGQJQAt4DVAJUBgAE8gcSAAAAWYgAAMgA5A8CAFQPfAV0B2QAJAAkCOQHIABbiAQAQgD5DwgA+gPfAtoH/gICAPIHEgAAAF2IAAAkAPIPCAB6CVoJ/gf6BQkEIADkDyAAYYgAAEQA8g8ICfgFrgP8A6wN+AEACOQPIABiiAAAjADgDxwAvAecB5gHvAe8BAAA5A8gAGOIgACIAEgIyA8oCBoEPATIAIgDSAQoCAAIZYgAAAgBigDqD5gASAEAAP4PIABAAMAAgABoiCABNAm0BLQHdAQ+BPQENAG0ArQEIAgAAGuICAGIAO4PnABIAQAIiARIBEQCMgIQAQAAbIgIAYgA7g+cAEgBAADQABAJEAj+BxAAAABwiBQBFAV8BVwH3AReBNwEXAFcA3wFFAUQBHeIAAAEAnQCVA5UCfYIVAlUAlQGdAkECQAAgYgAAhAC9AK0DrQJvgS0AbQCtAZ0BRAJAAiLiJACiAK8CoIOiAnICI4JmAKqBsoKygqoCI2IAAGMAOwPWAEAAPAHLAkoCegLCAr4CQAElogIAYgA6g/YAAAA+A+IBIgE/weIBIgE+A+ciAABigDqD9gAAARIAkgB/g9IAUgCSAQAAKuICAGIAMoPuAEADPgDyAhICX4GSAbICRgIrYiEAqQCpAqUDowJpgi8CdYC1gbUBcQFtAixiAABiADqD/AAIAD8DwIAEAf+AJADFgwAALSICAGIAOwPmAAAAKgAuAOsAqgKmAqoBqAAwYgAAVQL1AdeBFQBVAMQDP4CEAPSBBQIAAbCiNYC1gLeCq4OngnGBIABngLABsAF/gkACMWIoAKsApAKvA6ACagEqAG8AqgGqASoCAAAz4gABEQFfA18D3wJ/gl8A3wFfAV8C0QLAAjUiBQA1A90APQHbAVkBWYFzAbUAKQPJAAAANWICAGIAO4PWACIAAABxA+yCIgIsgjED4gB2IiABKwCrAqsDoQJ3gSEAaYCrgasBKQIAADZiAABiADrD9gAgAIqAeoHvgSqBKoEvgcIANyICAEIAc4PuAAAAOgPqAKoAv4PqAKqCuoH3YiQAr4CmAqYDr4JgASoBKgBvgKoBqgEiAjhiAgBiADsD9gAAAB8CVQJVAn8D1QJfAkAAOSIAAGKAOoP2AAADPwDRAC2ApQPlAKUAgAA84gAApwEhQK2DrQJ9gS0AbQCtgaFBJwIAAD4iAgBigDqD9AAgAT8BNQC1A/8D9QB/AKABPmIgAJEAnwBfAf8BP4EfAF8AnwCfAXEBAAA/YgIAr4CnAq+BpwF/ASAAZwCwAbABb4JAAQHiYAASADuB3gAAAU+Bf4FvAK8ArwFvAQEBBCJCAGJAMoPuAAAAb4HqgSqBaoGqgi+BwAAMokAAZQA1AewAAAE+APoA+wD+AfoA+gD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/AP0A/QFHAQAALiMAAAICOQL6gblBuQC5gLsBvYG9gcECAAIu4wACFQI3Av8B94H3APcA94H3Af8CxwIAAi8jAAI/A1UAVQB/AUAAIAPgAT/BJgEmA8YAL+MAAQQBPwF9APsA/AB9AHsA+QD1AUMBAAAwIwAABQIzAvmCvQK7ALgAv4K8gryCx4IAAjDjBAACADcA8QL4AvqA+oD/gvqC+kDKgAAAMSMAAj8DVQFVAH8BUAA+A+sAqgCqAroBwAAx4wQCBII9Av0BuQG9AL2AuwG9Ab0CxQIAADKjAAI/A1UAVQF/AFIAOgJSAR+AogFbAgIBtOMIAAsCOwH/AbsAv4C7AL8AvwG/AcMCAAI24wAABwIzAXuBewF7AHgAfwF7gX8BRwIIADcjAAI/A1UAVQF/AUAAb4C6gmqBKoDvgiAB96MAAAcCMYP9g30DfYF9AX0DfYNxQ8cCAAA4IwACPwFVAVUAfwFIAC0B6QEpgSkBLQHJADijAAIPgj6B/4H+gf6A+AD4gfaB5oHJgggAOOMAAQ6CO4H7gf+B+8D7gP+B+4H7gc+CAIA5IwACPwFVAVUAfwDqAjsBBgH2ga8CbgJEATmjAAI/A1UAfwFAAjUDxQI0AeQBP4DEAwUBuqMIAAcCMwL7Ab6BvgC7gLqBuoG2gsKCAgA7YwABPwHVAFUA/wFAAGkB/4FpAW8BaYHIAD0jAAEeAJYAfwPWAE4AMAL7ArkAvQG7AcACPqMAAD8DVQB/AIICGwF+A9oAfgPbgPoBUAI/IwACPwNVAFUA/wGwA/sAv4C7Av+CuwHIAL9jAAArAh8BPwH/AP+A/wD/AP8B7QEpAQAAAiNAAj8BVQB/AUAAPwP5wrkCvwK5ArnD3wACo0AACgI/g9eDVwFXAV8BV4FXgXsDxwICAgPjQAMggO2CjoHugm7A7oFOgC6B7oPCgQAAB2NAAAACPwJBAQEBAQC9AEEBAQE/AkACAAAHo0ACAAI8AsQCBAEHgLUARQEFAT0BQQIAAAfjSAIEAj4CRQIFgQUAtQBHAQQBPAJAAgAACGNAAAUCNQLVAhUBlwBVARUBFQI1AsUCAAAIo0ACP4JAgT6AwIA/g4AAAgDiAhoCP8HCAAjjRAAFAjcC1wIXARcA14AXARcBNwFFAgAACSNAAAeCMAFQAReAkABZgRaBFoI1gsSACAAJY0ACP4IAgb6Af4MAABwCI4EiAN4BAgIAAAmjQAEfwf5AAEC/wIACP8HIAToACYDIQQAACeNAAAICMQLXghBBkQBTwRUBFQI0gsKCAAAKI0AAPAHDADsCSwELAK8ASoEKgTqBQgIAAApjQAAfA/0AAQC/AAADvwBNAzUAhQD8gQECCqNCAAICNQLVAhSBFoDUgB0BFQE1AUECAgAK40IACgI7AtqCFoESANoAGoEXATEBQgICAAsjQAI/g3yAwIC/gAADCQCIgYqCeIIIQgACC2NAAj8DeQDBAD8DhAAzAEKAcgJCAj4BwAALo0AAPwJBAT0AwQA/A4QAAgEDgQIBAgEOAQvjQAACAj8C2oIagZ+AWoEagRqCP4LCAgAADGNAAj8CAQG9AH8AgAIUAT+BFAHVAlQCQAENI0ACPwN9AMEAPwGAACAD/4EiASIBIgPAAA1jQAAIAj8C3QIdAR0A34AdAR0BPwFIAgAADeNEAAICNwLQghIBEgDTgBYBGoI4gsUAAAAOI0AAAAI3AtSCFsEQANSAE4EYgTiBR4IAAA5jQAIQAjeC3YIXwRWA1YAXwRWBNYFFggAADqNAAAUCNQLTghkBlwBQARcBFQI1AscAAAAPI0ABPwC9AEEBPwAAAboAQgIfgSIB+oICAY+jQIIOgjqBWoEfgRqA2oAfgJqBOoFOggCAD+NAAD8DfQDBAD8BcAA+A+uAqgCqAroDwgAQY0IAAQI3wVABGoDagBqAn4CagTpBSoIAABEjRAIEgjUBUAEaAJmA1YATAJUBNQFDAgAAEuNAAD8DeQD/AAACNQPFAjUBxAA/gMQDBYGTI0AAPwP9AEEBPwFgADUD34FVAVYBdQPEABPjQAAHAiGC7QItAS2ArQAtAS2BIUFHAgAAFCNAAj8CQQE9AMEAPwOAAC+AOoLqgaqCb4HVI0ACPwH5AEEBPwFAACoD6QEpgS0BKQHIABWjQAI9ASUAv4PlAH0CgAI+AfWAxwI9AsACFqNAAj8DeQD/AAACFoF/A9YAfgPXgX4CUAAW40AAKwIvAj8BbwEvgK8ALwE/AW0BCQJAABejSAALgicC04IfARAA24AXAROBJwFLAgoAGCNAAB+BAID+gACAn4AmAd/BXwFfwX8BwAAYo0ADOIDvgr+B94MPwP+DN4HPgH+DwYEAABkjSACpAGkCCQG5AE+CCQI5A8kAKQAIAMAAmaNgAkkBOQDPgjkByQAgAk0BMoCiAN4BAgIa42ACSQE5AM+COQHpACAB+QBPgjkByQAgANwjSAIKASoAygEKAT8DygJKAkoCSgJIAgAAHSNEAbUARQC/gNUBFQEUAQABP4FCAQQBCAEdY0QBtQBFAH+A1QEVAQABcwEMARMBIIFAAR2jSAMpAMkBP4HpAikCAAIJAj8CyQIJAgAAHeNEAjUBxQC/geUCJQIAAjkCSQKJAo8CoAJgY0QBtQBFAH+A1QEUAQEBVIFIgWkBIgECASFjQAI2AcYBPwHmAgQCNQLTApkCmQK3AsACIqNIAyoA/wHqAgACPgJiAgICn4JyAoqCgAIi40gBqgBKAL+A4gEIAQYBVYFVAVcBfQFAASVjSAGqAEoAvwDqAUABVwE3ATcBdwE3AQABJmNIAyoAygC/AeoCAAI9AswCLwIkAr0CQAIn40ACKQHJAL/B6QIBAj0C5AIXgmQCPYLAAijjRQAFASeA/QDEAT+BKoE/gUABOQFHAUABKiNEAzUAxQC/geUCKQI7wteCUoJbgjeCwAAs40AAAAIPASkAyQEJAjkDyQJJAk8CQAIAAC0jQAI3gcSBPIHngAADvwBAAAEAPwAAAcACMONAAjeB/IHkgSeBAAAJAwiA/4AIgMiBCAIzI0ABN4HEgTyA14CAAhOBEgD/gBIA0gESAjRjQAE3gcSBPIHngQAAPoHtAj0CgQK/AkABN2NAATcBxQE9AOcAgAA/A8UBRQFFAX0BQAE340ACN4HEgTyB54AAAj8D1QI1AFUBnwFAAnhjQAEngfyB5IEDgLgDPgDDgj4BwgA6AEAAOiNAASeB/IH8geOBCAAuAOoCqwKuAqoBqgA6o0AAB4H8geSBD4M+AcWANQHVAhcCtAJEATvjQAI3gcSBPIHngSQAIgP1gikCLwIxA+AAPONAAjeB/IHngQAAAgN/gMAAP4HQAiYCAQF9Y0ABN4H8geSBB4CgAhIBP8ESAMqBaoJgAQKjgAAAAQeD/IHngQAAOQPpAL0D6wC5A8AAA+OAADeDxIE8geeBAAAuA+ACv4KkAqsDyQAEI4ABN4H8geSBB4IQAnoBS8HGAWpC00LJAkijgAE3gfyB5IEngKAAL4C6gmqBqoBvg8AACmOAACeD/IHngQABJQApA6EAdQPggK6BIIIKo4ABN4HEgT+B4AA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7AXsBfwLQAm5jwAIIgTsAwgEAAgIC8gIPggICggK+AkABLqPQghGBMgHAAQECMQLPAgECgQKBAr8CQAIu49ICFIE1gMEBBAIEAgQCP8LEAgQCBAIAAi8j0IIQgTMBwAIAAqCCWIIPgjACAAJAAoAAL2PAAgkBOgDAAQECAQKBAr0CxQIDAgECAAAvo8gCCIE7AMABAgICAvICD4ISAiICAgLAAjBjyAIJgToAwAEJAgkCCQI/AsiCCIIIggABMSPIAgkBOgDAAQwBAgJrApoCigKKAoICQAAxY8kCCQE6AcABCQIJAj0CyQIBAj8CQAKgAnHjyAIIgTsAwAECAgoCMgICAoICv4JCAgICMiPJAgkBOgHAAgEC8QIPAgUCBQKFAr0CQQEzo8ACEYMyAMABPwJBAkACPwLBAgECfwIAADQjyAIJAToBwAIEArUCTQJFAlUCZQJFAoACNGPQghCBMQHAAgAC/4IEggSCPILEggSCAAA1I8ACEIEzAcACAAL/ggyCtIKEgnSCjIKAgrYjwAIIgTsAwgEgAhECCQI/AsECCQIxAiACNmPAAgkBOgHAAgoCigJyghMCLgICAkICgAA248gCCIE7AMABEgISAv+CEgISAj+C0gISAjcjyAIJAToBwAIEAoUCfQIFAj0CxQKkAkAAN2PAAQiBOwDAARUBFQEVAT+BVQEVATEBQAA3o8ACCIE7AcABBQJLAkmCfQLJAkkCQQJAADfjyAIJAToAwAEAAn8CCQIZAjkCCQJPAoACOaPAAhOBMAHBAX8BAYI/AsACPwLBAr8CwAI6o8ACCQE6AcACPgLSApICv4LSApICvgLAADrj0QIRATIBwAEAAj4C0gKTgpICkgK+AsACPCPQghCBMwHAASICWgICAj+CwgIagiKCQAI9I+QCNQEtAMABPwJBAr0CpQK9AoECvwLAAD3j0IIRgTIBwAIJAuoCGAI/gtgCKgIJAsACvmPAAgkBOgDCARgCAgL+ggMCvgLCAjoCAAA/Y9CCEIExAMABPwJVApWClUKVApcCsALAAgAkEAIQgTMBwQIAAr+CyoKagiqCV4KQAoAAAGQQghCBMwHAARICE4KSAn4CEoJSgpICgAIApAgCCYE6AcABBQI1AtUCnwKUgpSCtILEAgDkAAIRAjIBwAEnAhACv4JAAj+CUAKnAqACgaQAAhODMADCATqCI4KiAr4CYgIjgjqCAgICZAACCQI6AcACCAKrAloCD4I6AsoCigKIAkKkAAIIgTsBwAEIgj6C0YIMAr+CwAIOAjAAA2QAACSCPQGlAUACPYLEAheCRAJlAryCwAID5AACCQI6AcABCwILAvcCFwInAqqCqoJIAgQkAAIIgTsAwAEEgWqCK4KUgriCVIIiggABBKQIAQiBOwDAAR0BVcF1AT8BVYEVQXcBAAEFJAACE4EwAcQBEgJVAhUCvIJVAhICVAJEAgXkAAIJAzIAxAEBAh0CtQKVArUC/QKBAoACBmQAABUBHwC2AMABPgFeAV8BXgF+AUIBAAEGpAgCCIE5AMABPoJrgiuCPoLrgiuCvoJAAAbkAAIJAToB0AILgv0CAAKJAr8CyQKJAoAAB2QAAgmCOgHAAhICv4JCAj8CxII8gsSCAAAHpAAANIIvAaYBQAIvAq0CvQLtAq8CgAKAAAfkEIIQgTMBwAIdApUCdQI/gvUCFQJdAoECiCQAAgkCOgHAAQgCKwLqAq8CqgKqAsgCAAAIpAACCYE4AcECJQKkgqvCuoLrgqqCggKEAgjkAIIJgTkAwAEfAlcCVwJ/gtcCVwJfAkECS6QAAhOCMAHEAiUClQKVAj+C1QJfAoQCgAIMZAACEIMzAMABP4JAgjqCXoJ6gkCCv4JAAgykAAIRgjIBwAEEAj+C6gK/AuqCqgKCAoACDiQQghEBMQHEAh4ClYJ1gh0CNwLUApwCgABO5AgCCQE6AMABJwIVAp8ClQJXAnUCBwIAAA8kCQIKAToB4ALfAVsDewPbA1sDfwPAAgAAD6QAAgiDOIDCAToBfwI/AsLCOoIBAzoDwgAQpAACEYEyAMABCgJbgnYCKgKyAmuCKgICAlFkEAIRATYAwAF/AgUCNQJ1AnUC/QJ3AkACEeQAAgkBOwHAAj+C2oI/gl+CWoLfgzADwAASpAACEYMwAMEBfwIFwrkCQwIRgr0C1QIRAhLkAAIIgzkAwAEegl6CXoJ+gt6CXoJegkAAU2QAAgiBOwDAAX8CNQLtAj2C7QI9Au8COALTpAACEIIzAcACOALPgjiCXoJ6gk+COALAABPkAAEIgLsA4AC3AU8BbwFvAU8BTwH/AcAAlOQIAgkBOgHAAQICPoLvgq4Cr4K+gsICAAAVJAACEYEyAMABNQJ9AnUCd4L1An0CdQJEAhVkAAIRAjIBwAI/ArcC9wK3grcC/wKiAoACFeQAAgiBOwDAATuCGoKagl/CGoK6gouCCAEWZCQCPYGkAUACLgOpA68DvYPrA6sDqQOgAhckAAA0Qy2AhAFQgT6CQYKXAj2C0IIwQoAAF6QkAjzBBQDgAR+CAIL8gg+Cn4IdQl1CjABYJACCEIIwgcIBHwJXAncCN4LXAn8CYgKAAhjkAIIQgzEAxAE/An8CvwK/gr8CvwKkAsACGWQAAgkDOgDAARMCXwKZArsC2QKYgpqC0AAaJCACNYIMAcEBvQJfg1UDUQLEAiOC3gKCAppkAAIRgzIAwAE9Ak0CPwJdgn8CTQK9AkACG2QAAgRBPYDAAT+Cb4Kvwq+Cr8K/gseCAAEbpAABCYC6AOAAnwEFAV0BFYGVAV0BBQFAABykJAI1AS0BwAG/AkMCLQKjArcC4wKvAoACnWQAAgmCOgHAAR8CW4LbAlsCXwN/g98CQQBd5CACNQEtAMABfwI7Av8DOwO/A/sDHwJAAl4kAEIJgTkA4AErgruCq4IoAjuCq4KrgoICHqQBAhEBMQDEAT8DfwL/An+CfwL/AsQCAAIf5AAAEQMyAMABfwLVArcCwgIuAjsC7QIqAiAkAIILAzgB0wG/Al+CVwLEAgOC+gIGAsACIGQkAjWBLAHAAiEC/QJ/gn0CfQJ/gj0CwAIhJACCEQIxAcQBH4Jegn+CPoLfgn6CZ4KEAiKkJAI1gSwB8AI/A38C34LfA/8D/wLwAgACI+QAACkDOgDAAT8D1QLnAvUC9wL1AvcCwAKkZAAAAAA3AdUCVQJ1AlUCVQJVAncCQAEAACTkAAAFAQkAsQBNAEMAgAA/A8EAHQCjAEAAJWQAAAEAPoH0ArUCtoL0ArUCtoK+gsACAAAl5BAAEQARAD8D0QARAAAAPwPBAB0AowBAAChkAgICAf4AC4IKAjoBwAA/A8EAHQCjAEAAKKQAAhEDvwBRABEAPwHRAAAAPwPBAB0AowBo5AkACQN/AMkCSQJ/AcAAPwPBAD0AgwBAACmkIAApAykA/8ApACkAAAA/g8CAHoChgEAAKqQAAAEBjQBpAj8DyQAAAD8DwQAdAKMAQAArpAAAPgHSAL+A0gC+AcAAPwPBAB0AowBAACvkAgA/g9IBEgESAT+DwAA/A8EAHwChAEAALGQAAT8ByQEJALkAyQC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rgWiBUAE6pJQC1gE9gdIBFgFCADoD6gC/g+oAuoPAADtklAJWAVUBPIHVAQAAXoMzANIAMwPeggABvySAABQC1wI8gdUB/wLDASkA+QDDAv8BwAABJNQCFgJ9gdUBEQFAATYAlYI1A90AEwFQAUik1AIWAX2B1QEVAEACCgJngUYB1oHKguoCCaTKAQuBfkDKgYqB4AHvgDrD6oAqgS+AwAAK5NQCFgJVATyB0QHAAS+BOoDqgaqCb4HAAAvk1gIVAnyB1QEBAUkAP4HZAVkBX4F5AcAADKTUAhYCfYHVAQABaIEKgDqD6oBKgK+AqAENpNIC1wI8gdUBEQBFABUD9QIfgjUA1QFQAlKk1gIVAnyB1QEBAX0BLQClAH+D7QB9AIEBEuTUAlYCPYHVAUEAOAPPgCyA6oCPgngBwAAdZNICFwJ8gfEBzAMLgPgBKoG/wuqCr4KCAh+k2gIbAlqBPkHagcCDP4Irgr+D64K/QoACIyTSATOBPkHSgXsBa0C/g+sAPwPrwL8BAAAlpNQCFgIVAnyB1QEAAn0C7AKvgKwAvYLAAiuk0AIUAtcCPIH1AUAAPwL7AruAuwK/AsACuGTUAhYCFYJ8QdSBAoN6ghuB2sBbg/qCQgEGJRQCFwF8gdUBQAA8gt6C3ML8w9yC34L8gs1lDAIWgr8BxwHdAC0B74HVAz+BRAH1ggABlGUUAhcCfIHBAd+AKoP7gm6DwAJTg9ICUgPcJQICFwJ8gdEBQgA6A/EB5IC9A+EAmgPAAB9lFAIXAXyB1QNAAgYCN4F3APcC94LrAsoAIiUmACGCPUPlASEBCAAIAAgAP4PIAAgACAAiZQAAJgAhgj1D5QElAQAAAQIBAj8BwQABACTlAAAmACGCPQPlASgAhwASgCICQgI+AcAAJ6UmACGCPUPlASEDIAIOAgABP4DgAEIADAAn5SYAIYI9Q+UBAQE8AGQAJAA/g+QAJAA8AGilJgAhgD1D5QEAAD+DwICMgH6AQII/gcAAKWUuACGCOUPpASkAAAM/AMkASQJJAn8DwAAppQAAJgAhgj0D5QEhAwwCA4G6AEIAzgECAinlJgAhAj2B5QEhAIQAE4CSAlICQgM+AMAAKmUmACGAPUPlAQEBBAB7gEICcgLCAj4BwAArpSYAIYI9A+UBIQMAAhCDv4JQghCDv4JAAixlJgAhgj1B5QE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OgDGAAAI6AquCpQPrAqkCqAIAACKlgAA/g8yAM4EgASqAnwKSAm4B08AqQMoAouWAAD+D3IAjgEgAJQP3APWA/QD1AvUB0AAjpYAAP4PAgD+AQAA3gdUBUAFXgVkBeQHEACPlgAA/g8KAPYLAAjoBwAI/AtWCVQJ9AsACJCWAAD+DwoA9gAABqwAqwWqCa4KqgD4DgAIlJYAAP4PCgH0AAAAvA+sAKwCrA6sArwIhAeZlgAA/g8CADoBxgQABP4C0AjeB9AA9gIABJuWAAD/DxkA7wBsBrcArgSgB6cAuAKuAiIAnJYAAP4PAgA6AcYAEAL0AvwC9g/8AvQCEAKglgAA/g8yAM4JBARsAWQNbAlkC3IJ6gEADKOWAAD+DzIAzgAACe4FmAO/AJgD6g+oAgAAp5YAAP4PMgDMCEAEtgeABKoJ+AzIC84IKAmolgAA/g8yAMwI4gcUBNQL7AjuCXwN7A8ECKqWAAD+DzoBxghQBLgC9AATCPQGuAToDAgAsZYAAP4PAgH+AMAN9gHyB/oL8g35AfUNoAi2lhAEVAVUBVQCVAr+B1QBVAJUA7wEkAQAALuWEAgQCXgJfAl4B3gFfAV4BXgHeAlICAAIvpYAABQGpAHkABwDIAD+D6gE+geoBKgEAADAlgAAUABYAMQP4AreCvAK8A/ECsQK2AoQAMGWAAb+AUIA+gcCACIA+gdSBfoHUgVSBQAAxJYIDOgDHgjIBwgEIAP8B6oEqAT8B6oEqATFliQGvAFkCPwHJADwD64EqAT+B6oEqAQAAMaWCAgIBXwFXgNcA9wPfgFdA1wFXAVECQABx5YAAAQO/AGsAOwP7ArsCuwP7ArsCvwKBAjMlgAA8A8ABP4HAAT+BzAC/g+oBPoHqAQIBNGWJAC0BI4ChA+8AkAEMAD+B0gF/AdKBUgF1ZaAD3wANAe0AjQJ/AcwAPwPqgT0B6gECATWlgAA7gSqBPoDrgLgBjAA/g+oBPoHqASoBNmWAAAICL8EvAS+BbwGiAK+ArwFvgW8BCQE3JYgAKQGlADGD7QCAAD+D6gEqgT6B6gEqATelgQIfAl8BaoDUg04AfwPqgSoBP4HqAQIBOKWgA/0ANQD1gLECPQHIAD+DygF/AcqBQAE45YAAPQJ1gX0A9YF9AUgAP4PqAT8B6oEqATolgQA9A8UAFQBFAD8DxQAVAFUChQI9A8EAOqWGADKCsoKygqKCr4KigrKCsoKyg8YAAAA75YACJgIygjqCcoGngTKBIoG2gnKCJgIAAjwlgAKGAmaBboFCgM+ARoJOgmKBxgBAAIAAPKWAAEMBWUFZQdFBV8FRQVlB2UHBQ0cCQAA9paAAJgAmgG6BUoF3gXKBVoNuguKAZgAgAD3lhgAyg/KCsoKigq+D4oKygrKCsoPGAAAAPuWAAAYANoH+gLKAt4H2gr6CsoLGAgABgAA/pYAAVgLXAtcC8wG3ALcAnwLTAtcBwAAAAAAlwAAWABaD3oBSg/eAVoPegFKCVgHQAAAAASXAAAeAA4IrgeGAd4FhgbWAt4KhgceAAAABpcACEwJ5gV2CyYIPg1GDfYPdg1mDQwNAAAHlxgM2gN6CfoHygXeBcoH+gX6BcoHWAsACQmXAAAMAWYF5gbmBsYH3gbGDuYO5gdMBQAACpcACDgJiguqCYoPvgmKD6oPqgkKCzgLAAgNlwABDAGmD7YLhgveD4YLtgumC4wIAAAAAA6XGAJaC0oLagvKD24PSg9aB/oHSgtaCxgIE5cAAA4ADgjWC64KrgYGAq4GvgrmCw4IAAQWlwAAmASKAroPigI+AIoGugG6D4oCmAQABByXAACYBLoCug+6Aj4Avgf6BfoF+gXIBwAAHpcYAMoP+gX6BcoF3gwKCPoL+gXKBdgLAAgnlwAAAAxMA+YP9gFGAx4KxgZ2A+YLTAcAATKXGAjKDXoJeg/KC54Cig56C/oKSg9YAgAAOJcAAEwH5gf2D8YHXgMGDPYD9gLmCswHAAA5lwAG7AF1B20FbQUFBy8C5QKlD60C7QKgAEKXAA7sAWUE/QT9BnUE5wdlBv0G9Qb1BCAASJcACAwJ5gv+C0YJrg+mCeYNTgu2COQIAABSlxAAFAD8D7wCvAK+ArwCvAq8CvwHFAAQAFaXCALoAg4C6AEAAPwPvAK+ArwKvAr8DxQAWZcQANwP3ALeCtwPEABYCVYJ9AdcAfABQABclxAI3AfcAt4K3AcAAIgCpArqB6IC6gOAAF6XAAEoASgBKAH+DwAAAAD+DygBKAEoAQABYJcABAgHfAdeB1wPXABeAFwPXAd8BwgHAARilwAA8g8SBPIHXgVSBfIHEgQSBPIPAgAAAGmXAAAEAuQCvgK0AvQPtAK0Ar4C5AIEAgAAi5cAAOQCrgL8D+4CBAogCCQJvw8kCSQJAACNlwQA7gKsA/4O5AIAAEgJxgl0BkQF6ARACJGXBALuAvwPrgJkCOAHBAiQC34I0AgQCwAAmJcEAP4CtAL0D74CQAj0BxAAXgEQCfQHAACtlwQC7gL8D24A/g98CawH/ASsCPwIBAgAANOX/AKsAq4PrAb8BgAE7AeuBawPrAXsBQgE5pcAAJIAkgCSAJIA/w+SAJIAkgSSBIADAADplwAA9ALUAt4P1AL0AgAAqAD+D6gAqASIA/OXEAAUANQHVAVUBVYFVAVUBVwF1AcUABAA9ZcgAOgHZgV0BeQHIAAQAS4FqAgICPgHAAD2lxAA3AdWBVwF1AcEALAHjgSiBKIEngcAAPuXEADcB1UFWgXUBwQA+A9UA1QDVAP8DwAI/5eUAL4A1QfgB/4H7gfOB8AH3gfGB5oAAAABmAAIBAj8C6wGrAasAqwCrAasBvwLBAgAAAKYBAgECPwPBAAACPwLrAqsAqwGrAb8CwAABZgEAQQB/AEEAQQI/AesBqwCrAasBvwLAAgGmAAI/AcAAPgDAAD+DwAA/AesBqwCrAr8CwiYSAjIBCQEEAMECPwLrAqsAqwCrAr8CwAIEJgkCCQI9A88AOQIAAj8C6wCrAKsCvwLAAARmAAAFAf0ABQC9AMACPwHrAasAqwC/AsACBOY6ACIAPwPiAToAgAI9Ae0BrwCtAr0CwAAF5gADvgBKAy8AqgDWAj8C6wKrAKsBvwHAAgYmAAAWADUB1IAxAkMBPwHrAKsAqwG/A8AAC2YAAB8CEwFTAR8BwAM/AmsCqwCrAb8BwAIO5gQAN4FEAR/AhQBkAD+DVYDVgNWAf4FAAQ8mAAAeAZYAfwPWAE4CvwJrAasAqwG/AcACEaYAAS8BKwC/A+sApwI+AmsCqwCrAb8BwAITJhADFwDXATcB1wJAAz8DVwJXAlcCfwNAAxNmCABrA+0BVYFpAcMAPwHrAasAqwK/AsAAE+YAAzsAzwIrgksBSQC/AusCqwCrAb8BwAIVJgADOQDLAimCiwFJAD8C6wKrAKsCvwLAAhYmAAP/AB8BqwArA/8AQAI/AesBqwC/AsACFuYBAr8C9wK3gL8CwAA/AesBqwCrAb8CwAAXpgAAKwEmALeAZwCiAj8C6wGrAKsAvwHAAhnmAAO+gEqD6oH2geABwII+guuBqoC+gcCDG+YAAH8DdoBGgn6A7wDAAn8B6wGrAL8CwAIdZgAAAQI9AsUCBQEFALcARQEFAj0CwQIAAB2mAAABAgECPwHBAAACPoJCgTuAwoI+gkAAHeYAAAAAPwDEAIQAQAI9AUUBNwDFAT0CQQIeZgEAQQB/AGEAAAI+gUKBAoD7gAKAgoE+gV6mAAM/AMAAPgDAAD+DwAA/AgMBuwBDAL8DHuYAARIBCYCkAECCPoECgLuAQoACgL6BAIIfZgAABIG8gESAPIHAAL6CAoG7gEKAPoOAAB+mPwPAgD6BwoE+gIACPoECgbuAQoA+g4AAH+YAAD0AIQA/w+EBGAC+ggKBu4BCgD6DgAIgZgwDAwC4gkgCO8HEAD6CQoE7gMKCPoJAACCmDAEDAPiAgAC3gcAAPoMCgLuAQoA+g0ABISYIgAqCOoHNgDiAAAI+gQKBu4BCgD6DgAAhpgQAFABTAJqDdAAAAj0BBQG3AEUAPQOAAiHmAAO/AEkDD4D5AYMAPAEFAbcARQA9A4ACIiYAACiCJIIige2BAAM+gkKBO4DCgj6CwAAiphIBFgESAP+AHgDSAjgBBQC3AEUAvQEAACRmCAAuAsgCPwFKAMgCPQJFATcAxQE9AkAAJaYAATPAtQB1A+yAQAK8ggaBtYBEgTyBQAIl5gABPwE1AL8D9QB/ADgCRQE3AMUCPQJAACYmEAMXANcBNwHXAkADPQMFAvcCBQK9AwEDJyYAAjyBxoBswSqAhII+gQKAu4BCgD6DgAAnZisABQGXgV0BZQOHAD0CRQG3AEUAPQNAASgmAQK/AvsCu4C/AsAAPQJFATcAxQI9AsAAKSYAAj8C/wL/gvMCzwD8AgKBO4DCgj6CQAAqJgAAAAO/AEEBOwFLAX8BywFxAz8BwAIAASxmAAO/gFCBPoDQgL+AAAD2ARWCVAJ3A0AAMSYBAD0DfwB/AekD/4HZgT2A/oD+gcECAAExphABsoBagBnBusBYgz/A2EE/QNhB/8BAAbOmAAAAA7+AQIEGgKiAeIAGgcCAP4HAAgABtiYdA3UAfwJ1Af8A9QBJA38AxQG5AH8BwAM25hQCFIG+gFCAEIA+g9CAEIAzgMUBSoJSAXemAAABAAEAAQABAAEAAQA/AAgB1AIiAiIBt+YAAAQABAI+A+0CLIJtAK0BvgJkAgQCAAA75gIBOQH0gTSBPQGAA7+AWIMogUiA+IEAAjymAgE9AeyBLIE9AYgABwMigP4AAgDOAQICPyYEAT8B7IEsgT0BgAA7AMsAewJBAj8BwAA/ZgIAAgE/Ae6BLoC9AYAAPgDlgT0BAQE/AT+mBAE/AeyBLoE8gY0BOgBJgD8DyQA5AMAAAWZBADyD1oJWgXyCQAAigz6A4gA/w+JAAAACpmAAJQAXAj+D9wJ3AncB9wF/g1cCJQIAAAQmRAAkACoCO4P3AuAA7YH1geWBa4IogAAABOZBAjyB3EGdQMhBIkE/wNYAB8C+APbBhAAGJkICOwPWglWBfQNBACUApQI8weUAIQCiAQomRAE+Ae0BLIE7AYcAPQPlAWWBZQF/AcAAFKZAADwD74EsgT0DkAAag16A28BKg/6DSgFZZkwAAwI6g8IBDgAAA78AQQABAD8DwAIAAZtmTAADAjKBxgAAA78ATQM1AIUA/IEEggAAG6ZcAAMCOoPCAQ4AgAIMAQOA+gACAMoBBgIcJkgABQAyg8YAgAA6AMnACQA/A8kACQC5AFxmWAAFADKDxgEQADwBywJKAnoCwgK+AkABHKZMAAMCMoHGAIIAOIDKgEqAeoJAgj+BwAAdpkgABQIygcYAggIoASuA7gApA/UCJQIAAR8mSAAFAjKDwgEuAKBCPoHiACIAPwPiwCAAH+ZIAAQAM4PGASAApQI/A8QBP4CkAVWCAAGgJkgABwAyg8IBBgAkAaYAJQI8g+UAJgCkASGmSAAFATKBxACBAD8B/QHVQVWBWQFDAcAAJaZAAAEAPQPVwVUBVwFVAVUBVcF9A8EAAAAmZmQAFQAVA+0CpQKvAqUCrIK0grSD1AAkAComQAAvAK8Av4O/A/0D/gO9g7yD/4O2AIAAqyZAAgADPwBVAFUBVQB/A1UAVQLVAkABwAAs5kABv4Aqgf+AqoKAAf8BxAI/gkQCPgIAAbBmQAG/gCqAv4JqguqBwAA1gwIAw4F0QQQCMWZAAb+AKoD/guqDoAN/gMiAOIAIgM+DAAAxpkABv4Aqgb+AqoLAAf+DwIEogVyBIoFAAXQmQAO/gCqBv4OqgmqBwAAigj6D4wIiAgACNKZAAb+AKoH/gKCChAHzAEqAegJCAj4BwAA1ZkAABQIzAXmAeQF7AHgA/4B8gPyBR4DAADbmQADfwDVA38DVQXBAxwMJAP/AiQEPAQACN2ZAAb+AKoH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\"\n    }\n}\n",
            "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
            "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage, ValType::Object)\n\nvoid RefImage::destroy(RefImage *t) {}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p size=%d x %d\", t, t->width(), t->height());\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((height() * 4 + 31) >> 5);\n}\n\nvoid RefImage::makeWritable() {\n    if (buffer->isReadOnly()) {\n        buffer = mkBuffer(data(), length());\n    }\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), buffer(buf) {\n    if (!buf)\n        oops(21);\n}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return sizeof(ImageHeader) + ((h + 7) >> 3) * w;\n    else\n        return sizeof(ImageHeader) + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ allocImage(const uint8_t *data, uint32_t sz) {\n    auto buf = mkBuffer(data, sz);\n    registerGCObj(buf);\n    Image_ r = NEW_GC(RefImage, buf);\n    unregisterGCObj(buf);\n    return r;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 2000 || height > 2000)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = allocImage(NULL, sz);\n    auto hd = r->header();\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = bpp;\n    hd->width = width;\n    hd->height = height;\n    hd->padding = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 9)\n        return false;\n\n    auto hd = (ImageHeader *)(buf->data);\n    if (hd->magic != IMAGE_HEADER_MAGIC || (hd->bpp != 1 && hd->bpp != 4))\n        return false;\n\n    int sz = byteSize(hd->width, hd->height, hd->bpp);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\nbool isLegacyImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf) - 4;\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True if the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    }\n}\n\nstatic int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\n/**\n * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n */\n//%\nvoid getRows(Image_ img, int x, Buffer dst) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    uint8_t *sp = img->pix(x, 0);\n    uint8_t *dp = dst->data;\n    int n = min(dst->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = *sp & 0xf;\n        *dp++ = *sp >> 4;\n        sp++;\n    }\n}\n\n/**\n * Copy row(s) of pixel from buffer to image.\n */\n//%\nvoid setRows(Image_ img, int x, Buffer src) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    img->makeWritable();\n\n    uint8_t *dp = img->pix(x, 0);\n    uint8_t *sp = src->data;\n    int n = min(src->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = (sp[0] & 0xf) | (sp[1] << 4);\n        sp += 2;\n    }\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid mapRect(Image_ img, int x, int y, int w, int h, Buffer map) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    if (img->bpp() != 4 || map->length < 16)\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    auto m = map->data;\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        auto ptr = p;\n        unsigned shift = y & 1;\n        for (int i = 0; i < h; i++) {\n            if (shift) {\n                *ptr = (m[*ptr >> 4] << 4) | (*ptr & 0x0f);\n                ptr++;\n                shift = 0;\n            } else {\n                *ptr = (m[*ptr & 0xf] & 0xf) | (*ptr & 0xf0);\n                shift = 1;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _mapRect(Image_ img, int xy, int wh, Buffer c) {\n    mapRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n//% argsNullable\nbool equals(Image_ img, Image_ other) {\n    if (!other) {\n        return false;\n    }\n    auto len = img->length();\n    if (len != other->length()) {\n        return false;\n    }\n    return 0 == memcmp(img->data(), other->data(), len);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    auto r = allocImage(img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src0 = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto sbh = img->byteHeight();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        auto src = src0 + i * sbh;\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    registerGCObj(tmp);\n    Image_ r = doubledY(tmp);\n    unregisterGCObj(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    // DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\",\n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n#define LOOPHD                                                                                     \\\n    for (int xx = 0; xx < w; ++xx, ++x)                                                            \\\n        if (0 <= x && x < sw)\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n            y = y0;\n\n            auto fdata = (uint32_t *)fromBase + wordH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            // DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n            //    (uint8_t*)fdata - from->pix());\n\n            auto cnt = wordH;\n            auto bot = min(sh, y + h);\n\n#define COLS(s) ((v >> (s)) & 0xf)\n#define COL(s) COLS(s)\n\n#define STEPA(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETLOW(s);                                                                                 \\\n    y++;\n#define STEPB(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETHIGH(s);                                                                                \\\n    y++;                                                                                           \\\n    tdata++;\n#define STEPAQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETLOW(s);\n#define STEPBQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETHIGH(s);                                                                                \\\n    tdata++;\n\n// perf: expanded version 5% faster\n#define ORDER(A, B)                                                                                \\\n    A(0);                                                                                          \\\n    B(4);                                                                                          \\\n    A(8);                                                                                          \\\n    B(12);                                                                                         \\\n    A(16);                                                                                         \\\n    B(20);                                                                                         \\\n    A(24);                                                                                         \\\n    B(28)\n//#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n#define LOOP(A, B, xbot)                                                                           \\\n    while (cnt--) {                                                                                \\\n        auto v = *fdata++;                                                                         \\\n        if (0 <= y && y <= xbot - 8) {                                                             \\\n            ORDER(A##Q, B##Q);                                                                     \\\n            y += 8;                                                                                \\\n        } else {                                                                                   \\\n            ORDER(A, B);                                                                           \\\n        }                                                                                          \\\n    }\n#define LOOPS(xbot)                                                                                \\\n    if (y & 1)                                                                                     \\\n        LOOP(STEPB, STEPA, xbot)                                                                   \\\n    else                                                                                           \\\n        LOOP(STEPA, STEPB, xbot)\n\n            if (color >= 0) {\n#define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n#define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                LOOPS(sh)\n            } else if (color == -2) {\n#undef COL\n#define COL(s) 1\n                LOOPS(bot)\n            } else {\n#undef COL\n#define COL(s) COLS(s)\n#undef SETHIGH\n#define SETHIGH(s)                                                                                 \\\n    if (*tdata & 0xf0)                                                                             \\\n    return true\n#undef SETLOW\n#define SETLOW(s)                                                                                  \\\n    if (*tdata & 0x0f)                                                                             \\\n    return true\n                LOOPS(sh)\n            }\n        }\n    } else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n            y = y0;\n\n            auto data = fromBase + fromH * xx;\n            auto off = imgBase + imgH * x;\n            auto off0 = off + left;\n            auto off1 = off + right;\n\n            int shift = (y & 7);\n\n            int y1 = y + h + (y & 7);\n            int prev = 0;\n\n            while (y < y1 - 8) {\n                int curr = *data++ << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = (curr >> 0) | (prev >> 8);\n\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n                off++;\n                prev = curr;\n                y += 8;\n            }\n\n            int left = y1 - y;\n            if (left > 0) {\n                int curr = *data << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n            }\n        }\n    } else if (tbp == 4 && fbp == 1) {\n        if (y < 0) {\n            fromBase = from->pix(0, -y);\n            imgBase = img->pix();\n        }\n        // icon mode\n        LOOPHD {\n            auto fdata = fromBase + fromH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            unsigned mask = 0x01;\n            auto v = *fdata++;\n            int off = (y & 1) ? 1 : 0;\n            if (y < 0) {\n                mask <<= -y & 7;\n                off = 0;\n            }\n            for (int i = off; i < len + off; ++i) {\n                if (mask == 0x100) {\n                    mask = 0x01;\n                    v = *fdata++;\n                }\n                if (v & mask) {\n                    if (i & 1)\n                        *tdata = (*tdata & 0x0f) | (color << 4);\n                    else\n                        *tdata = (*tdata & 0xf0) | color;\n                }\n                mask <<= 1;\n                if (i & 1)\n                    tdata++;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format (legacy)\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\nImage_ convertAndWrap(Buffer buf) {\n    if (isValidImage(buf))\n        return NEW_GC(RefImage, buf);\n\n    // What follows in this function is mostly dead code, except if people construct image buffers\n    // by hand. Probably safe to remove in a year (middle of 2020) or so. When removing, also remove\n    // from sim.\n    if (!isLegacyImage(buf))\n        return NULL;\n\n    auto tmp = mkBuffer(NULL, buf->length + 4);\n    auto hd = (ImageHeader *)tmp->data;\n    auto src = buf->data;\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = src[0] & 0xf;\n    hd->width = src[1];\n    hd->height = src[2];\n    hd->padding = 0;\n    memcpy(hd->pixels, src + 4, buf->length - 4);\n\n    registerGCObj(tmp);\n    auto r = NEW_GC(RefImage, tmp);\n    unregisterGCObj(tmp);\n    return r;\n}\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    img->makeWritable();\n\n    auto iconImg = convertAndWrap(icon);\n    if (!iconImg || iconImg->bpp() != 1)\n        return;\n\n    drawImageCore(img, iconImg, XX(xy), YY(xy), c);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid blitRow(Image_ img, int x, int y, Image_ from, int fromX, int fromH) {\n    if (!img->inRange(x, 0) || !img->inRange(fromX, 0) || fromH <= 0)\n        return;\n\n    if (img->bpp() != 4 || from->bpp() != 4)\n        return;\n\n    int fy = 0;\n    int stepFY = (from->width() << 16) / fromH;\n    int endY = y + fromH;\n    if (endY > img->height())\n        endY = img->height();\n    if (y < 0) {\n        fy += -y * stepFY;\n        y = 0;\n    }\n\n    auto dp = img->pix(x, y);\n    auto sp = from->pix(fromX, 0);\n\n    while (y < endY) {\n        int p = fy >> 16, c;\n        if (p & 1)\n            c = sp[p >> 1] >> 4;\n        else\n            c = sp[p >> 1] & 0xf;\n        if (y & 1) {\n            *dp = (*dp & 0x0f) | (c << 4);\n            dp++;\n        } else {\n            *dp = (*dp & 0xf0) | (c & 0xf);\n        }\n        y++;\n        fy += stepFY;\n    }\n}\n\n//%\nvoid _blitRow(Image_ img, int xy, Image_ from, int xh) {\n    blitRow(img, XX(xy), YY(xy), from, XX(xh), YY(xh));\n}\n\nvoid fillCircle(Image_ img, int cx, int cy, int r, int c) {\n    int x = r - 1;\n    int y = 0;\n    int dx = 1;\n    int dy = 1;\n    int err = dx - (r << 1);\n\n    while (x >= y) {\n        fillRect(img, cx + x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx + y, cy - x, 1, 1 + (x << 1), c);\n        fillRect(img, cx - x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx - y, cy - x, 1, 1 + (x << 1), c);\n        if (err <= 0) {\n            ++y;\n            err += dy;\n            dy += 2;\n        } else {\n            --x;\n            dx += 2;\n            err += dx - (r << 1);\n        }\n    }\n}\n\n//%\nvoid _fillCircle(Image_ img, int cxy, int r, int c) {\n    fillCircle(img, XX(cxy), YY(cxy), r, c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    return ImageMethods::convertAndWrap(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = NEW_GC(RefImage, icon);\n    registerGCObj(r);\n    auto t = ImageMethods::doubled(r);\n    unregisterGCObj(r);\n    return t->buffer;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif\n",
            "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Replace colors in a rectangle\n     */\n    //% helper=imageMapRect\n    mapRect(x: number, y: number, w: number, h: number, colorMap: Buffer): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Returns true if the provided image is the same as this image,\n     * otherwise returns false.\n     */\n    //% shim=ImageMethods::equals\n    equals(other: Image): boolean;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
            "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% snippet='img` `'\n//% pySnippet='img(\"\"\" \"\"\")'\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a circle\n     */\n    //% helper=imageDrawCircle\n    drawCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Fills a circle\n     */\n    //% helper=imageFillCircle\n    fillCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n\n    /**\n     * Scale and copy a row of pixels from a texture.\n     */\n    //% helper=imageBlitRow\n    blitRow(dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void;\n}\n\ninterface ScreenImage extends Image {\n    /**\n     * Sets the screen backlight brightness (10-100)\n     */\n    //% helper=setScreenBrightness\n    setBrightness(deg: number): Image;\n\n    /**\n     * Gets current screen backlight brightness (0-100)\n     */\n    //% helper=screenBrightness\n    brightness(): number;\n}\n\n// pxt compiler currently crashes on non-functions in helpers namespace; will fix\nnamespace _helpers_workaround {\n    export let brightness = 100\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_mapRect\n    function _mapRect(img: Image, xy: number, wh: number, m: Buffer): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillCircle\n    declare function _fillCircle(img: Image, cxy: number, r: number, c: color): void;\n\n    //% shim=ImageMethods::_blitRow\n    declare function _blitRow(img:Image, xy: number, from: Image, xh: number): void;\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageBlitRow(img:Image, dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void {\n        _blitRow(img, pack(dstX, dstY), from, pack(fromX, fromH))\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageMapRect(img: Image, x: number, y: number, w: number, h: number, m: Buffer): void {\n        _mapRect(img, pack(x, y), pack(w, h), m)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    export function imageDrawCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        cx = cx | 0;\n        cy = cy | 0;\n        r = r | 0;\n        // short cuts\n        if (r < 0) \n            return;\n        else if (r == 0) {\n            img.setPixel(cx, cy, col);\n            return;\n        } else if (r == 1) {\n            img.setPixel(cx + 1, cy, col);\n            img.setPixel(cx, cy + 1, col);\n            img.setPixel(cx - 1, cy, col);\n            img.setPixel(cx, cy - 1, col);\n            return;\n        }\n\n        const fcx = Fx8(cx);\n        const fcy = Fx8(cy);\n        const fr = Fx8(r);\n        const fr2 = Fx.leftShift(fr, 1);\n\n        let x = Fx.sub(fr, Fx.oneFx8)\n        let y = Fx.zeroFx8;\n        let dx = Fx.oneFx8;\n        let dy = Fx.oneFx8;\n        let err = Fx.sub(dx, fr2);\n        while (Fx.compare(x, y) >= 0) {\n            const cxpx = Fx.toInt(Fx.add(fcx, x));\n            const cxpy = Fx.toInt(Fx.add(fcx, y));\n            const cxmx = Fx.toInt(Fx.sub(fcx, x));\n            const cxmy = Fx.toInt(Fx.sub(fcx, y));\n            const cypy = Fx.toInt(Fx.add(fcy, y));\n            const cymy = Fx.toInt(Fx.sub(fcy, y));\n            const cypx = Fx.toInt(Fx.add(fcy, x));\n            const cymx = Fx.toInt(Fx.sub(fcy, x));\n\n            img.setPixel(cxpx, cypy, col);\n            img.setPixel(cxmx, cypy, col);\n            img.setPixel(cxmx, cymy, col);\n            img.setPixel(cxpx, cymy, col);\n            img.setPixel(cxpy, cypx, col);\n            img.setPixel(cxpy, cymx, col);\n            img.setPixel(cxmy, cymx, col);\n            img.setPixel(cxmy, cypx, col);\n\n            if (Fx.compare(err, Fx.zeroFx8) <= 0) {\n                y = Fx.add(y, Fx.oneFx8);\n                err = Fx.add(err, dy);\n                dy = Fx.add(dy, Fx.twoFx8);\n            } else {\n                x = Fx.sub(x, Fx.oneFx8);\n                dx = Fx.add(dx, Fx.twoFx8);\n                err = Fx.add(err, Fx.sub(dx, fr2));\n            }\n        }\n    }\n    export function imageFillCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        _fillCircle(img, pack(cx, cy), r, col);\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n    //% shim=pxt::setScreenBrightness\n    function _setScreenBrightness(brightness: number) { }\n\n    export function setScreenBrightness(img: Image, b: number) {\n        b = Math.clamp(10, 100, b | 0);\n        _helpers_workaround.brightness = b\n        _setScreenBrightness(_helpers_workaround.brightness)\n    }\n\n    export function screenBrightness(img: Image) {\n        return _helpers_workaround.brightness\n    }\n}\n\nnamespace image {\n    /**\n    * Get the screen image\n    */\n    //% blockNamespace=\"images\" group=\"Create\"\n    //% blockId=imagescreen block=\"screen\"\n    //% help=images/screen-image\n    export function screenImage(): Image {\n        return screen;\n    }\n}\n",
            "imagesoverrides.jres": "{\n  \n}",
            "imagesoverrides.ts": "// replace with built-in images",
            "ns.ts": " ",
            "panic.cpp": "// potentially overriden in targets",
            "pxt.json": "{\n  \"name\": \"screen---linux\",\n  \"description\": \"The screen library\",\n  \"files\": [\n    \"screen.cpp\",\n    \"panic.cpp\",\n    \"image.cpp\",\n    \"image.ts\",\n    \"text.ts\",\n    \"frame.ts\",\n    \"shims.d.ts\",\n    \"fieldeditors.ts\",\n    \"targetoverrides.ts\",\n    \"ns.ts\",\n    \"image.d.ts\",\n    \"pxtparts.json\",\n    \"imagesoverrides.jres\",\n    \"imagesoverrides.ts\",\n    \"font12.jres\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n  \"screen\": {\n    \"simulationBehavior\": \"screen\",\n    \"visual\": {\n      \"builtIn\": \"screen\",\n      \"width\": 158.43856811523438,\n      \"height\": 146.8025665283203,\n      \"pinDistance\": 14.91,\n      \"pinLocations\": [\n        {\n          \"x\": 4.227952701380444,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 18.170226805137037,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 46.05478386015504,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 59.99706238766404,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 73.93934976267785,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 87.88161944268204,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 101.82389797019104,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 32.11250533264604,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 117.68761950246274,\n          \"y\": 3.1650031792503945\n        }\n      ]\n    },\n    \"numberOfPins\": 9,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_DC\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_CS\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MOSI\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_SCK\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MISO\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_RST\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8\n        ]\n      }\n    ]\n  }\n}",
            "screen.cpp": "#include \"pxt.h\"\n#include \"pins.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <linux/fb.h>\n#include <linux/kd.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <pthread.h>\n\nnamespace pxt {\nclass WDisplay {\n  public:\n    uint32_t currPalette[16];\n    bool newPalette;\n    volatile bool painted;\n    volatile bool dirty;\n\n    uint8_t *screenBuf;\n    Image_ lastImg;\n\n    int width, height;\n\n    int fb_fd;\n    uint32_t *fbuf;\n    struct fb_fix_screeninfo finfo;\n    struct fb_var_screeninfo vinfo;\n\n    int eventId;\n\n    int is32Bit;\n\n    pthread_mutex_t mutex;\n\n    WDisplay();\n    void updateLoop();\n    void update(Image_ img);\n};\n\nSINGLETON(WDisplay);\n\nstatic void *updateDisplay(void *wd) {\n    ((WDisplay *)wd)->updateLoop();\n    return NULL;\n}\n\nvoid WDisplay::updateLoop() {\n    int cur_page = 1;\n    int frameNo = 0;\n\n    int sx = vinfo.xres / width;\n    int sy = vinfo.yres / height;\n    if (sx > sy)\n        sx = sy;\n    else\n        sy = sx;\n\n    sx &= ~1;\n\n    int offx = (vinfo.xres - width * sx) / 2;\n    int offy = (vinfo.yres - height * sy) / 2;\n    int screensize = finfo.line_length * vinfo.yres;\n    uint32_t skip = offx;\n\n    offx &= ~1;\n\n    memset(fbuf, 0x00, screensize * 2);\n\n    dirty = true;\n\n    DMESG(\"sx=%d sy=%d ox=%d oy=%d 32=%d\", sx,sy,offx,offy,is32Bit);\n\n    for (;;) {\n        auto start0 = current_time_us();\n\n        while (!dirty)\n            sleep_core_us(2000);\n\n        // auto start = current_time_us();\n\n        pthread_mutex_lock(&mutex);\n        dirty = false;\n\n        if (!is32Bit) {\n            uint16_t *dst =\n                (uint16_t *)fbuf + cur_page * screensize / 2 + offx + offy * finfo.line_length / 2;\n            uint32_t *d2 = (uint32_t *)dst;\n            for (int yy = 0; yy < height; yy++) {\n                auto shift = yy & 1 ? 4 : 0;\n                for (int i = 0; i < sy; ++i) {\n                    auto src = screenBuf + yy / 2;\n                    for (int xx = 0; xx < width; ++xx) {\n                        int c = this->currPalette[(*src >> shift) & 0xf];\n                        src += height / 2;\n                        for (int j = 0; j < sx / 2; ++j)\n                            *d2++ = c;\n                    }\n                    d2 += skip;\n                }\n            }\n        } else {\n            uint32_t *d2 =\n                (uint32_t *)fbuf + cur_page * screensize / 4 + offx + offy * finfo.line_length / 4;\n            for (int yy = 0; yy < height; yy++) {\n                auto shift = yy & 1 ? 4 : 0;\n                for (int i = 0; i < sy; ++i) {\n                    auto src = screenBuf + yy / 2;\n                    for (int xx = 0; xx < width; ++xx) {\n                        int c = this->currPalette[(*src >> shift) & 0xf];\n                        src += height / 2;\n                        for (int j = 0; j < sx; ++j)\n                            *d2++ = c;\n                    }\n                    d2 += skip << 1;\n                }\n            }\n        }\n\n        pthread_mutex_unlock(&mutex);\n\n        // auto len = current_time_us() - start;\n\n        painted = true;\n        raiseEvent(DEVICE_ID_NOTIFY_ONE, eventId);\n\n        vinfo.yoffset = cur_page * vinfo.yres;\n        ioctl(fb_fd, FBIOPAN_DISPLAY, &vinfo);\n        ioctl(fb_fd, FBIO_WAITFORVSYNC, 0);\n        cur_page = !cur_page;\n        frameNo++;\n\n        auto fulllen = current_time_us() - start0;\n        // throttle it to 40fps (really 30fps)\n        if (fulllen < 25000) {\n            ioctl(fb_fd, FBIO_WAITFORVSYNC, 0);\n        }\n\n        // auto tot = current_time_us() - start;\n        // if (frameNo % 37 == 0)\n        //    DMESG(\"copy %d us, tot %d us delay %d us\",  (int)len, (int)tot, (int)(start-start0));\n    }\n}\n\nWDisplay::WDisplay() {\n    pthread_mutex_init(&mutex, NULL);\n\n    width = getConfig(CFG_DISPLAY_WIDTH, 160);\n    height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n    screenBuf = new uint8_t[width * height / 2 + 20];\n    lastImg = NULL;\n    newPalette = false;\n\n    registerGC((TValue *)&lastImg);\n\n    eventId = allocateNotifyEvent();\n\n    int tty_fd = open(\"/dev/tty0\", O_RDWR);\n    ioctl(tty_fd, KDSETMODE, KD_GRAPHICS);\n\n    fb_fd = open(\"/dev/fb0\", O_RDWR);\n\n    if (fb_fd < 0)\n        target_panic(PANIC_SCREEN_ERROR);\n\n    ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo);\n    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);\n\n    DMESG(\"FB: %s at %dx%d %dx%d bpp=%d\", finfo.id, vinfo.xres, vinfo.yres, vinfo.xres_virtual,\n          vinfo.yres_virtual, vinfo.bits_per_pixel);\n\n    vinfo.yres_virtual = vinfo.yres * 2;\n    vinfo.xres_virtual = vinfo.xres;\n\n    if (vinfo.bits_per_pixel == 32) {\n        is32Bit = true;\n    } else {\n        vinfo.bits_per_pixel = 16;\n        is32Bit = false;\n    }\n\n    ioctl(fb_fd, FBIOPUT_VSCREENINFO, &vinfo);\n    ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo);\n    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);\n\n    DMESG(\"FB: %s at %dx%d %dx%d bpp=%d %d\", finfo.id, vinfo.xres, vinfo.yres, vinfo.xres_virtual,\n          vinfo.yres_virtual, vinfo.bits_per_pixel, finfo.line_length);\n\n    fbuf = (uint32_t *)mmap(0, finfo.line_length * vinfo.yres_virtual, PROT_READ | PROT_WRITE,\n                            MAP_SHARED, fb_fd, (off_t)0);\n\n    pthread_t upd;\n    pthread_create(&upd, NULL, updateDisplay, this);\n    pthread_detach(upd);\n}\n\n//%\nvoid setScreenBrightness(int level) {\n // TODO\n}\n\n//%\nvoid setPalette(Buffer buf) {\n    auto display = getWDisplay();\n    if (48 != buf->length)\n        target_panic(PANIC_SCREEN_ERROR);\n    for (int i = 0; i < 16; ++i) {\n        uint8_t r = buf->data[i * 3];\n        uint8_t g = buf->data[i * 3 + 1];\n        uint8_t b = buf->data[i * 3 + 2];\n        if (display->is32Bit) {\n            display->currPalette[i] = (r << 16) | (g << 8) | (b << 0);\n        } else {\n            r >>= 3;\n            g >>= 2;\n            b >>= 3;\n            uint16_t cc = (r << 11) | (g << 5) | (b << 0);\n            display->currPalette[i] = (cc << 16) | cc;\n        }\n    }\n    display->newPalette = true;\n}\n\nvoid WDisplay::update(Image_ img) {\n    if (img && img != lastImg) {\n        decrRC(lastImg);\n        incrRC(img);\n        lastImg = img;\n    }\n    img = lastImg;\n\n    if (img) {\n        if (img->bpp() != 4 || img->width() != width || img->height() != height)\n            target_panic(PANIC_SCREEN_ERROR);\n\n        if (!painted) {\n            // race is possible (though very unlikely), but in such case we just\n            // wait for next frame paint\n            waitForEvent(DEVICE_ID_NOTIFY, eventId);\n        }\n        painted = false;\n\n        pthread_mutex_lock(&mutex);\n        dirty = true;\n        if (newPalette) {\n            newPalette = false;\n        }\n        memcpy(screenBuf, img->pix(), img->pixLength());\n        pthread_mutex_unlock(&mutex);\n    }\n}\n\n//%\nvoid updateScreen(Image_ img) {\n    getWDisplay()->update(img);\n}\n\n//%\nvoid updateStats(String msg) {\n    // DMESG(\"render: %s\", msg->data);\n}\n} // namespace pxt",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True if the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n     */\n    //% shim=ImageMethods::getRows\n    getRows(x: int32, dst: Buffer): void;\n\n    /**\n     * Copy row(s) of pixel from buffer to image.\n     */\n    //% shim=ImageMethods::setRows\n    setRows(x: int32, src: Buffer): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(160, 120) as ScreenImage\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
            "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        multiplier?: number;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 6,\n        charHeight: 8,\n        data: hex`\n2000000000000000 210000005e000000 2200000e000e0000 230028fe28fe2800 24004c92ff926400 250002651248a640\n26006c92926ca000 270000000e000000 280000007c820000 29000000827c0000 2a00543810385400 2b0010107c101000\n2c00000090700000 2d00101010101000 2e00000060600000 2f00006010080600 3000003c42423c00 310000447e400000\n3200004462524c00 330000424a4e3200 34003028247e2000 3500004e4a4a3200 3600003c4a4a3000 3700000262120e00\n380000344a4a3400 3900000c52523c00 3a0000006c6c0000 3b00000096760000 3c00102828444400 3d00282828282800\n3e00444428281000 3f00000259090600 40003c425a560800 4100781412147800 42007e4a4a4a3400 4300003c42422400\n4400007e42423c00 4500007e4a4a4200 4600007e0a0a0200 4700003c42523400 4800007e08087e00 490000427e420000\n4a002040423e0200 4b00007e08146200 4c00007e40404000 4d007e0418047e00 4e00007e04087e00 4f003c4242423c00\n5000007e12120c00 5100003c5262bc00 5200007e12126c00 530000244a522400 540002027e020200 5500003e40403e00\n5600001e70701e00 57007e2018207e00 5800422418244200 5900060870080600 5a000062524a4600 5b00007e42420000\n5c00000608106000 5d000042427e0000 5e00080402040800 5f00808080808000 6000000002040000 6100003048487800\n6200007e48483000 6300003048484800 6400003048487e00 6500003068585000 660000107c120400 67000018a4a47800\n6800007e08087000 690000487a400000 6a000040847d0000 6b00007e10284000 6c0000427e400000 6d00780830087000\n6e00007808087000 6f00003048483000 700000fc24241800 710000182424fc00 7200007810081000 7300005058682800\n740000083e482000 7500003840407800 7600001860601800 7700384030403800 7800004830304800 7900005ca0a07c00\n7a00004868584800 7b00000836410000 7c000000fe000000 7d00004136080000 7e00000804080400 a000000000000000\na10000007a000000 a200003048fc4800 a30090fc92928400 a400542844285400 a5002a2c782c2a00 a6000000ee000000\na7000094aaaa5200 a800000200020000 a9003e414955413e aa0000242a2e0000 ab00102854284400 ac00001010107000\nad00001010101000 ae003e415d45413e af00000202020200 b000000814140800 b1008888be888800 b2000024322c0000\nb30000222a140000 b400000004020000 b50000f840207800 b6000c1e7e027e00 b700000010000000 b800000080400000\nb90000243e200000 ba0000242a240000 bb00442854281000 bc00025f70f84000 bd00021f90c8b000 be0011557af84000\nbf000030484d2000 c000601916186000 c100601816196000 c200601a151a6000 c300601a151a6100 c400601914196000\nc500601a151a6000 c6007c0a7e4a4200 c700001ea1611200 c800007c55564400 c900007c56554400 ca00007c56554600\ncb00007c55544500 cc0000457e440000 cd0000447e450000 ce0000467d460000 cf0000457c450000 d000087e4a423c00\nd100007e09127d00 d200003845463800 d300003846453800 d400003846453a00 d500003a45463900 d600003845443900\nd700442810284400 d80000fc724e3f00 d900003c41423c00 da00003c42413c00 db00003c42413e00 dc00003c41403d00\ndd00040872090400 de00007e24241800 df00007c025a2400 e0000030494a7800 e10000304a497800 e20000304a497a00\ne3000032494a7900 e40000304a487a00 e50000304a4d7a00 e600304878685000 e7000018a4642400 e8000030695a5000\ne90000306a595000 ea0000306a595200 eb0000306a585200 ec0000497a400000 ed0000487a410000 ee00004a79420000\nef00004a78420000 f00000304a4b3d00 f100007a090a7100 f2000030494a3000 f30000304a493000 f40000304a493200\nf5000032494a3100 f60000304a483200 f700101054101000 f800007068583800 f900003841427800 fa00003842417800\nfb00003842417a00 fc00003842407a00 fd0000b84241f800 fe0000ff24241800 ff00005ca1a07d00 0001601915196000\n010100304a4a7a00 0201611a16196000 030100314a4a7900 04013c0a094abc00 050100182464bc00 0601003846452800\n070100304a494800 0801003846452a00 090100304a494a00 0a01003844452800 0b010030484a4800 0c01003845462900\n0d010030494a4900 0e01007c45463900 0f0100314a497e00 1001087e4a423c00 110130484c7e0400 1201007d55554500\n130100326a5a5200 1401007d56564500 150100316a5a5100 1601007c55544400 170100306a585000 1801003f65a52100\n1901001874ac2800 1a01007c55564500 1b010030695a5100 1c01003846553600 1d0100304a49f200 1e01003946563500\n1f0100314a4af100 2001003844553400 21010018a4a57800 2201001ea1691a00 23010018a6a57800 2401007812117a00\n25017e080a710200 2601047e147e0400 2701047e0c087000 28010002457e4500 29010002497a4100 2a0100457d450000\n2b01004a7a420000 2c0100014a7a4900 2d0100014a7a4100 2e0100217fa10000 2f0100247da00000 300100447d440000\n3101004878400000 32017e0022423e00 33013d0040847d00 34012040463d0600 350100800af90200 360100bf440a3100\n370100bf48142000 3801007810284800 3901007c40424100 3a0100467d400000 3b01003fa0602000 3c0100a17f200000\n3d01007c41424100 3e0100457e410000 3f01007e40484000 400100427e400800 4101107e48404000 420100527e480000\n4301007c0a117c00 440100780a097000 450100bf42043f00 460100bc44043800 4701007c09127d00 480100790a097000\n49010a0678087000 4a01003f02847f00 4b01003c04847800 4c01394545453900 4d0100324a4a3200 4e01394646463900\n4f0100314a4a3100 50013a4544463900 5101324948320100 52013c427e4a4200 5301304830685000 5401007c16354800\n5501007812091000 560100bf49093600 570100bc48040800 5801007d16354800 5901007912091000 5a01004856552400\n5b0100505a692800 5c01004856552600 5d0100505a692a00 5e010012a5691200 5f010028ac741400 6001004855562500\n61010050596a2900 62010101bf410100 630100049f641000 640104057e050400 650100083d4a2100 660102127e120200\n670100183e582000 6801003a41423900 6901003a41427900 6a01003d41413d00 6b01003a42427a00 6c01003942423900\n6d01003942427900 6e01003a45453a00 6f01003a45457a00 70013a41403a0100 71013a41407a0100 7201001f60a01f00\n7301001c60a03c00 7401782211227800 7501384231423800 7601081261120800 770100b84241fa00 7801040970090400\n79010064564d4400 7a0100486a594800 7b010064544d4400 7c010048685a4800 7d010064554e4500 7e010048695a4900\n7f0100087c020400 8f01003452523c00 920100887e090200 a0013c42423c0806 a101003048483008 af01003e403e0806\nb001003840781008 b501006a5a4a4e00 b601005878585800 d101003845463900 d2010030494a3100 e601003845563500\ne7010030494af100 fa0100742a750000 fb0100304c4a7d00 fc0178147e554400 fd0130487a695000 fe010078744e3d00\nff0100706a593800 18020012a5691200 19020028ac741400 1a020101bf410100 1b0200049f641000 bb0200000c0a0000\nbc0200000a060000 bd020000060a0000 c602000201020000 c702000102010000 c902000202020000 d802000102020100\nd902000002000000 da02000205020000 db02000040800000 dc02000201020100 dd02020100020100 7403000002010000\n7503000080400000 7a030000c0800000 7e03000096760000 8403000003000000 8503020003000200 8603037c12127c00\n8703000010000000 880303007e4a4200 890303007e087e00 8a030300427e4200 8c03033c42423c00 8e0303000e700e00\n8f03035c62625c00 900302003b400200 9103781412147800 92037e4a4a4a3400 9303007e02020200 9403605846586000\n9503007e4a4a4200 96030062524a4600 9703007e08087e00 98033c4a4a4a3c00 990300427e420000 9a03007e08146200\n9b03601806186000 9c037e0418047e00 9d03007e04087e00 9e0300424a4a4200 9f033c4242423c00 a003007e02027e00\na103007e12120c00 a30300665a424200 a40302027e020200 a503060870080600 a60318247e241800 a703422418244200\na8030e107e100e00 a9035c6202625c00 aa0300457c450000 ab03040970090400 ac030030484a7900 ad030030685a5100\nae0378100a09f000 af03003a41200000 b0033a4043403a00 b103003048487800 b20300fe25251a00 b3030c30c0300c00\nb403344a4a4a3000 b503003068585000 b603021aa6a24200 b7033c080404f800 b803003c4a4a3c00 b903003840200000\nba03007820504800 bb03641212227c00 bc03fc2020103c00 bd03182040201800 be03112d2ba94100 bf03003048483000\nc003087808780800 c103f82424241800 c2031824a4a44800 c303304848582800 c403000838482800 c503384040403800\nc6031c20f8241800 c703c4281028c400 c8031c20fc201c00 c903304820483000 ca03000238422000 cb03384240423800\ncc0330484a493000 cd03384042413800 ce03304822493000 d0033c52525c2000 d10310344a3c0800 d203067804020400\nd303120a7c020400 d4030d7009040800 d5031824ff241800 d603384828483800 d70348302221d800 da031c2221a14200\ndb031824a4a44200 dc037e1212020200 dd0300fc24240400 de033e2010087c00 df030c0ac9281800 e003700c621c7000\ne10301092516f800 e2039ea0bea07e00 e30398a0b8a07800 e4030c1214107e00 e503001028207800 e603be9088887000\ne70348544e443800 e803245252524c00 e903285454544800 ea0364524c526400 eb03086458640800 ec03385454542200\ned03306848682400 ee03184a7e4a1800 ef031848ff0a0800 f003483020205800 f10378a4a4a49800 f203304848485000\nf303006080847d00 f4033c4a4a4a3c00 f503003058584800 0004007c55564400 0104007c55544500 020401013f857900\n0304007c06050400 04043c4a4a422400 050400244a522400 060400427e420000 070400457c450000 08042040423e0200\n09047c027e483000 0a047e087e483000 0b0402027e0a7200 0c04007c102a4500 0d047c2112087c00 0e040c5152523d00\n0f043f20e0203f00 1004781412147800 11047e4a4a4a3000 12047e4a4a4a3400 1304007e02020200 1404c07c427ec000\n1504007e4a4a4200 160476087e087600 170424424a4a3400 1804007e08047e00 1904007d120a7d00 1a04007e08146200\n1b04403c02027e00 1c047e0418047e00 1d04007e08087e00 1e043c4242423c00 1f047e0202027e00 2004007e12120c00\n2104003c42422400 220402027e020200 23040e5050503e00 240418247e241800 2504422418244200 26043f2020bf6000\n27040e1010107e00 28047e407e407e00 29043f203fa07f00 2a04027e48483000 2b047e4848307e00 2c04007e48483000\n2d0424424a4a3c00 2e047e183c423c00 2f04006c12127e00 3004304848784000 3104003c4a4a3100 3204007868502000\n3304007808080800 3404c0704878c000 3504306868500000 3604483078304800 3704004058683000 3804784020107800\n3904794222127900 3a04007820304800 3b04403008087800 3c04781020107800 3d04781010107800 3e04304848483000\n3f04780808087800 4004fc2424241800 4104304848485000 4204080878080800 43041ca0a0a07c00 44041824ff241800\n4504004830304800 46043c2020bc6000 4704182020207800 4804784078407800 49043c203ca07c00 4a04087850502000\n4b04785050207800 4c04007850502000 4d04485868300000 4e04783030483000 4f04502828780000 50040030696a5000\n51040032686a5000 5204023f0a887000 530400780a090800 5404003068584800 5504005058682800 560400487a400000\n5704004a78420000 5804004080847d00 5904700878502000 5a04781078502000 5b04047e14106000 5c04007822314800\n5d04784122107800 5e0418a1a2a27900 5f043c20e0203c00 6204027f4a483000 6304087e58502000 70040e107e100e00\n7104182078201800 72043c4a4a4a3c00 7304306858683000 7404001e70180c00 7504001860301000 9004007e02020300\n9104007808080c00 9204087e0a0a0200 9304207828080800 96043b043f043be0 970424183c1824c0 9a04003f040a31c0\n9b04003c101824c0 ae04060870080600 af040c10e0100c00 b004161870181600 b1042c30e0302c00 b20421120c1221c0\nb3040024181824c0 ba047e0808087000 bb04007e08087000 d804003452523c00 d904002868583000 e20400457d450000\ne304004a7a420000 e8043c4a4a4a3c00 e904003058583000 ee04003d41413d00 ef04003a42427a00 d005681020285000\nd105484848784000 d205004830600000 d305080808780800 d405680808087800 d505000008780000 d605080818680800\nd705087808087800 d805784050487800 d905000008180000 da0504040404fc00 db05484848483800 dc050e4848281800\ndd05087848487800 de05582010487000 df05000004fc0000 e005004040487800 e105000878483800 e205487840281800\ne305041c0404fc00 e405485848483800 e50504f820140800 e605485060685000 e705f40424241c00 e805080808087000\ne905785058403800 ea05487808087800 f005087800087800 f105081800087800 f205081800081800 f305000010080000\nf405100800100800 021e7c5455542800 031e007e48493000 0a1e007c45443800 0b1e003049487e00 1e1e007c15140400\n1f1e001079140800 401e7e0419047e00 411e780832087000 561e007c15140800 571e00fc25241800 601e004854552400\n611e0050586a2800 6a1e04047d040400 6b1e00083d482000 801e7c2112207c00 811e384132403800 821e7c2012217c00\n831e384032413800 841e7c2110217c00 851e384230423800 f21e040972080400 f31e00b84142f800 a3207e0a7a120a00\na420a8fcaa828400 a720087e2a1c0800 ab200098a4a6bf02 ac20183c5a5a4200 af20627f22443800 9021103854101000\n912108047e040800 9221101054381000 932110207e201000 9421103810103810 95212844fe442800 \n`,\n\n    }\n\n    // A unicode 12x12 pixel font based on https://github.com/adobe-fonts/source-han-sans\n    //% whenUsed jres\n    export const font12: Font = {\n        charWidth: 12,\n        charHeight: 12,\n        data: hex``\n    }\n\n    export function getFontForText(text: string) {\n        for (let i = 0; i < text.length; ++i) {\n            // this is quite approximate\n            if (text.charCodeAt(i) > 0x2000)\n                return image.font12\n        }\n        return image.font8\n    }\n\n    //% deprecated=1 hidden=1\n    export function doubledFont(f: Font): Font {\n        return scaledFont(f, 2)\n    }\n\n    export function scaledFont(f: Font, size: number): Font {\n        size |= 0\n        if (size < 2)\n            return f\n        return {\n            charWidth: f.charWidth * size,\n            charHeight: f.charHeight * size,\n            data: f.data,\n            multiplier: f.multiplier ? size * f.multiplier : size\n        }\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\nnamespace texteffects {\n    export interface TextEffectState {\n        xOffset: number;\n        yOffset: number;\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.getFontForText(text)\n        let w = text.length * font.charWidth\n        let x = (img.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]) {\n        x |= 0\n        y |= 0\n        if (!font)\n            font = image.getFontForText(text)\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let mult = font.multiplier ? font.multiplier : 1\n        let dataW = Math.idiv(font.charWidth, mult)\n        let dataH = Math.idiv(font.charHeight, mult)\n        let byteHeight = (dataH + 7) >> 3\n        let charSize = byteHeight * dataW\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        let imgBuf: Buffer\n        if (mult == 1) {\n            imgBuf = control.createBuffer(8 + charSize)\n            imgBuf[0] = 0x87\n            imgBuf[1] = 1\n            imgBuf[2] = dataW\n            imgBuf[4] = dataH\n        }\n        while (cp < text.length) {\n            let xOffset = 0, yOffset = 0;\n            if (offsets && cp < offsets.length) {\n                xOffset = offsets[cp].xOffset\n                yOffset = offsets[cp].yOffset\n            }\n\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            let l = 0\n            let r = lastchar\n            let off = 0 // this should be a space (0x0020)\n            let guess = (ch - 32) * dataSize\n            if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == ch)\n                off = guess\n            else {\n                while (l <= r) {\n                    let m = l + ((r - l) >> 1);\n                    let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                    if (v == ch) {\n                        off = m * dataSize\n                        break\n                    }\n                    if (v < ch)\n                        l = m + 1\n                    else\n                        r = m - 1\n                }\n            }\n\n            if (mult == 1) {\n                imgBuf.write(8, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x + xOffset, y + yOffset, color)\n                x += font.charWidth\n            } else {\n                off += 2\n                for (let i = 0; i < dataW; ++i) {\n                    let j = 0\n                    let mask = 0x01\n                    let c = fontdata[off++]\n                    while (j < dataH) {\n                        if (mask == 0x100) {\n                            c = fontdata[off++]\n                            mask = 0x01\n                        }\n                        let n = 0\n                        while (c & mask) {\n                            n++\n                            mask <<= 1\n                        }\n                        if (n) {\n                            img.fillRect(x + xOffset * mult, y + (j + yOffset) * mult, mult, mult * n, color)\n                            j += n\n                        } else {\n                            mask <<= 1\n                            j++\n                        }\n                    }\n                    x += mult\n                }\n            }\n        }\n    }\n}\n"
        },
        "screen---ext": {
            "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.filter=\"!tile !dialog\"\n    //% weight=100 group=\"Create\" duplicateShadowOnDrag\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8;20,15;40,15\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tile_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"16,16;32,32;8,8\"\n    //% img.fieldOptions.filter=\"tile\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _tileImage(img: Image) {\n        return img\n    }\n\n    //% blockId=dialog_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"15,15;18,18;21,21;24,24;9,9;12,12\"\n    //% img.fieldOptions.filter=\"dialog\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1 duplicateShadowOnDrag\n    export function _dialogImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n\n    /**\n     * A position picker\n     */\n    //% blockId=positionPicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"position\" color=\"#ffffff\" colorSecondary=\"#ffffff\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __positionPicker(index: number) {\n        return index;\n    }\n}\n",
            "font12.jres": "{\n    \"image.font12\": {\n        \"mimeType\": \"font/x-mkcd-b26\",\n        \"data\": \"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1Ad0AMwGAAD4CQAI/gcAAGNSEAjwBLwG8gG0AuQMAAD8AQAIAAj+BwAAZFIAACQIrAeWAqwCpA8kAAAA/AEACP4PAABlUqACKgoqCeoPKgG+AqAGAAD8CQAI/gcAAGdSwAc+AKoHqgT6BKoErgcAAPwAAAj/BwAAaVKICGwEbAIMAfwPDAFqAigEAAD8CQAI/gdqUgAFfAU8BT4FvAP8AQQBdAUGBXQFBAMAAG9SAgDeD1YF1gdWBVYF3g8AAPwJAAj+BwAAcFIAAKwE/AKsAfwPqgL6BgAA+AEACP4HAAByUowAvA+0BbQF9gW0B7QHjAcAAPwBAAj+B3VSEAAQDtAD+AX0BeQF6AcAAPgBAAj8BwAAf1IACHYFcAV0A/oPeANwA3YFAAD4CQAI/geDUkgE/Af8B/4H/Af8B/wH/AcABPgBAAj8B4dSAA74ARgE2AZ+A2wPbAIIBPABAAj8DwAAiFKAAHwI9Am0CbQF+ANUAVwJ9glcCVQHAACJUgAAnAnKC8kJsAfOBUIFDgT4AQAI/gcAAI1SCAjoBKwC6gBLCKIG5AQAAPwBAAj+BwAAkVI4AEgM9AOMApYCvALMDyAA/AEACP4HAACbUgAAEAgQBBACkAF+ABAAEAgQCBAM8AMAAJ1SAAQUAmQB5AAcCQAEiAN+AAgICAj4BwAAnlIAAIgJaAQIAogBfggICAgM+AMAAOABAACfUgQCBAL8AQQJBAkQBBAD/ggQCBAM8AMAAKBSCAgIBv4BCAgICPgHAAD8DwQEBAT8DwAAoVJACFAJSAksBTYDpAEkCTQJTAlEB0AAAACjUigIqAikCKIEoAOeAJAIiAiCCIQHCAAAAKhSAAAkBOQDJAKkAiQDAAgQB/4AEAjwBwAAqVIABP4DkgSSAv4LAAQQA/AIHwgQCPAHAACqUgAIRAlcCWYFJANcAUQBNAkkCVwHRAAAAKtSAABIB8gEfgJIAkAHEAAQD/4AEAjwBwAAsVIADvwBFAz0A1QI1AcEABAH/AAQCPAHAACyUgAApAikBJQHrASkBDAAEA7+ARAI8AcAALNSAAi0CJQElgSUA9QAlAiUCJYIlAc0AAAAtFIACLgIigSKBIgC6wGICIgIjAiKBzgAAAC5UigIqASoAgwBqAIICFAEEAP+CBAI8AcAAL9SAAAUCFQJfgUUBcADNAEeCQQJPAdAACAAwVIAALQEhAS0B4QEtAwEBBAD/ggQCPAHAADDUgAANAIUCV4HlAE0CQAEEAP+CBAI8AcAAMdSAAgCCvoKqgaqAvoCqgKuCqoK+gYAAAAAyVIQCPgElgP0AJwH8AgYCpgJfggICvgJAATLUgAI7gkqBKoDKgjuCwAAEAf+ABAI8AcAANJSAADkAr4C9A++AuQIBAQQA/4IEAjwBwAA1VIAAHwJfAn8B3oNCAQYApABfggQCPAHAADYUoAAggf/BaoEqgT/BYIMCAL/AQgE+AMAANlSAAAqA6oI6gc2AOAJSAcuATQJNAksB0QB3VIADP4Dkgj+B4ABagk4B64BOAluCaoHAAHeUhIIkgioBK4EoAKiAaQIqAimCCgHcgAAAN9SAAJEAfwFfgN8A3wBfAV+BfwDfAFEAgAA4lIAAKwJrAnuBawFgAP4ARgJDgl4BoAAYADkUgAI9AnWBfQH1gX0BQAMEAP+CBAI8AcAAOdSAAAgAewPuAfoB6gHqA4ABvwBEAjwBwAA8lIAAf4N/gH+Af4N/gEIC5gIfgAIAfgMAADzUgQIfQVtAf8E7AL8AgAGiAF/BAgE+AMAAPVSAAz8A8wP/AHsA/wLzA8ADP4DEAjwBwAA+FIAAfoPuweAB7sHugcADAgD/wAIBPgDAAD+UkAAYAAQA84CKAIIAUgJiAkICggI+AcAAP9SQAAgBhgBjgB4CAgGiAF4CAgICAz4AwAAAFMAAGAAEARMAkoCSAJICQgJCAgIDPgDAAAFUyAAEADIBy4JKAkoCegJCAgICvgJAAQAAAZTQABgBBACzgFoCJgEiAN4CQgJCAz4AwAACFMAAHAA6AMGAuUChAL0AgQCxAsECPwHAAAVUwAAAAD8ByAIIAggCCAIIAggCCAIAAYAABZTQAAgAPgPBgACAAAA/gcgCCAIEAgICAAGF1MAABAEEAIQAv4PAAAAAP4HIAgQCAgICAcZUyAGvAE8AvwDvAS8BAAE/AUQBhAGCAaIBSBTAAD+DwIIAgr6CUoISghKCMoLSghCCAIIKlMAAP4HAgQqBSoF+gUCBPoFqgSqBIoEAAAvUwAA/g8SCIYLIgj6C6oKqgr6C6oKqgoAADlTAAD8DwQExAQ8BAQEBAR8BIQEhARkBAAAOlMAAPwPBAQUBSQFpAREBKQElAQEBQQEAAA7UwAA/g8CBCIFKgWqBHoE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AAD8AwQB/AkABP4DEgDSB5IIkgheBgAAZlQAAPwDBAH8ABAD7gIgCQgG/gEICPgHAABoVAAAAA7+AQIAqgeqAroCqgsqCAII/gcAAHNUAAD8AwQB/AEABEgCSAH+D0gBSAJIBAAAdVQAAPwDBAH8AQAA9AMUARQB9AkECPwHBAB7VAAA/AMEAfwBAAD8AyQBJAH/DyQBJAH8A3xUAAD8AwQB/AEAALQIhAj8B4IAsgCKAAAAfVQAABAA0AdYAlgC1AMSANQPWABIAtABEACLVAAA/AMEAfwBEAAIAA4A+A8oASgBKAEAAIxUAAKUAVQA/AdSAAAA/AcEAgQCBAL8BwAAkFQAAPwDBAH8AWAA/A8CANAAEAkQCP4HEACSVAAIHAgUBNQDXABAAFwAVADUBxwIAAgABpVUAAD8AwQB/AEAAJAPkASQBP4EkASQDxAAllQAAPwHBAH8DAAC/gkIDPAD/A8EBPwPAACaVAAA/AMEAfwBUABIAi4CtQQ0BUwJRABAAKZUAAD8AwQB/AEACOwErAL+AawCrAS8CQAIp1QAAPwDBAH8AUAIvASUA2AA+AkACP4HAACoVCAAEQCKD6AErASjBJIEjgSSBKIPLgAAAKpUAAD8BwQC/AMACKwHIAD+DyAAqAMkDAAArFQAAPwDBAH8AQAIKAioBAoDzAUIBGgIQAivVAAA/AMEAfwBEAGID1YJZQl0CVwJhA+AALFUAAD8AQQB/AEAAPgHqAKsAqoCqAL4BwAAslQAAPwDBAH8CQAITgRMAvgBTAJOBEoIAACzVAAA/AMEAfwBAAgkBbQEbwIkApQFRAgAALhUAAz4AwgAqAeoAqgKCAv+CAgHyggsCAAGvVQAAPwDBAH4AP4PAgQiBfoEogUCBP4PAADAVAACBAF0AVQP1ARVBNYEVAFUAnQFBAUACMFUAADAD0AEXgTSBxIA0g9SBF4EQATADwAAxFQAAPwDBAH8AQAIiAT+AogAiAD+AogMgAjHVAAA/AMEAfwBAAgkCSQJvg8kCSQJIAkAAMhUAAD8AwQB/AFgADAPqASmBKgEMA9gAEAAyVQQANQHVAJeAlQC1AkQDP4CEAOSBFQIAAfNVAAA/AMEAfwBAAD4DwgA6AMuAegJCAj4B85UAAD8AwQB/AEACCQIzgQEAwQFzgQkCAQI0VQAAPwDBAH8BUAEBAT8BwQE/AcEBOQEAADXVAAA/AMEAfwBAAB8AQIBkA8+AUgBRAEkAN9UAAD8AwQB/AEABPwFggQQAs4ICAj4BwAA4VQAAAAI/wutBq0GrQKtAq0GrQb/CwAIAADlVAAARAB8B2wFbAVsBWwHfABECPwPRAAAAOZUAAD8AwQB/AEACPwPkgAQDP4DkAVWCAAG6FQAAPwDBAH8AQAA9g9QAV4BUAlQCfYHAADpVPwDBAH8AQAAfAlUCVQJ/A9UCVQJfAkAAOpUAAD8AwQB+AwCAv4Jkgj+B/wPAgD+AwAA7VSACJ4IkgiSBJ4DwACcA5QE1ATcCIAIAADyVAAAEgCyD78EigSgBJ4EiQSJBLkHCQAIAPpU/AMEAfwBAADoD6gCqAL+D6gCqgrsBwAA/FQAAPwBhAD8AAAAvAisCK4OrAGsAbwABAAGVQAA/AMEAfwJQAgoCZ4GiAT8BswFWAhACAdVAAAAD/4AIg7qCqoKagqqCqoKKg0iAQAACVUAAPwDBAH8AQAIKAkuBeoDKAUuCSgJAAAQVQAG/AEEAFwHXAVcBf4FXAVcBXwHFAAAABRVAAD8AwQB/AEAAKoHugSuBKoEugSiByAAJFX8AwQB/AEACPgElAKWAfQBnAKUBPQEgAgsVQAA/AMEAfwBAAz4AygIPgdsAGwHTAgABC5VCAAIAHwPXgVcBVwFfgVcBVwFXA9EAAAAL1UAAPwDBAH8AQAA/A+qBKgE/geoBKgEAAAxVQAA/AMEAfwBAAD+B2oFagVqBWoF/gcAADdVAAD8AwQB/AEACPQH7ADmAmUKZAr0ByQAOFUAAPwDBAH8CAAGKACkBLIJNAr0ACQGCAg+VQAA/AMEAfwBAAjUChQK/A8UCtIKUAoQCEZVAAAAAPQPFAB8BxYFNAVUBVwHFAD0DwAASlUAAPwDBAH4AP4PMgDMAeQDFAHkCPwHBABPVQAA/g8qAKoHvgKAAr4CqgMqCCoI/gcAAFNVwgA6AKoHqgSqBLoEkATOBLQENAdMAIQAX1UABvwBqgeqAqoCugMgBH4CiAHoAhgEAABhVQAA/AMEAfwBAAAoAf4PAAD+DygBKAEAAGRV/AMEAfwBAAB8AtQC1AJ+AlQPVAJ8AgAAZVUAAPwDBAH8ARAASAdEBfIFVAVEBUgHUABmVQAA/AMEAfwBAAz+AwgIYAiJCQoO6AkAAGpVAAD8AwQB/AGACP4HQAD4D4wEigT4DwAAeFX8AwQB/AEADKwDLAYsAf4PLAEsArwPCAB8VQAA/AMEAfwBAABsB6QApg+0AKQEpAMAAIBVAAD8BwQC/AMAAKQPtAlWCVQJpA6MAAAAglX8AwQB/AEAAPwA1A/UCPwJ1ALUB/wJAACDVQAA/AMEAfwA4A8UALQCngfUAhQI9AcAAIRVAAFEAVQPVgtUC/wLVAtUC9YL1A9EAQAAh1UAAPwDBAH8DGQCng/0AZQCYAj4CP4HAACJVQAA/AMEAfwBYAD4DwYAUAlUBdQDXAVQCYpVAAD8AwQB/AzwAwgHqAIIDX4CiAVqCAAGlFUAAPwDBAH8DAAC/Ak0CPQKtA+0CrwKAACYVfwDBAH8AQAAvA+wALAP/gCwD7AAvA8AAJpVAAD8AYQAfAjwBVgFNgOUAzwFUAXwCQABnFUAAQQBfA/cC1wLXgtcC1wL3At8DwQBAAGdVQAA/AMEAfwBAAC+BqoEqgWqCKoIvgcAAKdVAAD8AwQB/AEICPQLtAq2CrQK1AscCAAAqlUAAIQIvAisD7wIhAj+CYQCvASsCrwKhAirVQAA/AMEAfwJAAg+BTQDwAM8BQQJfAkAAKxVKAAsAJwP/ADcB9wF3AXcBfwHmgioDyAArlUAAAAE/gVaBVoF/g9QBV4FWgX6BQ4EAACyVQAA/gMCAf4BGAznApAAUAaOAAgI+AcAALVV/gGCAP4AAADwD5IElwTyB5AElwTyBwIAtlUAABgACgd8BVgF3gVYBVgFfAUKBxgAAAC3VfwDBAH8AQAI1AtUCFQGVgFUBFQI1AsACLtVAAD8AwQB/AEYANgPtALyD5QBGAjIBxAAxVUAAPwDBAH8AQAIfAVcBV4DXgPcBXwFAAnOVQAA/AMEAfwBAAz+AKoGqgD+BKoBgg8AANNVAAD8AwQB/AEACFIFdgOGD5YDUgUwBQAI2lUAAPwDBAH8CQAE/ADUDtYA1AXcCMAHAADcVQAA/AMEAfwBQAA0B34H1AfcB9QH1AcAAOFV/AMEAfwBAATIAlQKogcQAFICdArkBwgA41UAANwP1AfUD9wPhAFUAtQLBAj8BwAAAADkVfwBBAH8AQAE4AdsBngG7gdoBmgG7A8gCOhVAAD8AwQB/AAADkQAkAPMAqgLqAroBwAC71UAAPwDBAH4AD4BYgJqBFoFWgRCAX4DAAL9VQAA/AMEAfwEJAL+D1QBdAkQBs4BCAY4CAZW/AMEAfwBAAj0CtQK1gb0A9QG1gr0CgAACVYAAIIOvgLuCq4KrwauDO4Krgq+CoIOAAAOVgAA+AMIAfAFBAV8BfwDfAN8BfwFfAcEAxdWAAAMAEYP1gv0C/YL9Av0C/YLxQ+cAAAAG1YAAPwDBAH8CPgHBAH0DyYChAH0D6QABAMfVgAA/AMEAfwAgA9+BVAFiA/8BwQA/AMAADFWAAD8AYQAfAgAB/wOtAHcBfwH1AHcDwAAMlYAAPwDBAH8A3wCrg98Av4HkgD+DwAAAAA0VgAA/AMEAfwBEATYA+4C9AfwAu4C1AcQADZWAAD8AwQB+AAEDf4BVAH+DfwDJADiDyIAO1YAAPwDBAH8AQAAfA/cC14LXAvcC3wPBAE/VvwBhAD8AAAIXgVWAVIF/glaAVIFXgAADkFWAAD8AwQB/AAgDVQB3AcEC9wLVAl0AQANYlYAAPwDBAH4CXwIDAVkA3YBJANEBXwJAABoVgAAQAJcD1QJ1Al8D2AATA/0CXQJXA9AAmpWAAD8AwQB/AnABbwF9AOUD/QPvAPgBQAIdFYAAPwBhAD8BBAE9Af0AvYC9ALUBvQHEAiHVgAA/AMECfwH5As/COQPJA3kA/8PJACgA7RWAA7gAbwE9Af0B+wPuAHUCXQG/AVgCAAAt1YAAPwDBAH8BQAM/A/sCf4B9AfsBfwJAAC8VgAA/AMEAfwBAAD0D/IF+gwyAbkItQeAAMJWAAAIAv4H/gf+B/4G+AD+Bv4H/gcIBQAByVYAAP4BggB8AfcGpQIHA/0PVwX1B1cFAADKVgAFtAP8C/wH/AWeBfwB/AP8BdwHlAcAANpWAAD+DwIEAgWCBEIEOgTCBAIFAgT+DwAA21YAAPwPBATEBTwEBAQEBHwEhAQEBPwPAADeVgAA/g8CBPIEkgSSBJIE8gQCBAIE/g8AAOBWAAD+DwIEIgUiBaIEegSiBCIFAgT+DwAA4lYAAP4HAgSSBFIEUgUyBfoFEgQCBP4HAADjVgAA/gcCBAoEagQKBQoF+gQKBAIE/gcAAO1WAAD+BwIEKgXqBCoE6gUqBSoFAgT+BwAA8FYAAP4PAgSiBWIE+gViBKIEIgUCBP4PAADyVgAA/g8CBJIE+gWSBJIE+gWSBAIE/g8AAPNWAAD+DwIGWgdCBcoEwgQyBQoFAgT+DwAA9FYAAP4PAgSqBKoE+gWqBKoEigUCBP4PAAD6VgAA/g8CBBIE0gVSBXoFUgXSBQIE/g8AAP1WAAD+DwIEKgUqBfoFKgVqBSoFAgT+DwAA/lYAAP8PAQQpBS0FFQWVBa0GJQYBBP8PAAAGV/4HAgbeBlYGVgVWBVYEXgbCBgIE/gcAAAhXAAD+BwIEPgT+BToGugZ6BjoFAgT+BwAAC1cAAP4HAgTqBaoFSgR6BYoFbgYCBP4HAAANVwAA/gcCBP4FfgV+Bf4FfgV6BQIE/gcAAA9XAAD+BwIEagTqBfoG6gb6BmoEAgT+BwAAElcAAP4PAgzqDWoLegtqC2oL6gsCDP4PAAATVwAA/g8CCMIL+gvqC+oL6gv6CwII/g8AABZXAAD+BwIE/gf2B/YH9gd+BuIHAgT+BwAAGFf+DwIE/gT+Bf4E/gT+Bv4H/gQCBP4PAAAfVwAEIAQgBCAEIAT+ByAEIAQgBCAEAAQAACNXQAhECEwJLAk0CaQPNAk0CUwJRAhACAAAJ1cAAAAM/AMECEQIRAj0D0QIRAhECAQIAAAoVwgBiADIDzgAjgiICIgI6A+ICIgIiAgAAC1XAAgkCSQJJAkkCb8PJAkkCSQJJAkgCAAAMFcAAhAC/gEQAUAA/AcgCCAI/gkQCBAJ+AQzVwAEEAL+AxABAAz+AwAAAAD8BwAAAAD+DzpXAAIQAv4DEAEAASIJ8gQqAuYJIgzgAwAAPlcABBAC/gMQCgAEhAN8CIQEJAc8BeAEAAhAVxACEAL+ARABAAjwDwAIAAj+DyAIIAggCEJXAAIQAv8BkAQABv4BMgzSAhIDkgJyBAIIR1cAAhAC/gEQATAADAIqASgJqAgIDPgDAABKVxACEAL+ARAJAAwIAvgBSghICEgIyAcIAE5XAAIQAv4BEAFACDQICgboAQgCSAQ4CAAAT1cAAhAC/gEQAUQBRAAkAPwPBAAkAMQAgABQVyAIkAiOCLAIgAj+D6AIkAiOCJAIIAgAAFFXAAIQAv4BEAEADOgDKgAqAOgHCAgIBgAAV1cAAhAB/gGQAIAICARIA/4AyAFIAngEQAhaVwAIPggACQAJfglGDyoJEgkqCSYJQAgAAFtXAAIQAv4BEAEABCQGpAVkBCQEpAUkDgAIXVcAAhAC/gEQAQAI/gkCBAIC+gECBAIE/glfVwACEAL+ARABgAkIBHgEigOMAngECAgIBGBXAAR+BQIFPgUCBaAHMAUOBRAFIAVABAAAYVcAAhAC/gMQCQAM+APICX4GSAbICVgIAABkVxAC/gEQAQAA/AMkASQB/w8kASQB/AMAAGZXgAAQAf4AkAAABP4EkgSSBJIEkgT+BAAEalcAABAC/gMQAQIAugCCAP4PggCyAIoAAACCVwAAQAJUCvQLVApUCvwPVAryC1IKQAAAAINXAAIQAv4BEAEABCgEyAUKBAgH6AQIBAAAhFeICIgKaAoYCkwKSA94CqwKrAqICkgIAACLVwAAQATKBD4ECgV+BQoHAAUeBUAFfgQABJJXQAhoCUgJbAkKCQgPaAlMCUgJKAlACAAAo1cAAhAC/gMQCQQI9AtUClQKVApUCvQLBAimVwAAAAj+CqoKKgoqD2oKqgqqCt4KgAqACKtXJASUBf4FFAUABdQHNAUeBQQFfASABEAArlcABBAC/AMQAoAAqAK4A6wKqAqYCqgGqADDVwAEEAL+AxABQAgoCS4F6AMsBSwJIAkAAMtXAAIQAv4BEAEACHwJVAlUCfwPVAlUCXwJzlcAABAC/gEADPgDKAAoCsgJfgSIB24ICAbUVwACEAL+ARABAADoD6gCqAL+D6gCqgrqB99XAAAQAv4BEAFAAKgC6AoIBH4CiAVqCAwG4FcAAhAC/gEQAQAC/AK0ArYPtAK0AvwCAAL3VwAAlALUAp4P9AIQCEgG/gEIAQgA+AcADPlXAAEQAv4BAAEkAKQHtASmBKQEvASsByQA+lcAAEgBSAX8BHgFeAd4BXgF/ARIBUgBAAD8VwACEAH+ARABAAC0B7QCrgs2CDQI9A80AABYAAAIAf8AAAb/AQUOdQRFBPUHRQR3BwAAAlgAADgICgrsCqgKrg+oCqgK7AoKCjgIAAAFWAAEfgVWBXYFVgVeBwAFSgUyBToFRgRAAAZYEAIQAf4BgAAwAPwPqgSoBP4HqASoBAAAFVgACP4KCgp2CgAKfA8+CjwKvAr8CgQIAAAhWBAAEAR+BQAFXgU6BxoFegU6BV4FUAQAACRYEAQQBP4DEAqACL4GqgSqD6oKqgq+CoAIKlgAABAE/gMQAwQP/glUC1QLVAn+DQQJAAAvWAAAmAmcCXwFXAMOAVwBXAd8CVwJWAUAADBYAAIQAf4BEAD8DwQE/AZ8B3wF/AV8BEAAMVgAAFQBdAHeB3QBAAD+D2IIsgQyA+4MAAQ0WAACCAL+AQgAQAn+BWoDagVqA2oJfgcAADVYAAIQAf4BEAHUAFQA3gd0BVAFWAXWBxAAOlgAAQgB/gCACb4EqgTqAz4AKgDqD74BAAFBWAAIQAl+C2oLKgo+DyoKqgpqC34LQAkAAEpYAAQQAv4DEAEAAXwIVgfVAPwHVAhUC3wLTFgIAQgB/wEIAUAA3wFVBdUHlQFVCd8PAABRWAAAaAjMCngKTAooD4AKfApUClQK/AgAAFRYAAIQAv4BEAFEACQHJgVUBVQFJgUkB0QAV1jaCAIKigqoCiwKrA6qCvoKLAqsCqgICABYWAACCAH/AQgBAAb8ARwGXQX6BVwFfAcUAFpYAAIQAv4BkAUGBaoCegqKCToGygAmBwAAXlgAAIQKtAq0CfQKtAq2DvQKtAm0CoQKAABpWAABEAH+ARAFOAT2B9QH1ATUB/QEhAcABGtYAAQQAv4DEAEACPwLvAq+ArwK/AsECgAAdVgAAAAM/gfqBP4FagVrB34F6gXqBfoEAAB+WEQIfAl8C/4LfAoAD4gKaAoeCvgIAAnACINYAAIIAv8BiAgICPoFXgNbAV4P+gkIBAAAhVgACH4Lagv+C2oLfg8QCpIK+goWCnIIAACKWAAArAisCu4LvAqID+gKPApICvgIAAnACJNYAAFEBfwEfgV8BXwFfAd8BX4E/AREBQABl1gAAhAC/gEAAXwA1w/UCvwK1ArXCvwPAACZWAAAEAP+AZAABADsB+QH/gbkBmwF5AcAAJxYAAB+BIoGdgYABlYHPAW0BfQFFgVkBIAAnlgAABAD/wGAADwA5g90BXwFZAXnDzwAAACoWAAEIAR+BToFegU+B3oFPgU6BX4FIAQAAK5YAAD+CAIKfgoACvYPOwp+Cn4K3gp+CAgIs1gAAhAC/gEQAQQI1AfcB94D1APUB9QLEAjBWEAAfgRqBWoFagVuBzQFPAV2BTQFPAUABMdYAAAQAf4BAAF8BMwH/Af+B/wHzAd8BAQEylgAABAC/gEAA/QK1A70Cd4F9ALUBvQIAAjTWAAM/gPKAf4G/ga+B8IHEgf6BvIGtAQAAdhYAARwBX4FfgV+BX4HLgV+BX4FfgVwBAAA3lgAABAC/gEAAFwCrA48CW4JPALsBvwIAADiWAAAEAT8AwAI/AcEAPQOZAgEDvQKpAoAAORYAAAQAv4BAAV8BOwN/gvGAfwH7AX8CQQB61ggACAEIAQgBCAE/gcgBCAEIAQgBCAAAADuWAACGAIAAf4PAAAgCCAI/g8gCCAIIAgAAO9YgAieB5AA/g8AACAIIAggCP4PIAggCCAI8FgAAAQM1ANUAVQB3gFUAVQBVAHUAwQAAADyWAAIxAhUCFQGVAFeAFQAVAdUCFQIxAQAAPNYAAjECFQIVATUA94A1ADUB1QIVAjECAAE9lgAAMQIVApUCFQPVAheCFQPVAhUCsQIAAD5WAAANAS8BXwFfAV+BXwFfAf8BdwFFAQAAPpYAABkCDQLtAr0Dj4I9A60CrQKNAtkCAAA/ViUANwG/Ab8BvwG/gD8BPwC/ArcD9QCgAAEWYAIYAjeBAgD6AIYBAAI/gsgCEAIgAgAAAdZQABQAEgPrAq2CqQPtAqsCswKxA9AAEAACVkECkQKNAmEBaQGngTEBvwGhAmUCCQIAAANWQAACAgICnYJ3gdcBVwFXAVcC3wJBAgACA9ZAAgECnwJfAX8B3wFfAV8B3wJfAkECAAIFVkAAEAAIAgQCEgETgSKAggBiABoABgAAAAWWUAAYAhQBI4CiAFoABAAIAD+D4AAAAEAAhpZAABQCEgJRAk0BaYElAZMAkQBwABAAAAAHFmEAEQA9A8EAEQIZgS0AxQDlAR0BBQIAAAfWSAA8AMsCegJCAj4BwAAqAiWBFQCTAHAACBZCAmoBHYFVALMARAAzAMqAegJCAj4BwAAIlnEAHwKbApuC/wLbAVsBXYDbAF8AMQAAAAlWQAI/ATUAvwP1AL8ABAISAnWBrQEjAOAACdZEAgQBBACEAHQAD4AUACQARACEAQQCAAAKVlACEQIRAREAkQD/ABEAUQCRARECEAIAAAqWRAIEAQQBBAD0AI+BFAIkAEQAhAEEAgAACtZQAhIBEgESAJIAf4ASAFIAkgESARACAAALVkAAEAIRAhEBEQERAP8AEQDRARCBEIIQAguWQAAgAj4CIgEiAP+AIgBiAaIBPgIgAgAADFZYAhwBE4ESALIAX4AyAFIAkgESARACAAANFlABEgIUgRUBEQCwAF+AEACQAJABEAIAAA3WQAABAjsBKwErAL+AawDrASsCrwKhAkAADhZAAAoAKgAqAK4A6wCqAqoCrgKqAaoACgAOVkAAIAIiAioCIgEiAP+AIgDiASoBIgIgAg6WQAAqACoAKgAmAaMAIoImAiYD6gAqACoAD5ZCAmICGgECAQIA/wACAOIBGgIiAgICQAAR1kAADQAtAe0ArQCrAKuAywINAj0BzQAIABIWSgEqAyoApgIrAiqB6gAmAKoAqgMKAAAAElZAACgAKwCbAIsArwCrg+sAiwCbAKsAqAAS1lAAEQA5A9UBUwFxgdMBVQFZAXkD0QAQABOWRQEVARMBVwFVgV1B1QFXAVMBVQFFAQAAE9ZkABUCFwFfAVcA94BXANcBXwFXAlcCJAAUVkAAFQJVAl+CVQFQANCAyIFHglCCT4JAABUWSABJAkUBawDJAEmAXUBJAGMDxQBJAEgAVVZJAlUCUQJJAUcBQYDBgF8BQQFFAUkCQAIVlkgCSQJEAl+CQAFSANEAyYFJAkcCQQJAABXWSAAJAEUBfwHdAV2BXQFdAV8BRQNJAkgAFpZAAmECawFZAW0A6oBYgNSA0IFSgUACQAAYFkAAAQF/AXuBe4F3APcA+4F7gX8BQQFAABiWSgBKgGqAK4P6gq7CqoKugqmCqYPKgAqAGVZAAAACXwJDAVkBXYDJANMBQQFfAkACQAAZ1kACXwJBAVsBWwFLAN+ASwDLAOEBfwFAAloWQAALgkgCX4FAAUkA5IBFgORBf0FFQkQCWpZAABUATQB/AP0B/YB9AX0BfQD/AGUARQBblkAABoAmg/+Cv4K+w/6CvoK/gr6D0oAAABzWQAAEAgQCdAIMAkeBRICEAKQBXAEEAgQCHRZiAj4BA4DyAE4CAAMNATEA8QCPAQACAAAdlkICPgMDgOIA3AIBAf8AAQEPAgkCOAHAAB4WQAA+AgOBYgDeAwAAEQARAD8D0QARABAAHlZAAj4DA4DiAF4BgAA/AcQCP4JCAj4CAAGfVkACOgMHgOIA3gEAABECEQI9A9MAEQAQACCWQAACAj4CA4F6AMQAPwPBAQEBAQE/A8AAINZAAj4CA4FiAN4BAAAxAdECEQIRAj8CAAGhFmACIQIvAqkC6QKpgSkBKQHpAikCIQIAACGWQAAGAOAAP4PAACQCHAJHgYQA/AEEAgQCIdZCAj4BA4DiAF4AAAERAREBEQERAT8DwAAiFkACPgMDgPoAhgEcAFEAUQJZAlcDMADAACSWQAI+AwOA+gDGAzwA0gASgBKAEgA+AAAAJNZCAj4BI4CyAE4AgAIaASoBT4CqAVoBAgIllkABPwEBwPEAjwAAAwiAqIBfgChASECIASZWQAA6AieBsgBOAIACDwEgAT+AgACjAEwAJ5ZEAjwBA4DiAN4AAgI4A9cCEQI/A9ACAAApVkAAEQIVAbEB2QGbAJEAmIF8gRKBEAIAACoWQgA+AkOBYgDcAQAAAgP+ABOCEgIyAcIAK5ZAAj4DA8D+AgADP4DEgDSB5IIkgheCAAGs1kAANAIPgUQA/gEAADUAwoI+A8IANgBCAK5WQAI+AgOBYgDeAAADEgCSAH+D0gBSAJIBLtZFAlcCVwLXAvcBX4FXAVcB1wFfAkUCQAAxlkACPgJDAb4BQAA/AdEBFQFVAxEDPwHQATJWQAA6AgfB8gBOAbAASQAJAD+DyQA5AMAAMpZCAj4CA4H6AEQBngARA/EAP4PRADEBwAAy1kAAOgNHgOIAXgCAACwD64EoASsBDAHQADQWQAA+AkOBugDEAj8DyQJJAkkCfwPAAgAANFZAAD4DA4DiAN4BAAAkA+QBP4EkASQDwAA01kAAOgIHgXIAzgAIAicCJAI/g+QCJAIAAjUWagIrAisC5wKzAb8BIwCmgWqBKoIqAgAANpZAAj4BA4D8AgMCYAE/gMAAP4HQAicCIQG3FmgCKwIrQquC6wGvASsBq4FrQSsCKQIAADlWRAI8AQeA5ADeAQAAagHfgkoCTgJKAUkAOhZAAj4DI4DcAQEAOwMrAL+AawCrAS8CQAI61kAAPQMjwLkARgA/g+SBJIEngeSBPIEAATsWQAI+AQPA+gBEAD+BwIE8gSeB5IE8gQCBPtZAAD4DA8D6AEQAv4PAgXiBLoFAgT+DwAA/1kAAKIIlArUC8AGpgSUBIwGlAWkCKwIAAABWgAO+AEIBNgFeALYAwgI/gQIA8oEKggABgNaAAj4CA4H+AQAACQJJAm+DyQJJAkgCQAABFrICMgIrgqYC9gG/gSYBpwFqgTqCMgIAAAHWgAI+AQOA8gBOAZQADQPHAAUADIPUgCAABhaAAj4BA4D+AYAAPwPVARWBNQBVAO8BIAEG1oAAPANHgP4AAQIcAlcB+QBZAN8BcAJAAkcWgAA+AyOA3gIAgb+AZII/gf8DwIA/gMAAB9aCAj4CA4F6AMYAMAPvAK0ArQKtAr8DwAAJVoACPgM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XgmcB5wAXAFEAhwEAAS5WwAALAIkAZQPRAkmCSQJRAmUDyQBDAIAAL1bAAAMCNwLXAh8BF4DXAR8CFwI3AscCAAGvlsAAAwJBAX0BVQFTgFMAcwFTAVEBQwJAAC/W4AATADkBxQABADWB1QFdAVUBVQF1AcAAMJbAABMA0QI9A9UAEYLFAh0BJQD1AQ0CAAIxFsAAIwAxAfUBbQFtgW0B9QA1AjED4wAAADFWwAIDAjkC7QGtAb2A7QCtAa0BuQLDAgAAMZbAAAMAaQHhATkBE4HpASUBEQEFA9kAAAAx1tACFQE1ANUANQHVggECHQLVAvUCFQIAATMWwAADACEB/wF3AXeB9wF3AX8BYQHDAAAANJbAACMBLwCvAH8BL4IvAr8CLwJvAKMBAAA01sAAIQP9AD0AvQC9gP0AvQC9Ab0BIQHAADbWwAIDAjEC9QL9AfWA9QD9AfUC8QLDAgAAN1bAAAsAQQB/APECX4IfAt8BXwFfAvMCQAI3lsAAAwK5Ar0CvQG9gP0AvQG9ArkCgwKAADfWwAATAlkBbQB9AmGD5QBpAPUAzQFnAgAAOFbAACMAIQF/AX8A/wD/gH8BfwH/AGMAoAA4lsACWwHRAH0DwQA9gn0C/QF9Af0CKwJAADlWwABXAlcCbwKnAt+B0QGvAR8BXwBDAEAAOZbAAAUCNQH/Af8A/4D/AP8B/wH3AcUCAAA51sAAAwBxANUA9QLagvsD2QDRAPUAwwDAADoW4AEtAK0CrQL9AK2DrQC9Aq0C7QKhAIAAOlbAAFMAWQP9AtUC3YPVAtUC/QLVA9EAQAB61sAAAQB9AT0AvQA5gLEAfQA9AX0BIQDAADsWwAIDAjEC9QH1AfWA8QD1AfUC8QPDAgAAO5bAACMCEQI1AP0CtYO1AL0AtQLRAiMCAAA9VsAAFQI9AfUAfQK1AcGAPQHdAt0C3QOAAT2WwAEFgjWB94H1gPHA+4D7gP+B+4HLggAAPhbAAAIACgAaACIAQgICAgICP8HCAAIAAgA+VsACCQMRAKEAXwCAALQABAJEAj/BxAAAAD6W6AAqACoAKgGqAS8AKgIqAjoB6gAqACgAPtbAAAAAUQBVANUA1QBVAlUCVQHfAEAAQAB/FsAAAABPAFUA1QFVAFUCVQJVAdcAUABAAH+WwAIKAxIAo4BaAYIBFAA0AEQCP4PEAAAAP9bQAREBVQDVAH0BV4BVAlUCdQHVAFEAQAAAVwAAKQEpAS/B6QEpAQAANAJEAj+BxAAAAACXAAAAgF+AVYFVgF/CVYJVgnWB34BAgEAAARcgAT+BKoCqwmqCP4PCADoBAgE/wMIAAAABlwAAAgBkAD+DwAAhAK0ArYIlAjMD4QAAAAHXIAIngeQAP4PAADYAMQGrgSWCMwPhACAAAhcAAKEArwCvAa8Bv4CvAq8CvwHvAKEAgACCVwAD/4ACgKqCKoPqgCGAhAIkAj+BxAAAAAKXAAABAL0A5YHvAeUA7wL1AvWD/QDBAIAAAtcAAAgAzQD/AK8BhwC/Aq8CrwHvALgAgACDVwUBFgFbgXQB24FVAUUANAJEAj+BxAAAAAOXJAClgJwAoQG/Ab+AvwK/Ar8B/4ChAIAAg9cAAAAAeAAEAAACAAI/gcAAAAAEABgAIADEVxACCAIGAgACAAE/gQAAgACiAGQACAAAAAUXAAAIAIQAcwACggICPgPCABIAMgAGAEIAhZcoAiwCIwIgASAA94AgAOEBIQEmAigCAAAGFwAACAIEAkMCQAJAAm+DwAJBAkMCRAJIAgaXAAAAADkDygAoAe8AqACoAKgAygI5AcAAB1cAACYBLoMvAu4CL4EuAS4BLwGqgSYCAAAJFwACBAIEAQQAtABPgCQBxIIFAgUCBAGAAAsXAAI6AceAPgHCAgICugJBAgGCOgLCAgABDFcCAR4A1gI3AdYALgJAATwAx4A0AccCBgGNFwAAOgPHgD4BwAMnA+4D5AMjA+oDKgPCAw4XAAIAAz8AyQAJAAkACQAJAAkADwAAAAAADlcAAAQCJQElASUA/wAlACUAJQA/AEQAAAAOlwACAAG/gEiACIAIgBiAKIBIgI+BAAIAAA7XAAAAAz8AxQIlAb0AZQAlACUBxQIHAgABjxcAAAADv4BEgDSA5IEkgSSBFIEXgQAAwAAPVwAAoABfgASAlIEkgSSBDIIUgieAAADAAA+XAAAAAz+AxIA0gLSAtIHsgqyCrIJngUAAD9cAAAADv4BEgRSA5II0g+SAJIBUgJeBAAEQFwAAAAO/AFUAFQHVAVUBVQHVAhcCMAHAABBXAAA4A8eANIPkgiSBBIA0gcSCZIIXggABEJcAAAABv4BCgCqBKoHqgSqBKoEqgauDIAARVwAAIAPfABUD1QJVAn0CVQJVAlUD1wAAABGXAAA8A8OAOoPCghKCkoK6gtKCgoI7g8AAEhcAAAAD/4ACg7qCIoIigjqD4oI6ggODgAASlwAAOAHHADUB1QFVAXUB1QFVAVUBdwHAABLXAAAAAz8AxQI1ArUCtQP1ArUCtQKXAoACE1cAACAD3wAFAvUBtQCVAHUB1QJVAlcCQAETlwAAAAO/gESDLICkgDSD5IA0gLSAp4EgAhPXAAAAA7+AQoIOgX6AyoBKgH6DzoBLgEAAVFcAAAADPwDFACUD9QD9AOUA5QLtA8cAAAAVVwAAAAO/gEKCKoH6gSqBKoB6gKqBa4FgAheXAAO/AEUAPQP9AX0BfQH9AX0BdQJHA8AAGBcAAAADPwDFARUD1QP9A9UD9QPVA9cAQABYVwAAAAO/gEKCOoLSg3qBUoFSgfaBc4JwAlkXAAAAAz8AxQA9Af0B/QH9Af0B/QH/AAAAGVcAACABv4Bygc6ACoK+gb6B/oF+gf+BQAEbFwAAAAO/gEWCH4L9gvuB+YH/gf+COYHAABvXAAACADoAQgBCAH+BwgJCAkICegJCAgABHFcAADwDwAEAAQABP4HAAQABAAEAATwDwAAf1wAAPAD/gEAAvADAAB0AUgBSAlIDMgDAACBXAAAAAiOCYgIaAhYB08ESAJIAcgATgAAAIJcAAAMACgHKAkoCS4JKAkoCSgJ6AkMBAAAkFwAAPgH/gMAAvgLAAjoCCgFPgYoBegICAiRXEAATAAoASgBWAFeAVgBKA0oA0gBTABAAJRcAAAIAEQHSgQ4BIoHCgRKBDIEBAcIAAAAl1wAAOwPKACoAqgCLgEoAegCaAooCOwPAACaXAAAAAz8AxgA2AYeAZgBWAYYAPgHDAgABptcAAAAB3wERARUB1YERARUD1QITAjABwAAoVwAAPwPBACsByQCJALkAyQCJAKsCwQI/AepXCACLgGoAOgHqASuBKgEqASoBKgErgcgAK1cAAD8A/4DAAL8AxAASABEAlMCRAXIABAAsVwQAAgAfAcCBAgEzgcYBCgESgRKDygAAACzXEAAQAB8D1QEVATUB1QEUgRyBFAPQAAAALhcAAzgAywAqAKoAqgCrg+oAqgCqAKsAiAC4VwAAPAD/gMAAvgFAAy4BIgD/gGIAqgEiAjoXAAA8AP+AwAC+AMCCP4PEAD+BpAFVgwAAOpcAAD4AwAC/gMAAvgHwACmD5IIsAjGD4gA8FwAAPgH/wcABPwHAAAkBVcF2g9WBVIFEAT2XAAAAA78BFwFXAdeBVwFXAVcAVwJQAcAAPtcAAD4A/4D+AMAACgFjAXKAogCLgVoBAAAA10AAPAD/gPwAwAAVAPEAP4HxABUAUQCAAAHXQAJfAUYAVgJWAlcD1gBWAFYBRgFfAkAAA5d+AcAAv4DAAL4AwAAtAOsAq4LNAj0ByAAFF1AACwA6A9YBVgFXgX4B1gFWAVYBVwFAAQWXQAM/gMMCKwKrAquCuwOrAqsCqwKrgoICBddAAAAAPYPFABUBnYG1gd0BnQGFAj2BwAAKV0AAAwM7AOoCegPDgAICOgHqAKoCuwHAABKXQAA8AP8A/ADDADsBgwB/A8MAWwCqgQABEtd/AMAAv4DAALwBf4Dyg+qCq4KqgruDwAATF0gAOwPKAUoBegPDgDIDCgCqAEoBqwIYABQXQAA5g8cANwJXAn+D1wNXA2MCPwHBggABmldEACWD/QA9AD0B/QF9gX0BfQH9AiWDxAAi10AAAAA8Af+A/AJ/ARcDV4DXAtcCUAHAAC6XSAAkwCqAqoEsgcHAP4FrgWuAa4F/wUACM1dIAl8C3gFeAV4Cw4A+ATYA/gD3AbQBvAC3V0ACAAM/AMAAAAAAAD4BwAAAAAAAPwPAADeXQAAcAgABv4BIAAAAP4HAABwAAAA/g8AAOFdAAhECMgHAAT4CAQLcAiMCSAK2AgECwAI4l0AAAAF+wWoA6oD/Q+oAaoDrgX9BQAFAADjXQAAAAn+BagFqgP8D6gBqAOsBfoFAAkAAOVdAAQEBAQEBAQEBPwHBAQEBAQEBAQABAAA5l0AAAgMCAPICHwISghICMgPSAhICEgICAjnXQQCBAL8AwQBAAEEAHwERAhECEQMxAMAAOhdAAAAAP4PkgSSBJIEkgSSBJIE8gUCBAAA6V0EAgQC/AEECQAE/AMEAHQABAD8DwAIAAbrXQAFhAR0BIQEBAT8BwQFhAR0BIQEBAUAAO5dgAioBKoDrgioCfgJqA+uCaoJqAmACAAA8V0AAAAA5AckCCQIJAgkCCQIJAh8CAAHAAHyXQAABAD0B0QIRAhECEQIRAhECPwIAAYAAvRdAAAAAPwHRAhECHwIRAhECEQI/AgABgAA910AACABKAHoB74KqAqoCr4K6AuoCCAF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SAAAAP4PEAAgAMAAgABTYogAiAj+D0gASAAAAAQIBAj8BwQABAAAAFRiiACICP4PSABADAQD/AAEADwIJAjgBwAAVWKICIgI/g9IAEgIAAf4BAYEQASABwAMAABYYogAiAj+D0gAAABEAEQA/AdCCCIIIgggBltiiACICP4PSABIAAAEBAQEBPwHBAQEBAQEY2IIAYgI/geIAAAA/A8EBAQEBAQEBPwHAABnYoAAiAj/D0gAAAxIA/8AiAAIAPgHAAgABmligACICP4PSAAADPgDCAAKAAwACAAIAAAAa2KIAIgI/g+IAEgAAAREBEQERAREBPwPAABsYogAiAj/B4gAAAqiCXIEKgPmCCIO4AEAAG1iiACICP8HiABACAIIQg7+CUIIQg7+CQAIbmIIAYgI/g+IACAIUAROA8AAQghOCPAHYABvYpgAmAj+D1gAAAj4DwAIAAj/DyAIIAggCHBiiACICP4PiABACBAE0AM+AJAHFggQCBAGcWKIAIgI/g9IAAAH/ADEBAQFPAOQBHAIAABzYogAiAz+A4gIAA78AWQEpAUkAqQFZAgACHZigACICP4PSAAACEgESAP+AEgDSARICAAAeWKIAIgI/g+IAAAA/g8gBAAA/gcgCBgIEAZ+YogAiAj+D0gAAAgQBD4C0AMSBdQIFAgQBn9iAAAQBBAD9AAECqQK9AesAgwC5AAgAxAEgGKIAIgI/g9IAAAIaASoBT4CKAXoBCgIAACEYogAiAj+D0gAAAh4CAAE/gQAAowBUAAAAIpigACICP4HSAAAAPwHRAhECHwIRAhECPwIkWKAAIgI/gcAAPwHAgICAPwPBAAEBPwDAACSYogAiAj/D0gAAAAiCCoI6g82AKYAYgAAAJNigACICP4PSAAADvwBBAD8DwIA/gACDwAIlWKIAIgI/gdIAAAI3gRCBUIC3gVQCAgIAACWYogAiAj+D0gASAAAASIBTAEAAf4PgACAAJdiAACIAIgI/gdIAAAM6AMuACgA6AcICAAGmGKIAIgI/gdIAAAO/gEiACIAIgDiDyIAIgCaYoAAiAj+D0gAQAgEBKQDfADkByQIJAggBJtiAACICP4HSAAAD/8A+AcACfgIDgr4CQAEnGKIAIgI/g9IAAAMiAN+CKgFKALoBSgICAieYggJiAj+D4gAAAz8A0QARADEAUQCfAwACKJiiACICP4PSABAABAAyAcnCCUJyAgQBhAApGKIAIgI/gdIAAAM+ANIAEoASgBIAPgAAAClYogIiAj+D0gAAAD+DyIA8gwyAzIF7gQACKtiCAGIDP4DiAgADvgByAV+BkgFyARYCAAArGKAAIgI/g9IAAAAsA+sBKIEoASkBJgPIACxYpAAkAj8B1AAAACwB64IqAjoCQgJ+AgABrViiACICP4PSAAAAPwPJAQiAD4M4gciCCAGuWKIAIgI/g+IAEAECAJIAf4PyABIA0gEAAC8YoAAiAj+B4gAAAD8AaQApAD8D6QApAD8Ab1iiACICP4HCADgD5AEkAT+B5AEkATwDwAAwmIAAJAI/AdAAOgMqAL+AagA/g+oALgHAADFYogAiAj+D0gAAAj8CSQJJAkkCSQJ/AkACMZiiACICP4HiAAADPwDIgCiAOIPIgEiAgAAyWKAAIgI/g9IAAAEKATIBQoECAfoBAgEAADLYgAAiAj+B0gAAA/+AMgHAAn+CggK+AkABM1iCAGICP4HiAAAAPgPiASOBIoEiAT4DwAA0GKIAIgI/AdIAAAIvASkAqQBpAikCLwHAADSYogASAj/D0gAAAD+D5IEkgSSBJIE8gQCBNNiiACICP4PSAAIAYAA5A9cBEQERATEDwAA1GKIAIgI/g9IAAAMiAN+CKgFKgKqBWoICAjWYoAAiAj+B4gAIACQAM4HSAjoC0gI6AsICNhigACICP4PQAAQAMgDLgEoAegJCAj4BwAA2WKAAIgI/gdIAAAAvAcgBP4HIAQgBLwPAADaYgABGAn+B5gAAAiYBNQDkgCQANQPmACgANtigACICP8HSAAAAKIPmgSGBKIEogSeBwAA3GIAAJQMlAL8AZIAAwAoASoB/g8qASoBAAHdYogAiAj+B0gAQAEUAVQB/A9UAVQBBAEAAN9igACICP4PSAAABP4DAAG8DAACwAE+AQAO4GKAAEgI/gdgAP4MiANwBPwJBAj8CwAKgAnhYogAiAj+D0gAAA74AQgEiAduBAgFCAUIDuJigACICP8PiAAADpABfgwQBPIHlAhUCBAE42KAAJAI/AeQAAAE6AK4CqwI6A+IAIgCCATlYoAAiAj+B0gAAAz+A5IAkgD+D5IAkgj+B+ZigACICP4HiAAABJIElgSQBJgElgQQBAAA6GKAAIgI/geIAAACHAnQBH4FUALUBVQIEAjpYogAiAj+D0gAAAKkApwC1A+cAqQCJAIAAOxigABICP4PSAAAAJIPkgj+CJIIkgiRDxAA7WKAAIgI/g9IAAAEUATQBxAE/AEQBhQMAADvYoAAiAj/D0gAAAnSCCIK+gsmCNIIEgkAAPFigACICP4PSAAACIgE/gKIAIgA/gKIBIAI82KgAKgCagJsC3gL7gcoAygDbgKoAqAAAAD3YgABEAn8B5AAAAAoAagD/AqoCrgKqAYkAPxiAAEICf4HyAAACIkE+gOIAIgA/A+LAIAA/mKIAIgI/gdIAAAAmA+EBKIEogSkBIgHMAD/YggByAH4AfwF+gX6A/oB/AH4AfgBiAEIAQFjkACQCPwHUAAAAKgCqAK8CKgI6AeoACAAAmOAAIgI/g9IAAAIJAkkCb4PJAkkCSAJAAAHY4gASAj+D0gAAADeB2QFZAVkBWIF4gcYAAljCAEIDf4DCAhACFwIxAV3BkQDxARcCAAAEWOAAIgI/g9IAAAJiAT+AwAA/gdACJwIhAYWY4AASAj+D0AABABUBFQLRgnUCFQIBAYAABljiAJKAiwCuAqqCuwHqAKIAj4CSgJIAgAAH2MAAQgJ/gfIAAAIqAiIBv4BiAOoBIgIAAAgYwAAiAj+B0gAAAikBKYDvAC0D8wIrAiABCFjiAGICP4HSAAABC4FIAU+BSAFKAXmDwAAI2OAAIgI/g9IABAAWAlWCfQHXAFUAfABQAAkYwAAiAj+B0gAAAhEBEwDNgAkAFwPRABEACVjAACICP8HAACWAtICsgKaAtIPkgKWAgACKGOAAIgI/gdIAEAJLAUrA+gDKgMuBSgJAAgqYwAAiAz/AwAIkgb+AZII/gf8DwIA/gMAACtjgACICP4HSAAgCBwJYAn+DyAJHAkgCUAAL2OAAIgM/wOICAAO/gHCD1IE0gVSAVIOAAg6YwAAiAj/D0gAAgw+A+IEAAgiCf4JIgkiCT1jgACICP4HQAAQCPgIlASWAvQBnAeUCPAIRmOAAIgI/wcAAP4PAgRSBPoFUgQCBP4PAABJY4AAiAj+D0gAAAy8AyQE5A+kCKQIvAgACE1jiACICP4PSAAAAX4BagFqAeoPagF+AQABT2OIAEgI/g9IAAAEvgSqBKoHqgSqBL4EAARQY4gAiAj+B0gAAADuD6oCqgKqCqoK7g8AAFVjCAGICP4HiAAAAOgPqAKoAv4PqAKsCuwHXGOIAEgM/gMACLwErAWsBv4ErAasBbwIAAReY4AAiAj+D0gAAAiUBJYC1AGUCJYMNAMAAF9jgACICP4HSAAACOAJLgQqAqoBKgQuCOALYWOAAIgI/g+IACAEmAUkBKIFJAQIB9AEAABiY4gM/gNACBAI+ASUApYB9AGcApQE9ASACGNjAAEICf4HiAAABvwEhAaWBIQGvAiABwAAZ2OAAEgI/wdIAAAAagK+AqsPqgLqAqoCAABoY4gAiAj+B0gAEABMB1IFegVSBUQFSAdQAG5jQABICP4PSAAAB/4AMgeyBPIEsgS+BwAAcmMAARAJ/A+QAAQC1AdwCVwNUA1UDtQIQAN3Y4AAiAz/A0gIAgiqBqoEqgT/D6oK+goiCIBjAACICP4HAAD8DxQA9A8AABQO6gEIBjgIg2OAAEQI/wcEAGAAtQe1APUPtQC/BOADAACIY4AAiAj+B8gAYAhoCKQEqgeiBLoGagUACIljiAj+B0gAAAL4AqgCqAKuD6wCrAL8AgQCjGMAABwCzQL/AvwK/gf8AvwC/wKNApwCAACPYwABCAn+BxgAjAKqAugDqAKoCogI+AcAAJJjiACICP4PSABAAAgBKAHWDvwHKAEoAQAAmGOAAIgI/gcAAP4PCgDqDooI6g+KCO4OAACZYwABCAn+B4gAAAKsCqQK6geiAqoC6gOAAJtjgACQCPwHAAAoBb4HKAUAAPwPQADAAAAAoGOAAIgI/g+IAAAE9AKUCJYHlACUAvQCBAShY4AAiAj+B0gAAASUAoQB1A+CAbICigQAAKJjAAEICf4HwAAMBKQClAHED5QBpAKsBAAApWOAAIgI/gdIAAAIpAqsC6YEpAa0BaQIoACnYwABiAj+D0gADAikCJQIhg+UCKQIDAgAAKhjSABICP4PQAAwAPwPqgSoBP4HqASoBAAEqWOAAJAI/AdQAAAA6AO4AqwC6geoCrgK6AuqY4gASAj+D0gAAADUB14FVAVUBV4F1AcAALBjAACUCPwHsgA4BuYB/AMQCJII/geSAIAAsmMIAQgJ/gcIAAABvgPqBaoEqgKqCL4HAAC3YwAAiAj+B0gAAg74AU4HAAD+DwIA/gMAAMljgACICPwHSAAACXQFHANcD3wDFAU0CRAAz2NAAEQE/wMkAAAA9A+UBJcE9AeUBJcE9A/QYwABCAn+B4gAAAy+AqoEqg+qCqoKvgqACNJjAABEBP8DRAAAAOoPqgQKBP4HCQTpDwAA2mMEAYQM/wfEAAAG3wNVCVUFVQNVCV8HAADbY4AAiAj+B4gACAh4CTYFlAM8A1AFcAkACOFjAACQDvwBAAz8AzQItAr0CrQPtAq8CgAI42MAAIgI/gdAABwPsACwD/4AsA+wALwPAADqY0AAiAj+B0AAEgH+D0IAGgwAA/4AAAM4DO1jAAEICf4HiAAAAP4G6gSqBaoIqgi+BwAA7mMgAEgI/gdIAAAC+gK6AroC+g+6AroC+gL0Y4AAiAj+D4gAAgRWAvIJ1gbSBNkHVQhACPpjiACICP4HSADAAIwOpASsBOwHogSyBKoO/WMAAIgM/wNACB4IwAteCEAHVgjUCwQIAAQBZAAASAj+BwAA8g9CAFgHqgLaAgIL/gcAAAJkQACICP4PSAAACKoKmAveBJgGqgWqCIAABWQAAIgI/gdAABoI/AU4BLoHOAjuCQoIAAYNZIgAiAj+D0gAAAjsBewD7AHsAewF7AkACA9kgABQCPwHkAAAAHgDeAN4AX4JeAl8B3gBE2SAAIgM/gNICAAM1QNWCHwJVA9XCVQJAAAWZAAACAn+B4gAAAJUCsQKpgqeD4wKhAoAABxkiAj+B0gAAAi8CLQJoAb+BKAGtAm8CAAIHmSAAIQI/wckAIAPWgBaB1sFWgdaAMIPAAAsZAAAEA78AYAM+AN+CfgHAADeDUICngUgCC1kAACICP4HSABAAG4HVgVcBWQFTgdEAAQANmRAAEgI/A8gAJAPaAB4B3QFcgV0BWgHEAA6ZAABBA3/B4QADAj/BasDqgH/BasDqg6CAERkAACIDPwDKAiABLwGvAG8BbwGvAakCQAARmSAAIgI/gdAABwFVA1cC9QJXAVUBVwJAABHZIAAiAj+B0gAAAasBKQE6geiBKoEqg4AAEpkAABICP4POALIATgBMAD+D6gE/gesBAAEVGQAAIgI/geAAIgCBAK0Au4OxAIEArQCgABYZIAAiAj+BwgA4A8UAFwH9gVcBxQI9AcAAGdkAABICP4PSABMAOgHaAVuBegHaAVsBQAAaWQADPwDBAC0A7QLtguEB7QDtAN0A3QDVAJ4ZIAASAj+D0gAAAl0CXYH9AF0A3YFdAkECYNkAAL8A/wD/gv8C7wH2APWA1IDdgNUAoACh2QAAIgH/gDwD14A/AdwAPQHOgbFATwGAASQZJAAkAj8B5AAGAj8C9gG3gbYAv4PmAIAApFkgACQCPwHAACYA/wL2AvcB9gD/AMYAwAAkmSICP4HSAAQAPQPvgK0Cv4PEAjuBogDeAyVZAAAkAj8BwAA/A1YAfwFAAD4DyQA5A8kAJ5kSAj+B1gAAAj0CvQK9Ar2D/QK9Ar0ChAIpGRAAEQM/wcAAPIPvwLaDxAIOATHA3wMAAClZAAACAn8BwgAoAu8CuQOQAsoBfwHqAkAAKtkAAGQCPwHUAAADfwBKgHoDSgB6A0oAegNrWSAAIgI/gdYANQAVAe8BbwHlAW6BdIHkACuZIAAhA7/AWAE4Ae/BrUG9Q91BHUD/wVgBLBkAACICP4HoABOCfYFVgVAAU4F9gVWBUAJsmRAAEgI/g9IAAIJeAVuA+gBbgN4BWoJAAi8ZAAASAf+AAAO/AEsAdwHrAN/AqQDFQQAA79kAACICP4HCADoDLQC9AQSAPIMtALkBAgIwWRAAEgI/gcAALQMZAMEAPoHVAX8B1QFAATFZAAAiAj+B0AAfATMB/wH/gf8B8wHfAQABMdkAABICP4HIAC+AvoCvgK6D74C+gK+AgAAymRABPwE/Af+B/wO+A+QB+4GogbmBqgECAHLZIAASAj+B0gAAACaB/wF2AXeB9gF/gWKB81kAACQDPwDEAjABbwF9AOUD/QDvAXgCQAAzmQUADwCvgO4A84LvAuED6gDtgOUAywDRALSZAABiAj+B4gACA7EAZIH2gXyA7QJxA8AANRkgACICP4PSAAYDvgBrgy8D8wPvA/IDwAA2mSAAEgI/g8ABPgDGADYBf4DfA9sAWwGAATgZAAAiAj+BwgAYAzUA+QCvgK8ArwC7A8EAOZkAAAIDf4DCAksCZQB1Am+D7QB9AEcDQAA7GQAAIgI/AcAAF4N1ANUDAADLAT0DzwJZAj0ZIAAiA7+AQAM/ANECPQL9Av2A/QL1AsAAPpkAACIDP4DwAh2B8oM7gcKAG4GqgquCgAA/mQAAYgI/gcIAMIIfgreB14HXgf+C8IKAAgAZVQAzAJeAkwD4AvmC9QHwgNIA14CzAJUAA9lAACYDP4DAAjoB2YC9A8AAN4H1Av0CgAAFGUAAIgI/gcAAP4H9gR+A/AH7gP2CP4HAAAcZUAAJAT/AyAAiw9+AfoCewb6AXoE+wcgAB1lAACQCPwHUADEA/wC/A88APwD/APkByACJGUAAAAASAj+D/4L9Af+DvQPrgT6B6gEAAAvZQgIKARoBKgEKAM+AigDqARoBCgECAgAADZlAAD8AwABAAH+DwAAMARuBIgD6AIYBAgIOWUAAOQBJAIkAXwFYAwwBM4CCAHoAhgECAg7ZQQBBAH8AQQJZAkQBG4CiAOIAngECAgAAD5lAAgIBvgBKgjIByAAEAzuAogDeAQICAAAP2UEBPQDBAL8AyQCZAgwBO4CCAPoBBgIAAhFZQgAyA9IBH4EyA9gCDwEygKIA3gECAgAAEhlCAioBIoCjAMoBEAAMAzOAogDeAQICAAATGUAAJIPkgT+BJIEgg8gABQM6gKIA3gECAhPZUAA+AFWAfQFVAX0A2AJHgTlAsQDPAQECFFlCAJoCQgJ/g/IAAoJYAh+BIkD6AIYDAAAVmUABFQC1AH+BNQE1ANAAH4GiAFoAhgGAARXZQAI/AVUBVQB/AVgADgMzAKIA3gECAgAAFhlUAJYCVQI8gdEAGQLMAjuBAgD6AQYCAAIWWUAAlQCVAneD/QBWAk2CHwEiwPIAjgMCAhdZQAA9g/QAf4P0AH2DwAIPgTJA+gEGAgAAF5lAADuD+ABfgKgCe4PQAh+BIgD6AQYCAAAYmUAAAgC+gOqAqoC/g8AADAM7gKIA3gECAhjZQAA6g+vAqoCrwrKByAAGgx1AsQDPAQECGZlCAL4CtgK3A7YA3gKYAj+BAgD+AQICAAAbGVEAPQDVgHUCRYM9AMwCG4GiAHoAhgMAAhwZaAIqgqYB/4EmAeKCCAIPgTJA4gCeAQICHJlAAD0D/QD9gJ0CfQHAADgDD4DKAPoDAAIdGVAAFwIPAi+DrwI3A/YCrYKtApMCEQIAAB1ZQAA+g8OA/sCDgn6BxAAPwzEA3wGBAgAAHdlAAS/AqsB/wWrBb8DmAg/BMIDcgIODAIEeGUICXwLfAv+BXwFfAtgCTAE7gN4BAgIAACDZQAAXQl+Bf8HVANeAWgA5gNWBVwFZAVABIdlAAAICAgIGARoBIgCCgGIAmgEGAQICAgIiWUiBBIM0gNWAVoBSwFKAVYBVgHSBxIAEgCLZWQAZA9kAVQBXA/WAVQBXA9kAWQJZAdgAIxlCAhoBI4DfAIACNQP9AcQAP4DEAQWDgAAjmUkCCQPpAAcAlQJVg9UASwFJACkDyQAAACQZaQIrAisBKwFngbAAoACvgasBawIrAigCJFlAAAkBPwDAAgoBsoBOAIACEQI/A9ECAAIl2UAAhACJAEkAUgBCAEAAf4PAAGAAIAAAACZZQwAoAP+D6AArAAAAiQBSAEAAf4PAAEAAZxlAARYA1QI8g9UAAQDIABsAQAB/g+AAAAAn2VAAMgDfAX4BPgFfAUABCgAgAD/B4AAAACkZQAAAA78ASQAJAAkACQA4g8iACIAIAAAAKVlAAAADPwDJACkACQBJAHkDyQCIgIkAiAAp2UAACAIKAykA1YBWAFYAVoPZAFkASgBAACpZQQCdAJOAuQPRAEADPwDJAAiAOIPIgAAAKxlAAD8AqwC/g+sAvwO/AMkACQA4g8iAAAArWX+DwAElAVQBP8FUAQEDPgDJAAkAOIPIgCvZQgJ/AVYAVgF/AEADPgDJAAkAOQPJAAAALBlAASoBKQC5g+kAqgIAAT8AyQA4g8iAAAAt2UAAP4H6Aa+BbwH/gecCvgHJADiDyIAAAC5ZQgICAgIBIgDeABOCEgISAhIDMgDCAAAALxlAAAIDvoBKgjoBwAAEAJIAkYEiAgQABAAvWUAAAgO+AEuCOgHAADuB0oI6AsoCOgJAATBZQAIVAhUBFwC1AFWAVQJVAlcCVQHVAAAAMVlAAgIBvgBLgjIBxgAxw8kAFQBjAJMDAAAy2UAAAgM+gMsCMAHEAysAyoE6A8oCWgJKAjMZQAACA76ASwIyAcYAKYEpAT0B6QEpAQEBM9lAAgIDvgBLgzoAwAIjwi1BuQBpAKkBAAI12UICAgO/gEoDOgDGAj+BXQFdAH0BRQJAAjgZSAIJAgkBCQCpAF8AOQHJAgkCCQIIAgABuJlAAD8D1QEVAN8BwAAdA5EAfwPRAhECEAG5WUAAAAA/A9EBEQERAREBEQERAT8DwAAAADmZQAIAAj8CSQJJAkkCSQJJAkkCfwJAAgACOdlAAD8DwAAAAD8D0QERAREBEQERAT8DwAA6GUAAAAAzgdUBVQFVAVUBVIFUgXSBwgAAADpZQAAAAE+ASoBKgHqDyoBKgEqAT4BAAEAAOxlAABgABAAzgeqAqgC6AsICAgICAz4AwAA7WUACAgO/gEIAPgHAAj8CSQJJAkkCfwJAATxZQAAQAFeAVYBVgHWB1YBVgFWAV4BQAEAAPZlAAD8ByQCJAL8AwAAaACICQgI/gcIAAAA92UAAPwHJAL8AwAI+AcIAAoADAAIAAgAAAD6ZQAA/AMkAvwDAABEBEQE/AdEBEQERAQAAAJmAAQAB74EqgSqAioAqg+qAKoEvgSAAwAABmYAAAAEvgeqBKoCKgCqA6oEqgS+BIAEAAIHZgAAgAm8CWwFrANsAWwBLAGsDzwBAAEAAQxmAADAD34FagVqBWoFagVqBWoFfgXABwAADmYAAPwDJAEkAfwJAAT8AyQBJAkkCfwHAAAPZgAAQAD8D9QKtAq0CpwKtAqyClIPUAAAABNmAAEACfwE1ALUAdQM1ALUCdQI/AiABwAAFGYQABQA1AdeBVQFVAVUBVQFXgXUBxQAEAAfZgAAgAi+CqoKqgqqCqoPqgqqCr4KAAgAACBmAAD8ByQC/AMACPgIiAb+AYgCiAT4CIAIJWYAASIDqgDqD7oKrwqqCroK6g+qACIBAAAnZgAA/AckAvwHAAxIAkgB/g9IAUgCSAwAAChmAAD8ByQCJAL8AxAADgD4DygBKAEoAQgALWYAAPwDJAL8AwAAog+aBIYEogSiBJ4HAAAvZgAIgAj8BtQE1ATUCNQP1ArUCvwKgAoACDFmAACABL4EqgWqBKoEqgSqBqoEvgSABAAAPGYAAfAEDgTqB6oGqgaqBqoG+gdOBIAFAAA+ZgAEgAS+BSoEqgcqBCoEqgcqBL4FgAQABEJmAAD8ByQC/AMAAKQCpAK+CKQI5AekACAAQ2YAAAAJPgmqBSoD6gEqASoHqgk+CQAJAARJZkAAVADcD9wK1ArECtQK1ArUCtQPRAAAAEtmAAASANYPUgVeBVIFUgVeBVIF1g8SAAAATGYAAPwHJAL8AwAA+A8IAOgDLgHoCQgI+AdSZgAA/AckAvwB8A+KBX4ECgR+BIoE+g8AAFNmAAD8ByQC/AMACKgErgOYALgPzAisCIAEVWYABOAEvAa8B7wGvAa8DrwGvAbgBOAEAARaZgAA/AckAvwLEAj4BJYC9AGcD5QI8AgABGRmAAD8ByQC/AMgAKoHvgSuBKoEugSiBwIAZmYAAP4DEgH+AQAA9gNLAtoKSgpKBvoDQgJoZgAM4AM8AXwJfA98CXwFfAN8BXwLIAsAAGlm/AckAvwLEAj4BJQDlgD0AJwPlAjwCAAEbmYgACQA7AdmBXwFZAVkBXwFZgXsByQAIABvZgAEIASuB64Crgq+Dq4CrgauBq4HIAgACHBmAAD8ByQC/AMAAf4PyAAADPgDJADiDyIAdGYAAPwHJAL8AwAA3A/cAt4C3ArcCtwHEAB2ZgAAwAdABX4F6gcqAOoHagV+BUAFwAcAAHpmQABQADYPvAq0CoAKvAqkCqQKpA88AAAAgmYAAD4Asw+6CrIKsgqACr4KkgqyDxEAAACHZgAA/AdEAvwDAAD8D6QCHArACFQH3AlACJFmAABAAfwA/A/8CvwK/Ar8CtwK/A9QAAAAlmYAAPwHJAL8CQAESgLyCdYG0gTZB1UIQAiXZgAA/AckAvgDBADUB1wFVgVUBVwF1AcUAKJmAAD8A/8PJAEkAfgBnguqBqoOqgK+DgAAqGYgCD4Irg+uDa4Nzg3ODaoN/g3KD2oIIACrZgAAPgC2D78Ktgq+CpwKigqKCroPCQAIAK5mRAFEAfwP/gr8CvwK/Ar+CvwK/A9EAQACtGYAAqACvAm8BfwCvA68APwGvAS8CaACAADGZgAM/AMEALwPvAq8CoQKvAq8CrwPFAAAAMlmAAD8ByQC/AsMCewHrAEOAawP7AmsDQAF2WYAAPwHJAL4A04D2gd+BloG/gbaBk4HAADcZgAA/AMkAvwDgAGqB2oHXgfgB1oHXgcABN1mAAD8ByQC/AMACLwF/A68DrwE/AS8BYAA8GYAAAAA/A9EBEQERAREBEQERAQEBPwPAADyZgAA+A+IBIgE/geIBIgE/geIBIgE+A8AAPRmAAAECPwJrAWsBqwG/AWsCKwI/AgECAAA+GZIAHwA/A/8CvwK/gr8CvwK/Ar8D2gAAAD5ZgIAfgDWD9YK/wrWCtYK/wrWCtYPfgACAPxmAAjgCbwJvAn8B7wFvAX8BbwLvAngCAAI/WYAAHwA1Q/WCtQK/ArUCtYK1Qr8DwAAAAD+ZgAAAAD8D30FZgV8BWQFZgVtBeQPPAAAAP9mAAAsAJwHXgVMBUwFQAVcBU4FnAcsACgAAGcAAEAE/gfqBeoF6g9qCOoF6gL+BsAFQAgDZwAAEAB4ANgP/Ar6CtwK/ArYD2gAEAAAAAhnAAgABvwBJAEkASQBJAkkCSQJ/AcAAAAACWeAAIgASAD4D6wCqgKoAqgKqAroBwgAAAALZwAAAAz+A5IAkg7+AQAM/gOSCJII/gcAAA1nAAz+A5IIkgj+BwAA/g9iALINMgP+DAAIFGcAAOkIigb4AY4A6QgABv4BkgCSCP4HAAAXZwAE/AdUBFYCVAN8DAAG/AEkASQJ/AcAABtnAAAUBFwFVgVUBcAHXgVOBW4FbgV+BAAAHWcAAPwDLAMuDywD/AkABPwDJAEkCfwHAAAfZwAACAn+BVgBWAX+AQAM/gOSAJII/gcAACZnAAj+B5IA/g8QAEwF/gN8C3wHfgF8BkAEKGcQBBACEAGQAFAA/g9QAJAAEAEQAhAEAAAqZ0AISARIAkgByAD+D8gASAFIAkgEQAgAACtnCARIBEgCSAHIAP4PyABIAUgCSAQIBAAALGcIAggBiABIAjgC/w84AkgCiAAIAQgCAAAtZwACiAFIAP8PSAAAAP4HAAgACAAIAAgABi9nAAAQBBACEAGQAFAA/g9QAJIAFAEUAhAEMWdABFAETgJIAcgA/g/IAEgBSAJIBEAEAAA0ZwAAiAFIAP4PKADIAAAA/g8wACAAwACAADVngAigBJAEjgKCAcIPggGCAZ4CoASgBKAIOmcAAIgDSAD+D0gAAA78AQQABAD8BwAIAAY9ZwAAiANIAP4PSAAAAGQAXAhECEQMxAMAAEBnAACgBKQCpAKUCpgIyA+YAJQCogKgBIAEQmeAAKAEpAKUCowIxg+EAIQAvAKgBJAAAABDZwAAiAFIAP4PKADACBwEZAKEAcQCPAQECEZnAACIA0gA/g9IAAgAQABEAPwPRABEAEQASWcAAIgBSAD/DygACACACJgERAIiAhEBgABOZyQBFAFUAUwJRAleB8QBTAFUARQBJAEAAE9nSAAoAKgPmAiYCL4IiAiYCKgIqA8oAEgAUGcAAIgDSAD/DygAQAIIAcgIKAj/BwgAAABRZwAAiANIAP8PSACIACAAyAkICP8HCAAAAFZniAFIAP4PKADICAAE6AKIA3gEDgQICAgAXGcAAIgBSAD+D0gACAQgBCAE/gcgBCAEIARfZwAABAj0BJQClAH+D5QBlAKUBPQEBAgAAGFnEACoBKgCrAKWCNQHlACsAqQCoAwgAAAAZWdABEQEVAJEAcQA/g/EAEQBXAJMBEAEAABoZwgDiAD/D0gAAAqiCXIEKgPmCCIO4AEAAG1nAACIAUgA/w9IAAAM6AMqACoA6AcICAgGb2eIAUgA/g8oAIwARAAkACQA/A8EADQAxABwZ4gIiAZIACgAGAL+DBgAKAxIAIgGiAgIAHFnAAAEBPwErAKsAf4PrAGsAqwC/AQEBAAAfmeIAUgA/wdIAIAEOASGB2AEAQSOBTAGAAB/ZwgDiAD+D4gAAAz8A2QIpAUkBqQFZAgAAIFniANIAP4PSAAADIQDfAiEBTQCLAXgCAAIhGeIAUgA/g9IAAAAnAFqAQgJyAkIDPgDAACJZ4gDSAD+D0gAiAAACEQIRAj8D0QIRAhECJBniANIAP8PSACIAAAM/AMiACIA4g8iACAAlWeIA0gA/g9oAIAIOASIA34A6AcICDgIAAaXZwAAiAFIAP8PKAAoAoABSAD/D2gAiAMAAZpniANIAP8PSACgCBAEbgSIA8gCOAQICAAAnGcAAIAEvgSqAqoBqgH+D6oBqgK+BIAEAACdZ4gBSAD/D0gAiAggBKgEKAU+AigF6AQICJ5ngAFIAP8HSAAAB/4AAASAA34AgAMABAAAoGeIA0gA/g9IAAABJAEcAQYBhA88ASABEAGiZ4gDSAD+D0gAAAD8DwQIFAvkCLQJBAoACKNnAAAEAbQAlARUBH4JVApUCpQKtAAEAQAAqmeIA0gA/w9AABAAyAckCCMJJAnICBAGEACrZ4ABSAD+DygAQA/8AAQG9AEEAvwHAAwAAK9niAFIAP4PSABAABAPkAT+BJAEkASQBxAAtmcAAKQIlASOAoQB3A+AAbwCpAKkBLwEAATEZ4ABSAD+DygAAAD0DxQAlAF8AJQJFAj0B89nCAGIAP4PSAAAAPgPiASOBIoEiAT4DwAA0GcAAIQEhAS+AqwB7AesAKwBvgKEBIQEAADTZ4gEqgSqAoACpAG0D44BhAL8AsAEwASwBNRnAAlQCVQFNAN8A9wPdAMcAxQFNAkQCQAA2GeIAUgA/g8oACgBgAD0D0wERAREBMQPBADcZwgDiAD+D0gAAAD8DyQJJAkkCSQJ5AkECOVnAABICCgIqA9YDVwNSA1YDagPKAhICAAA72eIA0gA/g9IAAAA9AMUAfQJBAj8BwQAAADxZwAAiANIAP8PyAAICQAIigj6D4wIiAgICPNngANIAP4PAAD8CQIF+gIAAPwPBAD8AwAA9GegBL4EoAK/AqQBgA+fAaQCpAKkBKIEkAT7ZwAAJAgUCNQPrAquCqQKrArUDxQIJAgAAANoiAFIAP8PSAAAD/wAFA70AVIIUgjSBwAABGgABFAEXAJQAdIA1A/QAFABWAJUAlAEAAQHaIgBSAD+D0gAiAQgAqQJJAjkDyQApAEgBgtokANQAP8PUAAEBnwBRwjkD0QARAMEBAAAD2iIAUgA/g9IAEAEEgSWBJAEmASWBBAEAAARaAADiAD+D0gAAAbkARwDQADQCRAI/gcQABZoiAFIAP4PaAD6D4oFfgQKBH4EigT6DwAAF2gECXQJVAVUBXwD1A9UAXwDVAVUBXQJBAkhaIgBSAD/D0gACAhgBBgE2AIOAcgCKARICCpoiANIAP4PaACABBAETgPIAP4PyAFIAkAEN2gIAYgA/g9IAAABSgFKAfgPSAFOAQgBAAA4aIgBSAD/D0gAiAggBGgFmAROAigDqASICDloiANIAP8PSAAAAP4PUgjSCFIBUgZ+BQAJPGjEASQA/w8EAEwA5A9nBFsEWgRmBOIHQAA9aBAEVAJUAd4PVAFUCRAE/gIQA9IEFAgABj5oQAhkCRQFBAU8AwYPRAE8AwQFFAUkCQAIQmiIA0gA/g9IAAAIJAkkCb4PJAkkCSAJAABDaIADSAD+D0AADAmABP4DAAD+B0AInAgEBUZoiANIAP4PKABAAPwPBAhUCvQLVApUCgAISGgAAJQJlAW0BVQDVg9UAXQDlAWUBRQJAAhMaAAAAAl4BVgFWAPeD1wBXANcBXwFBAkAAFBoCAOIAP4PAAD8DwQA1ANUAtQDBAj8BwAAUWiQCZgFXgV+AxYBhg9WAVoDWgWwBYAJAABTaMQBJAD/DyQAAAT9BSUFJQUlBSUF/QUBAFxoiANIAP8PSADKCEIIxAVxBlYCQAXcBEIIY2iIA0gA/w9IAAIELAUgBT8FIAUoBeYPAABlaIgBSAD+DygAgAhUBDQDHAAUADIPUgCAAGZoiAFIAP4PSAAAAXwBAgGQDz4BSAFGASQAaWjEASQA/wcUAAAO/AEEBCUE9QckBCQEAAB2aIABSAD+BwgA4g9SAVoB+g9WAVIJ8gcAAH9oiAFIAP4HSAAAAX4BagFqAeoHagF+AQABgWhMCWAJEgVYA0IDMg8OAUIDQgU+BQwJMAmFaBABkAD8D5AAoATYA6wCqALoC6gK6AeAApNoCAOIAP4PSAAAAFQBRAHGD3QBRAFEAQAAnWgAACAA/A8CAPgDAACoBq4AlA+0AKwCpASiaIQBRAD+DyQABADxB1YBUAFeAVAF9gcAAKZoAAASCYoEXwRGBWoCSAJKAd8ARgAKABAAp2iIAUgA/gcoACAAqge+BKoEqgS6BKIHAACoaEAIKgkaBX4FGQOqDwABHgNABUAFfwkACa1ogANIAP4PSABAClgJHgXKBpgGngmoCAAIr2iIAUgA/g9IAAAE6gSsAvgPqACuBLgDAACwaAADiAD/D0gAgAzoA4gA6A/+BAgH6gggBLNogAFIAP4PSAAADLQDLACnDyQAtA8gBAAAtWgAADQIDATeA0wBVAFAAkwA3gcMCBQIJAa2aIgDSAD/D0gAAA/+AAoCqgLqB0oJTgkABMBoCAGIAP4PQAAQBQgFJASiBAwGkAVQBAAAxGhECVQF1AXMA8wB7g/MAcwDzAPMBVQFVAnJaIQDRAD/DyQAQACeB6oAqgDrD6oAvgSAA8toiAFIAP4PaABACQgF/gVYAVgB/gEIDQAAzWiQA1AA/g9QAAAA/A9UCVQA1Ad8CQAFAADSaIgBSAD+D0gAAABsAjwCrg+sAjwCbAKgANVohAFEAP8PZABMBkQBVATXB1QARAFMAgAA2miAA0gA/g8ABP4Dkgj+BwAM/gOSCP4HAADfaIgBSAD/D0gAAAT8BKwCrAH+D6wBrAL8BOBoAAgYCQoFfAVYA94PWANYA34FCgUYCQAA42gIA4gA/g9IAIAIFAZUAP4PVABUBXwFEAjuaAAApASUAtQPjAKMBD4EjALUD5QBpAKABPVoAADEASQA/w8kAAAD3wD1B/8H1QBfA0AC+miIAUgA/gdAABwA/Af0B1YFVAVkBQwHAAAFaYgDSAD+DwgAIAC0B6wCrgssCOQHIAAAAA1pyAAoAP8HCADgDwQE/AVcBV4FXAX8BQQEDmmIAUgA/g8AADAA/A+qBKgE/geoBKgEAAASaYABSAD+DwgAIA3+AygIgAkcBOQDdAYMCBxpkANQAP4PEADwCTgJNAXyAzQDOAX4CRAIMGmAA0gA/g8AAPwDVAL8DwAA/g8CAP4DAABKaRADkAD8D5AAAAj8B9QB1AXUA9QJ/AcAAFNpgAFIAP4DAAz+A0IAqgT6B6oEQgT+AwAMWmkAAFQITAZeA1QEwA9UCUwJXglMCNQIAAheaQADiAD+D0AAHAhUBNwDVAFcCVQJXAdAAGNpwAEkAP8PFACAA38A5Q9VBVcFVQX1DwcAbWkICWoFbAV4A24B6A9oAX4DbAVqBQgJAAB1aYgDSAD/DwgA4gmiCO4I+gtCCJIJcgoAAHxpgAFIAP4PKACICKoKmAfeBJgGqgWqCAAAfWkAAKQEpASAAvwB1gfUAfwBgAKsBKIEAACCaQADiAD+DwAA/AdUAnwJIATEA3wPRAhEBIZpgAFIAP4PCADwB7gC9A8WANYDBAjoBwgAnGmIAUgA/g8IAEAIXAbcAVYJVAlUCVQHAACuaQAE4gTsBK4CogCgD7IAqAKmAqgEogQAALRpAAOIAP4PyAAAALwPogqQCqQPnAqECrwPy2kAAMgDKAD/DwAA/A++ArwC/AO+CvwHEALNacgAKAD/BygACAboAXwHewV8BXQFdAcAANBpgAFIAP4PCAB8AFQIVgf8ANQHVAl8CwAI2GkIA4gA/g+IAAAEVgVUAPwPVAJWBVQFAAD9aYgDSAD+D0gAegDaD/8K2gr/CtoK+g8AAAJqwATsBNoCwAK8ANYH1gD8AogC9gTgBAAAEWqIB0gA/w9IAYQBJgkMDbgPDgF+BRAJAAATaoABSAD+D2gAAAh8C3wL/AV+BXwHfAl8CRlqiANIAP8PSAAcBWwBfAlsD3wBbAV8BQAFHmoAA5AA/g8AAPwHBAn0CtQLVAm0CoQLAAAfaoABUAD+D1AAAAL0AvwC9g/0AvQC9AIQAiFqgAFIAP4PaAAACXQFdgP0AXQDdgV0BQQJI2qEAUQA/w9EAAANKwOqCD4HagIrBaIMAAApajgDuAD8B7gAKACAAOwHuAeoB6gHqAcAACpqiAFIAP8PSAAICPoJXwVaBfoBXwVaBfoJMWqIA0gA/g8AAF4JOguODRwFQgV6C0IJXgk5agADiAD/D8gA4Ai0Cr4M9AYABJAA/g8QAEtqkANQAP4PEAAyD7IA8gf+BfIH0QCwDyAAX2qIA0gA/w9AAOYMuAO0Ct8IpAe4CrQIoARhaoABSAD+D0gACAS4BWwD7gq8CawHrAE4AmtqiAFIAP8PSAASCPIFfwV6BfoBfwVyBfIJlGqIA0gA/w9AABoH/AXYBd4H2AX+BYgHAACiaoABSAD+DwgA2Ay4AvQEFgDEDKgC6AQACMNqgAFIAP4HAAD+BwIE/gX+Bf4F/gX+BRIE+2qAA0gA/g8IAH4JLgv+DQAFXgUuC14JAAAEa4ABSAD+DwAA/gfuBOYD8A/mA+4M/gcAAAprCAOIAP4PiAEwAdQPNg+ADzYPVA90CQAAIGtACDAIDAQKAogBeACIAQgCSAQ4CAgIAAAhawAABAaEAQgIYAgeBAoD6AAIA0gEOAQACCJrFAQkAsQBPAMECDAEDgPoAAgDKAQYCAAAI2sABPwDFAAUAPIHAgAwDA4D6AAIATgGCAgnawAA/A8EBaQE1AQEDWAMHgf4AAgDeAwICDJriADED6IEkASSBOQHsAwOA/gACAM4BAAIOmsAAAgJ/AVYAfwFAAEwDA4D6AAIAzgMCAA9a1AIWAtUCPIHVA0ACDAEDgPoAAgDOAQICD5rAASqAqoIrweqAKICMAgOBugBCAM4DAgIR2sAAf4HqgSqBaoIvgcAABwOygEIAjgMAABJayQErQL+B/wDrgH9BDgMBwPkAAwDBAQAAExrgAC8B6wFvAeECLwHsAgOBvgBCAN4DAAAUGsAAP4DggTaBaoE2gUADBAD7gAIAygMGABTayAB7A+sB7gHqAfgDGAEHAPwARAC8AwAAGFrAAG6D7sHgAe7B5oHMAAPDuQBBAN8DAAAYmsABAAE8AcABAAEAAT+ByAEIAQgBCAEAABjawAEBATkBwQEBAQEBPwHRAREBEQERAQABGRrAAjwDwAIAAj+ByAEAAD+ByAIIAgQCBAGZWsgCCALvAigCCAIIAT+ByQCJAKkAaQAIABmawAAEAjUBxQE1AeUBBAE/gAQBxQIFAgQBmdrAAjwBwAE/gcgAggKaAioBT4CKAXoBAgIaWugAKAFfAhgCCAFIAX+BCQCpAEkAKQAIAFqayQIpAikDpQIlAi8CIQPlAqUCqQKpAoACG9rEADQBxwE0AWQBd4FngW0BRQE9AfwBxAAcmsIDOgDKABsC+gHaAIuCXwErAO8BKgIKAZzaxAO0AFQBNwC0A/QAF4J9AxUA3QFVAkQBHRrAAz8AwQIVAh0DxQIhA9UCvQKNArUCAAAd2sADPwDBAhsCPwObAgED2wK/ApsCqQIAAB4awAIfAdUBNYHPAVAADwHvAD8D7wAqAcAAHlrAACEAEQIJARUBJwCFAGUAHQAFAAEAAAAe2sAAMQIZAScBhQB9AAEAPwHRAgkCDQIJAZ8a8AAIgieBBID8gAAAEQARAD+D0IAQgBAAIprgABiCB4GkgFyBBAETgPIAP4PSAFIAkAEi2uAAOIIngSSA3IAAAioBP8EaANlBVUJQASWa0AAYgxeApIBcADkDwQE/AVuBWwF/AUEBJhrgABiCF4GkgFyCAIJqAUvBxgFXQsVC6AItGsAAPwPFAXkBBQNQAzeCEIHQgb+CWAIGAi1awAAAAL8D1ICUgIRCUAI3gVCAl4FoAgYCLdrAAz+A1UJVQk9B0AA4AheB0IG/gVgCAAAumsAAFIGVAHMD1MBAAjeBEIFQgJ+BeAEGAi8awAAbAxsA+4A7AcEAmAI3gRCA14DwAQACL9rAAf/APUOpQD1AqcEAASvAqECLwHoAgAEwGsAAHwJUglAB1QFPA1ACH4JQgb+CWAIAADBawAA/ATSBMAH1AQ8AkAI/gVCAv4FYAgAAMVrAABUATQL1goUB8QCEAjOBUIC3gVQCAAAy2sAACAA4Ak8BSQDpAF8CSQJJAf8ASABAADNawAAIADwAy4CogKqAqoKIgoiDv4DIAIAAM5rAABIAMQHcwJKAsoDegpKCkoO+gNCAkAAz2vAAMgC6AOmApQDlAPUA5QKlAr0B8QCwADSayABIgHqB2oFagX/B2oFag1qDeoHIgUAAdNrEAD4B7YFlAz0BwAAtA8sAKYPJAC0ByAI1GsAAAAA/g8gBCAEAAD+B0AIIAgQCBAHAADVawAAQAF+AUgBKAGADz4BSAFIAUQBJAEAANlrAABACn4L5AdkBVQDXgDkB2QKZAlQCUAE22sAACgBKAEoASQB/AckCaQIkgiSCJAIgAbrawAAxAT8BewF7APuB+wL7ArsCnwKxAoAAO9rJAEkAfwHkgiCCCgKZAoQCc4JEArMCgAED2wAAAAI/AckBCIEIgR+AKIDIgQhCCIIIAYRbAAAAAj8B6QEpASkBOQEpAGkBrwIgAgABhNsCAD4AQoCCAIACP4PkgiSBPIBkgaeCAAEFGwgABgARgBVAFQAVABUAFQA1AMUBAQIAAQXbAAIWAlGBVQCVALUBdQEVADUAxQMBAgABBtsEAAYCYQFIwMqCSoJqgeqACoB6gMKDAAGImwIAKgEtgW+BXwHfAW8BbwFHAD8AwQMAAYjbBAAGAlEBSMBqg8qASoBag0qAOoHAggABidsEADIAsQC3gLcD9wC3ALcAhwA/AcECAAGNGwAABAEEAKQAXAIAAj+ByAAwAAgARgC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AAF/BNUH9wTdB4AErgelBKQHBATubwAAEgakASAA/g9jBXgD7gF+BXgFKgkAAP5vAACBB0EAAAP+DPoBXgXrB1sHUwH3AwAEEXAQACQPJACABbwE/A68DLwO/AK8BLwJgAIfcBEEpgMAAAIAEwy6AzoD+A86AbsHugO6DyxwEAyiA4QANgZUAf4HJgHyBG4FagH6BQAETHAAACIIRAYEA3QO1A82D4QPdg9UD3QPAABRcAAAIgasAQAE6gPqB/oF4gHqA/oF6gUABGNwEAAmD0AAFwJNA6ADnAO2C/oLXAcSAkAAa3AACGAIGAQAAoABfgCAAQACQAQ4CAAIAABtcAAAAghCBDIEAgLCAT4AwgACA2ICEgQABG9wQAhwBAAC/gEQAgQABAgECPwHBAAEAAAAcHAEAoQBdAAOCOQEJAIEAfQABAFkAiQMAAB1cAAIAAmqCCoEKgKqASoCKgQqBb4IAAgAAHZwcAQADv4BAAEYBQAEIAQgBP4HIAQgBCAEfXAACAwJ0gQABAgD1gACAwgEDAXSCAAIAAB+cAAAmAiICGgECAIKAewACAMIBMgEGAgAAH9wOAgABv4BAAMIAPAHAAQABP4HAAQABPgPiXBwCAAG/gEAAjgIAgzyA5IAkgCSAPIBAACOcAAAQAgoCaQEIAQYA8YBGAIgBKQFJAhACJJwQAAwDv4BAAEYCkAIOAQABP4CAAKYASAAlXA4CAAG/gEQAgAI6AcqACoA6AcICAgGAACrcDgIAAb+AQADCABIBGgG2gVIBCgHCAQAAK1wAAzsAygIqAmoBC4GqAEoAigEKAmsCCAIrnBwCAAE/AMwBgAA+AcuCSgJ6AsICvgJAASzcBgIAAb+AQACGADgDxQAnAF8AJQJFAj0B7hwcAgADv4BAAIoBDAADgD4DygBKAEoAQgAuXAAAAAM4AKgAKAGvgCkAqQEpADkAgQEAAC6cAABiAyKAsoAuAasAKoCqAi4CuAIgAcAALxwOAgABv4BCAEQBHQDXgj0D0QARANEBAAAwXB4CAAG/gEIAxAAPAekACQI9A8kAKIDIATCcHgIAAb+AQABGAEABJYEkASYBJYEEAQAAMhwIAkSBw4DygBqDBoAAAR8CQABAAX+BQAIz3AACAAM/AFUAVQFVAFWBVQBVAtcCUAHAADYcDgIAAb+ARACgAiIBP4CiACIAP4CiAwACNtwQAgwBv4BEAYABPgIiAj+B4gE+AYACAAA33B4CAAO/gEQAP4PAgQiBfoEogUCBP4PAADkcPAIAAz8AwAEEAUAAagD/AqoCrgKqAYkAOZwIAQYBAAD/wAIAwAI+QQJAu8BCQT5BQAI53B4CAAG/gEAApAIhASmA7wAtA/ECKQIgATrcAAIighiChQJAAQqA1oELgSaCIoKeAgAAO1wAAAkBCQDfwAUBoAAZAA/BwQAfAKABkAICXEAABAIFAT0AVQJXANcAVwDXAlcCRQHAAAVcSAIEA7+ARACgAj4BJYC9AGcAvQEgAgAABpxAAAkChQLvgQMBKQDMAIMBH4FDAUUCCAEIXEoCCgN/gElAfwNJAH8BSQJ/AEkBSAIAAAmcRAIEAz4AV4BWA1YAfwBWg1YAVgBCA0ACDBxeAgABv4BAAI4ANAPSAUGBUQEXAXEDwAANnGICKgGbgJuABQFDAGAAGgGHgBoAooOgAg8cUAIOAQAAv4BEAikBPQDpgCkD/QIpAgABExxeAgABv4BAAKQCPwK1ArWD9QK1Ar8CAAATnEECfwEXQReAVwN/AAEAHYMBQH8AQQMAABVcQAAAAj+BLIAzgK6DAAA/gQSCRIDng8ACFlx8AgADPwDIAj0CpQK/AqUDvwKlAr0CgAAXnEAABgJVgVUAVwN9AEAABwN6gjIAjgFCAlkcTgEAAb+AQABEASEBL4CrAHsB74BhAIABGdxAAj8DZQAlADsDBQAzAFEBVQJVAHMDQAIaXE4CAAG/AEQAgAI/AusCqwCrAasBvwLAAhucQAAMA40APQBdAV+AXQFdAV4AfQBEgwAAH1xAAAQDv4BEA78A6wEbADqB6oEagL6DwAAhHE8CAAG/wEIAgAM/gCqBqsIqgqqAP4GAASKcQQEfAc/ALwAvgb8AAACZwSqAIkCRAwAAJRxGAAgDP4DEAQkAZQPRAkmCUQJlA8kAQAAmXEABAAG/gCSAO4GugAAAH4GkgSSAJ4CQASfcQQIvAy8Af4BvAwYAIgFfggIAPgEAAmAAKxxAAGcCHwEXgFcDdwAEAAIBb4MyAC4BAgJsXEAAEwJXAXOAVwNLAEIAZgMfggIAPgFgAjDcTgIAAb+AQgJMASuAHQODADIDj4AaA6KAMhxGAQAB/4AKAFSBLoFugS1BLYH+gUYBCgA0nEYCCAG/gEQAgwI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/g8SAPIDAABOc1AJPgUYBX8FEAO0AToDHwPaA3YFEgUQCWhzAACUC0gI8AdMAPQFfAX0B3wN9Az8BwAAcnMAAJYJWAjmBwAA9An+C/QF/AX+C5QJBAh1cwAAMgmMCPIH5A/aC9AAvg/SCZAO/gwAAHhzAAD+B/oF/gX0BeoPBgwQA/4AkAMWDAAAe3PQDygAvg/+B+wP3AcADBAO/gEQAxQMAACEcwgIKAhICKgGGAWOBEgEKAUoBggECAgAAIdzgAK0AgQClALsAqYOlALEAhQClAKEAgAAiXMACEQIRAhECEQI/A9ECEQJRAlECgAIAACLcwAERAREBEQERAT8B0QERAREBEQEAAQAAJFzAAAkBCQC/AMkAgAI/AcEAAQA/AcACAAGm3MABiQC/AMkAQAABAF0AUQBRAl8DMADAACpcwQEJAL8AyQKAAkkBOQDJADkDyQIJAggBqtzBAIkAvwDJAEECTAEbgSIA4gCeAQICAAIr3MABCQC/AMkAoAAxAAkAPwPBABkAIQAAACwcwQEJAL8AyQCAAj+BAIC+gECB34IAAgABrJzAAIkAvwBJAEAADAASAJUAkYNyAhQABAAu3MABCQC/AMkAAAM+APICX4GSAbICRgIAADCcwAEJAT8AyQCAAD0AxQB9AkECPwHBAAAAMpzAAAkBPwDBAJACP4HQgD+B/wPQgD+D0AAzXMEAiQC/AMkARABSAgkBZIExARIAhABAADgcwQEJAL8AyQCAABcBkgB/g9IAUgCQAQAAO1zAABEBPwHRAQAAvAIAAT+AwAI/A9ECAQI8nMAACQE/AMgAgwAjAL0ApQC1A+UApQCAAL+cyQEJAL8AyQKAAj8BVQDVAFUD1QJ/AkABAN0AAIkAvwDJAEMA2gCCAj+B4gACgNqBAAEBnQABCQC/AMkAgAJfAhUCdQP/A9UCVQJfAkJdAAEJAL8AyQCAAi0BywApg8kALQHJAgAABB0AAQkAvwDJAIACPQJFAQQAt4BEAQUCPQLInQABCQC/AMkAoAA1ALUCbwIxAdkAJQDAAQmdAACJAL8ASQBAAC0B7QCrAMuCPQPNAAAACp0AAQkAvwDJAIACAgF/gVYAVgB/gUIBQAIM3QAACQC/AEgA4gA/g9IAAADyAD+D0gAiAM0dAAAWgBaAV4BegFaAVgBegVeA1oBWgCQADx0AAhEBPwHRAYAAOgGqACsD6gAqAHoAwgES3QAACQE/AMkAgAA9Ae8BbYFtA+8BfAFAAVbdAACJAL8ASABBAT2BJQCkAHwAJQClgL0BFx0AAAkBPwDBAjwB7gC9A8WANYDBAjIBxAAXnQABCQC/AMkAgAAPACwD7AH/gCwD7AAvA9fdAAAlA5UCHwEVAaUCkAJVAm8BFQBVAYAAGp0BAIkAvwBJAEADP4AqgaqAP4GqgGCDwAAcHQABCQC/AMkAgAIfARUAtQB/gdWCFQLfAuDdAACJAT8AyQCBAB0D2QD1gVkA0QJdA8AAId0AAAkBPwDAAz6AyoIwAcWByoE6A8oCWgJi3QAACQC/AEkAAAC9AL0AvYP9AL0AvQCEAKedAACJAL8AyABCgRoBX4D6AFuBWgFbgkAAKd0gAB8CHQLtAu0C/wLAA9UC3YPVAtUCQAAsHQAAiQC/AEkBQAE/gS+B7oBvgK6An4FEAXKdAAEJAT8ByACCAz8D/4H7AfsB+gL6AsACNx0AAgABvwBBAAEBvwFAgSCBz4IwgMADAAA5nQAAAQEBA7kCRwI1AQUBRQA9AcECAQIBAbudAAAWAhIDuQHcgdoB2IHagFyD2QISAhIBO90AAD8BwQFtATkBBABAgz+C5IA8g8CCAAG9nQAAIgM+gOIAP4PigAACPwPlAD0DwQIBAT3dAAAQghUDMALaAlkC1YBTAFUD2QIYAQAAAR1AAB8CXwFXAdsBTwAgA98CJQA9A8ECAAGGHUAAAgACAD+D4gEiASIBIgE/g8IAAgAAAAadQAABAEED/4JVAlUC1QJVAv+CwQJBAkAABx1AACSD5IE/gSSBwAA/g+IBIgEiAT+DwgAH3UAACAIkAiOCIgIiAj+D4gIiAiICIgIAAgidQAM5AMkCbQKvAquCqwPvAq0CqQKJAgAACN1AAzkAyQIvAqkCqQKpg+0CqwKpAogCCAAKHUAAAAM/AMkASQBJAH8DyQBJAkkCfwHAAApdQAAAAz+A5IAkgD+B5IIkgiSCpIK/gkABCt1AAAIAOgPqAKoAqgC/A+oAqwK7AcIAAAAMHUAAPwPRAREBEQE/AdEBEQERAREBPwPAAAxdQAA+A+IBIgEiAT+B4gEiASIBIgE+A8AADJ1AAAAAPwBlACUAJQA/A+UAJQAlAD8AQAAM3UAAPwDJAEkASQB/w8kASQBJAEkAfwDAAA1dQAAAAD8AyQBJAH/ByQJJAkkCfwJAAgABjd1AAAACXwJVAVUA/wBVAlUCVQJfAkABwAAOHVAACAA+AeuAqgC6AOoAugLCAgIDPgDAAA6dQAA/gciAv4DIgL+AwAACAgICPgHCAAIADt1AAD0DwQE9AVUBVQF/AVUBVQF9AUEBPQPRXUAAPgB/g+uD3gAIgnyBDoC5gkiDOADAABMdQAAAAG+CKoEagI+ACoAag+qAL4AAAEAAE91AACACPwP1AjUCPwI1APUBNQG/AiACAAAUXV4CAAG/AEABhAA/A9EBEQE/AdEBEQE/A9UdQAA/AckAvwDJAL8A4AAqAD+D6AArACAAFl1AAA8AKQPogqSCqIKgA+8CoQKRA88AAAAXHUAAEQA1A/UCvwK1g/UCsQKpAqkDyQAAABidQAAoACuAu4CrgLuB64CrgLuAq4CgAAAAGV1AAD8B/wDJAL8A5AAiA/WCKQI3AjED0AAanWQAJQA3Ae0BZQFvAeUBbIF2gXaB5AAQABrdUgAfAT8B/wH/Af+B/wH/Af8B/wHSAQAAHB1AAAACrwK7AesBrwCrAKsBuwHvAoACgAAdHUAAPwHJAL8B3QGrAP0A14NVA1UCVQHAAF2dQAAOAAKD+wLqAuuC6gPqAvsCwoPOAAAAH91QADmB1kF1AdYBf8P4AR2A3kHtAhSCEAGhnUAAHQFVA9cDMAHBAD8D/QO/A/0DvwPRAiKdQAA8An+CP4P/g/+D64P/g/+D/4I8AkAAI51AATkBwQE9ANMAgQI9ASUAv4PlAL0DAAAj3UABMQD9ANMAgAIpAc8AKYPLAA8D2QIRASRdQAJbglUBdQDUgEIDaIDKgTqDzYJYgkgCJd1OAmABPwDBAAkACQIJwikD2QAZAAkAAAAmnUYCYAM/AMECMQINAQmAqQBZAIEBAQIAACkdZgEgAL8AQQA9AOUBPYElASUBPQEBAIAAKt1iAiwDvwBBAhECLQFlgaUBvQFxAhECAAAr3U4AYAM/AMEDPQDFACWAtQDFAD0BwQIBASydZgAgA78AQQO9AFUBNYFdAJUBZQENAgAALx1GAmADPwDBAAkBbQE1gjUCrQKlAAEAQAAvnWYCKAO/AEECIQEtASmAuQBpAKkBKQIAATFdZgIgAb8AQQA1A9UAFYD9ABUA1QI1A8AAMd1mASABvwBBATUBxQEFgT0B5QElASUBAAA0nWICJAG/AEEAKQCtAKmAuQPpAK0AqQCBADVdZgIgAb8AQQA/A+sBK4ErAGsBnwFBAkAANt1mAiADvwBBADsD7wCvgLsD7wCrArsDwQA3nWYBIAG/AEEAFQHVAU2BfQFFAVUBVQHVAD0dRgBgAz8AyQIlAT0A5YCBAD0DxQEFAT0Dwt2mACADvwF5AP0AHYFdgf0BfQA9AcEDAAAH3Y4AYAM/AMECPQPlAm2D7QJlA/0CQQPAAgkdpgAgA78AQQAvA+sCqYKjA+8CowKvA8AACZ2GAGADPwDNAhsC0YN9AVkDWwLfAkECAAAK3aICJAO/AEEBpQBdAMmAPYHVAX0B1QFAAQ+dlwAwA8+APoHNgDOBBMC6gfqBfoGYgACB0J2DAGADP4DAghKBOoBuwqqDroC6gtKCEAATHYYAYAM/AOEAHwF7AQuBuwEbAV8BcQFAABSdpgAgA78AQQM9AH0Bf4IXAoUANQGFAgAAGF2mABADvwBBAh0BfQDdggEB3QE9A9UCVQJYnaYAIAO/AG8APwPvAv+B/wH/Af8BbwIpABudhgBgAz8A/QPbAKcCaYD7A/sD+wL7A8EAHp2gABQCVQJZAXcA0QBQAHIB1QJcAlIBUAAe3YAAEAEKgSSBVoHVgVQBVwHkgUqBEgEAAB8diAAJAC0C7QK7AYEAHALHAXwB5gJqAAAAH12AAAAAPgPSARIBE4ESARIBEgE+A8AAAAAfnYAAAIA8g+SBJIEngSSBJIEkgTyDwIAAACCdgAAAAF8AVQBVAdWCVQJVAlUCXwJAAEAAIR2AAD4D0wESgT4BwAAHADqCAgJCAz4AwAAhnYAACAA/gdkBWQFQAVeBWQFZAXmBxAAAACHdgAAAAj8CtQK1ArUCtYP1ArUCvwKgAgAAIt2AACAArwCvAPsAq4OrAKsAqwDvAKAAgACk3YAAPgHTgL4AwAAUA9MCUgJfglICUgPSACudgAAAAz4A0gIyAhICX4GSAZICcgIGAgACLF2GASUBJMEmgT2DwAE/Av0DB8DlAR0DAAAw3YgACQIpA+UCJQPvAiED5QIlAikDyQIAADGdgAAEAiID5QJcg8QCZIPlglkCQgPEAgAAMh2AAACCHIPDglqD3oJAg8eCZIJkA9wCAAAynYACYgIyQ++CIgPiAiID5wIqwjJD4gIAAnPdgAAmAiYD5QJXg90CVYPVAm0CbQPFAgAANB2SAgoD6gIvgioD6gIgAi+D4gIkAiQDyAI0XYAADwIgA+ACL4PgAicD4oIqAioDwgIAADSdiAAMAjQD7gJuA+2CbQPuAmwCdAPIAgAANZ2AACACKgPrAmoD/gJqA+uCaoJqA+ACAAA13YAAEIIJA+gCYgPRgk8DzQJRAlUD0wIAADYdgAAoAigDnwJZA90CSYPJAmkCfwPIAggANt2AABgBBwHVAVUByQFTgc0BWYFlAZEBAAA3HYAAAgIag8CCVgPRgkkDxwJJAlEDtwIAADfdgAA/AhUDlQJPA9ACT4PKgkqCX4PAAgAAOF2iAKqCKoOqgqqD/8Kqg+qC6oKvgwICQAA43YAAH4E2gf+BNoH2gSAB84EyATIB0gEAADkdpAAcAgcDzQJlg/8Ca4PUglSCXYOmAiEAOd2AADADzgAmA/YC94P/Av8D/wL7A8ICAAA6nYAAAgEagcCBVAHPgV+B34FPgW+BlAEAADudgAAAAD+D5IEkgSSBJIEkgSSBP4PAAAAAO92AAD8B1QC/AMAAAQABAgECPwHBAAEAAAA8XYAAPwHlAH8AQAARABECEQI/AdEAEQARADydgQABAD8B3QFdAV2BXQFdAV0BfQHFAAAAPR2BAD0DwQEBAT8BVwFXgVcBVwF/AUEBAAA+HYAAIgBSAD/D0gAAAD+D5IEkgSSBP4PAAD8dgAA/AeUAfwBYAwYAsQBQABECFgH4AAgAP52AAAADPwDFADUD9QK/ArSCtIK0g8QAAAAAXcAAFAASADED8AK7grgCtAK1ArEDwgACAAJdwAAAAb+AQoA+g9aBV4FWgVaBVoF/g8AAAt3AAGUAFwA/A+8CrwKvAq8CrwK+g8QAAAADHcABPwEgAO+Aa4ArgCuB64ArgK+AoAEAAAZdwAA/AdUAlQC/AMAALAPrASiBKgEsA8gAB93AAoECvwLvAa8Br4CvgK8BrwG/AsECgAKIHcAAPwDlAH8AQAI/g+SCJII8gGSBp4IAAQodwAA/AdUAvwBIAwoAiQGNAmkCGIIJAgAAC93AAD8B1QC/AMgCLwHIAD+DyAAqAEkBgAANncAAPwPVAL8AwAA/A8ECFQK9AtUClQKAAA3dwAAoACoAO4HqAe8B6oHqAfuB6gAoAAAADp3AAD8B1QC/AsICIAG/gEAAP4HQAiYCYgEPHcAAPwHVAJUAvwDAAD+D1II0gFSBr4JgAg+dwAEPgKyATIBPgDyDzIAPgayATICHgQAAEB3AAGUAFwA/gd8BXwFfAV8BX4F/AcUAAAAQXcAAPwHVAL8AxAAWAlWCfQPXAFUAfABQABbdwAA/AdUAvwDAADcD1wDXgNcC1wL3AcUAGF3AAD8B1QC/ANACPQJVAn8D1QJ8glQAQAAY3cAACgA5A+/Cq4KtgqwCrYKqgrqDxYAEABsdwAA/AdUAvwDAABUB8QA7AfEAFIBSgYAAHl3AAD8A1QC/AOAAFQA1Ad+BVQFXAXUBxIAhHf+ByoB/gEAAPQPlASWBPQHlASWBPQHBACFdwAA/AdUAvwHEAP8D5YAsAgABv4BAAc4CI53AAD8A1QC/AMAAHQHdAX2BXQFdAV0B0AAkncAAPwHVAL8AZAPVAD2AVQE9ANWCNQHBACldwAAfAA4B/4HvAf6B5AHrge1BzwHRABEAKd3AAD8B1QC/AMwCPwFWgFYDfoBWA1YAAAOqncAAPwHVAL8AyAA+gU+BzAFPgfUB2QEAACsdwAA/AdUAvwDgAlUBdQDHADSA9oPUgIAAK13AAD8B1QC/AFgDPQBbAlmD2wB9AFEDAAAu3cAAPwHVAL8ASAM+AMWCLQPlA+8D9AP0ADbdwAAIAIkAiwBrAh0CPQHLAAsAaQAYAAgAOJ3UAhYCEcERQJEA/wARAFEAkQERAhACAAA43cACUgJPAkqBSkD6AEoAyYFJAkoCQgJAADldxAISAhHBvwBRAYAAPwPBAQEBAQE/A8AAOl3AABSCEwG+AFIBgAA/A8kCSQJJAnkCQQI7XcAAFAITAb4AUgCAAj0CpQKlAiUCvQKBAjud1gERwP8AEQDQABUCrQLlAa8BLIG0gXSCPN3AAEEAYQA5A9cBEQERAREBEQExA8EAAAA/3eEAPQPLAQkBOQHAAD8DwQABwAEAAQABAAAeIQA/AckAuQDAAimDHYCNgHuCCYM4AMAAAF4hAD0BywEJATkBwAAdAFEAUQJfAzAAwAAAniEAPwHJAIkAuQDYAgYBIAEfgIAAZgAIAANeEIA+gcWAhIC4gMYCAcH9ACEASQCHAQAABR4QgD6BxYCEgLwAwII/gciACIA/gciAAAAFXiEAfQHLAIkAuQDAAB0AQ4BhA88ASABEAEWeEIA+gcWAhIC8gMAAFIBfgJTAlIN0gASADB4hAD0DywE5AcAALQAhAD8D4QAtACAAAAAMniCAPoHJgQiBPIDOAecCJgI+AgICPgJAAQ0eIQA9A8sBOQDAAz4A8gISAl+BkgHyAgYCDh4AACEAPQPLATAA/wP5AgUCPQLFAj0CQAAQHiEAPQPLATkBwAAvAcgBCAE/gcgBDwEgA9VeAAAQgD6BxYC8gMACPoECgLuAQoE+gUABF14AAAEAfQPTASED/AHHABQAV4BEAn0DwAAa3gAAIQA9AcsBOQHAAC0DywApg8kALQPIARseIQA/A8kBOQHAAD8CKwKrAb8BawIrAj8CG54hAD0DywExAcQAPgPVgH0D1wBVAnwBwAAjHiCAPoHJgIiAuIDAABqAioJ6g8qAb4CoASNeIIA+gcmAiIC4gMAAV8DVQNVCdUPXwEAAY54hAD0DywE5AcAAGQBFAEkAcYPNAEkAUQBkXiEAPQHLAIkAuQDfADUAX4BVAHUB3wBAAGXeIQA9AcsBOAHxAA0DKQDRgD0BxQI9AkABJ94hAD0D0wEwAcIAHwNSAP8D2gDfAVICQAAp3gAAMoE6gL+D+oKgAr8CtQK1grUDvwAAACpeAAAhAD8ByQC5AsACPwHrAKsAqwG/A8ACLB4hAD8DyQE4AeIAA4J/A8ICPwPCgjICQAAs3iEAPwHJALkAwAIrAdoAC4NqAMoBKwJIAC6eIQA9A9MBMQHTADkD1wJVgn0D1QJVAlMCbx4AACCAP4HIgLAB34DqgSqAP4GqgGCDwAAwXiEAfwPJATkAwwIaA+OCOgOSAioD84IKA7KeAAAUgLSB3oFbgVqB2oC6gdqBXoFQgdAANB4UAVQBTwDVA8WC3wLCAtmC1ILvg+YAYAB1XgAAEQA9A8sBOADyA/8D84IzA/sCMgPAAjaeIQB9A8sBCQExAf8AtwG3A7+CtwP/AIEA+h4AA78AQQEtAS0DrQLlgqECrQKtAq0DpQA9HhEAPQPLATEByAAmgnaD9YI1gyaCiAIAAAOeYQA/AckAsQLFAhMBF4H0A9MCV4JVAkQCBl5AAAEAfwD5AsOCFQH1AFACAwH7A8sCWQAOnkAACAEJAKkASQIJAjkDyQAJACkASQCIAQ8eQAAiAGKAO4PWACIAQAA/gcACAAIAAgABj55AAAIAYgAzg+4AAgJIAggCP4PIAggCCAIQXkAAIgASgDsD1gAiAAAAPwPBAB0AowBAABCeQABiADKD3gAiAAgAPwHIAj+CRAI+AgABkh5CAGIAM4PeACICQAE/AMkACIA4g8iACAASXkIAYgA7g9YAIgIAAjwDwAI/g8gCCAIAAhQeYgAiADuD1gACAGAAPgPTgRIBEgEyA8AAFV5iACIAM4PfAAICOAMAALyB8QIMAhsBoAAVnkIAYgAyg+4AAAI/A8kCSQJJAkkCfwPAAhdeYgBSADuD1gAgAg8BCQD5AAkAOQPPAgABl55iAGIAO4PXACAAPgDKAEoAf4PKAH4AQAAX3kAAIAElgS0ArQAvge0ALQCtAKWBIAEAABleQgBiADOD3gACABAAUoBSgH4D0oBSgEIAWh5BAl0BdQF1AH8CdQJ1Af8AdQF1AV0DQQJbXkQABABmAhuBEwBdAlICUYPWAFkA1QDjAx3eQgBiADKD7gAAARUAtQBfgNUCVQPRAEAAHh5CAGKAOoPmAAAANwPVAH0AFQLVAjcDwAAenkIAYgA6g9YAEAICAn+BVgBWAH+BQgJAACAeQAABAr8C4wD/AvcC94P/AOMB/wHBAoAAIF5AAAUCUwFXgFMCUQJUA9MAV4FDAU0CSAAhHmIAIgAzg98AAgAQgQqAioJ6gcqAb4CoASFeYQARADmD1wABAHwAaoB+AesAaoB+AEAAI15gACIAOwPGADAD3wAxAf0AtQDVAj8BwAAj3mIAEgA7gdYAIIA+g9qBWoF6gdqBXoFwgemeQAAJAWzBYAF6wH+AdoHgAG+A4IDPgUABad5AAGKAOoPkAAEAHwP3AteC1wL3At8DwQBqnnEACQA9Q8tAEAC/wKtAv8PqgKtAv8CAAKueYgBSgDqD5gAAAj+C/8K6gr/CuoK/gsACLF5AAGKAOoPkADED/wF/Af+BvwC/A/cAgAAuXkAAIQPvACsBKwE/AesBKwCrAq6CIIHAAC6eQAAgA/8ANQC1AL8A9QC1ALUCPwIgA8AALt5BAAED3QBZAVkB9YFVAVUA0QJdAkEBwQAvXkQAAgP6AHEAZQFsge6BbIHhAnoDwgAAAC+eSAEJAIkAaQAZAD8D2IAogAiASICIAQAAL95AACQCFQIVAQ0A3wANAA0B1IIUgiQBIAAwHmICEwILAScA4wAvACKCpoJKglKB0gAAADBeQACkgFSAP4PUgBSBAAH+AQGBMAEAA8ACMN5AABQCFQIVAQ0A7wAlAA0B1IIVAhQBgAAyXkAACgEugS6AroBugH+D7oBugL5AigEAADLeQAAkgNSAP4PUgAACDgEgAN+AIADMAQICM15lANSAP4PUgACAPgBiACIAP4PiACIAPgB0XkAAJQDUgD+D1IAEAFCAUwBAAH+DwABAAHSeQAAlAFSAP4PEgCACDgEgAR+AgAB2AAAANh5EgOSAP4PUgCACWAE+geCCGAIHgjgBgAA33kUA5QA/A9UAJQJAAj8DyQJJAn8DwAIAADkeQAAFAOUAPwPkACEALQAhAD8D4QAtACEAOZ5IAGsCGwErAO8A64PbAEsA2wErAggAQAA6XmUA1QA/A9SAJIIEAROAkgB/gBIA0gEQAjveQAAlANUAPwPUgAACHwGRAFEAEQBfA4ACPB5kgNSAP4PUgCSAhACzwEECPwPBADsAQQC+3kAAJQBVAD8D1IAAgmoBKwEVgV0AswBQAAAehADkgD+DxIAAAHqB6wAvACkD6wAqgSoAwV6EgOSAP4PQgAICPQEkgOQAJIP5AgICBAEC3oAABgDmAD8DwABPAikCqQKpA+kCrwKAAgNepIBUgD+D1IAAADyB1QBUAFeAVAF9gcAAA56AACUA1IA/g8CADgMygNIAMwPTgh6CAAGGnoAAJQBVAD8D1IAEAD+D6gE/AeqBKgEAAAjehAA+AVWBfQFXAX0BiAHpAD8D6QAIgcAAC56AADKASoA/wMACP4Krgr+D64K/QoACAAAMXoUA5IA/g+SAAAC6A+kAqQC6gOiCroK4gcyehQDkgD+D1IAEgDADxIAwg9aBUIF2g8AADN6JAIkAfwPogAABlgAVgVWC1QJXAHwBQAIN3qUA1QA/A9SAAAJfgmWBdYGvgZWBVYIXgA7eooBSgD+D0kAAADKB6oEgQQtBKEE7QcAADx6FAOUAPwPUgBABVwFtAJ2CbQG1ABcA0AEPXoUA5IA/geSABAAdAesB64HtAe2B5YHVAA/eooDSgD+D0kAgA9eAFYPVgVXB14Awg8CAEJ6FAOSAP4PUgCABnwArAysCf4KrAKsBvwIRnoSA5IA/g9SAIAIvAwsBSwF7gYsArwCgABMehAM+AFWDfQBXA3wAgQGpAH8D6QAIgcAAk16mAFYAPwHVAAQBPwF/AX+AfwB/AX8BRAETnoABM4C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SAduANAPTADgCggIOATIAg4DyAQ4BAgIDX1IB24A0A9MAAAB+A8IAcgAPgDICPgHAAAQfRAOnADyDsgAgAIECEQM/AtECPwPQAgAABR9SAduANAPTAEAAOgDCAEIAf4HBAnkCQAEGX1IB3YA0A9MAGQBAAT+ByIE/gEiBiEMAAAafUgHWAD2D2AAQAsEB/wAhAQkBTwD4AQgCBt9SAd2ANAPTAAAC3AITgbAAUIITgjQByAAIH0gACoJagVqA+oL/wlqByoBqgWqCSALIAghfUgHfgDQD0wAxAoACAgH+AAuCCgI6AcIACJ9AAA0CBQFVAX0AV4JVA80AbQFFAU0CQAAJ30ACB4JgAXeAcAJogmSD14BUgUeBSIJIAArfRAJHAlQBV4FtAGQD04BFAWUBRIJCAoAAC99AAAACD4FagXqAX4Jag8qAaoFPgUACAAIMH1IB3YA0A9MAcAA/A9EBEQE/AdEBEQE/A85fUgHbgDQD0wAAAMgAKIPngSCBKIEng8AAEJ9SAduANAPTACAAogATgQ1BTQFTAlAAAAAQ30QDtwAsgZIAEAHSABoBloFzAQoBggMAABEfUgHbgDQD0wAAAMACPwPJAkkCSQJ/A8ACEx9SAduANAPTAAAA0IIJgkqCZIPKgkmCUAIUH1IB24A0A9MAKADBACkD6QEvwSkBKQPJABVfbAN7ACiBJgCAAD0BzQJLAnkCTQJLAngBV59SAd4ANYPUAAACygImAQYA84DCAQoCCgAYX1IB24A0A/MAMQDkADID9YEpATcBEQPgABmfUgHbgDQD2wBIACQD4wEogSkBIgEkA8gAG59AAAsCCwFlgHUCcwJgA9eAVIFEgUeCQAAcX1ID3YA0Q9MAAAJBAS8AycALAC8DwQIAARyfQAAkA78AJIGSAIAAFgDdgjQD0wA4AIABHV9SAd2ANAPTAAACxAIiAamBaQEiAawDBAAdn1IB24A0A9MAQAA+AeWCJYI/AicCJQI8AaTfZAMvAHiDNgAAAo6CEIJEgnqD4IJPglGCJl9QAduANAPTAAAAf4PAASoBP4FoAQsBQAEmn0AAEgHfgDQD6wDgAlUBFQDXgBUBtQIBAScfTAO7ACiDJgCAACMDKQCpwCkD6QArAKADKB9MA7sAKICmAQABNoCVAjUD3QATAKABAAArX1IB24A0A9MAEADEAD+D6gE/AeqBKgEAACxfU4HcADsD0AB/A/sA+QDJAKsCyQI/AcAALJ9SAd4ANYPgAL8DwwAvAPkBLQEBAD8DwAAv31IB24A0A9sAQAAvgeqAKoA6w+qAL4EgAPKfQABPgUuBb4F7gGuB6IBWgMaAyYFQgUAAM99SAd2ANAPTAAAAV4EQAD8D2QJcQhGA4gE0X1IB24A0A9MAAAFIASqAioI6gc+AaAGAADSfUgDdgDQD0wA4AOEAJQHfgVUBVwF1gcQANp9SAduANAPzADABZwCrAksCO4PLAO8BAAE4H1IB3gA1g9IAQgAoAeUAJwA1g+cALQHAADjfSAIvAziAtgCgAQgBH4DtAq0B7wBIAYAAOh9SAduANAPTAAAD/wHrAKsD6wCrA+8AoQP6X1IB24A0A9MAEAJFARcA/QJ1AbSBtwFVAjvfUgHWAD2D2ACAAT0BbwHtgW0D7wF8AUABPR9SAd4ANYPSAAAAvwErAKsAf4PrAH8AgQE+32QDtwAsgTAAZwE1AeUBAQA8AwOA/gEAAgBfkgHXgDwD2wAgAIgBGoDqgpqB74AIAcAAAR+RANfAOgPJgAAAfwHvAK8AvwHvAq8CvwNI35AAnwBfAD8B/wASAIYAXwE1ANUANACgAAmfkgHbgDQD8wAQAL2D5gHFgTwD5YIEAgAACt+EA7eAHEEbAMBCHYG4AksCLsK+wsmCgAILn5AB34A0A9MAUAA7A8EANYHdAVUBdQHAAAxfhAO3gCxDMwCAAD3DwAEzgMBBOgHhgiYCD1+kA7cALIMiAIADPwChAaWCaQLhAD8BgAAPn5IB24A0A9MAAAK/Aj8Bf4F/AH8BfwJEAhBfgAIMAq+CjwL/AM8D4gCXgZkB1wKhAoAAEp+QAdOAPAP7AHAB/QHHgT0A5AG/geQDBYCVH6gAy4A8Ae8ABAA/Ae2AtgPPwPQBBYOAABefpAO3ACyBIgCAAiqCeoHrwEKD+oJqgmABWp+AAd4AJQGUgEIADQH8gX6BdIF9AX0BwQAa34AAH4Kfgd/B/4PfgsYB/YC0gp+CpgKgAhwfkgHbgDQD0wBAATwAt4B+gfqAdYC8AQAAHN+kA7cALICCAk+DOsD6wm+BzQMiwN4DAAAfH4QDtwAsgZIAv4PNAi6DzgJPgisDxALAAiMfpgO9gCRBkgBEgjuB/4H7wP+A+4H+gcACI9+gA7cAKIGWAEADPwD9An+C/4O/Av8C4QJln5QB3wAagIACXYE9QcQBPYPMAT+B9AMFgKgfqAEsAVsBSIFkAQAAPwBAAEAAQAB/g8AAKJ+AAAwCewEogSYBgAABAQEBPwHBAQEBAQEpH4AADAJqAVmBRAFQABEAEQA/A9EAEIAQACmfqAEuAXkBJIEgAIwAI4AiAgICQgM+AMAAKd+IAW4BeYEkAIQDIQDfAiEBTQCrAVgCAAIqn4AACAFuAVmBRAFAADEB0QIRAhECPwIAAasfiAFuAVmBRAEAAKoAKgA/g+oAKgEiAMAAK9+IAW4BWcFEAUABPQBBAEEAf8HBAn0DQQEsX4AADAF6AWmBJACAAh4CAAE/gQAApgBIACyfgAAmAXXBLEEAAD+DwIAsgHaAQII/g8AALN+AAAwBc4FIgUAAPAPEAPwAJ4IEAjwDwAAtX4AADAF7AWiBJAAAA7+AQAMAAP+AAAHAAi3fgAAIAW4BWYFAAFgCFgExANACEYI2AdgALh+IAW4BWYFMAUAAPwPRAhEBPwBRAZCCEAGuX4AADAF7ASiApgKAAg4BMoCDgPoBBgECAi6fgAAMAWsBWIFGAEACAgH+ABOCEgIyAcIAL1+AAAwCawFYwUYAQIIQgz+C0IIQg7+CQAIv34AALgF5ASSAoAKEAhQBH4EyAMqBaoIAATDfrgE5ASyAgAAVAZ8AVYI9A9EAEQBBAYAAMR+AAAgBbgFZgUQAQAI/A8kCSQJ/A8ACAAAxX4AACAJuAVmBQAA+AMoASgB/g8oAfgBAADGfiAFsAVuBSIFAAD8D0QERAT8B0QE/A8AAMd+IAW4BOYEkAIACHwGRAFEAEQARAF8DgAIyH4AADAF6AWmBJAEEABIAlYEJAVUBUwIgADNfjAFnATyAogCIACiD5oEhgSiBKIEngcAAM9+IA24BeYEkAAACKQIpAiUD6wIpAggCAAA0X4AADgL5gmQAQAIKA3+AwAA/A8EAHwChAHSfiAAmATkArICCABABugBCAh+BIgHaggIBtN+MAXsBKICmAIAAKQHpASkBL8EpASkBwAA1X4gBbwE4gSYAgAIpASmA7wAtA/ECKQIAATYfjAF7AWiBIACIAiQDqwJpgSIBpAEoAgAANl+IAW4BOYCgAIgAKAPsA+uBKgEsA8gAEAA234gBLgFZgUSAkAAqAKoAq4ClA+sAqQCIALcfgAAMAXsBKICkAIQAEgPtgSkBLQETA9AAN1+IAWcBOIEmAQAAPgHlgiWCPQInAjwCAAG3n4gCbgFZgUQAUAIOAiYBQoCyAUoCEgIAADffiAFuAVmBZIEEAJACGgHXgBID2gISAhIBuJ+AAAgCbgFZAUAAOAPvAK0ArQKtAr8DwAA434wBawE4gSYAgAIrAScA4wAvACaCSoHAADlfjAF6ASmAqACCAhEBeQGagLCBVoMQAQAAOd+IAC4BeYEsAIAAPgHBASgBP4FYASsBQAA6X4wBZwE8gKYCgAI3AVcBF4DXABcBNwJEADqfgAAmAT2ApICAAJUANQHfgVUBVwF1AcSAO1+IAW4BOYEkAIAALQIFAUeA9QBFAVwBRAI7n4AALAF7ASiBDgAoAe0AqwCrgs0CNQHNADzfgAAsAVsBSIFAAD8A7QC9Ae0CrQK/AsAAPR+sATsBKICmAIgAPwPqgSoBPoHqASoBAAA9X4gAJgF1gSxAgAAvgeqAOsPqgCqBL4DAAD4fgAAsAXsBKICAAj8BwQA1Af0AgQJ/AcAAPx+AAAgBbgFZgUABRgAiAKqCKwPqACoAoAE/X4AADAF6AUkBQABKAyoAygE7g8oCSgJAAD/fgAAuAVkBRIFiABABCoCKgnqByoBvgKgBAV/AAC8BeIEmQIIAOIHEgTyB14F8gfyBwAABn8AANgCTgJ5AQAE7wQ/AqABKAMmBOwFBAQTfyAFvATjBJgCwAxUAvIJ1gbRBt0FVQgACBR/EAWsBWIFGAUAALQHnADWD5wAlAS0AwAAFX8AADgF5ASyBAgCoAiqC5gG3gSYB5oEqAgWfwAAuALkApIAAAb8AZQH1gPUB1QB3AcAABh/IAS8BWMFGQAABWwFawWqCqoHvgEgBiAEGX+QBNwCowKYAgIA6g9iBX4FfgViBeoPIAAafyAFsARuBSAFAAB4AXgFfAF4CfwP+AEAAR1/AADcBbMEiAAiCOAHBAivCuoLrgqiCgAIIH8AADgF5AUSAQAM/AN0CK4K/g+sCvwKAAgpfyABuATmAgACjADkDxQA1gd0BVQF1AcAADR/EAS8BOMCGAC+DOsD6gm+BzQMywN4DAAANn8AAFAASA9HBEQE/AdEBEQERARED0AAAAA4fwAAqAcmBPwDJAKkBwAABAT8BwQEBAQAADp/AACoByYE/AckBAQHwADIDv4ByAL4BMAIUH8QAAgH/gckBwQBNA/+DxQP5A8+DzQPBABRfwAA/A8EACQD5AAEBCQGxAE0CwQI/AcAAFV/AAAEAVQBVAFUAcQPTAFMAVQBVAEEAQAAV38AAB4JkghSCH4FUgZSAl4CUgHSAB4AAABafwAAngCyCLIPHgQSBBIA3gMSCBII3g8AAGJ/AABcCVQNVAtcCdQJVAlcCVQFVAVcCQAAaX8AABwC1APUA9wD9Af0A/wD9AP0AzwCAAJqfwACvAq0CrQG7AEUABQA7A+0ArQCvAIAAm5/IADcBzQENAT8B/QH9Af8B/QH9Ac8BAAEcH8gAP4H+gX6Bf4F+gcKAO4BCggKCO4PAAByfyABrgC6ALoHfgV6BXoFfgV6BfoHPgAgAHV/AAgOBPoA+gH+B/oA+gL+APoC+gSeAwAAd38AAFwI9Af0AfwKlAd0BrwKtAq0CrwKAACFfwAAbg3aAUoNDgVKAPoPrgqqCuoPrgqgCop/AAFIAUoBTAFIAfgPSAFMAUoBSAEAAQAAjn9ACFgJWglcBVgD+AFYA1wFWgVYCUAJAACefyABuAS4BHwEeAX4B3gFeAV8BfgHKAQAAKF/UARcApwCHgCcBVwEXANeAl4E3AVQBAAApH8AAagB+g+uBKoEvgcIAUoB+A9IAUsBAACofyAJLAyuAi4ILAn8BKwErAOuBKwIpAsACKl/QAPEC9QL1g/UA/wLVAlWB9YFVAtACQAEr38AACgBKg34Ay4BAAG+A2oEagVqCX4IwAe9fxQCJAEkCYQI/AcAABQCZAEECYQI/AcAAMF/SATEBFICWgrYDxAAWATaAlIKRArIDwgAxX8oCOgEPwPoBAAIkgqCCv4LCAhCDP4PAAjMf0QILAkkCQQNPAmACSwJLA1UCUQJfAkAANJ/QAAoAKQP5ArECvwKgAqsCqQKhA98AAAA1H8oCSoH+AGrAAECMAkCCP4HEAGCCP4HAADgfwACKgKuAq4C6gImD7ADZAKqAqoCLgIAAul/AAj8D+wH6g/qB/gOsgH+B5gB/g8AAAAA8H/8AqwCrg+sAvwCAAJYCvQPQgAUCvgHEAD5fwAJqAfsAQ4HbAkECZAL/AkACFQK/AkABPt/QADUD7IFvge6BZMHAAGSCP4HuAH+DwAA/H8AAAIL7gfuB+ID7gPgA+oD6gfiBw4LAAAAgAAE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tAK0Av4PtAK0CvQHEAC4hJIEkgZaADsBCg1qARoFOwlqAKIEEgkAALyEBAAkDOQD1g/wC+gL8AvUC/YL5A8kACAAxISQAJQAtAfWB9QH1Af0B/QH1gfUBtQAkADJhAAANAIUAVYPlAlUCVQJVAmWCVQPVAMAAcuEBABECNQO1grUDvQK0A7UCtYK1AxECUQA3YQEAAQIZA8OCWQPBAk8Dx4J1AmUDwQIAADmhEABRAX8BP4G/Ab8BvwG/gv8CvwGRAAAAOyEFAhUBMQHDgjkC9QLtAu0C7YLtAs0CkQA7oQACLQE8gMDBPoJWAtaC/4LXwtaC/oLAAIRhQQAdAzUA9YB9ArUCNQJ9gbUBtQI9AiABBOFAAjEC3wLfgv8D3wHfAf+B3wLfAvECQAIGoUED/QAVAzWAdQP8AEEBKQBJgj0DyQAAAAhhSQJpAiUBd4BtAmUCYQP9gHUBbQMFAkAACOFBAl0B0QB7g8EAFQFkAV0CVYJNA8UAQABLIUEBJQH9AeWBAQAVA90AFYPVgB0B3QIhAQ1hcQPNAD0D3YFdAd0BdQNfgSUB/QINAgABjqFBADEBxQAxgPUA9QD1APWB1QGFAT0AwAAPYUUANQPxAfuD8QD1A+ECO4EJAPkBSQIAABDhUACSgJKD+sLSgt4D0oLRgvnC1YPQgEAAkmFJAgkBvQAdgF0DXAB9AF0DXYBdAEUDQAAaYVECFQMBAKOAIQF9AXwA/QF9gP0CYQHBABthQAAJAh0B3YHcA/wB3QCdg90B3QHJA8EAHKFBADkAfQB5gf8AewBBAz+A0wAzA9EAAAAdIVCCmIJ0gpHBSINAgj6D6sPqg+qCfoPAgh+hQAAZAAsD+4LLAt4DywL7AuuCywPZAAAAISFJARMB0QAFgH0AfQD9AH+BfQH9AH0AQABh4UAATQBhA8GALQOsAC0DoQA3ggsB+QFIAibhQAA9A9UBVYFdAcEAJQC3gKUD9QClAKAAKaFBA70AbQItgP0C7QDtAv0A7YHtAv0BwQAqYUAAPoPOgDDDeoDKAiqCq4Kvw+qCqoKIAiqhQQEVAFcCd4HdAEEDPQDXgBUANQPVABAAKyFhACUCEQFBgX0A7QPtAH0AwYFRAWUCJQAr4UAAnQD1APWD/QP1A/QD/QP1g9UD3QBAACwhQIIig3+BdsB3gX+Ad4F/gXfAf4FigUAAMmFtAS0AvQPtgGUAgQA1A/+CtwK9ArUDwAAzYUAAPQE9Af2BfQH8AUEB1wFXgVUB1QEAADPhQAJdAdEAfQP9gO0BvQGHg/8BBQH1AgQBN2FBANcB1wH/gv8C5gLQAc2BxQHdAqEAkQA5IUEDPQDVAn2DwQBdAX0AH4PZAL0BWQJAADlhQAItAXkBQYF9AGwD7QB1AN+A2wFBAUAAOmFIgRqAwIBNwCyD/IKsgqzD6oK6g+iAAAA+4UCACoMSgMLBeIDvgN2D5cPdgO+BeIFAgUHhiQM5AF8Df4BdA3kBAACVAH2D0wBTAYEAAuGRABkC0QI7gVkAnAI9Av2CvQC9Ab0BwAILYYAAAAA/g//B/4C4AfAAv4D/wU+AP4HAABOhgAAAAzwAxAIUAd+AdQBtAeUCLQIsAQQAE+GAAAADPgDCAgoCT4HXAFcBUwJXA1YAwgAUIYAAMAPOACID6gKvgrcCtwKzArcCkgIKABRhgAAAA/wABAGUAB+BtQItAq0CJQCsAYAAFSGAAz4AwgIKAkoCz4NbAVsC0wLXAlYCQgAVYYADPgDCAuoBqgGPglcCNwL3AjcC1gKCABahgAAAA/wABAKUAh+DrQItA6UCLQKkAhQAFuGAACAD3AAEAtQCn4PVAi0DpQKtAowCAAAXoYAAAAM/AMECJQLfwe2A7YDtgfmBywKAABfhiAA7gSqBKoDJgbwARgMOANfAFoHSgQYAmeGAAz4AxgB3g+8D4wLGAjyAJIIkgiSBwAAa4YAAAAE+ASIBIgE/geIBIgEiAb4BAAIAAB5hgAA+ASIBP4D+AIABAQEBAT8BwQEBAQABH2GAAAACNwLVAlUCfQHVAVUBVQF3AUACAAIgIYgABQIyg8IBBgC8AiICIgE/geIBIgF+AeBhgAI+AmIBP4H+A4ACHgEggUMA+AEHAgACIqGAAD4Cf4Hjgf4BgAIGAjqDAoHiAN4BAgIjIYAAPgEiAT+B/gGAAQoASgB/g8kASQBAAGVhogASgjqCVoJTgnqB0oFSgVaB+oHSgxICMeGAAD4BP4HiATwBggA6AcKCYwIiAhYCAAGy4YAABIEygVKBVIF3gdWBVYFVgfWBRIIAADZhgAA+Az+B/4H+AYACCQJJAm/DyQJJAkgCNuGAAj4Bf4HiAT4BgAAXgZIAf4PSAFIAgAE7oYABBQE1AVEBVwFxgdEBVwFRAXUBRQIAAAAh0AAXAD0BXQFfAX0B3QFfAX0DTQI/AcAAAKHAAj4Cf4Hjgf4ClAASAVuBdQPbAVEBUAEHIcAABQEpAekBrQGtge0BqwGjAaUBxQIAAAhhwAA+ARIAv4DeAMABtQHXgVUBV4F1AcQAEeHAAD4CfgEjgf4BgAI/AO0AvQHtAr8DQAEZocACPgE/geIBHAC/g+SAg4IYAliB94IAAh0h/gJiAT+B4gEeACAB38CgA/+AxII/gcAAHaHAAj4Bf4H+AYAAHwNSAP8D2gDfAVICQAAgocACPgF/geIBnAE/AdWBTwC+A8EAPwDAACNhwQA/A/sBOwCfAmAB3gAiAj+B4gE+AYACJ6HAAD4BM4D/gNIAjABfgaqAv4BqgmCBwAAoocAAGIE6AfuBuQG4AfyBugG7gboB3QIAAi6hwAA+AmOB/4HiATwBR4J6g1+DyoBvgsACtGHAAj4Bf4H+AYACPQDdAN0A3YP9AMQAgAA8ocAAKALrAqsB6wHPgisA6wKvAesBqAHAAj5h4QEfAQ3Bb4FtgV4B8oHtgWyBboHNggAAPuHAAT8Av8DRAJ+ATsL2g9+A+oHKwdqCwAJDYgACPgF/gfwBnwPPAO8B+ADMAf+AAgDOAQfiAAA+An+B4gEcAImD3gLdAD6D1AEfgMADCGIAADUBdwFvge/BbcJPwCXBa0HrAWkBQAAIogAAKoFngX+B/4F/gn/AP4F/geeBaoHIAg7iCwAFwTeBUAFdgX/B34FcAVkBb8HNAgSAECIAAT4BwgECAT8BwoECAT4BwgECAT4BwAERogACCAJvAQkBLwApg98ASQCJAW8BCAIAABMiIgASADkDxIAAAAkACQAJAgkCOQPJAAgAE2IiABEAPMPCAAiDCIChAEgCCII4g8iAAAAU4hAAEQA8w8JAMgB/wcIAMMFEATyBxIAAABUiAAAzADyDxgAhgj1B5QEAAAkCOQPJAAAAFeIQABEAPIPGQJQAt4DVAJUBgAE8gcSAAAAWYgAAMgA5A8CAFQPfAV0B2QAJAAkCOQHIABbiAQAQgD5DwgA+gPfAtoH/gICAPIHEgAAAF2IAAAkAPIPCAB6CVoJ/gf6BQkEIADkDyAAYYgAAEQA8g8ICfgFrgP8A6wN+AEACOQPIABiiAAAjADgDxwAvAecB5gHvAe8BAAA5A8gAGOIgACIAEgIyA8oCBoEPATIAIgDSAQoCAAIZYgAAAgBigDqD5gASAEAAP4PIABAAMAAgABoiCABNAm0BLQHdAQ+BPQENAG0ArQEIAgAAGuICAGIAO4PnABIAQAIiARIBEQCMgIQAQAAbIgIAYgA7g+cAEgBAADQABAJEAj+BxAAAABwiBQBFAV8BVwH3AReBNwEXAFcA3wFFAUQBHeIAAAEAnQCVA5UCfYIVAlUAlQGdAkECQAAgYgAAhAC9AK0DrQJvgS0AbQCtAZ0BRAJAAiLiJACiAK8CoIOiAnICI4JmAKqBsoKygqoCI2IAAGMAOwPWAEAAPAHLAkoCegLCAr4CQAElogIAYgA6g/YAAAA+A+IBIgE/weIBIgE+A+ciAABigDqD9gAAARIAkgB/g9IAUgCSAQAAKuICAGIAMoPuAEADPgDyAhICX4GSAbICRgIrYiEAqQCpAqUDowJpgi8CdYC1gbUBcQFtAixiAABiADqD/AAIAD8DwIAEAf+AJADFgwAALSICAGIAOwPmAAAAKgAuAOsAqgKmAqoBqAAwYgAAVQL1AdeBFQBVAMQDP4CEAPSBBQIAAbCiNYC1gLeCq4OngnGBIABngLABsAF/gkACMWIoAKsApAKvA6ACagEqAG8AqgGqASoCAAAz4gABEQFfA18D3wJ/gl8A3wFfAV8C0QLAAjUiBQA1A90APQHbAVkBWYFzAbUAKQPJAAAANWICAGIAO4PWACIAAABxA+yCIgIsgjED4gB2IiABKwCrAqsDoQJ3gSEAaYCrgasBKQIAADZiAABiADrD9gAgAIqAeoHvgSqBKoEvgcIANyICAEIAc4PuAAAAOgPqAKoAv4PqAKqCuoH3YiQAr4CmAqYDr4JgASoBKgBvgKoBqgEiAjhiAgBiADsD9gAAAB8CVQJVAn8D1QJfAkAAOSIAAGKAOoP2AAADPwDRAC2ApQPlAKUAgAA84gAApwEhQK2DrQJ9gS0AbQCtgaFBJwIAAD4iAgBigDqD9AAgAT8BNQC1A/8D9QB/AKABPmIgAJEAnwBfAf8BP4EfAF8AnwCfAXEBAAA/YgIAr4CnAq+BpwF/ASAAZwCwAbABb4JAAQHiYAASADuB3gAAAU+Bf4FvAK8ArwFvAQEBBCJCAGJAMoPuAAAAb4HqgSqBaoGqgi+BwAAMokAAZQA1AewAAAE+APoA+wD+AfoA+gD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/AP0A/QFHAQAALiMAAAICOQL6gblBuQC5gLsBvYG9gcECAAIu4wACFQI3Av8B94H3APcA94H3Af8CxwIAAi8jAAI/A1UAVQB/AUAAIAPgAT/BJgEmA8YAL+MAAQQBPwF9APsA/AB9AHsA+QD1AUMBAAAwIwAABQIzAvmCvQK7ALgAv4K8gryCx4IAAjDjBAACADcA8QL4AvqA+oD/gvqC+kDKgAAAMSMAAj8DVQFVAH8BUAA+A+sAqgCqAroBwAAx4wQCBII9Av0BuQG9AL2AuwG9Ab0CxQIAADKjAAI/A1UAVQF/AFIAOgJSAR+AogFbAgIBtOMIAAsCOwH/AbsAv4C7AL8AvwG/AcMCAAI24wAABwIzAXuBewF7AHgAfwF7gX8BRwIIADcjAAI/A1UAVQF/AUAAb4C6gmqBKoDvgiAB96MAAAcCMYP9g30DfYF9AX0DfYNxQ8cCAAA4IwACPwFVAVUAfwFIAC0B6QEpgSkBLQHJADijAAIPgj6B/4H+gf6A+AD4gfaB5oHJgggAOOMAAQ6CO4H7gf+B+8D7gP+B+4H7gc+CAIA5IwACPwFVAVUAfwDqAjsBBgH2ga8CbgJEATmjAAI/A1UAfwFAAjUDxQI0AeQBP4DEAwUBuqMIAAcCMwL7Ab6BvgC7gLqBuoG2gsKCAgA7YwABPwHVAFUA/wFAAGkB/4FpAW8BaYHIAD0jAAEeAJYAfwPWAE4AMAL7ArkAvQG7AcACPqMAAD8DVQB/AIICGwF+A9oAfgPbgPoBUAI/IwACPwNVAFUA/wGwA/sAv4C7Av+CuwHIAL9jAAArAh8BPwH/AP+A/wD/AP8B7QEpAQAAAiNAAj8BVQB/AUAAPwP5wrkCvwK5ArnD3wACo0AACgI/g9eDVwFXAV8BV4FXgXsDxwICAgPjQAMggO2CjoHugm7A7oFOgC6B7oPCgQAAB2NAAAACPwJBAQEBAQC9AEEBAQE/AkACAAAHo0ACAAI8AsQCBAEHgLUARQEFAT0BQQIAAAfjSAIEAj4CRQIFgQUAtQBHAQQBPAJAAgAACGNAAAUCNQLVAhUBlwBVARUBFQI1AsUCAAAIo0ACP4JAgT6AwIA/g4AAAgDiAhoCP8HCAAjjRAAFAjcC1wIXARcA14AXARcBNwFFAgAACSNAAAeCMAFQAReAkABZgRaBFoI1gsSACAAJY0ACP4IAgb6Af4MAABwCI4EiAN4BAgIAAAmjQAEfwf5AAEC/wIACP8HIAToACYDIQQAACeNAAAICMQLXghBBkQBTwRUBFQI0gsKCAAAKI0AAPAHDADsCSwELAK8ASoEKgTqBQgIAAApjQAAfA/0AAQC/AAADvwBNAzUAhQD8gQECCqNCAAICNQLVAhSBFoDUgB0BFQE1AUECAgAK40IACgI7AtqCFoESANoAGoEXATEBQgICAAsjQAI/g3yAwIC/gAADCQCIgYqCeIIIQgACC2NAAj8DeQDBAD8DhAAzAEKAcgJCAj4BwAALo0AAPwJBAT0AwQA/A4QAAgEDgQIBAgEOAQvjQAACAj8C2oIagZ+AWoEagRqCP4LCAgAADGNAAj8CAQG9AH8AgAIUAT+BFAHVAlQCQAENI0ACPwN9AMEAPwGAACAD/4EiASIBIgPAAA1jQAAIAj8C3QIdAR0A34AdAR0BPwFIAgAADeNEAAICNwLQghIBEgDTgBYBGoI4gsUAAAAOI0AAAAI3AtSCFsEQANSAE4EYgTiBR4IAAA5jQAIQAjeC3YIXwRWA1YAXwRWBNYFFggAADqNAAAUCNQLTghkBlwBQARcBFQI1AscAAAAPI0ABPwC9AEEBPwAAAboAQgIfgSIB+oICAY+jQIIOgjqBWoEfgRqA2oAfgJqBOoFOggCAD+NAAD8DfQDBAD8BcAA+A+uAqgCqAroDwgAQY0IAAQI3wVABGoDagBqAn4CagTpBSoIAABEjRAIEgjUBUAEaAJmA1YATAJUBNQFDAgAAEuNAAD8DeQD/AAACNQPFAjUBxAA/gMQDBYGTI0AAPwP9AEEBPwFgADUD34FVAVYBdQPEABPjQAAHAiGC7QItAS2ArQAtAS2BIUFHAgAAFCNAAj8CQQE9AMEAPwOAAC+AOoLqgaqCb4HVI0ACPwH5AEEBPwFAACoD6QEpgS0BKQHIABWjQAI9ASUAv4PlAH0CgAI+AfWAxwI9AsACFqNAAj8DeQD/AAACFoF/A9YAfgPXgX4CUAAW40AAKwIvAj8BbwEvgK8ALwE/AW0BCQJAABejSAALgicC04IfARAA24AXAROBJwFLAgoAGCNAAB+BAID+gACAn4AmAd/BXwFfwX8BwAAYo0ADOIDvgr+B94MPwP+DN4HPgH+DwYEAABkjSACpAGkCCQG5AE+CCQI5A8kAKQAIAMAAmaNgAkkBOQDPgjkByQAgAk0BMoCiAN4BAgIa42ACSQE5AM+COQHpACAB+QBPgjkByQAgANwjSAIKASoAygEKAT8DygJKAkoCSgJIAgAAHSNEAbUARQC/gNUBFQEUAQABP4FCAQQBCAEdY0QBtQBFAH+A1QEVAQABcwEMARMBIIFAAR2jSAMpAMkBP4HpAikCAAIJAj8CyQIJAgAAHeNEAjUBxQC/geUCJQIAAjkCSQKJAo8CoAJgY0QBtQBFAH+A1QEUAQEBVIFIgWkBIgECASFjQAI2AcYBPwHmAgQCNQLTApkCmQK3AsACIqNIAyoA/wHqAgACPgJiAgICn4JyAoqCgAIi40gBqgBKAL+A4gEIAQYBVYFVAVcBfQFAASVjSAGqAEoAvwDqAUABVwE3ATcBdwE3AQABJmNIAyoAygC/AeoCAAI9AswCLwIkAr0CQAIn40ACKQHJAL/B6QIBAj0C5AIXgmQCPYLAAijjRQAFASeA/QDEAT+BKoE/gUABOQFHAUABKiNEAzUAxQC/geUCKQI7wteCUoJbgjeCwAAs40AAAAIPASkAyQEJAjkDyQJJAk8CQAIAAC0jQAI3gcSBPIHngAADvwBAAAEAPwAAAcACMONAAjeB/IHkgSeBAAAJAwiA/4AIgMiBCAIzI0ABN4HEgTyA14CAAhOBEgD/gBIA0gESAjRjQAE3gcSBPIHngQAAPoHtAj0CgQK/AkABN2NAATcBxQE9AOcAgAA/A8UBRQFFAX0BQAE340ACN4HEgTyB54AAAj8D1QI1AFUBnwFAAnhjQAEngfyB5IEDgLgDPgDDgj4BwgA6AEAAOiNAASeB/IH8geOBCAAuAOoCqwKuAqoBqgA6o0AAB4H8geSBD4M+AcWANQHVAhcCtAJEATvjQAI3gcSBPIHngSQAIgP1gikCLwIxA+AAPONAAjeB/IHngQAAAgN/gMAAP4HQAiYCAQF9Y0ABN4H8geSBB4CgAhIBP8ESAMqBaoJgAQKjgAAAAQeD/IHngQAAOQPpAL0D6wC5A8AAA+OAADeDxIE8geeBAAAuA+ACv4KkAqsDyQAEI4ABN4H8geSBB4IQAnoBS8HGAWpC00LJAkijgAE3gfyB5IEngKAAL4C6gmqBqoBvg8AACmOAACeD/IHngQABJQApA6EAdQPggK6BIIIKo4ABN4HEgT+B4AA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7AXsBfwLQAm5jwAIIgTsAwgEAAgIC8gIPggICggK+AkABLqPQghGBMgHAAQECMQLPAgECgQKBAr8CQAIu49ICFIE1gMEBBAIEAgQCP8LEAgQCBAIAAi8j0IIQgTMBwAIAAqCCWIIPgjACAAJAAoAAL2PAAgkBOgDAAQECAQKBAr0CxQIDAgECAAAvo8gCCIE7AMABAgICAvICD4ISAiICAgLAAjBjyAIJgToAwAEJAgkCCQI/AsiCCIIIggABMSPIAgkBOgDAAQwBAgJrApoCigKKAoICQAAxY8kCCQE6AcABCQIJAj0CyQIBAj8CQAKgAnHjyAIIgTsAwAECAgoCMgICAoICv4JCAgICMiPJAgkBOgHAAgEC8QIPAgUCBQKFAr0CQQEzo8ACEYMyAMABPwJBAkACPwLBAgECfwIAADQjyAIJAToBwAIEArUCTQJFAlUCZQJFAoACNGPQghCBMQHAAgAC/4IEggSCPILEggSCAAA1I8ACEIEzAcACAAL/ggyCtIKEgnSCjIKAgrYjwAIIgTsAwgEgAhECCQI/AsECCQIxAiACNmPAAgkBOgHAAgoCigJyghMCLgICAkICgAA248gCCIE7AMABEgISAv+CEgISAj+C0gISAjcjyAIJAToBwAIEAoUCfQIFAj0CxQKkAkAAN2PAAQiBOwDAARUBFQEVAT+BVQEVATEBQAA3o8ACCIE7AcABBQJLAkmCfQLJAkkCQQJAADfjyAIJAToAwAEAAn8CCQIZAjkCCQJPAoACOaPAAhOBMAHBAX8BAYI/AsACPwLBAr8CwAI6o8ACCQE6AcACPgLSApICv4LSApICvgLAADrj0QIRATIBwAEAAj4C0gKTgpICkgK+AsACPCPQghCBMwHAASICWgICAj+CwgIagiKCQAI9I+QCNQEtAMABPwJBAr0CpQK9AoECvwLAAD3j0IIRgTIBwAIJAuoCGAI/gtgCKgIJAsACvmPAAgkBOgDCARgCAgL+ggMCvgLCAjoCAAA/Y9CCEIExAMABPwJVApWClUKVApcCsALAAgAkEAIQgTMBwQIAAr+CyoKagiqCV4KQAoAAAGQQghCBMwHAARICE4KSAn4CEoJSgpICgAIApAgCCYE6AcABBQI1AtUCnwKUgpSCtILEAgDkAAIRAjIBwAEnAhACv4JAAj+CUAKnAqACgaQAAhODMADCATqCI4KiAr4CYgIjgjqCAgICZAACCQI6AcACCAKrAloCD4I6AsoCigKIAkKkAAIIgTsBwAEIgj6C0YIMAr+CwAIOAjAAA2QAACSCPQGlAUACPYLEAheCRAJlAryCwAID5AACCQI6AcABCwILAvcCFwInAqqCqoJIAgQkAAIIgTsAwAEEgWqCK4KUgriCVIIiggABBKQIAQiBOwDAAR0BVcF1AT8BVYEVQXcBAAEFJAACE4EwAcQBEgJVAhUCvIJVAhICVAJEAgXkAAIJAzIAxAEBAh0CtQKVArUC/QKBAoACBmQAABUBHwC2AMABPgFeAV8BXgF+AUIBAAEGpAgCCIE5AMABPoJrgiuCPoLrgiuCvoJAAAbkAAIJAToB0AILgv0CAAKJAr8CyQKJAoAAB2QAAgmCOgHAAhICv4JCAj8CxII8gsSCAAAHpAAANIIvAaYBQAIvAq0CvQLtAq8CgAKAAAfkEIIQgTMBwAIdApUCdQI/gvUCFQJdAoECiCQAAgkCOgHAAQgCKwLqAq8CqgKqAsgCAAAIpAACCYE4AcECJQKkgqvCuoLrgqqCggKEAgjkAIIJgTkAwAEfAlcCVwJ/gtcCVwJfAkECS6QAAhOCMAHEAiUClQKVAj+C1QJfAoQCgAIMZAACEIMzAMABP4JAgjqCXoJ6gkCCv4JAAgykAAIRgjIBwAEEAj+C6gK/AuqCqgKCAoACDiQQghEBMQHEAh4ClYJ1gh0CNwLUApwCgABO5AgCCQE6AMABJwIVAp8ClQJXAnUCBwIAAA8kCQIKAToB4ALfAVsDewPbA1sDfwPAAgAAD6QAAgiDOIDCAToBfwI/AsLCOoIBAzoDwgAQpAACEYEyAMABCgJbgnYCKgKyAmuCKgICAlFkEAIRATYAwAF/AgUCNQJ1AnUC/QJ3AkACEeQAAgkBOwHAAj+C2oI/gl+CWoLfgzADwAASpAACEYMwAMEBfwIFwrkCQwIRgr0C1QIRAhLkAAIIgzkAwAEegl6CXoJ+gt6CXoJegkAAU2QAAgiBOwDAAX8CNQLtAj2C7QI9Au8COALTpAACEIIzAcACOALPgjiCXoJ6gk+COALAABPkAAEIgLsA4AC3AU8BbwFvAU8BTwH/AcAAlOQIAgkBOgHAAQICPoLvgq4Cr4K+gsICAAAVJAACEYEyAMABNQJ9AnUCd4L1An0CdQJEAhVkAAIRAjIBwAI/ArcC9wK3grcC/wKiAoACFeQAAgiBOwDAATuCGoKagl/CGoK6gouCCAEWZCQCPYGkAUACLgOpA68DvYPrA6sDqQOgAhckAAA0Qy2AhAFQgT6CQYKXAj2C0IIwQoAAF6QkAjzBBQDgAR+CAIL8gg+Cn4IdQl1CjABYJACCEIIwgcIBHwJXAncCN4LXAn8CYgKAAhjkAIIQgzEAxAE/An8CvwK/gr8CvwKkAsACGWQAAgkDOgDAARMCXwKZArsC2QKYgpqC0AAaJCACNYIMAcEBvQJfg1UDUQLEAiOC3gKCAppkAAIRgzIAwAE9Ak0CPwJdgn8CTQK9AkACG2QAAgRBPYDAAT+Cb4Kvwq+Cr8K/gseCAAEbpAABCYC6AOAAnwEFAV0BFYGVAV0BBQFAABykJAI1AS0BwAG/AkMCLQKjArcC4wKvAoACnWQAAgmCOgHAAR8CW4LbAlsCXwN/g98CQQBd5CACNQEtAMABfwI7Av8DOwO/A/sDHwJAAl4kAEIJgTkA4AErgruCq4IoAjuCq4KrgoICHqQBAhEBMQDEAT8DfwL/An+CfwL/AsQCAAIf5AAAEQMyAMABfwLVArcCwgIuAjsC7QIqAiAkAIILAzgB0wG/Al+CVwLEAgOC+gIGAsACIGQkAjWBLAHAAiEC/QJ/gn0CfQJ/gj0CwAIhJACCEQIxAcQBH4Jegn+CPoLfgn6CZ4KEAiKkJAI1gSwB8AI/A38C34LfA/8D/wLwAgACI+QAACkDOgDAAT8D1QLnAvUC9wL1AvcCwAKkZAAAAAA3AdUCVQJ1AlUCVQJVAncCQAEAACTkAAAFAQkAsQBNAEMAgAA/A8EAHQCjAEAAJWQAAAEAPoH0ArUCtoL0ArUCtoK+gsACAAAl5BAAEQARAD8D0QARAAAAPwPBAB0AowBAAChkAgICAf4AC4IKAjoBwAA/A8EAHQCjAEAAKKQAAhEDvwBRABEAPwHRAAAAPwPBAB0AowBo5AkACQN/AMkCSQJ/AcAAPwPBAD0AgwBAACmkIAApAykA/8ApACkAAAA/g8CAHoChgEAAKqQAAAEBjQBpAj8DyQAAAD8DwQAdAKMAQAArpAAAPgHSAL+A0gC+AcAAPwPBAB0AowBAACvkAgA/g9IBEgESAT+DwAA/A8EAHwChAEAALGQAAT8ByQEJALkAyQCAAD8DwQAdAKMAQAAs5CEBEQEJAT8ByQCxAIAAPwPBAB0AowBAAC1kCAAog+eBIIEogSeBwAA/g8GAHYCjAEAALiQAAL+CSIJIgl+CKILAAD+DwIAegKGAQAAuZAIABgElASTBJIEngTgD/4DAgA6AcYAAAC7kBAAUAFIA1YOyAlQAAAA/A8EAHQCjAEAAMGQAADIAPgPrAKoCugHAAD8DwQA9AQMAwAAypBIBCgEqAIMAagBKAIAAPwHBAB0AowBAADOkAAE/AeUApYClAL8BAAA/A8EAHQCjAEAANGQQAhKBEoD+ABIAU4GAAD8DwQAfAKEAQAA05AAAJYC8gKaAtIPkgIGAPwPAgB6AoYBAADdkCAApAgkBv4B5A+kAAAA/g8CAHoChgEAAOGQCgIqAf4PqgSqBL4HAAD+DwIAegKGAQAA6JAgAKgPpASmBKQEqA8AAPwPBAB0AowBAADrkAAAfAHUAX4BVAd8AQAA/A8EAHQCjAEAAO2QBAL0AtQK1g/UAvQCAAD8DwQAdAKMAQAA75AAAKQIpAQQAs4DEAKkDf4PAgA6AsYBAAD0kIABSAD/DygBwAD/DygAAAD+DwIAegKGAfWQTAn8CUwJ/AdKBfoFAAD+DwIAOgLGAQAA95CYCNwGowEABP4HUgJ+AwAA/g8CAP4DAAD4kAAC8AK2AvAPvgLwAgAA/A8EAHQCjAEAAP2QAACUANQPfgVUBVwF1AcAAPwPBAB8AoQBApGAALwAtAu8CqgKtAa8AAAA/A9kBJwDAAAJkRAJ3AQyA4AA/AeWBPwGAAD+DwIA/gMAABmREADXB9UE/QXVBVcE0AcAAP4PAgA6AcYAJ5EoABoI2gpWCUANvglAAP4PAgB6AoYBAAAtkQAK9AsWB7wDPAtWC+QD/A8EAHQCjAEAADCRAAAoCewGiAO+AYgC3A+AAPwPBAL8AQAATJEAAPoPfgQ+BUoE+g8wAM4ICAkICPgHAABNkQAA+g8+BToFTgX6DwAA4gciCCIIfggABlKRAAAZBKMDAAD5D0kFPwUJBT8FSQX5BwAAbJEAAPoPfgU+BfoP8AD+ByAA/gcgAP8PAABxkUAAwg/UDtAO3g3ADOgM5g3WDtQOzA9EAHeRAAD6Dz4FfgX4DzwDqgSoBL4EqAcAAAAAeJEAAPoPPgV+BfoPAAEsBZoFuAKsBSgIAAB/kQAA+g9+BT4F+g8AAPwPVATWAFQDfAQABIeRAAD2Dz4FfgX2DwAAvAqsCq4PrAK8AgQCiZEAAPoPfgU+BfoPAAAkARQBxg80AWQBAAGLkQAA+g9+BB4F+g8AAOQHfwVkBX8F5AcAAJKRAAD6D34FPgVKBfAPngiqCqoPqgq+CgAAnJECAPoPfgQ+BfIPeAhUB/4A1Af8CwAEAACrkQAAXgD6B/4F7gb+BrwG9gfSB/YHVAAAAKyRkAC8D5gLvgmADbgNvA2cD9wP9AuUD5AAtJECAPoPfgQ+BUoEtg9qCP8N6gr/CusO/gvHkUAEVAJUAkQBzADkD8QAYgFyAkoCQAQAAMiRAACWAVIA/gdVAAAG/wEhAOEAIQM/DAAEypEAACoDogD+D6MAqgCgAq4Ckg+qAqYCIgLLkQQArAH8D6IAqAA+AvoCvgK6B74C+gIuAsyRAAAABL4EqgSqBKoE/geqBKoEvgQABAAAzZEAABAE9AX0BfQF/Af0BfQF8gXyBRAEAADOkQAAfAlUCfwHVAV8AQAIJAj0DywA5AAAAM+RAAAgBPwH/Af8B/wH/Af8B/wH/AcgBCAA0ZEQALAIkAmYC5YI8Q+SCJQImAqQCDAIAADdkVAIWAtUCPIHVAREBQAAIAD+DyAAIAAAAOORUAhYC1QI8gdUBEQFEADOCAgJCAz4AwAA55FACFgLVAjyB1QGAAz+AwAA/AcAAP4PAAAVklAIWAn2B1QEVAEACEQI/A9ECMQPfAhAAB6SUAhYC1QI8gdUBFgFBgElCSQJBAX8AwAANJJQCFgLVAjyB1QFEARIANcPUgBMBNAHEABEklAJXAjyB1QERAEQBE4ESAP+AEgDSARICHGSUAhcCfIHVAQADfgDCAAIB+4ECASIBwAIdJJACF4JQAtgCV4J0A9WCWQNNAlUCUQIAACAklAIWAtUCPIHVAcAAP4PSgjKAUoGfgkACIOSUAhcCfIHUgQEDWQENAMsACYAtA80CEQGhZJQCFwJ8gdSBIQE/g8CAOoDKgHCCP4HAACYklgEVAXyB1IERAUQAhgBlA/mBJwEhA8AAK2SUAhcBfIHVARUAQAIqAT+BagGqgmqCAAGs5JQCFwF9gdABRAA/ASSBpABkg/0CBgIEAS3kkAIUAlcBPIHRAYIDfYHEABeARAJ9gcAANKSAABQCFwF8gdUBQAASAWvBZIPrgWiBUAE6pJQC1gE9gdIBFgFCADoD6gC/g+oAuoPAADtklAJWAVUBPIHVAQAAXoMzANIAMwPeggABvySAABQC1wI8gdUB/wLDASkA+QDDAv8BwAABJNQCFgJ9gdUBEQFAATYAlYI1A90AEwFQAUik1AIWAX2B1QEVAEACCgJngUYB1oHKguoCCaTKAQuBfkDKgYqB4AHvgDrD6oAqgS+AwAAK5NQCFgJVATyB0QHAAS+BOoDqgaqCb4HAAAvk1gIVAnyB1QEBAUkAP4HZAVkBX4F5AcAADKTUAhYCfYHVAQABaIEKgDqD6oBKgK+AqAENpNIC1wI8gdUBEQBFABUD9QIfgjUA1QFQAlKk1gIVAnyB1QEBAX0BLQClAH+D7QB9AIEBEuTUAlYCPYHVAUEAOAPPgCyA6oCPgngBwAAdZNICFwJ8gfEBzAMLgPgBKoG/wuqCr4KCAh+k2gIbAlqBPkHagcCDP4Irgr+D64K/QoACIyTSATOBPkHSgXsBa0C/g+sAPwPrwL8BAAAlpNQCFgIVAnyB1QEAAn0C7AKvgKwAvYLAAiuk0AIUAtcCPIH1AUAAPwL7AruAuwK/AsACuGTUAhYCFYJ8QdSBAoN6ghuB2sBbg/qCQgEGJRQCFwF8gdUBQAA8gt6C3ML8w9yC34L8gs1lDAIWgr8BxwHdAC0B74HVAz+BRAH1ggABlGUUAhcCfIHBAd+AKoP7gm6DwAJTg9ICUgPcJQICFwJ8gdEBQgA6A/EB5IC9A+EAmgPAAB9lFAIXAXyB1QNAAgYCN4F3APcC94LrAsoAIiUmACGCPUPlASEBCAAIAAgAP4PIAAgACAAiZQAAJgAhgj1D5QElAQAAAQIBAj8BwQABACTlAAAmACGCPQPlASgAhwASgCICQgI+AcAAJ6UmACGCPUPlASEDIAIOAgABP4DgAEIADAAn5SYAIYI9Q+UBAQE8AGQAJAA/g+QAJAA8AGilJgAhgD1D5QEAAD+DwICMgH6AQII/gcAAKWUuACGCOUPpASkAAAM/AMkASQJJAn8DwAAppQAAJgAhgj0D5QEhAwwCA4G6AEIAzgECAinlJgAhAj2B5QEhAIQAE4CSAlICQgM+AMAAKmUmACGAPUPlAQEBBAB7gEICcgLCAj4BwAArpSYAIYI9A+UBIQMAAhCDv4JQghCDv4JAAixlJgAhgj1B5QE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OgDGAAAI6AquCpQPrAqkCqAIAACKlgAA/g8yAM4EgASqAnwKSAm4B08AqQMoAouWAAD+D3IAjgEgAJQP3APWA/QD1AvUB0AAjpYAAP4PAgD+AQAA3gdUBUAFXgVkBeQHEACPlgAA/g8KAPYLAAjoBwAI/AtWCVQJ9AsACJCWAAD+DwoA9gAABqwAqwWqCa4KqgD4DgAIlJYAAP4PCgH0AAAAvA+sAKwCrA6sArwIhAeZlgAA/g8CADoBxgQABP4C0AjeB9AA9gIABJuWAAD/DxkA7wBsBrcArgSgB6cAuAKuAiIAnJYAAP4PAgA6AcYAEAL0AvwC9g/8AvQCEAKglgAA/g8yAM4JBARsAWQNbAlkC3IJ6gEADKOWAAD+DzIAzgAACe4FmAO/AJgD6g+oAgAAp5YAAP4PMgDMCEAEtgeABKoJ+AzIC84IKAmolgAA/g8yAMwI4gcUBNQL7AjuCXwN7A8ECKqWAAD+DzoBxghQBLgC9AATCPQGuAToDAgAsZYAAP4PAgH+AMAN9gHyB/oL8g35AfUNoAi2lhAEVAVUBVQCVAr+B1QBVAJUA7wEkAQAALuWEAgQCXgJfAl4B3gFfAV4BXgHeAlICAAIvpYAABQGpAHkABwDIAD+D6gE+geoBKgEAADAlgAAUABYAMQP4AreCvAK8A/ECsQK2AoQAMGWAAb+AUIA+gcCACIA+gdSBfoHUgVSBQAAxJYIDOgDHgjIBwgEIAP8B6oEqAT8B6oEqATFliQGvAFkCPwHJADwD64EqAT+B6oEqAQAAMaWCAgIBXwFXgNcA9wPfgFdA1wFXAVECQABx5YAAAQO/AGsAOwP7ArsCuwP7ArsCvwKBAjMlgAA8A8ABP4HAAT+BzAC/g+oBPoHqAQIBNGWJAC0BI4ChA+8AkAEMAD+B0gF/AdKBUgF1ZaAD3wANAe0AjQJ/AcwAPwPqgT0B6gECATWlgAA7gSqBPoDrgLgBjAA/g+oBPoHqASoBNmWAAAICL8EvAS+BbwGiAK+ArwFvgW8BCQE3JYgAKQGlADGD7QCAAD+D6gEqgT6B6gEqATelgQIfAl8BaoDUg04AfwPqgSoBP4HqAQIBOKWgA/0ANQD1gLECPQHIAD+DygF/AcqBQAE45YAAPQJ1gX0A9YF9AUgAP4PqAT8B6oEqATolgQA9A8UAFQBFAD8DxQAVAFUChQI9A8EAOqWGADKCsoKygqKCr4KigrKCsoKyg8YAAAA75YACJgIygjqCcoGngTKBIoG2gnKCJgIAAjwlgAKGAmaBboFCgM+ARoJOgmKBxgBAAIAAPKWAAEMBWUFZQdFBV8FRQVlB2UHBQ0cCQAA9paAAJgAmgG6BUoF3gXKBVoNuguKAZgAgAD3lhgAyg/KCsoKigq+D4oKygrKCsoPGAAAAPuWAAAYANoH+gLKAt4H2gr6CsoLGAgABgAA/pYAAVgLXAtcC8wG3ALcAnwLTAtcBwAAAAAAlwAAWABaD3oBSg/eAVoPegFKCVgHQAAAAASXAAAeAA4IrgeGAd4FhgbWAt4KhgceAAAABpcACEwJ5gV2CyYIPg1GDfYPdg1mDQwNAAAHlxgM2gN6CfoHygXeBcoH+gX6BcoHWAsACQmXAAAMAWYF5gbmBsYH3gbGDuYO5gdMBQAACpcACDgJiguqCYoPvgmKD6oPqgkKCzgLAAgNlwABDAGmD7YLhgveD4YLtgumC4wIAAAAAA6XGAJaC0oLagvKD24PSg9aB/oHSgtaCxgIE5cAAA4ADgjWC64KrgYGAq4GvgrmCw4IAAQWlwAAmASKAroPigI+AIoGugG6D4oCmAQABByXAACYBLoCug+6Aj4Avgf6BfoF+gXIBwAAHpcYAMoP+gX6BcoF3gwKCPoL+gXKBdgLAAgnlwAAAAxMA+YP9gFGAx4KxgZ2A+YLTAcAATKXGAjKDXoJeg/KC54Cig56C/oKSg9YAgAAOJcAAEwH5gf2D8YHXgMGDPYD9gLmCswHAAA5lwAG7AF1B20FbQUFBy8C5QKlD60C7QKgAEKXAA7sAWUE/QT9BnUE5wdlBv0G9Qb1BCAASJcACAwJ5gv+C0YJrg+mCeYNTgu2COQIAABSlxAAFAD8D7wCvAK+ArwCvAq8CvwHFAAQAFaXCALoAg4C6AEAAPwPvAK+ArwKvAr8DxQAWZcQANwP3ALeCtwPEABYCVYJ9AdcAfABQABclxAI3AfcAt4K3AcAAIgCpArqB6IC6gOAAF6XAAEoASgBKAH+DwAAAAD+DygBKAEoAQABYJcABAgHfAdeB1wPXABeAFwPXAd8BwgHAARilwAA8g8SBPIHXgVSBfIHEgQSBPIPAgAAAGmXAAAEAuQCvgK0AvQPtAK0Ar4C5AIEAgAAi5cAAOQCrgL8D+4CBAogCCQJvw8kCSQJAACNlwQA7gKsA/4O5AIAAEgJxgl0BkQF6ARACJGXBALuAvwPrgJkCOAHBAiQC34I0AgQCwAAmJcEAP4CtAL0D74CQAj0BxAAXgEQCfQHAACtlwQC7gL8D24A/g98CawH/ASsCPwIBAgAANOX/AKsAq4PrAb8BgAE7AeuBawPrAXsBQgE5pcAAJIAkgCSAJIA/w+SAJIAkgSSBIADAADplwAA9ALUAt4P1AL0AgAAqAD+D6gAqASIA/OXEAAUANQHVAVUBVYFVAVUBVwF1AcUABAA9ZcgAOgHZgV0BeQHIAAQAS4FqAgICPgHAAD2lxAA3AdWBVwF1AcEALAHjgSiBKIEngcAAPuXEADcB1UFWgXUBwQA+A9UA1QDVAP8DwAI/5eUAL4A1QfgB/4H7gfOB8AH3gfGB5oAAAABmAAIBAj8C6wGrAasAqwCrAasBvwLBAgAAAKYBAgECPwPBAAACPwLrAqsAqwGrAb8CwAABZgEAQQB/AEEAQQI/AesBqwCrAasBvwLAAgGmAAI/AcAAPgDAAD+DwAA/AesBqwCrAr8CwiYSAjIBCQEEAMECPwLrAqsAqwCrAr8CwAIEJgkCCQI9A88AOQIAAj8C6wCrAKsCvwLAAARmAAAFAf0ABQC9AMACPwHrAasAqwC/AsACBOY6ACIAPwPiAToAgAI9Ae0BrwCtAr0CwAAF5gADvgBKAy8AqgDWAj8C6wKrAKsBvwHAAgYmAAAWADUB1IAxAkMBPwHrAKsAqwG/A8AAC2YAAB8CEwFTAR8BwAM/AmsCqwCrAb8BwAIO5gQAN4FEAR/AhQBkAD+DVYDVgNWAf4FAAQ8mAAAeAZYAfwPWAE4CvwJrAasAqwG/AcACEaYAAS8BKwC/A+sApwI+AmsCqwCrAb8BwAITJhADFwDXATcB1wJAAz8DVwJXAlcCfwNAAxNmCABrA+0BVYFpAcMAPwHrAasAqwK/AsAAE+YAAzsAzwIrgksBSQC/AusCqwCrAb8BwAIVJgADOQDLAimCiwFJAD8C6wKrAKsCvwLAAhYmAAP/AB8BqwArA/8AQAI/AesBqwC/AsACFuYBAr8C9wK3gL8CwAA/AesBqwCrAb8CwAAXpgAAKwEmALeAZwCiAj8C6wGrAKsAvwHAAhnmAAO+gEqD6oH2geABwII+guuBqoC+gcCDG+YAAH8DdoBGgn6A7wDAAn8B6wGrAL8CwAIdZgAAAQI9AsUCBQEFALcARQEFAj0CwQIAAB2mAAABAgECPwHBAAACPoJCgTuAwoI+gkAAHeYAAAAAPwDEAIQAQAI9AUUBNwDFAT0CQQIeZgEAQQB/AGEAAAI+gUKBAoD7gAKAgoE+gV6mAAM/AMAAPgDAAD+DwAA/AgMBuwBDAL8DHuYAARIBCYCkAECCPoECgLuAQoACgL6BAIIfZgAABIG8gESAPIHAAL6CAoG7gEKAPoOAAB+mPwPAgD6BwoE+gIACPoECgbuAQoA+g4AAH+YAAD0AIQA/w+EBGAC+ggKBu4BCgD6DgAIgZgwDAwC4gkgCO8HEAD6CQoE7gMKCPoJAACCmDAEDAPiAgAC3gcAAPoMCgLuAQoA+g0ABISYIgAqCOoHNgDiAAAI+gQKBu4BCgD6DgAAhpgQAFABTAJqDdAAAAj0BBQG3AEUAPQOAAiHmAAO/AEkDD4D5AYMAPAEFAbcARQA9A4ACIiYAACiCJIIige2BAAM+gkKBO4DCgj6CwAAiphIBFgESAP+AHgDSAjgBBQC3AEUAvQEAACRmCAAuAsgCPwFKAMgCPQJFATcAxQE9AkAAJaYAATPAtQB1A+yAQAK8ggaBtYBEgTyBQAIl5gABPwE1AL8D9QB/ADgCRQE3AMUCPQJAACYmEAMXANcBNwHXAkADPQMFAvcCBQK9AwEDJyYAAjyBxoBswSqAhII+gQKAu4BCgD6DgAAnZisABQGXgV0BZQOHAD0CRQG3AEUAPQNAASgmAQK/AvsCu4C/AsAAPQJFATcAxQI9AsAAKSYAAj8C/wL/gvMCzwD8AgKBO4DCgj6CQAAqJgAAAAO/AEEBOwFLAX8BywFxAz8BwAIAASxmAAO/gFCBPoDQgL+AAAD2ARWCVAJ3A0AAMSYBAD0DfwB/AekD/4HZgT2A/oD+gcECAAExphABsoBagBnBusBYgz/A2EE/QNhB/8BAAbOmAAAAA7+AQIEGgKiAeIAGgcCAP4HAAgABtiYdA3UAfwJ1Af8A9QBJA38AxQG5AH8BwAM25hQCFIG+gFCAEIA+g9CAEIAzgMUBSoJSAXemAAABAAEAAQABAAEAAQA/AAgB1AIiAiIBt+YAAAQABAI+A+0CLIJtAK0BvgJkAgQCAAA75gIBOQH0gTSBPQGAA7+AWIMogUiA+IEAAjymAgE9AeyBLIE9AYgABwMigP4AAgDOAQICPyYEAT8B7IEsgT0BgAA7AMsAewJBAj8BwAA/ZgIAAgE/Ae6BLoC9AYAAPgDlgT0BAQE/AT+mBAE/AeyBLoE8gY0BOgBJgD8DyQA5AMAAAWZBADyD1oJWgXyCQAAigz6A4gA/w+JAAAACpmAAJQAXAj+D9wJ3AncB9wF/g1cCJQIAAAQmRAAkACoCO4P3AuAA7YH1geWBa4IogAAABOZBAjyB3EGdQMhBIkE/wNYAB8C+APbBhAAGJkICOwPWglWBfQNBACUApQI8weUAIQCiAQomRAE+Ae0BLIE7AYcAPQPlAWWBZQF/AcAAFKZAADwD74EsgT0DkAAag16A28BKg/6DSgFZZkwAAwI6g8IBDgAAA78AQQABAD8DwAIAAZtmTAADAjKBxgAAA78ATQM1AIUA/IEEggAAG6ZcAAMCOoPCAQ4AgAIMAQOA+gACAMoBBgIcJkgABQAyg8YAgAA6AMnACQA/A8kACQC5AFxmWAAFADKDxgEQADwBywJKAnoCwgK+AkABHKZMAAMCMoHGAIIAOIDKgEqAeoJAgj+BwAAdpkgABQIygcYAggIoASuA7gApA/UCJQIAAR8mSAAFAjKDwgEuAKBCPoHiACIAPwPiwCAAH+ZIAAQAM4PGASAApQI/A8QBP4CkAVWCAAGgJkgABwAyg8IBBgAkAaYAJQI8g+UAJgCkASGmSAAFATKBxACBAD8B/QHVQVWBWQFDAcAAJaZAAAEAPQPVwVUBVwFVAVUBVcF9A8EAAAAmZmQAFQAVA+0CpQKvAqUCrIK0grSD1AAkAComQAAvAK8Av4O/A/0D/gO9g7yD/4O2AIAAqyZAAgADPwBVAFUBVQB/A1UAVQLVAkABwAAs5kABv4Aqgf+AqoKAAf8BxAI/gkQCPgIAAbBmQAG/gCqAv4JqguqBwAA1gwIAw4F0QQQCMWZAAb+AKoD/guqDoAN/gMiAOIAIgM+DAAAxpkABv4Aqgb+AqoLAAf+DwIEogVyBIoFAAXQmQAO/gCqBv4OqgmqBwAAigj6D4wIiAgACNKZAAb+AKoH/gKCChAHzAEqAegJCAj4BwAA1ZkAABQIzAXmAeQF7AHgA/4B8gPyBR4DAADbmQADfwDVA38DVQXBAxwMJAP/AiQEPAQACN2ZAAb+AKoH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\"\n    }\n}\n",
            "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
            "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage, ValType::Object)\n\nvoid RefImage::destroy(RefImage *t) {}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p size=%d x %d\", t, t->width(), t->height());\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((height() * 4 + 31) >> 5);\n}\n\nvoid RefImage::makeWritable() {\n    if (buffer->isReadOnly()) {\n        buffer = mkBuffer(data(), length());\n    }\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), buffer(buf) {\n    if (!buf)\n        oops(21);\n}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return sizeof(ImageHeader) + ((h + 7) >> 3) * w;\n    else\n        return sizeof(ImageHeader) + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ allocImage(const uint8_t *data, uint32_t sz) {\n    auto buf = mkBuffer(data, sz);\n    registerGCObj(buf);\n    Image_ r = NEW_GC(RefImage, buf);\n    unregisterGCObj(buf);\n    return r;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 2000 || height > 2000)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = allocImage(NULL, sz);\n    auto hd = r->header();\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = bpp;\n    hd->width = width;\n    hd->height = height;\n    hd->padding = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 9)\n        return false;\n\n    auto hd = (ImageHeader *)(buf->data);\n    if (hd->magic != IMAGE_HEADER_MAGIC || (hd->bpp != 1 && hd->bpp != 4))\n        return false;\n\n    int sz = byteSize(hd->width, hd->height, hd->bpp);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\nbool isLegacyImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf) - 4;\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True if the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    }\n}\n\nstatic int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    } else if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\n/**\n * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n */\n//%\nvoid getRows(Image_ img, int x, Buffer dst) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    uint8_t *sp = img->pix(x, 0);\n    uint8_t *dp = dst->data;\n    int n = min(dst->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = *sp & 0xf;\n        *dp++ = *sp >> 4;\n        sp++;\n    }\n}\n\n/**\n * Copy row(s) of pixel from buffer to image.\n */\n//%\nvoid setRows(Image_ img, int x, Buffer src) {\n    if (img->bpp() != 4)\n        return;\n\n    int w = img->width();\n    int h = img->height();\n    if (x >= w || x < 0)\n        return;\n\n    img->makeWritable();\n\n    uint8_t *dp = img->pix(x, 0);\n    uint8_t *sp = src->data;\n    int n = min(src->length, (w - x) * h) >> 1;\n\n    while (n--) {\n        *dp++ = (sp[0] & 0xf) | (sp[1] << 4);\n        sp += 2;\n    }\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid mapRect(Image_ img, int x, int y, int w, int h, Buffer map) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    if (img->bpp() != 4 || map->length < 16)\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    auto m = map->data;\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        auto ptr = p;\n        unsigned shift = y & 1;\n        for (int i = 0; i < h; i++) {\n            if (shift) {\n                *ptr = (m[*ptr >> 4] << 4) | (*ptr & 0x0f);\n                ptr++;\n                shift = 0;\n            } else {\n                *ptr = (m[*ptr & 0xf] & 0xf) | (*ptr & 0xf0);\n                shift = 1;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _mapRect(Image_ img, int xy, int wh, Buffer c) {\n    mapRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n//% argsNullable\nbool equals(Image_ img, Image_ other) {\n    if (!other) {\n        return false;\n    }\n    auto len = img->length();\n    if (len != other->length()) {\n        return false;\n    }\n    return 0 == memcmp(img->data(), other->data(), len);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    auto r = allocImage(img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src0 = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto sbh = img->byteHeight();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        auto src = src0 + i * sbh;\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    registerGCObj(tmp);\n    Image_ r = doubledY(tmp);\n    unregisterGCObj(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    // DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\",\n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n#define LOOPHD                                                                                     \\\n    for (int xx = 0; xx < w; ++xx, ++x)                                                            \\\n        if (0 <= x && x < sw)\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n            y = y0;\n\n            auto fdata = (uint32_t *)fromBase + wordH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            // DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n            //    (uint8_t*)fdata - from->pix());\n\n            auto cnt = wordH;\n            auto bot = min(sh, y + h);\n\n#define COLS(s) ((v >> (s)) & 0xf)\n#define COL(s) COLS(s)\n\n#define STEPA(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETLOW(s);                                                                                 \\\n    y++;\n#define STEPB(s)                                                                                   \\\n    if (COL(s) && 0 <= y && y < bot)                                                               \\\n        SETHIGH(s);                                                                                \\\n    y++;                                                                                           \\\n    tdata++;\n#define STEPAQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETLOW(s);\n#define STEPBQ(s)                                                                                  \\\n    if (COL(s))                                                                                    \\\n        SETHIGH(s);                                                                                \\\n    tdata++;\n\n// perf: expanded version 5% faster\n#define ORDER(A, B)                                                                                \\\n    A(0);                                                                                          \\\n    B(4);                                                                                          \\\n    A(8);                                                                                          \\\n    B(12);                                                                                         \\\n    A(16);                                                                                         \\\n    B(20);                                                                                         \\\n    A(24);                                                                                         \\\n    B(28)\n//#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n#define LOOP(A, B, xbot)                                                                           \\\n    while (cnt--) {                                                                                \\\n        auto v = *fdata++;                                                                         \\\n        if (0 <= y && y <= xbot - 8) {                                                             \\\n            ORDER(A##Q, B##Q);                                                                     \\\n            y += 8;                                                                                \\\n        } else {                                                                                   \\\n            ORDER(A, B);                                                                           \\\n        }                                                                                          \\\n    }\n#define LOOPS(xbot)                                                                                \\\n    if (y & 1)                                                                                     \\\n        LOOP(STEPB, STEPA, xbot)                                                                   \\\n    else                                                                                           \\\n        LOOP(STEPA, STEPB, xbot)\n\n            if (color >= 0) {\n#define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n#define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                LOOPS(sh)\n            } else if (color == -2) {\n#undef COL\n#define COL(s) 1\n                LOOPS(bot)\n            } else {\n#undef COL\n#define COL(s) COLS(s)\n#undef SETHIGH\n#define SETHIGH(s)                                                                                 \\\n    if (*tdata & 0xf0)                                                                             \\\n    return true\n#undef SETLOW\n#define SETLOW(s)                                                                                  \\\n    if (*tdata & 0x0f)                                                                             \\\n    return true\n                LOOPS(sh)\n            }\n        }\n    } else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n            y = y0;\n\n            auto data = fromBase + fromH * xx;\n            auto off = imgBase + imgH * x;\n            auto off0 = off + left;\n            auto off1 = off + right;\n\n            int shift = (y & 7);\n\n            int y1 = y + h + (y & 7);\n            int prev = 0;\n\n            while (y < y1 - 8) {\n                int curr = *data++ << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = (curr >> 0) | (prev >> 8);\n\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n                off++;\n                prev = curr;\n                y += 8;\n            }\n\n            int left = y1 - y;\n            if (left > 0) {\n                int curr = *data << shift;\n                if (off0 <= off && off <= off1) {\n                    uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                    if (color == -1) {\n                        if (*off & v)\n                            return true;\n                    } else {\n                        *off |= v;\n                    }\n                }\n            }\n        }\n    } else if (tbp == 4 && fbp == 1) {\n        if (y < 0) {\n            fromBase = from->pix(0, -y);\n            imgBase = img->pix();\n        }\n        // icon mode\n        LOOPHD {\n            auto fdata = fromBase + fromH * xx;\n            auto tdata = imgBase + imgH * x;\n\n            unsigned mask = 0x01;\n            auto v = *fdata++;\n            int off = (y & 1) ? 1 : 0;\n            if (y < 0) {\n                mask <<= -y & 7;\n                off = 0;\n            }\n            for (int i = off; i < len + off; ++i) {\n                if (mask == 0x100) {\n                    mask = 0x01;\n                    v = *fdata++;\n                }\n                if (v & mask) {\n                    if (i & 1)\n                        *tdata = (*tdata & 0x0f) | (color << 4);\n                    else\n                        *tdata = (*tdata & 0xf0) | color;\n                }\n                mask <<= 1;\n                if (i & 1)\n                    tdata++;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format (legacy)\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\nImage_ convertAndWrap(Buffer buf) {\n    if (isValidImage(buf))\n        return NEW_GC(RefImage, buf);\n\n    // What follows in this function is mostly dead code, except if people construct image buffers\n    // by hand. Probably safe to remove in a year (middle of 2020) or so. When removing, also remove\n    // from sim.\n    if (!isLegacyImage(buf))\n        return NULL;\n\n    auto tmp = mkBuffer(NULL, buf->length + 4);\n    auto hd = (ImageHeader *)tmp->data;\n    auto src = buf->data;\n    hd->magic = IMAGE_HEADER_MAGIC;\n    hd->bpp = src[0] & 0xf;\n    hd->width = src[1];\n    hd->height = src[2];\n    hd->padding = 0;\n    memcpy(hd->pixels, src + 4, buf->length - 4);\n\n    registerGCObj(tmp);\n    auto r = NEW_GC(RefImage, tmp);\n    unregisterGCObj(tmp);\n    return r;\n}\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    img->makeWritable();\n\n    auto iconImg = convertAndWrap(icon);\n    if (!iconImg || iconImg->bpp() != 1)\n        return;\n\n    drawImageCore(img, iconImg, XX(xy), YY(xy), c);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\nvoid blitRow(Image_ img, int x, int y, Image_ from, int fromX, int fromH) {\n    if (!img->inRange(x, 0) || !img->inRange(fromX, 0) || fromH <= 0)\n        return;\n\n    if (img->bpp() != 4 || from->bpp() != 4)\n        return;\n\n    int fy = 0;\n    int stepFY = (from->width() << 16) / fromH;\n    int endY = y + fromH;\n    if (endY > img->height())\n        endY = img->height();\n    if (y < 0) {\n        fy += -y * stepFY;\n        y = 0;\n    }\n\n    auto dp = img->pix(x, y);\n    auto sp = from->pix(fromX, 0);\n\n    while (y < endY) {\n        int p = fy >> 16, c;\n        if (p & 1)\n            c = sp[p >> 1] >> 4;\n        else\n            c = sp[p >> 1] & 0xf;\n        if (y & 1) {\n            *dp = (*dp & 0x0f) | (c << 4);\n            dp++;\n        } else {\n            *dp = (*dp & 0xf0) | (c & 0xf);\n        }\n        y++;\n        fy += stepFY;\n    }\n}\n\n//%\nvoid _blitRow(Image_ img, int xy, Image_ from, int xh) {\n    blitRow(img, XX(xy), YY(xy), from, XX(xh), YY(xh));\n}\n\nvoid fillCircle(Image_ img, int cx, int cy, int r, int c) {\n    int x = r - 1;\n    int y = 0;\n    int dx = 1;\n    int dy = 1;\n    int err = dx - (r << 1);\n\n    while (x >= y) {\n        fillRect(img, cx + x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx + y, cy - x, 1, 1 + (x << 1), c);\n        fillRect(img, cx - x, cy - y, 1, 1 + (y << 1), c);\n        fillRect(img, cx - y, cy - x, 1, 1 + (x << 1), c);\n        if (err <= 0) {\n            ++y;\n            err += dy;\n            dy += 2;\n        } else {\n            --x;\n            dx += 2;\n            err += dx - (r << 1);\n        }\n    }\n}\n\n//%\nvoid _fillCircle(Image_ img, int cxy, int r, int c) {\n    fillCircle(img, XX(cxy), YY(cxy), r, c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    return ImageMethods::convertAndWrap(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = NEW_GC(RefImage, icon);\n    registerGCObj(r);\n    auto t = ImageMethods::doubled(r);\n    unregisterGCObj(r);\n    return t->buffer;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif\n",
            "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Replace colors in a rectangle\n     */\n    //% helper=imageMapRect\n    mapRect(x: number, y: number, w: number, h: number, colorMap: Buffer): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Returns true if the provided image is the same as this image,\n     * otherwise returns false.\n     */\n    //% shim=ImageMethods::equals\n    equals(other: Image): boolean;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
            "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% snippet='img` `'\n//% pySnippet='img(\"\"\" \"\"\")'\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a circle\n     */\n    //% helper=imageDrawCircle\n    drawCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Fills a circle\n     */\n    //% helper=imageFillCircle\n    fillCircle(cx: number, cy: number, r: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n\n    /**\n     * Scale and copy a row of pixels from a texture.\n     */\n    //% helper=imageBlitRow\n    blitRow(dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void;\n}\n\ninterface ScreenImage extends Image {\n    /**\n     * Sets the screen backlight brightness (10-100)\n     */\n    //% helper=setScreenBrightness\n    setBrightness(deg: number): Image;\n\n    /**\n     * Gets current screen backlight brightness (0-100)\n     */\n    //% helper=screenBrightness\n    brightness(): number;\n}\n\n// pxt compiler currently crashes on non-functions in helpers namespace; will fix\nnamespace _helpers_workaround {\n    export let brightness = 100\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_mapRect\n    function _mapRect(img: Image, xy: number, wh: number, m: Buffer): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillCircle\n    declare function _fillCircle(img: Image, cxy: number, r: number, c: color): void;\n\n    //% shim=ImageMethods::_blitRow\n    declare function _blitRow(img:Image, xy: number, from: Image, xh: number): void;\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageBlitRow(img:Image, dstX: number, dstY: number, from: Image, fromX: number, fromH: number): void {\n        _blitRow(img, pack(dstX, dstY), from, pack(fromX, fromH))\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageMapRect(img: Image, x: number, y: number, w: number, h: number, m: Buffer): void {\n        _mapRect(img, pack(x, y), pack(w, h), m)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    export function imageDrawCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        cx = cx | 0;\n        cy = cy | 0;\n        r = r | 0;\n        // short cuts\n        if (r < 0) \n            return;\n        else if (r == 0) {\n            img.setPixel(cx, cy, col);\n            return;\n        } else if (r == 1) {\n            img.setPixel(cx + 1, cy, col);\n            img.setPixel(cx, cy + 1, col);\n            img.setPixel(cx - 1, cy, col);\n            img.setPixel(cx, cy - 1, col);\n            return;\n        }\n\n        const fcx = Fx8(cx);\n        const fcy = Fx8(cy);\n        const fr = Fx8(r);\n        const fr2 = Fx.leftShift(fr, 1);\n\n        let x = Fx.sub(fr, Fx.oneFx8)\n        let y = Fx.zeroFx8;\n        let dx = Fx.oneFx8;\n        let dy = Fx.oneFx8;\n        let err = Fx.sub(dx, fr2);\n        while (Fx.compare(x, y) >= 0) {\n            const cxpx = Fx.toInt(Fx.add(fcx, x));\n            const cxpy = Fx.toInt(Fx.add(fcx, y));\n            const cxmx = Fx.toInt(Fx.sub(fcx, x));\n            const cxmy = Fx.toInt(Fx.sub(fcx, y));\n            const cypy = Fx.toInt(Fx.add(fcy, y));\n            const cymy = Fx.toInt(Fx.sub(fcy, y));\n            const cypx = Fx.toInt(Fx.add(fcy, x));\n            const cymx = Fx.toInt(Fx.sub(fcy, x));\n\n            img.setPixel(cxpx, cypy, col);\n            img.setPixel(cxmx, cypy, col);\n            img.setPixel(cxmx, cymy, col);\n            img.setPixel(cxpx, cymy, col);\n            img.setPixel(cxpy, cypx, col);\n            img.setPixel(cxpy, cymx, col);\n            img.setPixel(cxmy, cymx, col);\n            img.setPixel(cxmy, cypx, col);\n\n            if (Fx.compare(err, Fx.zeroFx8) <= 0) {\n                y = Fx.add(y, Fx.oneFx8);\n                err = Fx.add(err, dy);\n                dy = Fx.add(dy, Fx.twoFx8);\n            } else {\n                x = Fx.sub(x, Fx.oneFx8);\n                dx = Fx.add(dx, Fx.twoFx8);\n                err = Fx.add(err, Fx.sub(dx, fr2));\n            }\n        }\n    }\n    export function imageFillCircle(img: Image, cx: number, cy: number, r: number, col: number) {\n        _fillCircle(img, pack(cx, cy), r, col);\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n    //% shim=pxt::setScreenBrightness\n    function _setScreenBrightness(brightness: number) { }\n\n    export function setScreenBrightness(img: Image, b: number) {\n        b = Math.clamp(10, 100, b | 0);\n        _helpers_workaround.brightness = b\n        _setScreenBrightness(_helpers_workaround.brightness)\n    }\n\n    export function screenBrightness(img: Image) {\n        return _helpers_workaround.brightness\n    }\n}\n\nnamespace image {\n    /**\n    * Get the screen image\n    */\n    //% blockNamespace=\"images\" group=\"Create\"\n    //% blockId=imagescreen block=\"screen\"\n    //% help=images/screen-image\n    export function screenImage(): Image {\n        return screen;\n    }\n}\n",
            "imagesoverrides.jres": "{\n  \n}",
            "imagesoverrides.ts": "// replace with built-in images",
            "ns.ts": " ",
            "panic.cpp": "// potentially overriden in targets",
            "pxt.json": "{\n  \"name\": \"screen---ext\",\n  \"description\": \"The screen library\",\n  \"files\": [\n    \"screen.cpp\",\n    \"panic.cpp\",\n    \"image.cpp\",\n    \"image.ts\",\n    \"text.ts\",\n    \"frame.ts\",\n    \"shims.d.ts\",\n    \"fieldeditors.ts\",\n    \"targetoverrides.ts\",\n    \"ns.ts\",\n    \"image.d.ts\",\n    \"pxtparts.json\",\n    \"imagesoverrides.jres\",\n    \"imagesoverrides.ts\",\n    \"font12.jres\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n  \"screen\": {\n    \"simulationBehavior\": \"screen\",\n    \"visual\": {\n      \"builtIn\": \"screen\",\n      \"width\": 158.43856811523438,\n      \"height\": 146.8025665283203,\n      \"pinDistance\": 14.91,\n      \"pinLocations\": [\n        {\n          \"x\": 4.227952701380444,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 18.170226805137037,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 46.05478386015504,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 59.99706238766404,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 73.93934976267785,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 87.88161944268204,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 101.82389797019104,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 32.11250533264604,\n          \"y\": 3.1650031792503945\n        },\n        {\n          \"x\": 117.68761950246274,\n          \"y\": 3.1650031792503945\n        }\n      ]\n    },\n    \"numberOfPins\": 9,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_DC\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_CS\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MOSI\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_SCK\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_MISO\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"DISPLAY_RST\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8\n        ]\n      }\n    ]\n  }\n}",
            "screen.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nclass WDisplay {\n  public:\n    uint32_t currPalette[16];\n    bool newPalette, dataWaiting;\n    uint8_t *screenBuf;\n\n    int width, height;\n\n    WDisplay();\n    void updateLoop();\n    void update(Image_ img);\n};\n\nSINGLETON(WDisplay);\n\nWDisplay::WDisplay() {\n    width = getConfig(CFG_DISPLAY_WIDTH, 160);\n    height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n    DMESG(\"init display: %dx%d\", width, height);\n    screenBuf = new uint8_t[width * height / 2 + 20];\n    newPalette = false;\n}\n\n//% expose\nvoid setScreenBrightness(int level) {\n    // TODO\n}\n\n//% expose\nvoid setPalette(Buffer buf) {\n    auto display = getWDisplay();\n    if (48 != buf->length)\n        target_panic(PANIC_SCREEN_ERROR);\n    for (int i = 0; i < 16; ++i) {\n        uint8_t r = buf->data[i * 3];\n        uint8_t g = buf->data[i * 3 + 1];\n        uint8_t b = buf->data[i * 3 + 2];\n        display->currPalette[i] = (0xff << 24) | (r << 16) | (g << 8) | (b << 0);\n    }\n    display->newPalette = true;\n}\n\nstatic pthread_mutex_t screenMutex;\nstatic pthread_cond_t dataBroadcast;\nstatic int numGetPixels;\n\nDLLEXPORT void pxt_screen_get_pixels(int width, int height, uint32_t *screen) {\n    auto disp = instWDisplay;\n    numGetPixels++;\n\n    if (!disp) {\n        int n = width * height;\n        uint32_t *p = screen;\n        // blue screen\n        while (n--)\n            *p++ = 0xff000000;\n        return;\n    }\n\n    pthread_mutex_lock(&screenMutex);\n    if (!disp->dataWaiting) {\n        struct timespec timeout = {0, 100 * 1000 * 1000}; // up to 100ms\n        pthread_cond_timedwait(&dataBroadcast, &screenMutex, &timeout);\n    }\n    if (width != disp->width || height != disp->height)\n        target_panic(PANIC_SCREEN_ERROR);\n    if (panicCode > 0) {\n        int n = width * height;\n        uint32_t *p = screen;\n        // blue screen\n        while (n--)\n            *p++ = 0xff0000ff;\n    } else {\n        auto sp = disp->screenBuf;\n        auto pal = disp->currPalette;\n        for (int x = 0; x < width; ++x) {\n            uint32_t *p = screen + x;\n            for (int y = 0; y < (height >> 1); ++y) {\n                uint8_t v = *sp++;\n                *p = pal[v & 0xf];\n                p += width;\n                *p = pal[v >> 4];\n                p += width;\n            }\n        }\n    }\n    pthread_cond_broadcast(&dataBroadcast);\n    disp->dataWaiting = false;\n    pthread_mutex_unlock(&screenMutex);\n}\n\nvoid WDisplay::update(Image_ img) {\n    if (!img)\n        return;\n\n    if (img->bpp() != 4 || img->width() != width || img->height() != height)\n        target_panic(PANIC_SCREEN_ERROR);\n\n    pthread_mutex_lock(&screenMutex);\n    // if the data have not been picked up, but it had been in the past, wait\n    if (dataWaiting && numGetPixels)\n        pthread_cond_wait(&dataBroadcast, &screenMutex);\n    memcpy(screenBuf, img->pix(), img->pixLength());\n    dataWaiting = true;\n    pthread_cond_broadcast(&dataBroadcast);\n    pthread_mutex_unlock(&screenMutex);\n\n    if (newPalette) {\n        newPalette = false;\n    }\n}\n\n//% expose\nvoid updateScreen(Image_ img) {\n    getWDisplay()->update(img);\n}\n\n//% expose\nvoid updateStats(String msg) {\n    DMESG(\"stats: %s\", msg->getUTF8Data());\n}\n} // namespace pxt",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True if the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Copy row(s) of pixel from image to buffer (8 bit per pixel).\n     */\n    //% shim=ImageMethods::getRows\n    getRows(x: int32, dst: Buffer): void;\n\n    /**\n     * Copy row(s) of pixel from buffer to image.\n     */\n    //% shim=ImageMethods::setRows\n    setRows(x: int32, src: Buffer): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(160, 120) as ScreenImage\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
            "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        multiplier?: number;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 6,\n        charHeight: 8,\n        data: hex`\n2000000000000000 210000005e000000 2200000e000e0000 230028fe28fe2800 24004c92ff926400 250002651248a640\n26006c92926ca000 270000000e000000 280000007c820000 29000000827c0000 2a00543810385400 2b0010107c101000\n2c00000090700000 2d00101010101000 2e00000060600000 2f00006010080600 3000003c42423c00 310000447e400000\n3200004462524c00 330000424a4e3200 34003028247e2000 3500004e4a4a3200 3600003c4a4a3000 3700000262120e00\n380000344a4a3400 3900000c52523c00 3a0000006c6c0000 3b00000096760000 3c00102828444400 3d00282828282800\n3e00444428281000 3f00000259090600 40003c425a560800 4100781412147800 42007e4a4a4a3400 4300003c42422400\n4400007e42423c00 4500007e4a4a4200 4600007e0a0a0200 4700003c42523400 4800007e08087e00 490000427e420000\n4a002040423e0200 4b00007e08146200 4c00007e40404000 4d007e0418047e00 4e00007e04087e00 4f003c4242423c00\n5000007e12120c00 5100003c5262bc00 5200007e12126c00 530000244a522400 540002027e020200 5500003e40403e00\n5600001e70701e00 57007e2018207e00 5800422418244200 5900060870080600 5a000062524a4600 5b00007e42420000\n5c00000608106000 5d000042427e0000 5e00080402040800 5f00808080808000 6000000002040000 6100003048487800\n6200007e48483000 6300003048484800 6400003048487e00 6500003068585000 660000107c120400 67000018a4a47800\n6800007e08087000 690000487a400000 6a000040847d0000 6b00007e10284000 6c0000427e400000 6d00780830087000\n6e00007808087000 6f00003048483000 700000fc24241800 710000182424fc00 7200007810081000 7300005058682800\n740000083e482000 7500003840407800 7600001860601800 7700384030403800 7800004830304800 7900005ca0a07c00\n7a00004868584800 7b00000836410000 7c000000fe000000 7d00004136080000 7e00000804080400 a000000000000000\na10000007a000000 a200003048fc4800 a30090fc92928400 a400542844285400 a5002a2c782c2a00 a6000000ee000000\na7000094aaaa5200 a800000200020000 a9003e414955413e aa0000242a2e0000 ab00102854284400 ac00001010107000\nad00001010101000 ae003e415d45413e af00000202020200 b000000814140800 b1008888be888800 b2000024322c0000\nb30000222a140000 b400000004020000 b50000f840207800 b6000c1e7e027e00 b700000010000000 b800000080400000\nb90000243e200000 ba0000242a240000 bb00442854281000 bc00025f70f84000 bd00021f90c8b000 be0011557af84000\nbf000030484d2000 c000601916186000 c100601816196000 c200601a151a6000 c300601a151a6100 c400601914196000\nc500601a151a6000 c6007c0a7e4a4200 c700001ea1611200 c800007c55564400 c900007c56554400 ca00007c56554600\ncb00007c55544500 cc0000457e440000 cd0000447e450000 ce0000467d460000 cf0000457c450000 d000087e4a423c00\nd100007e09127d00 d200003845463800 d300003846453800 d400003846453a00 d500003a45463900 d600003845443900\nd700442810284400 d80000fc724e3f00 d900003c41423c00 da00003c42413c00 db00003c42413e00 dc00003c41403d00\ndd00040872090400 de00007e24241800 df00007c025a2400 e0000030494a7800 e10000304a497800 e20000304a497a00\ne3000032494a7900 e40000304a487a00 e50000304a4d7a00 e600304878685000 e7000018a4642400 e8000030695a5000\ne90000306a595000 ea0000306a595200 eb0000306a585200 ec0000497a400000 ed0000487a410000 ee00004a79420000\nef00004a78420000 f00000304a4b3d00 f100007a090a7100 f2000030494a3000 f30000304a493000 f40000304a493200\nf5000032494a3100 f60000304a483200 f700101054101000 f800007068583800 f900003841427800 fa00003842417800\nfb00003842417a00 fc00003842407a00 fd0000b84241f800 fe0000ff24241800 ff00005ca1a07d00 0001601915196000\n010100304a4a7a00 0201611a16196000 030100314a4a7900 04013c0a094abc00 050100182464bc00 0601003846452800\n070100304a494800 0801003846452a00 090100304a494a00 0a01003844452800 0b010030484a4800 0c01003845462900\n0d010030494a4900 0e01007c45463900 0f0100314a497e00 1001087e4a423c00 110130484c7e0400 1201007d55554500\n130100326a5a5200 1401007d56564500 150100316a5a5100 1601007c55544400 170100306a585000 1801003f65a52100\n1901001874ac2800 1a01007c55564500 1b010030695a5100 1c01003846553600 1d0100304a49f200 1e01003946563500\n1f0100314a4af100 2001003844553400 21010018a4a57800 2201001ea1691a00 23010018a6a57800 2401007812117a00\n25017e080a710200 2601047e147e0400 2701047e0c087000 28010002457e4500 29010002497a4100 2a0100457d450000\n2b01004a7a420000 2c0100014a7a4900 2d0100014a7a4100 2e0100217fa10000 2f0100247da00000 300100447d440000\n3101004878400000 32017e0022423e00 33013d0040847d00 34012040463d0600 350100800af90200 360100bf440a3100\n370100bf48142000 3801007810284800 3901007c40424100 3a0100467d400000 3b01003fa0602000 3c0100a17f200000\n3d01007c41424100 3e0100457e410000 3f01007e40484000 400100427e400800 4101107e48404000 420100527e480000\n4301007c0a117c00 440100780a097000 450100bf42043f00 460100bc44043800 4701007c09127d00 480100790a097000\n49010a0678087000 4a01003f02847f00 4b01003c04847800 4c01394545453900 4d0100324a4a3200 4e01394646463900\n4f0100314a4a3100 50013a4544463900 5101324948320100 52013c427e4a4200 5301304830685000 5401007c16354800\n5501007812091000 560100bf49093600 570100bc48040800 5801007d16354800 5901007912091000 5a01004856552400\n5b0100505a692800 5c01004856552600 5d0100505a692a00 5e010012a5691200 5f010028ac741400 6001004855562500\n61010050596a2900 62010101bf410100 630100049f641000 640104057e050400 650100083d4a2100 660102127e120200\n670100183e582000 6801003a41423900 6901003a41427900 6a01003d41413d00 6b01003a42427a00 6c01003942423900\n6d01003942427900 6e01003a45453a00 6f01003a45457a00 70013a41403a0100 71013a41407a0100 7201001f60a01f00\n7301001c60a03c00 7401782211227800 7501384231423800 7601081261120800 770100b84241fa00 7801040970090400\n79010064564d4400 7a0100486a594800 7b010064544d4400 7c010048685a4800 7d010064554e4500 7e010048695a4900\n7f0100087c020400 8f01003452523c00 920100887e090200 a0013c42423c0806 a101003048483008 af01003e403e0806\nb001003840781008 b501006a5a4a4e00 b601005878585800 d101003845463900 d2010030494a3100 e601003845563500\ne7010030494af100 fa0100742a750000 fb0100304c4a7d00 fc0178147e554400 fd0130487a695000 fe010078744e3d00\nff0100706a593800 18020012a5691200 19020028ac741400 1a020101bf410100 1b0200049f641000 bb0200000c0a0000\nbc0200000a060000 bd020000060a0000 c602000201020000 c702000102010000 c902000202020000 d802000102020100\nd902000002000000 da02000205020000 db02000040800000 dc02000201020100 dd02020100020100 7403000002010000\n7503000080400000 7a030000c0800000 7e03000096760000 8403000003000000 8503020003000200 8603037c12127c00\n8703000010000000 880303007e4a4200 890303007e087e00 8a030300427e4200 8c03033c42423c00 8e0303000e700e00\n8f03035c62625c00 900302003b400200 9103781412147800 92037e4a4a4a3400 9303007e02020200 9403605846586000\n9503007e4a4a4200 96030062524a4600 9703007e08087e00 98033c4a4a4a3c00 990300427e420000 9a03007e08146200\n9b03601806186000 9c037e0418047e00 9d03007e04087e00 9e0300424a4a4200 9f033c4242423c00 a003007e02027e00\na103007e12120c00 a30300665a424200 a40302027e020200 a503060870080600 a60318247e241800 a703422418244200\na8030e107e100e00 a9035c6202625c00 aa0300457c450000 ab03040970090400 ac030030484a7900 ad030030685a5100\nae0378100a09f000 af03003a41200000 b0033a4043403a00 b103003048487800 b20300fe25251a00 b3030c30c0300c00\nb403344a4a4a3000 b503003068585000 b603021aa6a24200 b7033c080404f800 b803003c4a4a3c00 b903003840200000\nba03007820504800 bb03641212227c00 bc03fc2020103c00 bd03182040201800 be03112d2ba94100 bf03003048483000\nc003087808780800 c103f82424241800 c2031824a4a44800 c303304848582800 c403000838482800 c503384040403800\nc6031c20f8241800 c703c4281028c400 c8031c20fc201c00 c903304820483000 ca03000238422000 cb03384240423800\ncc0330484a493000 cd03384042413800 ce03304822493000 d0033c52525c2000 d10310344a3c0800 d203067804020400\nd303120a7c020400 d4030d7009040800 d5031824ff241800 d603384828483800 d70348302221d800 da031c2221a14200\ndb031824a4a44200 dc037e1212020200 dd0300fc24240400 de033e2010087c00 df030c0ac9281800 e003700c621c7000\ne10301092516f800 e2039ea0bea07e00 e30398a0b8a07800 e4030c1214107e00 e503001028207800 e603be9088887000\ne70348544e443800 e803245252524c00 e903285454544800 ea0364524c526400 eb03086458640800 ec03385454542200\ned03306848682400 ee03184a7e4a1800 ef031848ff0a0800 f003483020205800 f10378a4a4a49800 f203304848485000\nf303006080847d00 f4033c4a4a4a3c00 f503003058584800 0004007c55564400 0104007c55544500 020401013f857900\n0304007c06050400 04043c4a4a422400 050400244a522400 060400427e420000 070400457c450000 08042040423e0200\n09047c027e483000 0a047e087e483000 0b0402027e0a7200 0c04007c102a4500 0d047c2112087c00 0e040c5152523d00\n0f043f20e0203f00 1004781412147800 11047e4a4a4a3000 12047e4a4a4a3400 1304007e02020200 1404c07c427ec000\n1504007e4a4a4200 160476087e087600 170424424a4a3400 1804007e08047e00 1904007d120a7d00 1a04007e08146200\n1b04403c02027e00 1c047e0418047e00 1d04007e08087e00 1e043c4242423c00 1f047e0202027e00 2004007e12120c00\n2104003c42422400 220402027e020200 23040e5050503e00 240418247e241800 2504422418244200 26043f2020bf6000\n27040e1010107e00 28047e407e407e00 29043f203fa07f00 2a04027e48483000 2b047e4848307e00 2c04007e48483000\n2d0424424a4a3c00 2e047e183c423c00 2f04006c12127e00 3004304848784000 3104003c4a4a3100 3204007868502000\n3304007808080800 3404c0704878c000 3504306868500000 3604483078304800 3704004058683000 3804784020107800\n3904794222127900 3a04007820304800 3b04403008087800 3c04781020107800 3d04781010107800 3e04304848483000\n3f04780808087800 4004fc2424241800 4104304848485000 4204080878080800 43041ca0a0a07c00 44041824ff241800\n4504004830304800 46043c2020bc6000 4704182020207800 4804784078407800 49043c203ca07c00 4a04087850502000\n4b04785050207800 4c04007850502000 4d04485868300000 4e04783030483000 4f04502828780000 50040030696a5000\n51040032686a5000 5204023f0a887000 530400780a090800 5404003068584800 5504005058682800 560400487a400000\n5704004a78420000 5804004080847d00 5904700878502000 5a04781078502000 5b04047e14106000 5c04007822314800\n5d04784122107800 5e0418a1a2a27900 5f043c20e0203c00 6204027f4a483000 6304087e58502000 70040e107e100e00\n7104182078201800 72043c4a4a4a3c00 7304306858683000 7404001e70180c00 7504001860301000 9004007e02020300\n9104007808080c00 9204087e0a0a0200 9304207828080800 96043b043f043be0 970424183c1824c0 9a04003f040a31c0\n9b04003c101824c0 ae04060870080600 af040c10e0100c00 b004161870181600 b1042c30e0302c00 b20421120c1221c0\nb3040024181824c0 ba047e0808087000 bb04007e08087000 d804003452523c00 d904002868583000 e20400457d450000\ne304004a7a420000 e8043c4a4a4a3c00 e904003058583000 ee04003d41413d00 ef04003a42427a00 d005681020285000\nd105484848784000 d205004830600000 d305080808780800 d405680808087800 d505000008780000 d605080818680800\nd705087808087800 d805784050487800 d905000008180000 da0504040404fc00 db05484848483800 dc050e4848281800\ndd05087848487800 de05582010487000 df05000004fc0000 e005004040487800 e105000878483800 e205487840281800\ne305041c0404fc00 e405485848483800 e50504f820140800 e605485060685000 e705f40424241c00 e805080808087000\ne905785058403800 ea05487808087800 f005087800087800 f105081800087800 f205081800081800 f305000010080000\nf405100800100800 021e7c5455542800 031e007e48493000 0a1e007c45443800 0b1e003049487e00 1e1e007c15140400\n1f1e001079140800 401e7e0419047e00 411e780832087000 561e007c15140800 571e00fc25241800 601e004854552400\n611e0050586a2800 6a1e04047d040400 6b1e00083d482000 801e7c2112207c00 811e384132403800 821e7c2012217c00\n831e384032413800 841e7c2110217c00 851e384230423800 f21e040972080400 f31e00b84142f800 a3207e0a7a120a00\na420a8fcaa828400 a720087e2a1c0800 ab200098a4a6bf02 ac20183c5a5a4200 af20627f22443800 9021103854101000\n912108047e040800 9221101054381000 932110207e201000 9421103810103810 95212844fe442800 \n`,\n\n    }\n\n    // A unicode 12x12 pixel font based on https://github.com/adobe-fonts/source-han-sans\n    //% whenUsed jres\n    export const font12: Font = {\n        charWidth: 12,\n        charHeight: 12,\n        data: hex``\n    }\n\n    export function getFontForText(text: string) {\n        for (let i = 0; i < text.length; ++i) {\n            // this is quite approximate\n            if (text.charCodeAt(i) > 0x2000)\n                return image.font12\n        }\n        return image.font8\n    }\n\n    //% deprecated=1 hidden=1\n    export function doubledFont(f: Font): Font {\n        return scaledFont(f, 2)\n    }\n\n    export function scaledFont(f: Font, size: number): Font {\n        size |= 0\n        if (size < 2)\n            return f\n        return {\n            charWidth: f.charWidth * size,\n            charHeight: f.charHeight * size,\n            data: f.data,\n            multiplier: f.multiplier ? size * f.multiplier : size\n        }\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\nnamespace texteffects {\n    export interface TextEffectState {\n        xOffset: number;\n        yOffset: number;\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.getFontForText(text)\n        let w = text.length * font.charWidth\n        let x = (img.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font, offsets?: texteffects.TextEffectState[]) {\n        x |= 0\n        y |= 0\n        if (!font)\n            font = image.getFontForText(text)\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let mult = font.multiplier ? font.multiplier : 1\n        let dataW = Math.idiv(font.charWidth, mult)\n        let dataH = Math.idiv(font.charHeight, mult)\n        let byteHeight = (dataH + 7) >> 3\n        let charSize = byteHeight * dataW\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        let imgBuf: Buffer\n        if (mult == 1) {\n            imgBuf = control.createBuffer(8 + charSize)\n            imgBuf[0] = 0x87\n            imgBuf[1] = 1\n            imgBuf[2] = dataW\n            imgBuf[4] = dataH\n        }\n        while (cp < text.length) {\n            let xOffset = 0, yOffset = 0;\n            if (offsets && cp < offsets.length) {\n                xOffset = offsets[cp].xOffset\n                yOffset = offsets[cp].yOffset\n            }\n\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            let l = 0\n            let r = lastchar\n            let off = 0 // this should be a space (0x0020)\n            let guess = (ch - 32) * dataSize\n            if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == ch)\n                off = guess\n            else {\n                while (l <= r) {\n                    let m = l + ((r - l) >> 1);\n                    let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                    if (v == ch) {\n                        off = m * dataSize\n                        break\n                    }\n                    if (v < ch)\n                        l = m + 1\n                    else\n                        r = m - 1\n                }\n            }\n\n            if (mult == 1) {\n                imgBuf.write(8, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x + xOffset, y + yOffset, color)\n                x += font.charWidth\n            } else {\n                off += 2\n                for (let i = 0; i < dataW; ++i) {\n                    let j = 0\n                    let mask = 0x01\n                    let c = fontdata[off++]\n                    while (j < dataH) {\n                        if (mask == 0x100) {\n                            c = fontdata[off++]\n                            mask = 0x01\n                        }\n                        let n = 0\n                        while (c & mask) {\n                            n++\n                            mask <<= 1\n                        }\n                        if (n) {\n                            img.fillRect(x + xOffset * mult, y + (j + yOffset) * mult, mult, mult * n, color)\n                            j += n\n                        } else {\n                            mask <<= 1\n                            j++\n                        }\n                    }\n                    x += mult\n                }\n            }\n        }\n    }\n}\n"
        },
        "game": {
            "ask.ts": "namespace game {\n    /**\n     * Prompts the user for a boolean question\n     * @param title\n     * @param subtitle\n     */\n    //% group=\"Gameplay\"\n    //% weight=89 help=game/ask\n    //% blockId=gameask block=\"ask %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function ask(title: string, subtitle?: string): boolean {\n        game.eventContext(); // initialize the game\n        control.pushEventContext();\n        game.showDialog(title, subtitle, \"A = OK, B = CANCEL\");\n        let answer: boolean = null;\n        // short pause so that players don't skip through prompt\n        pause(500);\n\n        controller.A.onEvent(ControllerButtonEvent.Pressed, () => answer = true);\n        controller.B.onEvent(ControllerButtonEvent.Pressed, () => answer = false);\n        pauseUntil(() => answer !== null);\n        control.popEventContext();\n        return answer;\n    }\n}",
            "background.ts": "enum BackgroundAlignment {\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"right\"\n    Right,\n    //% block=\"top\"\n    Top,\n    //% block=\"bottom\"\n    Bottom,\n    //% block=\"center\"\n    Center\n}\n\nnamespace scene {\n    export class Background {\n        color: number;\n        _image: Image;\n        camera: Camera;\n        private _layers: BackgroundLayer[];\n\n        constructor(camera: Camera) {\n            this.color = 0;\n            this.camera = camera;\n            this._layers = [];\n        }\n\n        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignment) {\n            const layer = new BackgroundLayer(distance, alignment, pic);\n            this._layers.push(layer);\n            this._layers.sort((a, b) => b.distance - a.distance);\n            return layer;\n        }\n\n        get image() {\n            if (!this._image) {\n                this._image = image.create(screen.width, screen.height);\n            }\n            return this._image;\n        }\n        \n        set image(image: Image) {\n            this._image = image;\n        }\n\n        hasBackgroundImage(): boolean {\n            return !!this._image;\n        }\n\n        draw() {\n            screen.fill(this.color);\n            if (this._image)\n                screen.drawTransparentImage(this._image, 0, 0)\n            if (this._layers) {\n                this._layers.forEach(layer => {\n                    // compute displacement based on distance\n                    const ox = Math.round(this.camera.drawOffsetX / (1 + layer.distance));\n                    const oy = Math.round(this.camera.drawOffsetY / (1 + layer.distance));\n                    layer.draw(ox, oy);\n                });\n            }\n        }\n    }\n\n\n    export class BackgroundLayer {\n        distance: number;\n        img: Image;\n        repeatX: boolean;\n        repeatY: boolean;\n        alignX: BackgroundAlignment;\n        alignY: BackgroundAlignment;\n\n        constructor(distance: number, alignment: BackgroundAlignment, img: Image) {\n            this.distance = Math.max(1, distance);\n            this.img = img;\n            switch (alignment) {\n                case BackgroundAlignment.Center:\n                    this.repeatX = true;\n                    this.repeatY = true;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Left:\n                case BackgroundAlignment.Right:\n                    this.repeatX = false;\n                    this.repeatY = true;\n                    this.alignX = alignment;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Top:\n                case BackgroundAlignment.Bottom:\n                    this.repeatX = true;\n                    this.repeatY = false;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = alignment;\n                    break;\n            }\n        }\n\n        draw(offsetX: number, offsetY: number) {\n            const w = screen.width;\n            const h = screen.height;\n            const pw = this.img.width;\n            const ph = this.img.height;\n\n            if (!pw || !ph) return; // empty image.\n\n            // left, top aligned\n            let rx = -offsetX;\n            let ry = -offsetY;\n\n            switch (this.alignX) {\n                case BackgroundAlignment.Right: rx -= (w + pw); break;\n                case BackgroundAlignment.Center: rx -= (w + pw) >> 1; break;\n            }\n            switch (this.alignY) {\n                case BackgroundAlignment.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignment.Center: ry -= (h + ph) >> 1; break;\n            }\n\n            rx %= w; if (rx < 0) rx += w;\n            ry %= h; if (ry < 0) ry += h;\n\n            // avoid subpixel aliasing\n            rx = Math.floor(rx);\n            ry = Math.floor(ry);\n\n            let y = 0;\n            let py = 0;\n            while (y < h) {\n                py = y % ph;\n                let dh = Math.min(ph - py, h - ry);\n                let x = 0;\n                let rxl = rx;\n                while (x < w) {\n                    let px = x % pw;\n                    let dw = Math.min(pw - px, w - rxl);\n                    screen.drawImage(this.img, rxl, ry);\n                    rxl = (rxl + dw) % w;\n                    x += this.repeatX ? dw : w;\n                }\n                ry = (ry + dh) % h;\n                y += this.repeatY ? dh : h;\n            }\n        }\n    }\n}",
            "basesprite.ts": "interface SpriteLike {\n    z: number;\n    id: number;\n    flags?: number;\n\n    __update(camera: scene.Camera, dt: number): void;\n    __draw(camera: scene.Camera): void;\n    __serialize(offset: number): Buffer;\n}\n\nnamespace sprites {\n    export class BaseSprite implements SpriteLike {\n        protected _z: number;\n        id: number;\n\n        constructor(z: number) {\n            this.z = z;\n\n            // this assigns the sprite an id as a side effect\n            game.currentScene().addSprite(this);\n        }\n\n        __visible(): boolean {\n            return true;\n        }\n\n        get z(): number {\n            return this._z;\n        }\n\n        set z(v: number) {\n            if (this._z !== v) {\n                this._z = v;\n                game.currentScene().flags |= scene.Flag.NeedsSorting;\n            }\n        }\n\n        __draw(camera: scene.Camera) {\n            if (this.__visible()) {\n                this.__drawCore(camera);\n            }\n        }\n\n        __drawCore(camera: scene.Camera) { }\n\n        __update(camera: scene.Camera, dt: number) { }\n\n        __serialize(offset: number): Buffer { return undefined }\n    }\n}",
            "camera.ts": "namespace scene {\n    export class Camera {\n        // coordinate used for all physics computation\n        offsetX: number;\n        offsetY: number;\n        // coordinate used for draw sprites, may including shaking\n        drawOffsetX: number;\n        drawOffsetY: number;\n        sprite: Sprite;\n\n        private shakeStartTime: number;\n        private shakeDuration: number;\n        private shakeAmplitude: number;\n\n        constructor() {\n            this.offsetX = 0;\n            this.offsetY = 0;\n\n            this.drawOffsetX = 0;\n            this.drawOffsetY = 0;\n        }\n\n        shake(amplitude: number = 4, duration: number = 1000) {\n            if (amplitude <= 0 || duration <= 0) {\n                this.shakeStartTime = undefined;\n            } else {\n                // this overrides any existing shake operation            \n                this.shakeStartTime = control.millis();\n                this.shakeAmplitude = amplitude;\n                this.shakeDuration = duration;\n                // don't reset offset, will be recomputed in update\n            }\n        }\n\n        update() {\n            const scene = game.currentScene();\n\n            // if sprite, follow sprite\n            if (this.sprite) {\n                this.offsetX = this.sprite.x - (screen.width >> 1);\n                this.offsetY = this.sprite.y - (screen.height >> 1);\n            }\n\n            // don't escape tile map\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this.offsetX = scene.tileMap.offsetX(this.offsetX);\n                this.offsetY = scene.tileMap.offsetY(this.offsetY);\n            }\n\n            // normalize offset\n            this.offsetX |= 0;\n            this.offsetY |= 0;\n\n            this.drawOffsetX = this.offsetX;\n            this.drawOffsetY = this.offsetY;\n\n            // apply shake if needed\n            if (this.shakeStartTime !== undefined) {\n                const elapsed = control.millis() - this.shakeStartTime;\n                if (elapsed >= this.shakeDuration) {\n                    // we are done!\n                    this.shakeStartTime = undefined;\n                } else {\n                    // compute new shake\n                    const percentComplete = elapsed / this.shakeDuration;\n                    const dampStart = 0.75;\n                    let damp = 1;\n                    if (percentComplete >= dampStart)\n                        damp = Math.max(0, 1 - percentComplete);\n                    const f = this.shakeAmplitude * damp;\n                    const x = (Math.random() * f) >> 0;\n                    const y = (Math.random() * f) >> 0;\n                    // apply to offset\n                    this.drawOffsetX += x;\n                    this.drawOffsetY += y;\n                }\n            }\n        }\n    }\n}",
            "console.ts": "namespace game.consoleOverlay {\n    let consoleColor = 1;\n    let consoleStrings: string[];\n    let tabSize = 8;\n    const marginx = 4;\n    const marginy = 2;\n    const consoleFont = image.font5;\n    const consoleLines = Math.floor(screen.height / (consoleFont.charHeight + marginy)) - 1;\n    const consoleColumns = Math.floor((screen.width - 2 * marginx) / consoleFont.charWidth);\n    console.addListener(listener);\n\n    export function isVisible() {\n        return !!consoleStrings;\n    }\n\n    export function clear() {\n        consoleStrings = [];\n    }\n\n    export function setVisible(value: boolean, col?: number) {\n        if (value != !!consoleStrings)\n            consoleStrings = value ? [] : undefined;\n        if (col !== undefined)\n            consoleColor = col;\n    }\n\n    function listener(priority: ConsolePriority, text: string) {\n        if (!consoleStrings || !text)\n            return;\n\n        // split text into lines\n        text.split(\"\\n\")\n            .filter(line => !!line)\n            .forEach(line => {\n                for (let j = 0; j < line.length; j += consoleColumns) {\n                    consoleStrings.push(line.slice(j, j + consoleColumns));\n                }\n            });\n\n        if (consoleStrings.length > consoleLines) {\n            consoleStrings.splice(0, consoleStrings.length - consoleLines);\n        }\n    }\n\n    export function draw() {\n        if (!consoleStrings || scene.systemMenu.isVisible()) return;\n        const height = consoleFont.charHeight + marginy;\n        const top = 2 + (game.stats ? height : 0);\n        for (let i = 0; i < consoleStrings.length; ++i) {\n            if (consoleStrings[i].indexOf(\"\\t\") >= 0) {\n                const t = consoleStrings[i].split(\"\\t\");\n                let tOff = 0;\n                for (let tab of t) {\n                    let padding = tabSize - ((tOff + tab.length) % tabSize)\n                    screen.print(tab, marginx + (tOff * consoleFont.charWidth), top + i * height, consoleColor, consoleFont);\n                    tOff += tab.length + padding;\n                }\n            }\n            else\n                screen.print(consoleStrings[i], marginx, top + i * height, consoleColor, consoleFont);\n        }\n    }\n}",
            "constants.ts": "const KEY_UP = 2048;\nconst KEY_DOWN = 2049;\nconst INTERNAL_KEY_UP = 2050;\nconst INTERNAL_KEY_DOWN = 2051;\nconst SYSTEM_KEY_UP = 2052;\nconst SYSTEM_KEY_DOWN = 2053;\nconst KEY_REPEAT = 2054;\nconst SYSTEM_KEY_REPEAT = 2055;\n",
            "controller.ts": "enum ControllerButtonEvent {\n    //% block=\"pressed\"\n    Pressed = KEY_DOWN,\n    //% block=\"released\"\n    Released = KEY_UP,\n    //% block=\"repeat\"\n    Repeated = KEY_REPEAT\n}\n\n\nenum ControllerButton {\n    //% block=\"A\"\n    A = 5,\n    //% block=\"B\"\n    B = 6,\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"up\"\n    Up = 2,\n    //% block=\"right\"\n    Right = 3,\n    //% block=\"down\"\n    Down = 4\n}\n\nenum ControllerEvent {\n    //% block=\"connected\"\n    Connected = 1,\n    //% block=\"disconnected\"\n    Disconnected = 2\n}\n\n/**\n * Access to game controls\n */\n//% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n//% groups='[\"Single Player\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace controller {\n    let _userEventsEnabled = true;\n    let defaultRepeatDelay = 500;\n    let defaultRepeatInterval = 30;\n\n    //% fixedInstances\n    export class Button {\n        _owner: Controller;\n        public id: number;\n        //% help=controller/button/repeat-delay\n        public repeatDelay: number;\n        //% help=controller/button/repeat-interval\n        public repeatInterval: number;\n        private _pressed: boolean;\n        private _pressedElasped: number;\n        private _repeatCount: number;\n        private _buttonId: number;\n\n        toString(): string {\n            return `btn ${this.id} ${this._buttonId} ${this._pressed ? \"down\" : \"up\"}`;\n        }\n\n        constructor(id: number, buttonId: number) {\n            this.id = id;\n            this._buttonId = buttonId;\n            this._pressed = false;\n            this.repeatDelay = undefined;\n            this.repeatInterval = undefined;\n            this._repeatCount = 0;\n            if (id > 0) {\n                // this is to deal with the \"anyButton\" hack, which creates a button that is not visible\n                // in the UI, but used in event-handler to simulate the wildcard ANY for matching. As \n                // this button can't actually be pressed, we don't want it to propagate events\n                control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16)\n                control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16)\n            }\n            if (buttonId > -1) {\n                // only add these events when running on real hardware\n                control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_UP, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_DOWN, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n            }\n        }\n\n        private raiseButtonUp() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_UP, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_UP, this.id);\n        }\n\n        private raiseButtonDown() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_DOWN, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n        }\n\n        private raiseButtonRepeat() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_REPEAT, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8 help=controller/button/on-event\n        //% blockId=keyonevent block=\"on %button **button** %event\"\n        //% group=\"Single Player\"\n        onEvent(event: ControllerButtonEvent, handler: () => void) {\n            control.onEvent(event, this.id, handler);\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/pause-until\n        // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n        //% group=\"Single Player\"\n        pauseUntil(event: ControllerButtonEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=keyispressed block=\"is %button **button** pressed\"\n        //% group=\"Single Player\"\n        isPressed() {\n            return this._pressed;\n        }\n\n        setPressed(pressed: boolean) {\n            if (this._pressed != pressed) {\n                power.poke();\n                if (this._owner)\n                    this._owner.connected = true;\n                this._pressed = pressed;\n                if (this._pressed) {\n                    this._pressedElasped = 0;\n                    this.raiseButtonDown();\n                } else {\n                    this._repeatCount = 0;\n                    this.raiseButtonUp();\n                }\n            }\n        }\n\n        __update(dtms: number) {\n            if (!this._pressed) return;\n            this._pressedElasped += dtms;\n\n            const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n            const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n\n            // inital delay\n            if (this._pressedElasped < delay)\n                return;\n\n            // repeat count for this step\n            const count = Math.floor((this._pressedElasped - delay - interval) / interval);\n            if (count != this._repeatCount) {\n                this.raiseButtonRepeat();\n                this._repeatCount = count;\n            }\n        }\n    }\n\n    /**\n     * Configures the timing of the on button repeat event for all of the controller buttons\n     * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n     * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n     */\n    export function setRepeatDefault(delay: number, interval: number) {\n        defaultRepeatDelay = delay;\n        defaultRepeatInterval = interval;\n    }\n\n    let _players: Controller[];\n\n    function addController(ctrl: Controller) {\n        if (!_players) {\n            _players = [];\n        }\n        _players[ctrl.playerIndex - 1] = ctrl;\n    }\n\n    function player1(): Controller {\n        if (!_players || !_players[0])\n            new Controller(1, [controller.left, controller.up, controller.right, controller.down, controller.A, controller.B, controller.menu]);\n        return _players[0];\n    }\n\n    export function players(): Controller[] {\n        player1(); // ensure player1 is present\n        return _players.filter(ctrl => !!ctrl);\n    }\n\n    export class ControlledSprite {\n        public _inputLastFrame: boolean;\n        constructor(\n            public s: Sprite,\n            public vx: number,\n            public vy: number\n        ) { }\n    }\n\n    export function _moveSprites() {\n        // todo: move to currecnt sceane\n        control.enablePerfCounter(\"controller\")\n        players().forEach(ctrl => ctrl.__preUpdate());\n    }\n\n    //% fixedInstances\n    export class Controller {\n        playerIndex: number;\n        buttons: Button[];\n        private _id: number;\n        private _connected: boolean;\n\n        // array of left,up,right,down,a,b,menu buttons\n        constructor(playerIndex: number, buttons: Button[]) {\n            this._id = control.allocateNotifyEvent();\n            this._connected = false;\n            this.playerIndex = playerIndex;\n            if (buttons)\n                this.buttons = buttons;\n            else {\n                this.buttons = [];\n                const leftId = 1 + (this.playerIndex - 1) * 7;\n                for (let i = 0; i < 7; ++i) {\n                    this.buttons.push(new Button(leftId + i, -1));\n                }\n            }\n            for (let i = 0; i < this.buttons.length; ++i)\n                this.buttons[i]._owner = this;\n            addController(this);\n        }\n\n        get _controlledSprites(): ControlledSprite[] {\n            return game.currentScene().controlledSprites[this.playerIndex];\n        }\n\n        set _controlledSprites(cps: ControlledSprite[]) {\n            game.currentScene().controlledSprites[this.playerIndex] = cps;\n        }\n\n        get id() {\n            return this._id;\n        }\n\n        dump() {\n            this.buttons.forEach(b => console.log(b.toString()));\n        }\n\n        /**\n         * Gets the left button\n         */\n        //%\n        get left() {\n            return this.button(ControllerButton.Left);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get right() {\n            return this.button(ControllerButton.Right);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get up() {\n            return this.button(ControllerButton.Up);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get down() {\n            return this.button(ControllerButton.Down);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get A() {\n            return this.button(ControllerButton.A);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get B() {\n            return this.button(ControllerButton.B);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get menu() {\n            return this.button(7);\n        }\n\n        /**\n         * Control a sprite using the direction buttons from the controller. Note that this will overwrite\n         * the current velocity of the sprite whenever a directional button is pressed. To stop controlling\n         * a sprite, pass 0 for vx and vy.\n         *\n         * @param sprite The Sprite to control\n         * @param vx The velocity used for horizontal movement when left/right is pressed\n         * @param vy The velocity used for vertical movement when up/down is pressed\n         */\n        //% blockId=\"ctrlgame_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n        //% weight=100\n        //% expandableArgumentMode=\"toggle\"\n        //% vx.defl=100 vy.defl=100\n        //% help=controller/move-sprite\n        //% group=\"Multiplayer\"\n        moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            if (!sprite) return;\n            if (!this._controlledSprites) this._controlledSprites = [];\n            let cp = this._controlledSprites.find(cp => cp.s.id == sprite.id);\n            if (!cp) {\n                cp = new ControlledSprite(sprite, vx, vy);\n                this._controlledSprites.push(cp);\n            }\n            if (cp.vx && vx == 0) {\n                cp.s.vx = 0\n            }\n            if (cp.vy && vy == 0) {\n                cp.s.vy = 0\n            }\n            cp.vx = vx;\n            cp.vy = vy;\n        }\n\n        private button(button: ControllerButton): Button {\n            return this.buttons[button - 1];\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-button-event\n        onButtonEvent(btn: ControllerButton, event: ControllerButtonEvent, handler: () => void) {\n            this.button(btn).onEvent(event, handler);\n        }\n\n        /**\n         * Register code run when a controller event occurs\n         * @param event\n         * @param handler\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonevent block=\"on %controller %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-event\n        onEvent(event: ControllerEvent, handler: () => void) {\n            control.onEvent(this.id, event, handler);\n        }\n\n        get connected() {\n            return this._connected;\n        }\n\n        set connected(value: boolean) {\n            if (value != this._connected) {\n                this._connected = value;\n                control.raiseEvent(this.id, this._connected ? ControllerEvent.Connected : ControllerEvent.Disconnected);\n            }\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n        //% group=\"Multiplayer\"\n        isPressed(btn: ControllerButton): boolean {\n            return this.button(btn).isPressed();\n        }\n\n        /**\n         * Get the horizontal movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=50 blockGap=8 help=controller/dx\n        //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        dx(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.left.isPressed()) {\n                if (this.right.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.right.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        /**\n         * Get the vertical movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=49 help=keys/dy\n        //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        dy(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.up.isPressed()) {\n                if (this.down.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.down.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        __preUpdate() {\n            if (!this._controlledSprites) return;\n\n            let deadSprites = false;\n            let svx: number;\n            let svy: number;\n            this._controlledSprites.forEach(sprite => {\n                if (sprite.s.flags & sprites.Flag.Destroyed) {\n                    deadSprites = true;\n                    return;\n                }\n\n                svx = 0;\n                svy = 0;\n\n                if (sprite.vx) {\n                    if (this.right.isPressed()) {\n                        svx += sprite.vx;\n                    }\n                    if (this.left.isPressed()) {\n                        svx -=sprite.vx;\n                    }\n                }\n\n                if (sprite.vy) {\n                    if (this.down.isPressed()) {\n                        svy += sprite.vy;\n                    }\n                    if (this.up.isPressed()) {\n                        svy -= sprite.vy;\n                    }\n                }\n\n                if (sprite._inputLastFrame) {\n                    if (sprite.vx) sprite.s.vx = 0;\n                    if (sprite.vy) sprite.s.vy = 0;\n                }\n\n                if (svx || svy) {\n                    if (sprite.vx) sprite.s.vx = svx;\n                    if (sprite.vy) sprite.s.vy = svy;\n                    sprite._inputLastFrame = true;\n                }\n                else {\n                    sprite._inputLastFrame = false;\n                }\n            });\n\n            if (deadSprites)\n                this._controlledSprites = this._controlledSprites\n                    .filter(s => !(s.s.flags & sprites.Flag.Destroyed));\n        }\n\n        __update(dtms: number) {\n            dtms = dtms | 0;\n            this.buttons.forEach(btn => btn.__update(dtms));\n        }\n\n        serialize(offset: number): Buffer {\n            const buf = control.createBuffer(offset + 1);\n            let b = 0;\n            for (let i = 0; this.buttons.length; ++i)\n                b |= (this.buttons[i].isPressed() ? 1 : 0) << i;\n            buf[offset] = b\n            return buf;\n        }\n    }\n\n    /**\n     * Called by the game engine to update and/or raise events\n     */\n    export function __update(dt: number) {\n        const dtms = (dt * 1000) | 0\n        players().forEach(ctrl => ctrl.__update(dtms));\n    }\n\n    export function serialize(offset: number): Buffer {\n        return player1().serialize(offset);\n    }\n\n    /**\n     * Control a sprite using the direction buttons from the controller. Note that this\n     * control will take over the vx and vy of the sprite and overwrite any changes\n     * made unless a 0 is passed.\n     *\n     * @param sprite The Sprite to control\n     * @param vx The velocity used for horizontal movement when left/right is pressed\n     * @param vy The velocity used for vertical movement when up/down is pressed\n     */\n    //% blockId=\"game_control_sprite\" block=\"move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n    //% weight=100\n    //% expandableArgumentMode=\"toggle\"\n    //% vx.defl=100 vy.defl=100\n    //% help=controller/move-sprite\n    //% group=\"Single Player\"\n    export function moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n        player1().moveSprite(sprite, vx, vy);\n    }\n\n\n    /**\n     * Pause the program until a button is pressed\n     */\n    //% weight=10\n    export function pauseUntilAnyButtonIsPressed() {\n        control.waitForEvent(KEY_DOWN, 0)\n    }\n\n    export function _setUserEventsEnabled(enabled: boolean) {\n        _userEventsEnabled = enabled;\n    }\n\n    /**\n     * Get the horizontal movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=50 blockGap=8 help=controller/dx\n    //% blockId=keydx block=\"dx (left-right buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dx(step: number = 100) {\n        return player1().dx(step);\n    }\n\n    /**\n     * Get the vertical movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=49 help=keys/dy\n    //% blockId=keydy block=\"dy (up-down buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dy(step: number = 100) {\n        return player1().dy(step);\n    }\n\n\n    //% fixedInstance block=\"any\"\n    export const anyButton = new Button(0, -1);\n}\n",
            "controlleroverrides.ts": "namespace controller {\n    //% fixedInstance whenUsed block=\"A\"\n    export const A = new Button(ControllerButton.A, -1);\n    //% fixedInstance whenUsed block=\"B\"\n    export const B = new Button(ControllerButton.B, -1);\n    //% fixedInstance whenUsed block=\"left\"\n    export const left = new Button(ControllerButton.Left, -1);\n    //% fixedInstance whenUsed block=\"up\"\n    export const up = new Button(ControllerButton.Up, -1);\n    //% fixedInstance whenUsed block=\"right\"\n    export const right = new Button(ControllerButton.Right, -1);\n    //% fixedInstance whenUsed block=\"down\"\n    export const down = new Button(ControllerButton.Down, -1);\n    //% fixedInstance whenUsed block=\"menu\"\n    export const menu = new Button(7, -1);\n\n    //% fixedInstance whenUsed block=\"player 2\"\n    export const player2 = new Controller(2, undefined);\n    //% fixedInstance whenUsed block=\"player 3\"\n    export const player3 = new Controller(3, undefined);\n    //% fixedInstance whenUsed block=\"player 4\"\n    export const player4 = new Controller(4, undefined);\n}",
            "effects.ts": "namespace effects {\n    //% fixedInstances\n    export class ImageEffect implements BackgroundEffect {\n\n        // If used in an animation, this should be used as the default delay between method calls\n        protected preferredDelay: number;\n        protected effect: (image: Image, fastRandom?: Math.FastRandom) => void;\n        protected fastRandom: Math.FastRandom;\n        private times: number;\n\n        constructor(defaultRate: number, effectFactory: (image: Image, fastRandom?: Math.FastRandom) => void) {\n            this.effect = effectFactory;\n            this.fastRandom = new Math.FastRandom();\n            this.preferredDelay = defaultRate;\n            this.times = undefined;\n        }\n\n        /**\n         * Apply this effect to the image of the current sprite\n         * @param sprite\n         */\n        applyTo(sprite: Sprite) {\n            if (!sprite || !sprite.image) return;\n            const clonedImage = sprite.image.clone();\n            this.change(clonedImage)\n            sprite.setImage(clonedImage);\n        }\n\n        /**\n         * Change the given image with this effect\n         * @param input \n         */\n        change(input: Image) {\n            this.effect(input, this.fastRandom);\n        }\n\n        /**\n         * Make this effect occur repeatedly on the background image\n         * @param times number of times effect should occur\n         * @param delay delay between instances of the effect\n         */\n        startScreenEffect(times?: number, delay?: number): void {\n            if (!game.currentScene().background.hasBackgroundImage()) return;\n            const wasRunning = this.times != undefined;\n            this.times = times ? times : 15;\n\n            if (!wasRunning) {\n                control.runInParallel(() => {\n                    while (this.times > 0) {\n                        this.change(scene.backgroundImage());\n                        pause(delay ? delay : this.preferredDelay);\n                        --this.times;\n                    }\n                    this.times = undefined;\n                });\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"dissolve\"\n    export const dissolve = new ImageEffect(100, (input: Image, r: Math.FastRandom) => {\n        for (let i = (input.width * input.height) >> 5; i > 0; --i) {\n            const x = r.randomRange(0, input.width)\n            const y = r.randomRange(0, input.height)\n            const w = r.randomRange(1, 3);\n            const h = r.randomRange(1, 3);\n\n            input.drawRect(x, y, w, h, 0);\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"melt\"\n    export const melt = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const rounds = (input.width * input.height) >> 5;\n        for (let j = 0; j < rounds; ++j) {\n            let x = r.randomRange(0, input.width - 1)\n            let y = r.randomRange(0, input.height - 3)\n            let c = input.getPixel(x, y)\n            input.setPixel(x, y + 1, c)\n            input.setPixel(x, y + 2, c)\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"slash\"\n    export const slash = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const rounds = 12;\n        for (let j = 0; j < rounds; ++j) {\n            let horizontal = r.randomBool();\n            let length = r.randomRange(5, 50);\n            let x = r.randomRange(0, input.width - (horizontal ? length : 1));\n            let y = r.randomRange(0, input.height - (horizontal ? 3 : length));\n            input.drawLine(x, y, horizontal ? x + length : x, horizontal ? y : y + length, 1);\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"splatter\"\n    export const splatter = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const imgs: Image[] = [\n            img`\n            . 1 .\n            1 1 1\n            . 1 1`,\n            img`\n            . 1 1 .\n            1 1 1 1\n            . 1 1 .`,\n            img`\n            . 1 1 1 .\n            1 1 1 1 1\n            1 1 1 1 1\n            1 1 1 1 1\n            . 1 1 1 .`,\n            img`\n            . . 1 1 . .\n            . 1 1 1 1 .\n            1 1 1 1 1 1\n            1 1 1 1 1 1\n            . 1 1 1 1 .\n            . . 1 1 . .`,\n            img`\n            . . 1 1 1. .\n            . 1 1 1 1 1 .\n            1 1 1 1 1 1 1\n            1 1 1 1 1 1 1\n            1 1 1 1 1 1 1\n            . 1 1 1 1 1 .\n            . . 1 1 1. .`,\n            img`\n            . . 1 1 1 1 . .\n            . 1 1 1 1 1 1 .\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            . 1 1 1 1 1 1 .\n            . . 1 1 1 1 . .`,\n            img`\n            . . . 1 1 1 . . .\n            . . 1 1 1 1 1 . .\n            . 1 1 1 1 1 1 1 .\n            1 1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1 1\n            . 1 1 1 1 1 1 1 .\n            . . 1 1 1 1 1 . .\n            . . . 1 1 1 . . .`,\n        ];\n\n        const rounds = 12;\n        for (let j = 0; j < rounds; ++j) {\n            const im = imgs[r.randomRange(0, imgs.length - 1)];\n            const x = r.randomRange(0, input.width - im.width / 2);\n            const y = r.randomRange(0, input.height - im.height / 2);\n            input.drawTransparentImage(im, x, y);\n        }\n    });\n}",
            "fieldeditors.ts": "namespace __internal {\n\n    /**\n     * A speed picker\n     * @param speed the speed, eg: 50\n     */\n    //% blockId=spriteSpeedPicker block=\"%speed\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 \n    //% speed.fieldOptions.decompileLiterals=1\n    //% speed.fieldOptions.format=\"{0}pix/s\"\n    export function __spriteSpeedPicker(speed: number): number {\n        return speed;\n    }\n\n    /**\n     * A sprite acceleration picker\n     * @param acceleration the acceleration in pixel/sec^2\n     */\n    //% blockId=spriteAccPicker block=\"%acceleration\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 \n    //% speed.fieldOptions.decompileLiterals=1\n    //% speed.fieldOptions.format=\"{0}pix/s²\"\n    export function __accSpeedPicker(acceleration: number): number {\n        return acceleration;\n    }\n}",
            "game.ts": "/**\n * Game transitions and dialog\n **/\n//% color=#008272 weight=97 icon=\"\\uf111\"\n//% groups='[\"Gameplay\", \"Prompt\"]'\nnamespace game {\n    /**\n     * Determines if diagnostics are shown\n     */\n    export let debug = false;\n    export let stats = false;\n    export let winEffect: effects.BackgroundEffect = undefined;\n    export let loseEffect: effects.BackgroundEffect = undefined;\n    let loseSound: music.Melody = undefined;\n    let winSound: music.Melody = undefined;\n\n    let _scene: scene.Scene;\n    let _sceneStack: scene.Scene[];\n\n    let _scenePushHandlers: ((scene: scene.Scene) => void)[];\n    let _scenePopHandlers: ((scene: scene.Scene) => void)[];\n\n    export function currentScene(): scene.Scene {\n        init();\n        return _scene;\n    }\n\n    let __waitAnyButton: () => void;\n    let __gameOverHandler: (win: boolean) => void;\n    let __isOver = false;\n\n    export function setWaitAnyButton(f: () => void) {\n        __waitAnyButton = f\n    }\n\n    export function waitAnyButton() {\n        if (__waitAnyButton) __waitAnyButton()\n        else pause(3000)\n    }\n\n    export function eventContext(): control.EventContext {\n        init();\n        return _scene.eventContext;\n    }\n\n    function init() {\n        if (!_scene) _scene = new scene.Scene(control.pushEventContext());\n        _scene.init();\n\n        if (!winEffect)\n            winEffect = effects.confetti;\n        if (!loseEffect)\n            loseEffect = effects.melt;\n\n        if (!winSound)\n            winSound = music.powerUp;\n        if (!loseSound)\n            loseSound = music.wawawawaa;\n    }\n\n    export function pushScene() {\n        const oldScene = game.currentScene()\n        particles.clearAll();\n        particles.disableAll();\n        if (!_sceneStack) _sceneStack = [];\n        _sceneStack.push(_scene);\n        _scene = undefined;\n        init();\n\n        if (_scenePushHandlers) {\n            _scenePushHandlers.forEach(cb => cb(oldScene));\n        }\n    }\n\n    export function popScene() {\n        const oldScene = game.currentScene()\n        if (_sceneStack && _sceneStack.length) {\n            // pop scenes from the stack\n            _scene = _sceneStack.pop();\n            control.popEventContext();\n        } else if (_scene) {\n            // post last scene\n            control.popEventContext();\n            _scene = undefined;\n        }\n\n        if (_scene)\n            particles.enableAll();\n\n        if (_scenePopHandlers) {\n            _scenePopHandlers.forEach(cb => cb(oldScene));\n        }\n    }\n\n    function showDialogBackground(h: number, c: number) {\n        const top = (screen.height - h) >> 1;\n        screen.fillRect(0, top, screen.width, h, 0)\n        screen.drawLine(0, top, screen.width, top, 1)\n        screen.drawLine(0, top + h - 1, screen.width, top + h - 1, 1)\n\n        return top;\n    }\n\n    export function showDialog(title: string, subtitle: string, footer?: string) {\n        init();\n        const titleFont = image.getFontForText(title || \"\");\n        const subFont = image.getFontForText(subtitle || \"\")\n        const footerFont = image.getFontForText(footer || \"\");\n        let h = 8;\n        if (title)\n            h += titleFont.charHeight;\n        if (subtitle)\n            h += 2 + subFont.charHeight\n        h += 8;\n        const top = showDialogBackground(h, 9)\n        let y = top + 8;\n        if (title) {\n            screen.print(title, 8, y, screen.isMono ? 1 : 7, titleFont);\n            y += titleFont.charHeight + 2;\n        }\n        if (subtitle) {\n            screen.print(subtitle, 8, y, screen.isMono ? 1 : 6, subFont);\n            y += subFont.charHeight + 2;\n        }\n        if (footer) {\n            const footerTop = screen.height - footerFont.charHeight - 4;\n            screen.fillRect(0, footerTop, screen.width, footerFont.charHeight + 4, 0);\n            screen.drawLine(0, footerTop, screen.width, footerTop, 1);\n            screen.print(\n                footer,\n                screen.width - footer.length * footerFont.charWidth - 8,\n                screen.height - footerFont.charHeight - 2,\n                1,\n                footerFont\n            )\n        }\n    }\n\n    /**\n     * Set the effect that occurs when the game is over\n     * @param win whether the animation should run on a win (true)\n     * @param effect\n     */\n    export function setGameOverEffect(win: boolean, effect: effects.BackgroundEffect) {\n        init();\n        if (!effect) return;\n        if (win)\n            winEffect = effect;\n        else\n            loseEffect = effect;\n    }\n\n    /**\n     * Set the music that occurs when the player wins\n     * @param win\n     * @param effect\n     */\n    export function setGameOverSound(win: boolean, sound: music.Melody) {\n        init();\n        if (!sound) return;\n        if (win)\n            winSound = sound;\n        else\n            loseSound = sound;\n    }\n    /**\n     * Set the function to call on game over. The 'win' boolean is\n     * passed to the handler.\n     * @param handler\n     */\n    export function onGameOver(handler: (win: boolean) => void) {\n        __gameOverHandler = handler;\n    }\n\n    /**\n     * Finish the game and display the score\n     */\n    //% group=\"Gameplay\"\n    //% blockId=gameOver block=\"game over %win=toggleWinLose || with %effect effect\"\n    //% weight=80 help=game/over\n    export function over(win: boolean = false, effect?: effects.BackgroundEffect) {\n        init();\n        if (__isOver) return;\n        __isOver = true;\n\n        if (__gameOverHandler) {\n            __gameOverHandler(win);\n        } else {\n            if (!effect) {\n                effect = win ? winEffect : loseEffect;\n            }\n\n            // collect the scores before poping the scenes\n            const scoreInfo = info.player1.getState();\n            const highScore = info.highScore();\n            if (scoreInfo.score > highScore)\n                info.saveHighScore();\n\n            // releasing memory and clear fibers. Do not add anything that releases the fiber until background is set below,\n            // or screen will be cleared on the new frame and will not appear as background in the game over screen.\n            while (_sceneStack && _sceneStack.length) {\n                _scene.destroy();\n                popScene();\n            }\n            pushScene();\n            scene.setBackgroundImage(screen.clone());\n\n            if (win)\n                winSound.play();\n            else\n                loseSound.play();\n\n            effect.startScreenEffect();\n\n            pause(400);\n\n            const overDialog = new GameOverDialog(win, scoreInfo.score, highScore);\n            scene.createRenderable(scene.HUD_Z, target => {\n                overDialog.update();\n                target.drawTransparentImage(\n                    overDialog.image,\n                    0,\n                    (screen.height - overDialog.image.height()) >> 1\n                );\n            });\n\n            pause(500); // wait for users to stop pressing keys\n            overDialog.displayCursor();\n            waitAnyButton();\n            control.reset();\n        }\n    }\n\n    /**\n     * Update the position and velocities of sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update weight=100 afterOnStart=true\n    //% blockId=gameupdate block=\"on game update\"\n    //% blockAllowMultiple=1\n    export function onUpdate(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(scene.UPDATE_PRIORITY, a);\n    }\n\n    /**\n     * Run code on an interval of time. This executes before game.onUpdate()\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update-interval weight=99 afterOnStart=true\n    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n    //% blockAllowMultiple=1\n    export function onUpdateInterval(period: number, a: () => void): void {\n        init();\n        if (!a || period < 0) return;\n        let timer = 0;\n        game.eventContext().registerFrameHandler(scene.UPDATE_INTERVAL_PRIORITY, () => {\n            const time = game.currentScene().millis();\n            if (timer <= time) {\n                timer = time + period;\n                a();\n            }\n        });\n    }\n\n    // Indicates whether the fiber needs to be created\n    let foreverRunning = false;\n\n    /**\n     * Repeats the code forever in the background for this scene.\n     * On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    export function forever(action: () => void): void {\n        if (!foreverRunning) {\n            foreverRunning = true;\n            control.runInParallel(() => {\n                while (1) {\n                    const handlers = game.currentScene().gameForeverHandlers;\n                    handlers.forEach(h => {\n                        if (!h.lock) {\n                            h.lock = true;\n                            control.runInParallel(() => {\n                                h.handler();\n                                h.lock = false;\n                            });\n                        }\n                    });\n                    pause(20);\n                }\n            });\n        }\n\n        game.currentScene().gameForeverHandlers.push(\n            new scene.GameForeverHandler(action)\n        );\n    }\n\n    /**\n     * Draw on screen before sprites, after background\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/paint weight=10 afterOnStart=true\n    export function onPaint(a: () => void): void {\n        init();\n        if (!a) return;\n        scene.createRenderable(scene.ON_PAINT_Z, a);\n    }\n\n    /**\n     * Draw on screen after sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/shade weight=10 afterOnStart=true\n    export function onShade(a: () => void): void {\n        init();\n        if (!a) return;\n        scene.createRenderable(scene.ON_SHADE_Z, a);\n    }\n\n    /**\n     * Returns the time since the game started in milliseconds\n     */\n    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n    //% group=\"Gameplay\" weight=11\n    //% help=game/runtime\n    export function runtime(): number {\n        return currentScene().millis();\n    }\n\n    /**\n     * Register a handler that runs whenever a scene is pushed onto the scene\n     * stack. Useful for extensions that need to store/restore state as the\n     * event context changes. The handler is run AFTER the push operation (i.e.\n     * after game.currentScene() has changed)\n     *\n     * @param handler Code to run when a scene is pushed onto the stack\n     */\n    export function addScenePushHandler(handler: (oldScene: scene.Scene) => void) {\n        if (!_scenePushHandlers) _scenePushHandlers = [];\n        if (_scenePushHandlers.indexOf(handler) < 0)\n            _scenePushHandlers.push(handler);\n    }\n\n    /**\n     * Remove a scene push handler. Useful for extensions that need to store/restore state as the\n     * event context changes.\n     *\n     * @param handler The handler to remove\n     */\n    export function removeScenePushHandler(handler: (oldScene: scene.Scene) => void) {\n        if (_scenePushHandlers) _scenePushHandlers.removeElement(handler);\n    }\n\n    /**\n     * Register a handler that runs whenever a scene is popped off of the scene\n     * stack. Useful for extensions that need to store/restore state as the\n     * event context changes. The handler is run AFTER the pop operation. (i.e.\n     * after game.currentScene() has changed)\n     *\n     * @param handler Code to run when a scene is removed from the top of the stack\n     */\n    export function addScenePopHandler(handler: (oldScene: scene.Scene) => void) {\n        if (!_scenePopHandlers) _scenePopHandlers = [];\n        if (_scenePopHandlers.indexOf(handler) < 0)\n            _scenePopHandlers.push(handler);\n    }\n\n    /**\n     * Remove a scene pop handler. Useful for extensions that need to store/restore state as the\n     * event context changes.\n     *\n     * @param handler The handler to remove\n     */\n    export function removeScenePopHandler(handler: (oldScene: scene.Scene) => void) {\n        if (_scenePopHandlers) _scenePopHandlers.removeElement(handler);\n    }\n}\n",
            "gameoverrides.ts": "/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true blockNamespace=\"loops\"\n//% blockId=forever block=\"forever\" blockAllowMultiple=1\nfunction forever(a: () => void): void {\n    game.forever(a);\n}\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function forever(a: () => void) {\n        game.forever(a);\n    }\n}",
            "hitbox.ts": "namespace game {\n    export class Hitbox {\n        parent: Sprite;\n        ox: number;\n        oy: number;\n        width: number;\n        height: number;\n\n        constructor(parent: Sprite, width: number, height: number, ox: number, oy: number) {\n            this.width = width;\n            this.height = height;\n            this.parent = parent;\n            this.ox = ox;\n            this.oy = oy;\n        }\n\n        get left() {\n            return Fx.iadd(this.ox, this.parent._x)\n        }\n\n        get top() {\n            return Fx.iadd(this.oy, this.parent._y)\n        }\n\n        get right() {\n            return Fx.iadd(this.width - 1, this.left)\n        }\n\n        get bottom() {\n            return Fx.iadd(this.height - 1, this.top)\n        }\n    }\n\n\n    export function calculateHitBox(s: Sprite): Hitbox {\n        const i = s.image;\n        let minX = i.width;\n        let minY = i.height;\n        let maxX = 0;\n        let maxY = 0;\n\n        for (let c = 0; c < i.width; c++) {\n            for (let r = 0; r < i.height; r++) {\n                if (i.getPixel(c, r)) {\n                    minX = Math.min(minX, c);\n                    minY = Math.min(minY, r);\n                    maxX = Math.max(maxX, c);\n                    maxY = Math.max(maxY, r);\n                }\n            }\n        }\n\n        const width = maxX - minX + 1;\n        const height = maxY - minY + 1;\n        \n        return new Hitbox(s, width, height, minX, minY);\n    }\n}",
            "info.ts": "\n/**\n * Head-up display\n *\n*/\n//% color=#AA5585 weight=80 icon=\"\\uf2bb\" blockGap=8\n//% groups='[\"Score\", \"Life\", \"Countdown\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace info {\n\n    export enum Visibility {\n        None = 0,\n        Countdown = 1 << 0,\n        Score = 1 << 1,\n        Life = 1 << 2,\n        Hud = 1 << 3,\n        Multi = 1 << 4,\n        UserHeartImage = 1 << 5\n    }\n\n    class PlayerState {\n        public score: number;\n        // undefined: not used\n        // null: reached 0 and callback was invoked\n        public life: number;\n        public lifeZeroHandler: () => void;\n\n        constructor() { }\n    }\n\n    class InfoState {\n        public playerStates: PlayerState[];\n        public visibilityFlag: number;\n\n        public gameEnd: number;\n        public heartImage: Image;\n        public multiplierImage: Image;\n        public bgColor: number;\n        public borderColor: number;\n        public fontColor: number;\n        public countdownExpired: boolean;\n        public countdownEndHandler: () => void;\n\n        constructor() {\n            this.visibilityFlag = Visibility.Hud;\n            this.playerStates = [];\n            this.heartImage = defaultHeartImage();\n            this.multiplierImage = img`\n                1 . . . 1\n                . 1 . 1 .\n                . . 1 . .\n                . 1 . 1 .\n                1 . . . 1\n            `;\n            this.bgColor = screen.isMono ? 0 : 1;\n            this.borderColor = screen.isMono ? 1 : 3;\n            this.fontColor = screen.isMono ? 1 : 3;\n            this.countdownExpired = undefined;\n            this.countdownEndHandler = undefined;\n            this.gameEnd = undefined;\n            this.playerStates = [];\n        }\n    }\n\n    let infoState: InfoState = undefined;\n\n    let players: PlayerInfo[];\n\n    let infoStateStack: {\n        state: InfoState,\n        scene: scene.Scene\n    }[];\n\n    game.addScenePushHandler(oldScene => {\n        if (infoState) {\n            if (!infoStateStack) infoStateStack = [];\n            infoStateStack.push({\n                state: infoState,\n                scene: oldScene\n            });\n            infoState = undefined;\n        }\n    });\n\n    game.addScenePopHandler(() => {\n        const scene = game.currentScene();\n        infoState = undefined;\n        if (infoStateStack && infoStateStack.length) {\n            const nextState = infoStateStack.pop();\n            if (nextState.scene == scene) {\n                infoState = nextState.state;\n            } else {\n                infoStateStack.push(nextState);\n            }\n        }\n    });\n\n    function initHUD() {\n        if (infoState) return;\n\n        infoState = new InfoState();\n\n        scene.createRenderable(\n            scene.HUD_Z,\n            () => {\n                if (!infoState) return;\n                control.enablePerfCounter(\"info\")\n                // show score, lifes\n                if (infoState.visibilityFlag & Visibility.Multi) {\n                    const ps = players.filter(p => !!p);\n                    // First draw players\n                    ps.forEach(p => p.drawPlayer());\n                    // Then run life over events\n                    ps.forEach(p => p.raiseLifeZero(false));\n                } else { // single player\n                    // show score\n                    const p = player1;\n                    if (p.hasScore() && (infoState.visibilityFlag & Visibility.Score)) {\n                        p.drawScore();\n                    }\n                    // show life\n                    if (p.hasLife() && (infoState.visibilityFlag & Visibility.Life)) {\n                        p.drawLives();\n                    }\n                    p.raiseLifeZero(true);\n                }\n                // show countdown in both modes\n                if (infoState.gameEnd !== undefined && infoState.visibilityFlag & Visibility.Countdown) {\n                    const scene = game.currentScene();\n                    const elapsed = infoState.gameEnd - scene.millis();\n                    drawTimer(elapsed);\n                    let t = elapsed / 1000;\n                    if (t <= 0) {\n                        t = 0;\n                        if (!infoState.countdownExpired) {\n                            infoState.countdownExpired = true;\n                            if (infoState.countdownEndHandler) {\n                                infoState.countdownEndHandler();\n                                infoState.gameEnd = undefined;\n                            }\n                            else {\n                                game.over();\n                            }\n                        }\n                    }\n                }\n            }\n        );\n    }\n\n    function initMultiHUD() {\n        if (infoState.visibilityFlag & Visibility.Multi) return;\n\n        infoState.visibilityFlag |= Visibility.Multi;\n        if (!(infoState.visibilityFlag & Visibility.UserHeartImage))\n            infoState.heartImage = defaultMultiplayerHeartImage();\n        infoState.multiplierImage = img`\n            1 . 1\n            . 1 .\n            1 . 1\n        `;\n    }\n\n    function defaultHeartImage() {\n        return screen.isMono ?\n            img`\n                . 1 1 . 1 1 . .\n                1 . . 1 . . 1 .\n                1 . . . . . 1 .\n                1 . . . . . 1 .\n                . 1 . . . 1 . .\n                . . 1 . 1 . . .\n                . . . 1 . . . .\n            `\n            :\n            img`\n                . c 2 2 . 2 2 .\n                c 2 2 2 2 2 4 2\n                c 2 2 2 2 4 2 2\n                c 2 2 2 2 2 2 2\n                . c 2 2 2 2 2 .\n                . . c 2 2 2 . .\n                . . . c 2 . . .\n            `;\n    }\n\n    function defaultMultiplayerHeartImage() {\n        return screen.isMono ?\n            img`\n                    . . 1 . 1 . .\n                    . 1 . 1 . 1 .\n                    . 1 . . . 1 .\n                    . . 1 . 1 . .\n                    . . . 1 . . .\n                `\n            :\n            img`\n                    . . 1 . 1 . .\n                    . 1 2 1 4 1 .\n                    . 1 2 4 2 1 .\n                    . . 1 2 1 . .\n                    . . . 1 . . .\n                `;\n    }\n\n    export function saveHighScore() {\n        if (players) {\n            let hs = 0;\n            players\n                .filter(p => p && p.hasScore())\n                .forEach(p => hs = Math.max(hs, p.score()));\n            const curr = settings.readNumber(\"high-score\")\n            if (curr == null || hs > curr)\n                settings.writeNumber(\"high-score\", hs);\n        }\n    }\n\n    /**\n     * Get the current score if any\n     */\n    //% weight=95 blockGap=8\n    //% blockId=hudScore block=\"score\"\n    //% help=info/score\n    //% group=\"Score\"\n    export function score() {\n        return player1.score();\n    }\n\n    //%\n    //% group=\"Score\"\n    export function hasScore() {\n        return player1.hasScore();\n    }\n\n    /**\n     * Get the last recorded high score\n     */\n    //% weight=94\n    //% blockId=highScore block=\"high score\"\n    //% help=info/high-score\n    //% group=\"Score\"\n    export function highScore(): number {\n        return settings.readNumber(\"high-score\") || 0;\n    }\n\n    /**\n     * Set the score\n     */\n    //% weight=93 blockGap=8\n    //% blockId=hudsetScore block=\"set score to %value\"\n    //% help=info/set-score\n    //% group=\"Score\"\n    export function setScore(value: number) {\n        player1.setScore(value);\n    }\n\n    /**\n     * Change the score by the given amount\n     * @param value the amount of change, eg: 1\n     */\n    //% weight=92\n    //% blockId=hudChangeScoreBy block=\"change score by %value\"\n    //% help=info/change-score-by\n    //% group=\"Score\"\n    export function changeScoreBy(value: number) {\n        player1.changeScoreBy(value);\n    }\n\n    /**\n     * Get the number of lives\n     */\n    //% weight=85 blockGap=8\n    //% blockId=hudLife block=\"life\"\n    //% help=info/life\n    //% group=\"Life\"\n    export function life() {\n        return player1.life();\n    }\n\n    //% group=\"Life\"\n    export function hasLife() {\n        return player1.hasLife();\n    }\n\n    /**\n     * Set the number of lives\n     * @param value the number of lives, eg: 3\n     */\n    //% weight=84 blockGap=8\n    //% blockId=hudSetLife block=\"set life to %value\"\n    //% help=info/set-life\n    //% group=\"Life\"\n    export function setLife(value: number) {\n        player1.setLife(value);\n    }\n\n    /**\n     * Change the lives by the given amount\n     * @param value the change of lives, eg: -1\n     */\n    //% weight=83\n    //% blockId=hudChangeLifeBy block=\"change life by %value\"\n    //% help=info/change-life-by\n    //% group=\"Life\"\n    export function changeLifeBy(value: number) {\n        player1.changeLifeBy(value);\n    }\n\n    /**\n     * Run code when the player's life reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% weight=82\n    //% blockId=gamelifeevent block=\"on life zero\"\n    //% help=info/on-life-zero\n    //% group=\"Life\"\n    export function onLifeZero(handler: () => void) {\n        player1.onLifeZero(handler);\n    }\n\n    /**\n     * Start a countdown of the given duration in seconds\n     * @param duration the duration of the countdown, eg: 10\n     */\n    //% blockId=gamecountdown block=\"start countdown %duration (s)\"\n    //% help=info/start-countdown weight=79 blockGap=8\n    //% group=\"Countdown\"\n    export function startCountdown(duration: number) {\n        updateFlag(Visibility.Countdown, true);\n        infoState.gameEnd = game.currentScene().millis() + duration * 1000;\n        infoState.countdownExpired = false;\n    }\n\n    /**\n     * Stop the current countdown and hides the timer display\n     */\n    //% blockId=gamestopcountdown block=\"stop countdown\" weight=78\n    //% help=info/stop-countdown\n    //% group=\"Countdown\"\n    export function stopCountdown() {\n        updateFlag(Visibility.Countdown, false);\n        infoState.gameEnd = undefined;\n        infoState.countdownExpired = true;\n    }\n\n    /**\n     * Run code when the countdown reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% blockId=gamecountdownevent block=\"on countdown end\" weight=77\n    //% help=info/on-countdown-end\n    //% group=\"Countdown\"\n    export function onCountdownEnd(handler: () => void) {\n        initHUD();\n        infoState.countdownEndHandler = handler;\n    }\n\n    /**\n     * Replaces the image used to represent the player's lives. Images\n     * should be no larger than 8x8\n     */\n    //% group=\"Life\"\n    export function setLifeImage(image: Image) {\n        updateFlag(Visibility.UserHeartImage, true);\n        infoState.heartImage = image;\n    }\n\n    /**\n     * Set whether life should be displayed\n     * @param on if true, lives are shown; otherwise, lives are hidden\n     */\n    //% group=\"Life\"\n    export function showLife(on: boolean) {\n        updateFlag(Visibility.Life, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    //% group=\"Score\"\n    export function showScore(on: boolean) {\n        updateFlag(Visibility.Score, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    //% group=\"Countdown\"\n    export function showCountdown(on: boolean) {\n        updateFlag(Visibility.Countdown, on);\n    }\n\n    function updateFlag(flag: Visibility, on: boolean) {\n        initHUD();\n        if (on) infoState.visibilityFlag |= flag;\n        else infoState.visibilityFlag = ~(~infoState.visibilityFlag | flag);\n    }\n\n    /**\n     * Sets the color of the borders around the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setBorderColor(color: number) {\n        initHUD();\n        infoState.borderColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the background of the score, countdown, and life\n     * elements. Defaults to 1\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setBackgroundColor(color: number) {\n        initHUD();\n        infoState.bgColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the text used in the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setFontColor(color: number) {\n        initHUD();\n        infoState.fontColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Get the current color of the borders around the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function borderColor(): number {\n        initHUD();\n        return infoState.borderColor ? infoState.borderColor : 3;\n    }\n\n    /**\n     * Get the current color of the background of the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function backgroundColor(): number {\n        initHUD();\n        return infoState.bgColor ? infoState.bgColor : 1;\n    }\n\n    /**\n     * Get the current color of the text usded in the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function fontColor(): number {\n        initHUD();\n        return infoState.fontColor ? infoState.fontColor : 3;\n    }\n\n    function drawTimer(millis: number) {\n        if (millis < 0) millis = 0;\n        millis |= 0;\n\n        const font = image.font8;\n        const smallFont = image.font5;\n        const seconds = Math.idiv(millis, 1000);\n        const width = font.charWidth * 5 - 2;\n        let left = (screen.width >> 1) - (width >> 1) + 1;\n        let color1 = infoState.fontColor;\n        let color2 = infoState.bgColor;\n\n        if (seconds < 10 && (seconds & 1) && !screen.isMono) {\n            const temp = color1;\n            color1 = color2;\n            color2 = temp;\n        }\n\n        screen.fillRect(left - 3, 0, width + 6, font.charHeight + 3, infoState.borderColor)\n        screen.fillRect(left - 2, 0, width + 4, font.charHeight + 2, color2)\n\n\n        if (seconds < 60) {\n            const top = 1;\n            const remainder = Math.idiv(millis % 1000, 10);\n\n            screen.print(formatDecimal(seconds) + \".\", left, top, color1, font)\n            const decimalLeft = left + 3 * font.charWidth;\n            screen.print(formatDecimal(remainder), decimalLeft, top + 2, color1, smallFont)\n        }\n        else {\n            const minutes = Math.idiv(seconds, 60);\n            const remainder = seconds % 60;\n            screen.print(formatDecimal(minutes) + \":\" + formatDecimal(remainder), left, 1, color1, font);\n        }\n    }\n\n    //% fixedInstances\n    //% blockGap=8\n    export class PlayerInfo {\n        protected _player: number;\n        public bg: number; // background color\n        public border: number; // border color\n        public fc: number; // font color\n        public showScore?: boolean;\n        public showLife?: boolean;\n        public visilibity: Visibility;\n        public showPlayer?: boolean;\n        public x?: number;\n        public y?: number;\n        public left?: boolean; // if true banner goes from x to the left, else goes rightward\n        public up?: boolean; // if true banner goes from y up, else goes downward\n\n        constructor(player: number) {\n            this._player = player;\n            this.border = 1;\n            this.fc = 1;\n            this.visilibity = Visibility.None;\n            this.showScore = undefined;\n            this.showLife = undefined;\n            this.showPlayer = undefined;\n            this.left = undefined;\n            this.up = undefined;\n            if (this._player === 1) {\n                // Top left, and banner is white on red\n                this.bg = screen.isMono ? 0 : 2;\n                this.x = 0;\n                this.y = 0;\n            } else if (player === 2) {\n                // Top right, and banner is white on blue\n                this.bg = screen.isMono ? 0 : 8;\n                this.x = screen.width;\n                this.y = 0;\n                this.left = true;\n            } else if (player === 3) {\n                this.bg = screen.isMono ? 0 : 4;\n                this.x = 0;\n                this.y = screen.height;\n                this.up = true;\n            } else {\n                // bottom left, banner is white on green\n                this.bg = screen.isMono ? 0 : 7;\n                this.x = screen.width;\n                this.y = screen.height;\n                this.left = true;\n                this.up = true;\n            }\n\n            if (!players) players = [];\n            players[this._player - 1] = this;\n        }\n\n        private init() {\n            initHUD();\n            if (this._player > 1) initMultiHUD();\n            if (!infoState.playerStates[this._player - 1]) {\n                infoState.playerStates[this._player - 1] = new PlayerState();\n            }\n        }\n\n        getState(): PlayerState {\n            this.init();\n            return infoState.playerStates[this._player - 1];\n        }\n\n        // the id numbera of the player\n        id(): number {\n            return this._player;\n        }\n\n        /**\n         * Get the player score\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=piscore block=\"%player score\"\n        //% help=info/score\n        score(): number {\n            if (this.showScore === undefined) this.showScore = true;\n            if (this.showPlayer === undefined) this.showPlayer = true;\n\n            const state = this.getState();\n\n            if (state.score == null)\n                state.score = 0;\n            return state.score;\n        }\n\n        /**\n         * Set the player score\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pisetscore block=\"set %player score to %value\"\n        //% value.defl=0\n        //% help=info/set-score\n        setScore(value: number) {\n            const state = this.getState();\n            updateFlag(Visibility.Score, true);\n\n            this.score(); // invoked for side effects\n            state.score = (value | 0);\n        }\n\n        /**\n         * Change the score of a player\n         * @param value \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pichangescore block=\"change %player score by %value\"\n        //% value.defl=1\n        //% help=info/change-score-by\n        changeScoreBy(value: number): void {\n            this.setScore(this.score() + value);\n        }\n\n        hasScore() {\n            const state = this.getState();\n            return state.score !== undefined;\n        }\n\n        /**\n         * Get the player life\n         */\n        //% group=\"Multiplayer\"\n        //% blockid=piflife block=\"%player life\"\n        //% help=info/life\n        life(): number {\n            const state = this.getState();\n            if (this.showLife === undefined) this.showLife = true;\n            if (this.showPlayer === undefined) this.showPlayer = true;\n\n            if (state.life === undefined) {\n                state.life = 3;\n            }\n            return state.life || 0;\n        }\n\n        /**\n         * Set the player life\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pisetlife block=\"set %player life to %value\"\n        //% value.defl=3\n        //% help=info/set-life\n        setLife(value: number): void {\n            const state = this.getState();\n            updateFlag(Visibility.Life, true);\n\n            this.life(); // invoked for side effects\n            state.life = (value | 0);\n        }\n\n        /**\n         * Change the life of a player\n         * @param value \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pichangelife block=\"change %player life by %value\"\n        //% value.defl=-1\n        //% help=info/change-life-by\n        changeLifeBy(value: number): void {\n            this.setLife(this.life() + value);\n        }\n\n        /**\n         * Return true if the given player currently has a value set for health,\n         * and false otherwise.\n         * @param player player to check life of\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pihaslife block=\"%player has life\"\n        //% help=info/has-life\n        hasLife(): boolean {\n            const state = this.getState();\n            return state.life !== undefined && state.life !== null;\n        }\n\n        /**\n         * Runs code when life reaches zero\n         * @param handler \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=playerinfoonlifezero block=\"on %player life zero\"\n        //% help=info/on-life-zero\n        onLifeZero(handler: () => void) {\n            const state = this.getState();\n            state.lifeZeroHandler = handler;\n        }\n\n        raiseLifeZero(gameOver: boolean) {\n            const state = this.getState();\n            if (state.life !== null && state.life <= 0) {\n                state.life = null;\n                if (state.lifeZeroHandler) {\n                    state.lifeZeroHandler();\n                } else if (gameOver) {\n                    game.over();\n                }\n            }\n        }\n\n        drawPlayer() {\n            const state = this.getState();\n\n            const font = image.font5;\n            let score: string;\n            let life: string;\n            let height = 4;\n            let scoreWidth = 0;\n            let lifeWidth = 0;\n            const offsetX = 1;\n            let offsetY = 2;\n            let showScore = this.showScore && state.score !== undefined;\n            let showLife = this.showLife && state.life !== undefined;\n\n            if (showScore) {\n                score = \"\" + state.score;\n                scoreWidth = score.length * font.charWidth + 3;\n                height += font.charHeight;\n                offsetY += font.charHeight + 1;\n            }\n\n            if (showLife) {\n                life = \"\" + (state.life || 0);\n                lifeWidth = infoState.heartImage.width + infoState.multiplierImage.width + life.length * font.charWidth + 3;\n                height += infoState.heartImage.height;\n            }\n\n            const width = Math.max(scoreWidth, lifeWidth);\n\n            // bump size for space between lines\n            if (showScore && showLife) height++;\n\n            const x = this.x - (this.left ? width : 0);\n            const y = this.y - (this.up ? height : 0);\n\n            // Bordered Box\n            if (showScore || showLife) {\n                screen.fillRect(x, y, width, height, this.border);\n                screen.fillRect(x + 1, y + 1, width - 2, height - 2, this.bg);\n            }\n\n            // print score\n            if (showScore) {\n                const bump = this.left ? width - scoreWidth : 0;\n                screen.print(score, x + offsetX + bump + 1, y + 2, this.fc, font);\n            }\n\n            // print life\n            if (showLife) {\n                const xLoc = x + offsetX + (this.left ? width - lifeWidth : 0);\n\n                let mult = infoState.multiplierImage.clone();\n                mult.replace(1, this.fc);\n\n                screen.drawTransparentImage(\n                    infoState.heartImage,\n                    xLoc,\n                    y + offsetY\n                );\n                screen.drawTransparentImage(\n                    mult,\n                    xLoc + infoState.heartImage.width,\n                    y + offsetY + font.charHeight - infoState.multiplierImage.height - 1\n                );\n                screen.print(\n                    life,\n                    xLoc + infoState.heartImage.width + infoState.multiplierImage.width + 1,\n                    y + offsetY,\n                    this.fc,\n                    font\n                );\n            }\n\n            // print player icon\n            if (this.showPlayer) {\n                const pNum = \"\" + this._player;\n\n                let iconWidth = pNum.length * font.charWidth + 1;\n                const iconHeight = Math.max(height, font.charHeight + 2);\n                let iconX = this.left ? (x - iconWidth + 1) : (x + width - 1);\n                let iconY = y;\n\n                // adjustments when only player icon shown\n                if (!showScore && !showLife) {\n                    iconX += this.left ? -1 : 1;\n                    if (this.up) iconY -= 3;\n                }\n\n                screen.fillRect(\n                    iconX,\n                    iconY,\n                    iconWidth,\n                    iconHeight,\n                    this.border\n                );\n                screen.print(\n                    pNum,\n                    iconX + 1,\n                    iconY + (iconHeight >> 1) - (font.charHeight >> 1),\n                    this.bg,\n                    font\n                );\n            }\n        }\n\n        drawScore() {\n            const s = this.score() | 0;\n\n            let font: image.Font;\n            let offsetY: number;\n            if (s >= 1000000) {\n                offsetY = 2;\n                font = image.font5;\n            }\n            else {\n                offsetY = 1;\n                font = image.font8;\n            }\n\n            const num = s.toString();\n            const width = num.length * font.charWidth;\n\n            screen.fillRect(\n                screen.width - width - 2,\n                0,\n                screen.width,\n                image.font8.charHeight + 3,\n                infoState.borderColor\n            );\n            screen.fillRect(\n                screen.width - width - 1,\n                0,\n                screen.width,\n                image.font8.charHeight + 2,\n                infoState.bgColor\n            );\n            screen.print(\n                num,\n                screen.width - width,\n                offsetY,\n                infoState.fontColor,\n                font\n            );\n        }\n\n        drawLives() {\n            const state = this.getState();\n            if (state.life < 0) return;\n            const font = image.font8;\n            if (state.life <= 4) {\n                screen.fillRect(\n                    0,\n                    0,\n                    state.life * (infoState.heartImage.width + 1) + 3,\n                    infoState.heartImage.height + 4,\n                    infoState.borderColor\n                );\n                screen.fillRect(\n                    0,\n                    0,\n                    state.life * (infoState.heartImage.width + 1) + 2,\n                    infoState.heartImage.height + 3,\n                    infoState.bgColor\n                );\n                for (let i = 0; i < state.life; i++) {\n                    screen.drawTransparentImage(\n                        infoState.heartImage,\n                        1 + i * (infoState.heartImage.width + 1),\n                        1\n                    );\n                }\n            }\n            else {\n                const num = state.life + \"\";\n                const textWidth = num.length * font.charWidth - 1;\n                screen.fillRect(\n                    0,\n                    0,\n                    infoState.heartImage.width + infoState.multiplierImage.width + textWidth + 5,\n                    infoState.heartImage.height + 4,\n                    infoState.borderColor\n                );\n                screen.fillRect(\n                    0,\n                    0,\n                    infoState.heartImage.width + infoState.multiplierImage.width + textWidth + 4,\n                    infoState.heartImage.height + 3,\n                    infoState.bgColor\n                );\n                screen.drawTransparentImage(\n                    infoState.heartImage,\n                    1,\n                    1\n                );\n\n                let mult = infoState.multiplierImage.clone();\n                mult.replace(1, infoState.fontColor);\n\n                screen.drawTransparentImage(\n                    mult,\n                    infoState.heartImage.width + 2,\n                    font.charHeight - infoState.multiplierImage.height - 1\n                );\n                screen.print(\n                    num,\n                    infoState.heartImage.width + 3 + infoState.multiplierImage.width,\n                    1,\n                    infoState.fontColor,\n                    font\n                );\n            }\n        }\n    }\n\n    function formatDecimal(val: number) {\n        val |= 0;\n        if (val < 10) {\n            return \"0\" + val;\n        }\n        return val.toString();\n    }\n\n    //% fixedInstance whenUsed block=\"player 2\"\n    export const player2 = new PlayerInfo(2);\n    //% fixedInstance whenUsed block=\"player 3\"\n    export const player3 = new PlayerInfo(3);\n    //% fixedInstance whenUsed block=\"player 4\"\n    export const player4 = new PlayerInfo(4);\n    //% fixedInstance whenUsed block=\"player 1\"\n    export const player1 = new PlayerInfo(1);\n}\n",
            "mathUtil.ts": "namespace Math {\n    /**\n     * Returns a random boolean that is true the given percentage of the time.\n     * @param percentage The percentage chance that the returned value will be true from 0 - 100\n     */\n    //% weight=2\n    //% blockId=percentchance block=\"%percentage|\\\\% chance\"\n    //% percentage.min=0 percentage.max=100;\n    export function percentChance(percentage: number): boolean {\n        if (percentage >= 100) {\n            return true;\n        }\n        else if (percentage <= 0) {\n            return false;\n        }\n        return Math.randomRange(0, 99) < percentage;\n    }\n\n    /**\n     * Returns a random element from the given list\n     * @param list The list to choose an element from\n     */\n    //% weight=1\n    export function pickRandom<T>(list: T[]) {\n        if (!list || list.length == 0) {\n            return undefined;\n        }\n        return list[Math.randomRange(0, list.length - 1)];\n    }\n\n    /**\n     * Fast, 16 bit, seedable (pseudo) random generator.\n     */\n    export class FastRandom {\n        // Implementation of the Galois Linear Feedback Shift Register\n        private lfsr: number;\n        // A value between 0x0001 and 0xFFFF to generate random values from\n        public seed: number;\n\n        /**\n         * Create a new Fast Random generator\n         * @param seed [Optional] initial seed between 0x0001 and 0xFFFF.\n         */\n        constructor(seed?: number) {\n            if (seed === undefined) seed = Math.randomRange(0x0001, 0xFFFF);\n            this.seed = seed;\n            this.lfsr = seed;\n        }\n\n        /**\n         * @returns the next random number between 0x0001 and 0xFFFF inclusive\n         */\n        next(): number {\n            return this.lfsr = (this.lfsr >> 1) ^ ((-(this.lfsr & 1)) & 0xb400);\n        }\n\n        /**\n         * @param min the minimum value to generate\n         * @param max the maximum value to generate\n         * @returns a random value between min and max (inclusive). If min is greater than or equal to max, returns min.\n         */\n        randomRange(min: number, max: number): number {\n            return min + (max > min ? this.next() % (max - min + 1) : 0);\n        }\n\n        /**\n         * Returns a random element from the given list\n         * @param list The list to choose an element from\n         */\n        pickRandom<T>(list: T[]) {\n            if (!list || list.length == 0) {\n                return undefined;\n            }\n            return list[this.randomRange(0, list.length - 1)];\n        }\n\n        /**\n         * @returns a random boolean value\n         */\n        randomBool(): boolean {\n            return !(this.next() & 1);\n        }\n\n        /**\n         * @param percent the percentage chance that the returned value will be true from 0 - 100\n         * @returns a boolean with approximately the given percent chance to be true or false\n         */\n        percentChance(percent: number): boolean {\n            return this.randomRange(0, 100) < percent;\n        }\n\n        /**\n         * Reset the state to the current seed\n         */\n        reset() {\n            this.lfsr = this.seed;\n        }\n    }\n}\n",
            "metrics.ts": "namespace performance {\n\n}",
            "numberprompt.ts": "namespace game {\n\n    /**\n     * Ask the player for a number value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of digits the user can enter (1 - 10)\n     */\n    //% group=\"Gameplay\"\n    //% weight=10 help=game/ask-for-number\n    //% blockId=gameaskfornumber block=\"ask for number %message || and max length %answerLength\"\n    //% message.defl=\"\"\n    //% answerLength.defl=\"6\"\n    //% answerLength.min=1\n    //% answerLength.max=10\n    //% group=\"Prompt\"\n    export function askForNumber(message: string, answerLength = 6) {\n        answerLength = Math.max(0, Math.min(10, answerLength));\n        let p = new game.NumberPrompt();\n        const result = p.show(message, answerLength);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8;\n    //% whenUsed=true\n    const PADDING_HORIZONTAL = 40;\n    //% whenUsed=true\n    const PADDING_VERTICAL = 4;\n    //% whenUsed=true\n    const PROMPT_LINE_SPACING = 2;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 12;\n    //% whenUsed=true\n    const NUMPAD_ROW_LENGTH = 3;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / NUMPAD_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 1;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING_HORIZONTAL * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING_VERTICAL * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING_VERTICAL;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_HEIGHT = Math.floor(CONTENT_HEIGHT / (NUM_ROWS + 4));\n    //% whenUsed=true\n    const CELL_WIDTH = CELL_HEIGHT//Math.floor(CONTENT_WIDTH / NUMPAD_ROW_LENGTH);\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING_HORIZONTAL + CELL_WIDTH / 2 + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * NUMPAD_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_NUMPAD_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING_VERTICAL + BOTTOM_BAR_NUMPAD_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_TOP = screen.height - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING_HORIZONTAL * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n\n    // Dimensions of the numpad area\n    //% whenUsed=true\n    const NUMPAD_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const NUMPAD_TOP = screen.height - NUMPAD_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const NUMPAD_INPUT_MARGIN = 4;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = NUMPAD_TOP - INPUT_HEIGHT - NUMPAD_INPUT_MARGIN;\n\n    // Pixels kept blank on left and right sides of prompt\n    //% whenUsed=true\n    const PROMPT_MARGIN_HORIZ = 3;\n\n    // Dimensions of prompt message area\n    //% whenUsed=true\n    const PROMPT_HEIGHT = INPUT_TOP - CONTENT_TOP;\n    //% whenUsed=true\n    const PROMPT_WIDTH = screen.width - PROMPT_MARGIN_HORIZ * 2\n\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class NumberPrompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        private cursor: Sprite;\n        private confirmButton: Sprite;\n\n        private numbers: Sprite[];\n        private inputs: Sprite[];\n\n        private confirmPressed: boolean;\n        private cursorRow: number;\n        private cursorColumn: number;\n        private hasDecimal: boolean;\n        private inputIndex: number;\n        private blink: boolean;\n        private frameCount: number;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.hasDecimal = false;\n            this.inputIndex = 0;\n        }\n\n        show(message: string, answerLength: number) : number {\n            this.message = message;\n            this.answerLength = answerLength;\n            this.inputIndex = 0;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.draw();\n            this.registerHandlers();\n            this.confirmPressed = false;\n\n            pauseUntil(() => this.confirmPressed);\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return parseFloat(this.result);\n        }\n\n        private draw() {\n            this.drawPromptText();\n            this.drawNumpad();\n            this.drawInputarea();\n            this.drawBottomBar();\n        }\n\n        private drawPromptText() {\n            const prompt = sprites.create(layoutText(this.message, PROMPT_WIDTH, PROMPT_HEIGHT, this.theme.colorPrompt), -1);\n            prompt.x = screen.width / 2\n            prompt.y = CONTENT_TOP + Math.floor((PROMPT_HEIGHT - prompt.height) / 2) + Math.floor(prompt.height / 2);\n        }\n\n        private drawInputarea() {\n            const answerLeft = (screen.width - this.answerLength * CELL_WIDTH) / 2\n\n            this.inputs = [];\n            for (let i = 0; i < this.answerLength; i++) {\n                const blank = image.create(CELL_WIDTH, CELL_HEIGHT);\n                this.drawInput(blank, \"\", this.theme.colorInput);\n\n                const s = sprites.create(blank, -1);\n                s.left = answerLeft + i * CELL_WIDTH;\n                s.y = INPUT_TOP;\n                this.inputs.push(s);\n            }\n        }\n\n        private drawNumpad() {\n            const cursorImage = image.create(CELL_WIDTH, CELL_HEIGHT);\n            cursorImage.fill(this.theme.colorCursor);\n            this.cursor = sprites.create(cursorImage, -1);\n            this.cursor.z = -1;\n            this.updateCursor();\n\n            this.numbers = [];\n            for (let j = 0; j < NUM_LETTERS; j++) {\n                const letter = image.create(CELL_WIDTH, CELL_HEIGHT);\n\n                const col2 = j % NUMPAD_ROW_LENGTH;\n                const row2 = Math.floor(j / NUMPAD_ROW_LENGTH);\n\n                const t = sprites.create(letter, -1);\n                t.x = ROW_LEFT + col2 * CELL_WIDTH;\n                t.y = NUMPAD_TOP + row2 * CELL_HEIGHT;\n\n                this.numbers.push(t);\n            }\n            this.updateKeyboard();\n        }\n\n        private drawBottomBar() {\n            const bg = image.create(screen.width, BOTTOM_BAR_HEIGHT);\n            bg.fill(this.theme.colorBottomBackground);\n\n            const bgSprite = sprites.create(bg, -1);\n            bgSprite.x = screen.width / 2;\n            bgSprite.y = BOTTOM_BAR_TOP + BOTTOM_BAR_HEIGHT / 2;\n            bgSprite.z = -1;\n\n            this.confirmButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.confirmButton.right = screen.width;\n            this.confirmButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.updateButtons();\n        }\n\n        private updateButtons() {\n            if (this.cursorRow === 4) {\n                this.confirmButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.confirmButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            this.confirmButton.image.print(confirmText, BOTTOM_BAR_CONFIRM_X, BOTTOM_BAR_TEXT_Y);\n        }\n\n        private updateCursor() {\n            if (this.cursorRow === 4) {\n                this.cursor.image.fill(0);\n                this.updateButtons();\n            }\n            else {\n                this.cursor.x = ROW_LEFT + this.cursorColumn * CELL_WIDTH;\n                this.cursor.y = NUMPAD_TOP + this.cursorRow * CELL_HEIGHT;\n            }\n        }\n\n        private updateSelectedInput() {\n            if (this.inputIndex < this.answerLength) {\n                const u = this.inputs[this.inputIndex];\n                if (this.blink) {\n                    this.drawInput(u.image, \"\", this.theme.colorInput);\n                }\n                else {\n                    this.drawInput(u.image, \"\", this.theme.colorInputHighlighted)\n                }\n            }\n        }\n\n        private updateKeyboard() {\n            const len = this.numbers.length;\n            for (let k = 0; k < len; k++) {\n                const img = this.numbers[k].image;\n                img.fill(0);\n                img.print(getSymbolFromIndex(k), LETTER_OFFSET_X, LETTER_OFFSET_Y);\n            }\n        }\n\n        private drawInput(img: Image, char: string, color: number) {\n            img.fill(0);\n            img.fillRect(BLANK_PADDING, CELL_HEIGHT - 1, CELL_WIDTH - BLANK_PADDING * 2, 1, color)\n\n            if (char) {\n                img.print(char, LETTER_OFFSET_X, LETTER_OFFSET_Y, this.theme.colorInputText, font);\n            }\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n\n\n            this.frameCount = 0;\n            this.blink = true;\n\n            game.onUpdate(() => {\n                this.frameCount = (this.frameCount + 1) % 30;\n\n                if (this.frameCount === 0) {\n                    this.blink = !this.blink;\n\n                    this.updateSelectedInput();\n                }\n            })\n        }\n\n        private moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === 4) {\n                    this.cursor.image.fill(this.theme.colorCursor);\n                    this.cursorRow = 3;\n\n                    this.updateButtons();\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(4, this.cursorRow + 1);\n            }\n\n            this.updateCursor();\n        }\n\n        private moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % NUMPAD_ROW_LENGTH;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (NUMPAD_ROW_LENGTH - 1)) % NUMPAD_ROW_LENGTH;\n            }\n\n            this.updateCursor();\n        }\n\n        private confirm() {\n            if (this.cursorRow === 4) {\n                this.confirmPressed = true;\n            } else {\n                if (this.inputIndex >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * NUMPAD_ROW_LENGTH\n                const letter = getSymbolFromIndex(index);\n\n                if (letter === \".\") {\n                    if(this.hasDecimal) {\n                        return;\n                    } else {\n                        this.hasDecimal = true;\n                    }\n                }\n\n                if (letter === \"-\" && (this.result && this.result.length > 0)) {\n                    return;\n                }\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                const sprite = this.inputs[this.inputIndex];\n                this.changeInputIndex(1);\n                this.drawInput(sprite.image, letter, this.theme.colorInput);\n            }\n        }\n\n        private delete() {\n            if (this.inputIndex <= 0) return;\n\n            if (this.inputIndex < this.answerLength) {\n                this.drawInput(this.inputs[this.inputIndex].image, \"\", this.theme.colorInput);\n            }\n\n            if (this.result.charAt(this.result.length - 1) === \".\") {\n                this.hasDecimal = false;\n            }\n\n            this.result = this.result.substr(0, this.result.length - 1);\n\n            this.changeInputIndex(-1);\n        }\n\n        private changeInputIndex(delta: number) {\n            this.inputIndex += delta;\n            this.frameCount = 0\n            this.blink = false;\n            this.updateSelectedInput();\n        }\n    }\n\n    function layoutText(message: string, width: number, height: number, color: number) {\n        const lineHeight = font.charHeight + PROMPT_LINE_SPACING;\n\n        const lineLength = Math.floor(width / font.charWidth);\n        const numLines = Math.floor(height / lineHeight);\n\n        let lines: string[] = [];\n        let word: string;\n        let line: string;\n\n        let pushWord = () => {\n            if (line) {\n                if (line.length + word.length + 1 > lineLength) {\n                    lines.push(line);\n                    line = word;\n                }\n                else {\n                    line = line + \" \" + word;\n                }\n            }\n            else {\n                line = word;\n            }\n\n            word = null;\n        }\n\n        for (let l = 0; l < message.length; l++) {\n            const char = message.charAt(l);\n\n            if (char === \" \") {\n                if (word) {\n                    pushWord();\n                }\n                else {\n                    word = \" \";\n                }\n            }\n            else if (!word) {\n                word = char;\n            }\n            else {\n                word += char;\n            }\n        }\n\n        if (word) {\n            pushWord();\n        }\n\n        if (line) {\n            lines.push(line);\n        }\n\n        let maxLineWidth = 0;\n        for (let m = 0; m < lines.length; m++) {\n            maxLineWidth = Math.max(maxLineWidth, lines[m].length);\n        }\n\n        const actualWidth = maxLineWidth * font.charWidth;\n        const actualHeight = lines.length * lineHeight;\n\n        const res = image.create(actualWidth, actualHeight);\n\n        for (let n = 0; n < lines.length; n++) {\n            if ((n + 1) > numLines) break;\n            res.print(lines[n], 0, n * lineHeight, color, font);\n        }\n\n        return res;\n    }\n\n    function getSymbolFromIndex(index: number) {\n        if (index < 9) {\n            // Calculator Layout\n            return \"\" + (3 * Math.idiv(9 - index - 1, 3) + index % 3 + 1);\n        } else if (index == 9) {\n            return \"-\";\n        } else if (index == 10) {\n            return \"0\";\n        } else if (index == 11) {\n            return \".\";\n        } else {\n            return \"\";\n        }\n    }\n\n}",
            "obstacle.ts": "namespace sprites {\n    enum ObstacleFlags {\n        Moved = 1 << 4,\n        Dead = 1 << 5\n    }\n\n    export interface Obstacle {\n        x: number;\n        y: number;\n        left: number;\n        right: number;\n        top: number;\n        bottom: number;\n        width: number;\n        height: number;\n        layer: number;\n        image: Image;\n        tileIndex: number;\n    }\n\n    export class StaticObstacle implements Obstacle {\n        layer: number;\n        image: Image;\n        tileIndex: number;\n\n        top: number;\n        left: number;\n\n        constructor(image: Image, top: number, left: number, layer: number, tileIndex?: number) {\n            this.image = image;\n            this.layer = layer;\n            this.top = top;\n            this.left = left;\n            this.tileIndex = tileIndex;\n        }\n\n        get x(): number {\n            return this.left + this.width >> 1;\n        }\n\n        get y(): number {\n            return this.top + this.height >> 1;\n        }\n\n        get height(): number {\n            return this.image.height;\n        }\n\n        get width(): number {\n            return this.image.width;\n        }\n\n        get bottom(): number {\n            return this.top + this.height;\n        }\n\n        get right(): number {\n            return this.left + this.width;\n        }\n    }\n}",
            "particleeffects.ts": "namespace effects {\n\n    //% fixedInstances\n    export interface BackgroundEffect {\n        startScreenEffect(): void;\n    }\n\n    //% fixedInstances\n    export class ParticleEffect {\n        protected sourceFactory: (anchor: particles.ParticleAnchor, pps: number) => particles.ParticleSource;\n        protected defaultRate: number;\n        protected defaultLifespan: number;\n\n        constructor(defaultParticlesPerSecond: number, defaultLifespan: number,\n                sourceFactory: (anchor: particles.ParticleAnchor, particlesPerSecond: number) => particles.ParticleSource) {\n            this.sourceFactory = sourceFactory;\n            this.defaultRate = defaultParticlesPerSecond;\n            this.defaultLifespan = defaultLifespan;\n        }\n\n        /**\n         * Attaches a new particle animation to the sprite or anchor for a short period of time\n         * @param anchor\n         * @param duration\n         * @param particlesPerSecond \n         */\n        start(anchor: particles.ParticleAnchor, duration?: number, particlesPerSecond?: number): void {\n            if (!this.sourceFactory) return;\n            const src = this.sourceFactory(anchor, particlesPerSecond ? particlesPerSecond : this.defaultRate);\n            if (duration)\n                src.lifespan = duration > 0 ? duration : this.defaultLifespan;\n        }\n\n        /**\n         * Destroy the provided sprite with an effect\n         * @param sprite\n         * @param duration how long the sprite will remain on the screen. If set to 0 or undefined,\n         *                  uses the default rate for this effect.\n         * @param particlesPerSecond\n         */\n        destroy(anchor: Sprite, duration?: number, particlesPerSecond?: number) {\n            anchor.setFlag(SpriteFlag.Ghost, true);\n            this.start(anchor, particlesPerSecond);\n            anchor.lifespan = duration ? duration : this.defaultLifespan >> 2;\n            effects.dissolve.applyTo(anchor);\n        }\n    }\n\n    /**\n     * Anchor used for effects that occur across the screen.\n     */\n    class SceneAnchor implements particles.ParticleAnchor {\n        private camera: scene.Camera;\n\n        constructor() {\n            this.camera = game.currentScene().camera;\n        }\n\n        get x() {\n            return this.camera.offsetX + (screen.width >> 1);\n        }\n\n        get y() {\n            return this.camera.offsetY + (screen.height >> 1);\n        }\n\n        get width() {\n            return screen.width;\n        }\n\n        get height() {\n            return screen.height;\n        }\n    }\n\n    //% fixedInstances\n    export class ScreenEffect extends ParticleEffect implements BackgroundEffect {\n        protected source: particles.ParticleSource;\n        protected sceneDefaultRate: number;\n\n        constructor(anchorDefault: number, sceneDefault: number, defaultLifespan: number,\n                sourceFactory: (anchor: particles.ParticleAnchor, particlesPerSecond: number) => particles.ParticleSource) {\n            super(anchorDefault, defaultLifespan, sourceFactory);\n            this.sceneDefaultRate = sceneDefault;\n        }\n\n        /**\n         * Creates a new effect that occurs over the entire screen\n         * @param particlesPerSecond \n         * @param duration\n         */\n        //% blockId=particlesStartScreenAnimation block=\"start screen %effect effect || for %duration ms\"\n        //% duration.shadow=timePicker\n        //% blockNamespace=scene\n        //% group=\"Effects\" blockGap=8\n        //% weight=90 help=effects/start-screen-effect\n        startScreenEffect(duration?: number, particlesPerSecond?: number): void {\n            if (!this.sourceFactory)\n                return;\n\n            if (this.source && this.source.enabled) {\n                if (duration)\n                    this.source.lifespan = duration;\n                return;\n            }\n\n            this.endScreenEffect();\n            this.source = this.sourceFactory(new SceneAnchor(), particlesPerSecond ? particlesPerSecond : this.sceneDefaultRate);\n            this.source.priority = 10;\n            if (duration)\n                this.source.lifespan = duration;\n        }\n\n        /**\n         * If this effect is currently occurring as a full screen effect, stop producing particles and end the effect\n         * @param particlesPerSecond \n         */\n        //% blockId=particlesEndScreenAnimation block=\"end screen %effect effect\"\n        //% blockNamespace=scene\n        //% group=\"Effects\" blockGap=8\n        //% weight=80 help=effects/end-screen-effect\n        endScreenEffect(): void {\n            if (this.source) {\n                this.source.destroy();\n                this.source = undefined;\n            }\n        }\n    }\n\n    /**\n     * Removes all effects at anchor's location\n     * @param anchor the anchor to remove effects from\n     */\n    //% blockId=particlesclearparticles block=\"clear effects on %anchor=variables_get(mySprite)\"\n    //% blockNamespace=sprites\n    //% group=\"Effects\" weight=89\n    //% help=effects/clear-particles\n    export function clearParticles(anchor: particles.ParticleAnchor) {\n        const sources = game.currentScene().particleSources;\n        if (!sources) return;\n        sources\n            .filter(ps => ps.anchor == anchor || ps.anchor.x == anchor.x && ps.anchor.y == anchor.y)\n            .forEach(ps => ps.destroy());\n    }\n\n    function createEffect(defaultParticlesPerSecond: number, defaultLifespan: number,\n            factoryFactory: (anchor?: particles.ParticleAnchor) => particles.ParticleFactory): ParticleEffect {\n        return new ParticleEffect(defaultParticlesPerSecond, defaultLifespan,\n                    (anchor: particles.ParticleAnchor, pps: number) =>\n                        new particles.ParticleSource(anchor, pps, factoryFactory()));\n    }\n\n    //% fixedInstance whenUsed block=\"spray\"\n    export const spray = createEffect(20, 2000, function () { return new particles.SprayFactory(100, 0, 120) });\n\n    //% fixedInstance whenUsed block=\"trail\"\n    export const trail = new ParticleEffect(20, 4000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.TrailFactory(anchor, 250, 1000);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"fountain\"\n    export const fountain = new ParticleEffect(20, 3000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        class FountainFactory extends particles.SprayFactory {\n            galois: Math.FastRandom;\n    \n            constructor() {\n                super(40, 180, 90);\n                this.galois = new Math.FastRandom(1234);\n            }\n    \n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.color = this.galois.randomBool() ? 8 : 9;\n                p.lifespan = 1500;\n                return p;\n            }\n    \n            drawParticle(p: particles.Particle, x: Fx8, y: Fx8) {\n                screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n            }\n        }\n\n        const factory = new FountainFactory();\n        const source = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        source.setAcceleration(0, 40);\n        return source;\n    });\n\n    //% fixedInstance whenUsed block=\"confetti\"\n    export const confetti = new ScreenEffect(10, 40, 4000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ConfettiFactory(anchor.width ? anchor.width : 16, 16);\n        factory.setSpeed(30);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"hearts\"\n    export const hearts = new ScreenEffect(5, 20, 2000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ShapeFactory(anchor.width ? anchor.width : 16, 16, img`\n            . F . F .\n            F . F . F\n            F . . . F\n            . F . F .\n            . . F . .\n        `);\n\n        // if large anchor, increase lifespan\n        if (factory.xRange > 50) {\n            factory.minLifespan = 1000;\n            factory.maxLifespan = 2000;\n        }\n\n        factory.setSpeed(90);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"smiles\"\n    export const smiles = new ScreenEffect(5, 25, 1500, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ShapeFactory(anchor.width ? anchor.width : 16, 16, img`\n            . f . f . \n            . f . f . \n            . . . . . \n            f . . . f \n            . f f f . \n        `);\n        // if large anchor, increase lifespan\n        if (factory.xRange > 50) {\n            factory.minLifespan = 1250;\n            factory.maxLifespan = 2500;\n        }\n\n        factory.setSpeed(50);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"rings\"\n    export const rings = createEffect(5, 1000, function () {\n        return new particles.ShapeFactory(16, 16, img`\n            . F F F . \n            F . . . F \n            F . . . F \n            f . . . f \n            . f f f . \n        `);\n    });\n\n    //% fixedInstance whenUsed block=\"fire\"\n    export const fire = new ParticleEffect(50, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.FireFactory(5);\n        const src = new particles.FireSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, -20);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"warm radial\"\n    export const warmRadial = createEffect(30, 2500, function () { return new particles.RadialFactory(0, 30, 10) });\n\n    //% fixedInstance whenUsed block=\"cool radial\"\n    export const coolRadial = createEffect(30, 2000, function () { return new particles.RadialFactory(0, 30, 10, [0x6, 0x7, 0x8, 0x9, 0xA]) });\n\n    //% fixedInstance whenUsed block=\"halo\"\n    export const halo = createEffect(70, 3000, function () {\n        class RingFactory extends particles.RadialFactory {\n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.lifespan = this.galois.randomRange(200, 350);\n                return p;\n            }\n        }\n        return new RingFactory(30, 40, 10, [0x4, 0x4, 0x5]);\n    });\n\n    //% fixedInstance whenUsed block=\"ashes\"\n    export const ashes = new ParticleEffect(60, 2000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.AshFactory(anchor);\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, 500);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"disintegrate\"\n    export const disintegrate = new ParticleEffect(60, 1250, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.AshFactory(anchor, true, 30);\n        factory.minLifespan = 200;\n        factory.maxLifespan = 500;\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, 750);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"blizzard\"\n    export const blizzard = new ScreenEffect(15, 50, 3000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        class SnowFactory extends particles.ShapeFactory {\n            constructor(xRange: number, yRange: number) {\n                super(xRange, yRange, img`F`);\n                this.addShape(img`\n                    F\n                    F`\n                );\n                this.minLifespan = 200;\n                this.maxLifespan = this.xRange > 50 ? 1200: 700;\n            }\n\n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.color = this.galois.percentChance(80) ? 0x1 : 0x9;\n                return p;\n            }\n        }\n\n        const factory = new SnowFactory(anchor.width ? anchor.width : 16, anchor.height ? anchor.height : 16);\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(-300, -100);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"bubbles\"\n    export const bubbles = new ScreenEffect(15, 40, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const min = anchor.width > 50 ? 2000 : 500;\n        const factory = new particles.BubbleFactory(anchor, min, min * 2.5);\n        return new particles.BubbleSource(anchor, particlesPerSecond, factory.stateCount - 1, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"star field\"\n    export const starField = new ScreenEffect(2, 5, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.StarFactory([0x1, 0x3, 0x5, 0x9, 0xC]);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"clouds\"\n    export const clouds = new ScreenEffect(.5, 1.5, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.CloudFactory();\n        const source = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n\n        // render behind tile map\n        source.z = -2;\n        return source;\n    });\n}",
            "particlefactories.ts": "namespace particles {\n    let cachedSin: Fx8[];\n    let cachedCos: Fx8[];\n\n    const NUM_SLICES = 100;\n    const galois = new Math.FastRandom();\n    let angleSlice = 2 * Math.PI / NUM_SLICES;\n\n    /**\n     * Initialize sin and cos values for each slice to minimize recomputation\n     */\n    function initTrig() {\n        if (!cachedSin) {\n            cachedSin = cacheSin(NUM_SLICES);\n            cachedCos = cacheCos(NUM_SLICES);\n        }\n    }\n\n    /**\n     * @param slices number of cached sin values to make\n     * @returns array of cached sin values between 0 and 360 degrees\n     */\n    export function cacheSin(slices: number): Fx8[] {\n        let sin: Fx8[] = [];\n        let anglePerSlice = 2 * Math.PI / slices;\n        for (let i = 0; i < slices; i++) {\n            sin.push(Fx8(Math.sin(i * anglePerSlice)));\n        }\n        return sin;\n    }\n\n    /**\n     * @param slices number of cached cos values to make\n     * @returns array of cached cos values between 0 and 360 degrees\n     */\n    export function cacheCos(slices: number): Fx8[] {\n        let cos: Fx8[] = [];\n        let anglePerSlice = 2 * Math.PI / slices;\n        for (let i = 0; i < slices; i++) {\n            cos.push(Fx8(Math.cos(i * anglePerSlice)));\n        }\n        return cos;\n    }\n\n    const ratio = Math.PI / 180;\n    function toRadians(degrees: number) {\n        if (degrees < 0)\n            degrees = 360 - (Math.abs(degrees) % 360);\n        else\n            degrees = degrees % 360;\n\n        return degrees * ratio;\n    }\n\n    /**\n     * A factory for generating particles\n     */\n    export class ParticleFactory {\n\n        constructor() {\n            // Compiler errors if this doesn't exist\n        }\n\n        /**\n         * Generate a particle at the position of the given anchor\n         * @param anchor \n         */\n        createParticle(anchor: ParticleAnchor): Particle {\n            const p = new Particle();\n\n            p._x = Fx8(anchor.x);\n            p._y = Fx8(anchor.y);\n            p.vx = Fx.zeroFx8;\n            p.vy = Fx.zeroFx8;\n            p.lifespan = 500;\n\n            return p;\n        }\n\n        /**\n         * Draw the given particle at the given location\n         * @param particle \n         * @param x \n         * @param y \n         */\n        drawParticle(particle: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), 1);\n        }\n    }\n\n    /**\n     * A factory for creating a spray of particles\n     */\n    export class SprayFactory extends ParticleFactory {\n        protected speed: Fx8;\n        protected minAngle: number;\n        protected spread: number;\n\n        constructor(speed: number, centerDegrees: number, arcDegrees: number) {\n            super();\n            initTrig();\n            this.setSpeed(speed);\n            this.setDirection(centerDegrees, arcDegrees);\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            const angle = (this.minAngle + galois.randomRange(0, this.spread)) % NUM_SLICES;\n            p.vx = Fx.mul(cachedSin[angle], this.speed);\n            p.vy = Fx.mul(cachedCos[angle], this.speed);\n\n            return p;\n        }\n\n        drawParticle(particle: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), 1);\n        }\n\n        setSpeed(pixelsPerSecond: number) {\n            this.speed = Fx8(pixelsPerSecond);\n        }\n\n        setDirection(centerDegrees: number, arcDegrees: number) {\n            this.minAngle = (toRadians(centerDegrees - (arcDegrees >> 1)) / angleSlice) | 0;\n            this.spread = (toRadians(arcDegrees) / angleSlice) | 0;\n        }\n    }\n\n    /**\n     * A factory for creating particles within rectangular area\n     */\n    export class AreaFactory extends SprayFactory {\n        xRange: number;\n        yRange: number;\n        minLifespan: number;\n        maxLifespan: number;\n        protected galois: Math.FastRandom;\n\n        constructor(xRange: number, yRange: number, minLifespan?: number, maxLifespan?: number) {\n            super(40, 0, 90);\n            this.xRange = xRange;\n            this.yRange = yRange;\n            this.minLifespan = minLifespan ? minLifespan : 150;\n            this.maxLifespan = maxLifespan ? maxLifespan : 850;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(0, this.yRange) - (anchor.height ? anchor.height >> 1 : 0), p._y);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const col = p.lifespan > 500 ?\n                4 : p.lifespan > 250 ?\n                    5 : 1;\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), col);\n        }\n    }\n\n    /**\n     * A factory for creating a trail that is emitted by sprites.\n     */\n    export class TrailFactory extends ParticleFactory {\n        minLifespan: number;\n        maxLifespan: number;\n        xRange: number;\n        yRange: number;\n        protected galois: Math.FastRandom;\n\n        constructor(sprite: ParticleAnchor, minLifespan: number, maxLifespan: number) {\n            super();\n            this.xRange = sprite.width ? sprite.width >> 1 : 8;\n            this.yRange = sprite.height ? sprite.height >> 1 : 8;\n            this.minLifespan = minLifespan;\n            this.maxLifespan = maxLifespan;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(0, this.yRange) - (this.yRange >> 1), p._y);\n            p.color = this.galois.randomRange(0x1, 0xF);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n        }\n    }\n\n    /**\n     * A factory for creating particles with the provided shapes fall down the screen.\n     * \n     * Any pixels assigned to 0xF (black) in the provided shape will be replaced with a\n     * random color for each particle.\n     */\n    export class ShapeFactory extends AreaFactory {\n        protected sources: Image[];\n        protected ox: Fx8;\n        protected oy: Fx8;\n\n        constructor(xRange: number, yRange: number, source: Image) {\n            super(xRange, yRange);\n            this.sources = [source];\n\n            // Base offsets off of initial shape\n            this.ox = Fx8(source.width >> 1);\n            this.oy = Fx8(source.height >> 1);\n        }\n\n        /**\n         * Add another possible shape for a particle to display as\n         * @param shape \n         */\n        addShape(shape: Image) {\n            if (shape) this.sources.push(shape);\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const pImage = this.galois.pickRandom(this.sources).clone();\n            pImage.replace(0xF, p.color);\n\n            screen.drawTransparentImage(pImage,\n                Fx.toInt(Fx.sub(x, this.ox)),\n                Fx.toInt(Fx.sub(y, this.oy))\n            );\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            p.color = this.galois.randomRange(1, 14);\n            return p;\n        }\n    }\n\n    export class ConfettiFactory extends ShapeFactory {\n        constructor(xRange: number, yRange: number) {\n            const confetti = [\n                img`\n                    F\n                `,\n                img`\n                    F\n                    F\n                `,\n                img`\n                    F F\n                `,\n                img`\n                    F F\n                    F .\n                `,\n                img`\n                    F F\n                    . F\n            `];\n            super(xRange, yRange, confetti[0]);\n            for (let i = 1; i < confetti.length; i++) {\n                this.addShape(confetti[i]);\n            }\n\n            this.minLifespan = 1000;\n            this.maxLifespan = 4500;\n        }\n    }\n\n    export class FireFactory extends ParticleFactory {\n        protected galois: Math.FastRandom;\n        protected minRadius: number;\n        protected maxRadius: number;\n    \n        constructor(radius: number) {\n            super();\n            initTrig();\n            this.galois = new Math.FastRandom();\n            this.minRadius = radius >> 1;\n            this.maxRadius = radius;\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            p.color = this.galois.randomBool() ?\n                2 : this.galois.randomBool() ?\n                    4 : 5;\n\n            const i = this.galois.randomRange(0, cachedCos.length);\n            const r = this.galois.randomRange(this.minRadius, this.maxRadius);\n\n            p._x = Fx.iadd(anchor.x, Fx.mul(Fx8(r), cachedCos[i]));\n            p._y = Fx.iadd(anchor.y, Fx.mul(Fx8(r), cachedSin[i]));\n            p.vy = Fx8(Math.randomRange(0, 10));\n            p.vx = Fx8(Math.randomRange(-5, 5));\n            p.lifespan = 1500;\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(\n                Fx.toInt(x),\n                Fx.toInt(y),\n                p.color\n            );\n        }\n    }\n\n    export class RadialFactory extends ParticleFactory {\n        protected r: Fx8;\n        protected speed: Fx8;\n        protected t: number;\n        protected spread: number;\n        protected galois: Math.FastRandom;\n        protected colors: number[];\n\n        constructor(radius: number, speed: number, spread: number, colors?: number[]) {\n            super();\n            initTrig();\n\n            if (colors && colors.length != 0)\n                this.colors = colors;\n            else\n                this.colors = [0x2, 0x3, 0x4, 0x5];\n\n            this.setRadius(radius)\n            this.speed = Fx8(-speed);\n            this.spread = spread;\n            this.t = 0;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const time = ++this.t % cachedCos.length;\n            const offsetTime = (time + this.galois.randomRange(0, this.spread)) % cachedCos.length;\n\n            p._x = Fx.iadd(anchor.x, Fx.mul(this.r, cachedCos[time]));\n            p._y = Fx.iadd(anchor.y, Fx.mul(this.r, cachedSin[time]));\n            p.vx = Fx.mul(this.speed, Fx.neg(cachedSin[offsetTime]));\n            p.vy = Fx.mul(this.speed, cachedCos[offsetTime]);\n\n            p.lifespan = this.galois.randomRange(200, 1500);\n            p.color = this.galois.pickRandom(this.colors);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(\n                Fx.toInt(x),\n                Fx.toInt(y),\n                p.color\n            );\n        }\n\n        setRadius(r: number) {\n            this.r = Fx8(r >> 1);\n        }\n\n        setSpeed(s: number) {\n            this.speed = Fx8(-s);\n        }\n\n        setSpread(s: number) {\n            this.spread = s;\n        }\n    }\n\n    class ColorCount {\n        constructor(public color: number, public count: number) { }\n    }\n\n    export class AshFactory extends AreaFactory {\n        private colors: ColorCount[];\n        \n        constructor(anchor: ParticleAnchor, updateImage?: boolean, percentKept: number = 20) {\n            super(anchor.width ? anchor.width : 8, anchor.height ? anchor.height >> 1 : 8, 300, 700);\n\n            if (!anchor.image) {\n                this.colors = [new ColorCount(1, 20)];\n                return;\n            }\n\n            let counts: number[] = [];\n            for (let i = 0x0; i <= 0xF; i++) {\n                counts[i] = 0;\n            }\n            let result: Image = anchor.image.clone();\n\n            for (let x = 0; x < result.width; x++) {\n                for (let y = 0; y < result.height; y++) {\n                    const c = result.getPixel(x, y);\n                    if (c && this.galois.percentChance(percentKept)) {\n                        counts[c]++;\n                        result.setPixel(x, y, 0x0);\n                    }\n                }\n            }\n\n            /** TODO: The following should be:\n             * if (updateImage && anchor.setImage) {\n             *     anchor.setImage(result);\n             * }\n             * but this fails due to https://github.com/Microsoft/pxt-arcade/issues/515 .\n             * This is a temporary workaround.\n             */\n            if (updateImage) {\n                (anchor as Sprite).setImage(result);\n            }\n\n            this.colors = counts\n                .map((value: number, index: number) => new ColorCount(index, value))\n                .filter(v => v.count != 0);\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            if (this.colors.length === 0) return undefined;\n\n            const index = this.galois.randomRange(0, this.colors.length - 1);\n            const choice = this.colors[index];\n            const p = super.createParticle(anchor);\n\n            choice.count--;\n            if (choice.count === 0) this.colors.removeAt(index);\n\n            p.color = choice.color;\n\n            p._y = Fx.iadd(this.galois.randomRange(this.yRange >> 1, this.yRange), p._y);\n            p.vx = anchor.vx ? Fx.neg(Fx8(anchor.vx >> 2)): Fx.zeroFx8;\n            p.vy = Fx8(this.galois.randomRange(-150, -50));\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n        }\n    }\n\n    export class BubbleFactory extends ParticleFactory {\n        minLifespan: number;\n        maxLifespan: number;\n        xRange: number;\n        yRange: number;\n        protected galois: Math.FastRandom;\n        protected states: Image[];\n    \n        constructor(sprite: ParticleAnchor, minLifespan: number, maxLifespan: number) {\n            super();\n            initTrig();\n            this.galois = new Math.FastRandom();\n\n            this.xRange = sprite.width ? sprite.width : 16;\n            this.yRange = 8;\n            this.minLifespan = minLifespan;\n            this.maxLifespan = maxLifespan;\n\n            this.states = [\n                img`\n                    F\n                `, img`\n                    F F\n                `, img`\n                    F F\n                    F F\n                `, img`\n                    F F F\n                    F . F\n                    F F F\n                `, img`\n                    . F F .\n                    F . . F\n                    F . . F\n                    . F F .\n                `, img`\n                    . F F F .\n                    F . . . F\n                    F . . . F\n                    . F F F .\n                `\n            ];\n        }\n\n        get stateCount(): number {\n            return this.states.length;\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(-this.yRange, 0) + (anchor.height ? anchor.height >> 1 : 0), p._y);\n\n            p.vy = Fx8(Math.randomRange(-30, -5));\n            p.vx = Fx8(Math.randomRange(-10, 10));\n\n            p.data = this.galois.percentChance(80) ? 0 : 2;\n            p.color = this.galois.percentChance(90) ?\n                0x9 : (this.galois.percentChance(50) ?\n                    0x6 : 0x8);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const toDraw = this.states[p.data].clone();\n            toDraw.replace(0xF, p.color);\n            screen.drawTransparentImage(toDraw, Fx.toInt(x), Fx.toInt(y));\n        }\n    }\n\n    export class StarFactory extends ParticleFactory {\n        protected galois: Math.FastRandom;\n        protected possibleColors: number[]\n        minRate: number;\n        maxRate: number;\n        images: Image[];\n\n        constructor(possibleColors?: number[], minRate: number = 15, maxRate: number = 25) {\n            super();\n            this.galois = new Math.FastRandom();\n            this.minRate = minRate;\n            this.maxRate = maxRate;\n            this.images = [\n                img`\n                    1\n                `,\n                img`\n                    1 . 1\n                    . 1 .\n                    1 . 1\n                `, img`\n                    . 1 .\n                    1 1 1\n                    . 1 .\n                `\n            ];\n\n            if (possibleColors && possibleColors.length)\n                this.possibleColors = possibleColors\n            else\n                this.possibleColors = [1];\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const xRange = anchor.width ? anchor.width >> 1 : 8;\n\n            p._x = Fx8(this.galois.randomRange(anchor.x - xRange, anchor.x + xRange));\n            p._y = Fx8(anchor.height ? anchor.y - (anchor.height >> 1) : anchor.y);\n            p.vy = Fx8(this.galois.randomRange(this.minRate, this.maxRate));\n\n            // set lifespan based off velocity and screen height (plus a little to make sure it doesn't disappear early)\n            p.lifespan = Fx.toInt(Fx.mul(Fx.div(Fx8(screen.height + 20), p.vy), Fx8(1000)));\n\n            const length = this.possibleColors.length - 1;\n            p.color = this.possibleColors[this.possibleColors.length - 1];\n            for (let i = 0; i < length; ++i) {\n                if (this.galois.percentChance(80 - (i * 10))) {\n                    p.color = this.possibleColors[i];\n                    break;\n                }\n            }\n\n            // images besides the first one are only used on occasion\n            p.data = this.galois.percentChance(15) ? this.galois.randomRange(1, this.images.length - 1) : 0;\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            // on occasion, twinkle from white to yellow\n            const twinkleFlag = 0x8000;\n            const rest = 0x7FFF;\n            if (twinkleFlag && p.data) {\n                if (this.galois.percentChance(10)) {\n                    p.color = 1;\n                    p.data &= rest;\n                }\n            } else if (p.color === 1 && this.galois.percentChance(1)) {\n                p.color = 5;\n                p.data |= twinkleFlag;\n            }\n\n            const selected = this.images[rest & p.data].clone();\n            selected.replace(0x1, p.color);\n            screen.drawTransparentImage(selected, Fx.toInt(x), Fx.toInt(y));\n        }\n    }\n\n    export class CloudFactory extends ParticleFactory {\n        minRate: number;\n        maxRate: number;\n        clouds: Image[];\n        camera: scene.Camera;\n\n        constructor(minRate: number = 8, maxRate: number = 12) {\n            super();\n\n            this.minRate = minRate;\n            this.maxRate = maxRate;\n            this.camera = game.currentScene().camera;\n\n            this.clouds = [\n                img`\n                    . . . . . . . . . . f f f . . .\n                    . . . . . . . . . f f 9 f f . .\n                    . f f f . f f f . f 9 9 9 f f .\n                    f f 1 f f f 1 f f f 1 1 1 9 f f\n                    f 1 9 1 9 9 1 9 9 1 1 1 1 9 9 f\n                    f 9 1 9 9 1 9 1 1 9 1 1 1 1 1 f\n                    f f 1 1 1 1 1 1 1 1 1 1 1 1 1 f\n                    . f 1 1 1 1 9 9 1 f f f 1 1 1 f\n                    . f 1 f f f 9 f f f . f f 1 f f\n                    . f f f . f f f . . . . f f f .\n                `, img`\n                    . . . . . f f f f f . .\n                    . . f f . f 1 1 1 f f .\n                    f f f 1 f f 9 9 1 1 f .\n                    f 9 9 1 1 1 1 1 9 9 f f\n                    . f 1 9 9 1 9 1 1 1 1 f\n                    f 1 f f f 1 1 1 1 9 9 f\n                    f f f . f f f f 9 f f f\n                    . . . . . . . f f f . .\n                `, img`\n                    . . . . . . . . f f f . .\n                    . . . . . . . f f 1 f . .\n                    . f f f . . . f 1 9 f f .\n                    f f 1 f f . f f 1 1 1 f f\n                    f 1 9 1 f f f 1 9 1 1 1 f\n                    f f 1 9 1 1 1 9 1 1 1 1 f\n                    . f f 9 1 1 9 9 1 1 1 f f\n                    . . f 1 1 9 9 1 1 1 f f .\n                    . . f f 1 1 1 1 1 f f . .\n                    . . . f f 1 f f f f . . .\n                    . . . . f f f . . . . . .\n                `, img`\n                    . f f f .\n                    f 1 9 1 f\n                    f 9 1 1 f\n                    f f 1 f f\n                    . f f f .\n                `, img`\n                    . . . . . f f f f f f .\n                    . . . f f f 1 1 1 1 f f\n                    . f f f 1 9 1 1 9 1 1 f\n                    f f 1 1 9 1 1 1 9 1 1 f\n                    f 1 1 9 1 1 1 9 1 1 1 f\n                    f f 1 9 1 1 1 1 1 1 1 f\n                    . f f 1 1 1 1 1 1 1 f f\n                    . . f f f f f f f f f .\n                `, img`\n                    . f f f . .\n                    f f 1 f . .\n                    f 1 1 f f f\n                    f 1 9 9 1 f\n                    f 9 1 1 1 f\n                    f f 1 1 1 f\n                    . f 1 1 1 f\n                    . f f f f f\n                `, img`\n                    . . . . . . . . . . . . f f f\n                    . . . . . . . . . . f f f 1 f\n                    f f f f f . f f f . f 1 1 1 f\n                    f 1 1 1 f f f 1 f . f 1 1 1 f\n                    f f 1 1 1 f 1 1 f f f 1 1 1 f\n                    . f f 1 9 1 1 9 1 1 1 1 1 1 f\n                    . . f 9 1 1 1 9 1 1 1 1 1 f f\n                    . . f 1 1 1 9 9 1 1 1 1 1 f .\n                    . . f 1 1 9 9 1 1 1 1 1 f f .\n                    . . f f f 1 1 1 1 f f f f . .\n                    . . . . f f 1 f f f . . . . .\n                    . . . . . f f f . . . . . . .\n                `\n            ];\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const yRange = anchor.height ? anchor.height >> 1 : 8;\n            p.data = Math.randomRange(0, this.clouds.length - 1);\n            p._x = Fx8(anchor.width ? anchor.x + (anchor.width >> 1) : anchor.x)\n            p._y = Fx.add(\n                Fx8(Math.randomRange(anchor.y - yRange, anchor.y + yRange)),\n                Fx8(this.clouds[p.data].width >> 1)\n            );\n            p.vx = Fx8(-Math.randomRange(this.minRate, this.maxRate));\n\n            // p.color stores information on conjoined clouds\n            p.color = 0;\n            if (Math.percentChance(30)) {\n                const isConjoined = 1 << 0;\n                const isOffsetX = Math.randomRange(0, 1) << 1;\n                const isOffsetY = Math.randomRange(0, 1) << 2;\n                const selection = Math.randomRange(0, this.clouds.length - 1) << 3;\n\n                p.color = isConjoined | isOffsetX | isOffsetY | selection;\n            }\n\n            p.lifespan = Fx.toInt(\n                Fx.mul(\n                    Fx.div(\n                        Fx8(screen.width + 30),\n                        Fx.abs(p.vx)\n                    ),\n                    Fx8(1000)\n                )\n            );\n\n            return p;\n        }\n\n        drawParticle(p: particles.Particle, x: Fx8, y: Fx8) {\n            const mainImage = this.clouds[p.data];\n            screen.drawTransparentImage(\n                mainImage,\n                Fx.toInt(x),\n                Fx.toInt(y)\n            );\n\n            if (p.color & 1) {\n                const isOffsetX = (p.color >> 1) & 1;\n                const isOffsetY = (p.color >> 2) & 1;\n                const selection = this.clouds[p.color >> 3];\n\n                const xOffset = isOffsetX ? Fx8(mainImage.width >> 2) : Fx.zeroFx8;\n                const yOffset = isOffsetY ? Fx8(mainImage.height >> 2) : Fx.zeroFx8;\n\n                screen.drawTransparentImage(\n                    selection,\n                    Fx.toInt(Fx.add(x, xOffset)),\n                    Fx.toInt(Fx.add(y, yOffset))\n                );\n            }\n        }\n    }\n}\n",
            "particles.ts": "namespace particles {\n    enum Flag {\n        enabled = 1 << 0,\n        destroyed = 1 << 1,\n    }\n\n    // maximum count of sources before removing previous sources\n    const MAX_SOURCES = (() => {\n        const sz = control.ramSize();\n        if (sz <= 1024 * 100) {\n            return 8;\n        } else if (sz <= 1024 * 200) {\n            return 16;\n        } else {\n            return 50;\n        }\n    })();\n    const TIME_PRECISION = 10; // time goes down to down to the 1<<10 seconds\n    let lastUpdate: number;\n\n    /**\n     * A single particle\n     */\n    export class Particle {\n        _x: Fx8;\n        _y: Fx8;\n        vx: Fx8;\n        vy: Fx8;\n        lifespan: number;\n        next: Particle;\n        data?: number;\n        color?: number;\n    }\n\n    /**\n     * An anchor for a Particle to originate from\n     */\n    export interface ParticleAnchor {\n        x: number;\n        y: number;\n        vx?: number;\n        vy?: number;\n        width?: number;\n        height?: number;\n        image?: Image;\n        flags?: number;\n        setImage?: (i: Image) => void;\n    }\n\n    /**\n     * A source of particles\n     */\n    export class ParticleSource extends sprites.BaseSprite {\n        /**\n         * A relative ranking of this sources priority\n         * When necessary, a source with a lower priority will\n         * be culled before a source with a higher priority.\n         */\n        priority: number;\n        _dt: number;\n        /**\n         * The anchor this source is currently attached to\n         */\n        anchor: ParticleAnchor;\n        /**\n         * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n         * and the source gets destroyed when it reaches 0.\n         */\n        lifespan: number;\n\n        protected pFlags: number;\n        protected head: Particle;\n        protected timer: number;\n        protected period: number;\n        protected _factory: ParticleFactory;\n\n        protected ax: Fx8;\n        protected ay: Fx8;\n\n        /**\n         * @param anchor to emit particles from\n         * @param particlesPerSecond rate at which particles are emitted\n         * @param factory [optional] factory to generate particles with; otherwise, \n         */\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, factory?: ParticleFactory) {\n            super(scene.SPRITE_Z)\n            init();\n            const sources = particleSources();\n\n            // remove and immediately destroy oldest source if over MAX_SOURCES\n            if (sources.length >= MAX_SOURCES) {\n                sortSources(sources);\n                const removedSource = sources.shift();\n                removedSource.clear();\n                removedSource.destroy();\n            }\n\n            this.pFlags = 0;\n            this.setRate(particlesPerSecond);\n            this.setAcceleration(0, 0);\n            this.setAnchor(anchor);\n            this.lifespan = undefined;\n            this._dt = 0;\n            this.priority = 0;\n            this.setFactory(factory || particles.defaultFactory);\n            sources.push(this);\n            this.enabled = true;\n        }\n\n        __draw(camera: scene.Camera) {\n            let current = this.head;\n            const left = Fx8(camera.drawOffsetX);\n            const top = Fx8(camera.drawOffsetY);\n\n            while (current) {\n                if (current.lifespan > 0)\n                    this.drawParticle(current, left, top);\n                current = current.next;\n            }\n        }\n\n        _update(dt: number) {\n            this.timer -= dt;\n\n            if (this.lifespan !== undefined) {\n                this.lifespan -= dt;\n                if (this.lifespan <= 0) {\n                    this.lifespan = undefined;\n                    this.destroy();\n                }\n            } else if (this.anchor && this.anchor.flags !== undefined && (this.anchor.flags & sprites.Flag.Destroyed)) {\n                this.lifespan = 750;\n            }\n\n            while (this.timer < 0 && this.enabled) {\n                this.timer += this.period;\n                const p = this._factory.createParticle(this.anchor);\n                if (!p) continue; // some factories can decide to not produce a particle\n                p.next = this.head;\n                this.head = p;\n            }\n\n            if (!this.head) return;\n\n            let current = this.head;\n\n            this._dt += dt;\n            let fixedDt = Fx8(this._dt);\n            if (fixedDt) {\n                do {\n                    if (current.lifespan > 0) {\n                        current.lifespan -= dt;\n                        this.updateParticle(current, fixedDt)\n                    }\n                } while (current = current.next);\n                this._dt = 0;\n            } else {\n                do {\n                    current.lifespan -= dt;\n                } while (current = current.next);\n            }\n        }\n\n        _prune() {\n            while (this.head && this.head.lifespan <= 0) {\n                this.head = this.head.next;\n            }\n\n            if ((this.pFlags & Flag.destroyed) && !this.head) {\n                const scene = game.currentScene();\n                if (scene)\n                    scene.allSprites.removeElement(this);\n                const sources = particleSources();\n                if (sources && sources.length)\n                    sources.removeElement(this);\n                this.anchor == undefined;\n            }\n\n            let current = this.head;\n            while (current && current.next) {\n                if (current.next.lifespan <= 0) {\n                    current.next = current.next.next;\n                } else {\n                    current = current.next;\n                }\n            }\n        }\n\n        /**\n         * Sets the acceleration applied to the particles\n         */\n        setAcceleration(ax: number, ay: number) {\n            this.ax = Fx8(ax);\n            this.ay = Fx8(ay);\n        }\n\n        /**\n         * Enables or disables particles\n         * @param on \n         */\n        setEnabled(on: boolean) {\n            this.enabled = on;\n        }\n\n        get enabled() {\n            return !!(this.pFlags & Flag.enabled);\n        }\n\n        /**\n         * Set whether this source is currently enabled (emitting particles) or not\n         */\n        set enabled(v: boolean) {\n            if (v !== this.enabled) {\n                this.pFlags = v ? (this.pFlags | Flag.enabled) : (this.pFlags ^ Flag.enabled);\n                this.timer = 0;\n            }\n        }\n\n        /**\n         * Destroy the source\n         */\n        destroy() {\n            // The `_prune` step will finishing destroying this Source once all emitted particles finish rendering\n            this.enabled = false;\n            this.pFlags |= Flag.destroyed;\n            this._prune();\n        }\n\n        /**\n         * Clear all particles emitted from this source\n         */\n        clear() {\n            this.head = undefined;\n        }\n\n        /**\n         * Set a anchor for particles to be emitted from\n         * @param anchor\n         */\n        setAnchor(anchor: ParticleAnchor) {\n            this.anchor = anchor;\n        }\n\n        /**\n         * Sets the number of particle created per second\n         * @param particlesPerSecond \n         */\n        setRate(particlesPerSecond: number) {\n            this.period = Math.ceil(1000 / particlesPerSecond);\n            this.timer = 0;\n        }\n\n        get factory(): ParticleFactory {\n            return this._factory;\n        }\n\n        /**\n         * Sets the particle factor\n         * @param factory \n         */\n        setFactory(factory: ParticleFactory) {\n            if (factory)\n                this._factory = factory;\n        }\n\n        protected updateParticle(p: Particle, fixedDt: Fx8) {\n            fixedDt = Fx.rightShift(fixedDt, TIME_PRECISION);\n\n            p.vx = Fx.add(p.vx, Fx.mul(this.ax, fixedDt));\n            p.vy = Fx.add(p.vy, Fx.mul(this.ay, fixedDt));\n\n            p._x = Fx.add(p._x, Fx.mul(p.vx, fixedDt));\n            p._y = Fx.add(p._y, Fx.mul(p.vy, fixedDt));\n        }\n\n        protected drawParticle(p: Particle, screenLeft: Fx8, screenTop: Fx8) {\n            this._factory.drawParticle(p, Fx.sub(p._x, screenLeft), Fx.sub(p._y, screenTop));\n        }\n    }\n\n    //% whenUsed\n    export const defaultFactory = new particles.SprayFactory(20, 0, 60);\n\n    /**\n     * Creates a new source of particles attached to a sprite\n     * @param sprite \n     * @param particlesPerSecond number of particles created per second\n     */\n    export function createParticleSource(sprite: Sprite, particlesPerSecond: number): ParticleSource {\n        return new ParticleSource(sprite, particlesPerSecond);\n    }\n\n    function init() {\n        const scene = game.currentScene();\n        if (scene.particleSources) return;\n        scene.particleSources = [];\n        lastUpdate = control.millis();\n        game.onUpdate(updateParticles);\n        game.onUpdateInterval(250, pruneParticles);\n    }\n\n    function updateParticles() {\n        const sources = particleSources();\n        if (!sources) return;\n        sortSources(sources);\n\n        const time = control.millis();\n        const dt = time - lastUpdate;\n        lastUpdate = time;\n\n        for (let i = 0; i < sources.length; i++) {\n            sources[i]._update(dt);\n        }\n    }\n\n    function pruneParticles() {\n        const sources = particleSources();\n        if (sources) sources.slice(0, sources.length).forEach(s => s._prune());\n    }\n    \n    function sortSources(sources: ParticleSource[]) {\n        sources.sort((a, b) => (a.priority - b.priority || a.id - b.id));\n    }\n\n    /**\n     * A source of particles where particles will occasionally change speed based off of each other\n     */\n    export class FireSource extends ParticleSource {\n        protected galois: Math.FastRandom;\n\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, factory?: ParticleFactory) {\n            super(anchor, particlesPerSecond, factory);\n            this.galois = new Math.FastRandom();\n            this.z = 20;\n        }\n\n        updateParticle(p: Particle, fixedDt: Fx8) {\n            super.updateParticle(p, fixedDt);\n            if (p.next && this.galois.percentChance(30)) {\n                p.vx = p.next.vx;\n                p.vy = p.next.vy;\n            }\n        }\n    }\n\n    /**\n     * A source of particles where the particles oscillate horizontally, and occasionally change\n     * between a given number of defined states\n     */\n    export class BubbleSource extends ParticleSource {\n        protected maxState: number;\n        protected galois: Math.FastRandom;\n        stateChangePercentage: number;\n        oscillationPercentage: number\n\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, maxState: number, factory?: ParticleFactory) {\n            super(anchor, particlesPerSecond, factory);\n            this.galois = new Math.FastRandom();\n            this.maxState = maxState;\n            this.stateChangePercentage = 3;\n            this.oscillationPercentage = 4;\n        }\n\n        updateParticle(p: Particle, fixedDt: Fx8) {\n            super.updateParticle(p, fixedDt);\n            if (this.galois.percentChance(this.stateChangePercentage)) {\n                if (p.data < this.maxState) {\n                    p.data++;\n                } else if (p.data > 0) {\n                    p.data--;\n                }\n            }\n\n            if (this.galois.percentChance(this.oscillationPercentage)) {\n                p.vx = Fx.neg(p.vx);\n            }\n        }\n    }\n\n    export function clearAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.clear());\n            pruneParticles();\n        }\n    }\n\n    /**\n     * Stop all particle sources from creating any new particles\n     */\n    export function disableAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.enabled = false);\n            pruneParticles();\n        }\n    }\n\n    /**\n     * Allow all particle sources to create any new particles\n     */\n    export function enableAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.enabled = true);\n            pruneParticles();\n        }\n    }\n\n    function particleSources() {\n        const sources = game.currentScene().particleSources;\n        return sources;\n    }\n}\n",
            "physics.ts": "class PhysicsEngine {\n    constructor() {\n    }\n\n    /**\n     * Adds sprite to the physics\n     * @param sprite\n     */\n    addSprite(sprite: Sprite) { }\n\n    removeSprite(sprite: Sprite) { }\n\n    /** move a single sprite **/\n    moveSprite(s: Sprite, dx: Fx8, dy: Fx8) { }\n\n    draw() { }\n\n    /** Apply physics and collisions to all sprites **/\n    move(dt: number) { }\n\n    overlaps(sprite: Sprite): Sprite[] { return []; }\n}\n\nconst MAX_TIME_STEP = Fx8(100); // milliseconds\nconst SPRITE_CANNOT_COLLIDE = sprites.Flag.Ghost | sprites.Flag.Destroyed;\nconst MIN_MOVE_GAP = Fx8(0.1);\n\nclass MovingSprite {\n    constructor(\n        public sprite: Sprite,\n        // vx and vy when last updated\n        public cachedVx: Fx8,\n        public cachedVy: Fx8,\n        // remaining x\n        public dx: Fx8,\n        public dy: Fx8,\n        // how much to move per step\n        public xStep: Fx8,\n        public yStep: Fx8\n    ) { }\n}\n\n/**\n * A physics engine that does simple AABB bounding box check\n */\nclass ArcadePhysicsEngine extends PhysicsEngine {\n    protected sprites: Sprite[];\n    protected map: sprites.SpriteMap;\n    protected maxVelocity: Fx8;\n    protected maxNegativeVelocity: Fx8;\n    protected minSingleStep: Fx8;\n    protected maxSingleStep: Fx8;\n\n    constructor(maxVelocity = 500, minSingleStep = 2, maxSingleStep = 4) {\n        super();\n        this.sprites = [];\n        this.maxVelocity = Fx8(maxVelocity);\n        this.maxNegativeVelocity = Fx.neg(this.maxVelocity);\n        this.map = new sprites.SpriteMap();\n        this.minSingleStep = Fx8(minSingleStep);\n        this.maxSingleStep = Fx8(maxSingleStep);\n    }\n\n    addSprite(sprite: Sprite) {\n        this.sprites.push(sprite);\n    }\n\n    removeSprite(sprite: Sprite) {\n        this.sprites.removeElement(sprite);\n    }\n\n    draw() {\n        this.map.draw();\n    }\n\n    move(dt: number) {\n        // Sprite movement logic is done in milliseconds to avoid rounding errors with Fx8 numbers\n        const dtf = Fx.min(\n            MAX_TIME_STEP,\n            Fx8(dt * 1000)\n        );\n        const dtSec = Fx.idiv(dtf, 1000);\n        const dt2 = Fx.idiv(dtf, 2);\n\n        const scene = game.currentScene();\n\n        const movingSprites = this.sprites\n            .map(sprite => this.createMovingSprite(sprite, dtSec, dt2));\n        const tileMap = scene.tileMap;\n\n        // clear obstacles if moving on that axis\n        this.sprites.forEach(s => {\n            if (s.vx || s.vy) s.clearObstacles();\n        });\n\n        this.map.clear();\n        this.map.resizeBuckets(this.sprites);\n\n        const MAX_STEP_COUNT = Fx.toInt(\n            Fx.mul(\n                Fx.div(\n                    this.maxVelocity,\n                    this.minSingleStep\n                ),\n                dtSec\n            )\n        );\n        const overlapHandlers = scene.overlapHandlers.slice();\n\n        // buffers store the moving sprites on each step; switch back and forth between the two\n        let selected = 0;\n        let buffers = [movingSprites, []];\n        for (let count = 0; count < MAX_STEP_COUNT && buffers[selected].length !== 0; ++count) {\n            const currMovers = buffers[selected];\n            selected ^= 1;\n            const remainingMovers = buffers[selected];\n\n            for (let ms of currMovers) {\n                const s = ms.sprite;\n                // if still moving and speed has changed from a collision or overlap;\n                // reverse direction if speed has reversed\n                if (ms.cachedVx !== s._vx) {\n                    if (s._vx == Fx.zeroFx8) {\n                        ms.dx = Fx.zeroFx8;\n                    } else if (s._vx < Fx.zeroFx8 && ms.cachedVx > Fx.zeroFx8\n                            || s._vx > Fx.zeroFx8 && ms.cachedVx < Fx.zeroFx8) {\n                        ms.dx = Fx.neg(ms.dx);\n                        ms.xStep = Fx.neg(ms.xStep);\n                    }\n\n                    ms.cachedVx = s._vx;\n                }\n                if (ms.cachedVy !== s._vy) {\n                    if (s._vy == Fx.zeroFx8) {\n                        ms.dy = Fx.zeroFx8;\n                    } else if (s._vy < Fx.zeroFx8 && ms.cachedVy > Fx.zeroFx8\n                            || s._vy > Fx.zeroFx8 && ms.cachedVy < Fx.zeroFx8) {\n                        ms.dy = Fx.neg(ms.dy);\n                        ms.yStep = Fx.neg(ms.yStep);\n                    }\n\n                    ms.cachedVy = s._vy;\n                }\n\n                // identify how much to move in this step\n                const stepX = Fx.abs(ms.xStep) > Fx.abs(ms.dx) ? ms.dx : ms.xStep;\n                const stepY = Fx.abs(ms.yStep) > Fx.abs(ms.dy) ? ms.dy : ms.yStep;\n                ms.dx = Fx.sub(ms.dx, stepX);\n                ms.dy = Fx.sub(ms.dy, stepY);\n\n                s._lastX = s._x;\n                s._lastY = s._y;\n                s._x = Fx.add(s._x, stepX);\n                s._y = Fx.add(s._y, stepY);\n\n                // if the sprite can collide with things, check tile map\n                // and add to collision detection\n                if (!(s.flags & SPRITE_CANNOT_COLLIDE)) {\n                    this.map.insertAABB(s);\n                    if (tileMap && tileMap.enabled) {\n                        this.tilemapCollisions(ms, tileMap);\n                    }\n                }\n\n                // if sprite still needs to move, add it to the next step of movements\n                if (Fx.abs(ms.dx) > MIN_MOVE_GAP || Fx.abs(ms.dy) > MIN_MOVE_GAP) {\n                    remainingMovers.push(ms);\n                }\n            }\n\n            // this step is done; check collisions between sprites\n            this.spriteCollisions(currMovers, overlapHandlers);\n            // clear moving sprites buffer for next step\n            while (currMovers.length) currMovers.pop();\n        }\n    }\n\n    private createMovingSprite(sprite: Sprite, dtSec: Fx8, dt2: Fx8): MovingSprite {\n        const ovx = this.constrain(sprite._vx);\n        const ovy = this.constrain(sprite._vy);\n        sprite._lastX = sprite._x;\n        sprite._lastY = sprite._y;\n\n        sprite._vx = this.constrain(\n            Fx.add(\n                sprite._vx,\n                Fx.mul(\n                    sprite._ax,\n                    dtSec\n                )\n            )\n        );\n        sprite._vy = this.constrain(\n            Fx.add(\n                sprite._vy,\n                Fx.mul(\n                    sprite._ay,\n                    dtSec\n                )\n            )\n        );\n\n        const dx = Fx.idiv(\n            Fx.mul(\n                Fx.add(\n                    sprite._vx,\n                    ovx\n                ),\n                dt2\n            ),\n            1000\n        );\n\n        const dy = Fx.idiv(\n            Fx.mul(\n                Fx.add(\n                    sprite._vy,\n                    ovy\n                ),\n                dt2\n            ),\n            1000\n        );\n\n        let xStep = dx;\n        let yStep = dy;\n\n        // make step increments smaller until under max step size\n        while (Fx.abs(xStep) > this.maxSingleStep || Fx.abs(yStep) > this.maxSingleStep) {\n            if (Fx.abs(xStep) > this.minSingleStep) {\n                xStep = Fx.idiv(xStep, 2);\n            }\n            if (Fx.abs(yStep) > this.minSingleStep) {\n                yStep = Fx.idiv(yStep, 2);\n            }\n        }\n\n        return new MovingSprite(\n            sprite,\n            sprite._vx,\n            sprite._vy,\n            dx,\n            dy,\n            xStep,\n            yStep\n        );\n    }\n\n    private spriteCollisions(movedSprites: MovingSprite[], handlers: scene.OverlapHandler[]) {\n        control.enablePerfCounter(\"phys_collisions\");\n        if (!handlers.length) return;\n\n        // sprites that have moved this step\n        for (const ms of movedSprites) {\n            const sprite = ms.sprite;\n            if (sprite.flags & SPRITE_CANNOT_COLLIDE) continue;\n            const overSprites = this.map.overlaps(ms.sprite);\n\n            for (const overlapper of overSprites) {\n                if (overlapper.flags & SPRITE_CANNOT_COLLIDE) continue;\n                const thisKind = sprite.kind();\n                const otherKind = overlapper.kind();\n\n                // skip if no overlap event between these two kinds of sprites\n                if (sprite._kindsOverlappedWith.indexOf(otherKind) === -1) continue;\n\n                // Maintaining invariant that the sprite with the higher ID has the other sprite as an overlapper\n                const higher = sprite.id > overlapper.id ? sprite : overlapper;\n                const lower = higher === sprite ? overlapper : sprite;\n\n                // if the two sprites are not currently engaged in an overlap event,\n                // apply all matching overlap events\n                if (higher._overlappers.indexOf(lower.id) === -1) {\n                    handlers\n                        .filter(h => (h.kind === thisKind && h.otherKind === otherKind)\n                                    || (h.kind === otherKind && h.otherKind === thisKind)\n                        )\n                        .forEach(h => {\n                            higher._overlappers.push(lower.id);\n                            control.runInParallel(() => {\n                                h.handler(\n                                    thisKind === h.kind ? sprite : overlapper,\n                                    thisKind === h.kind ? overlapper : sprite\n                                );\n                                higher._overlappers.removeElement(lower.id);\n                            });\n                        });\n                }\n            }\n        }\n    }\n\n    private tilemapCollisions(movingSprite: MovingSprite, tm: tiles.TileMap) {\n        const sprite = movingSprite.sprite;\n        const tileScale = tm ? tm.scale : 0;\n        const tileSize = tm ? 1 << tileScale : 0;\n\n        const xDiff = Fx.sub(\n            sprite._x,\n            sprite._lastX\n        );\n\n        const yDiff = Fx.sub(\n            sprite._y,\n            sprite._lastY\n        );\n\n        if (xDiff !== Fx.zeroFx8) {\n            const right = xDiff > Fx.zeroFx8;\n            const x0 = Fx.toIntShifted(\n                Fx.add(\n                    right ?\n                        Fx.iadd(1, sprite._hitbox.right)\n                        :\n                        Fx.iadd(-1, sprite._hitbox.left),\n                    Fx.oneHalfFx8\n                ),\n                tileScale\n            );\n            const collidedTiles: sprites.StaticObstacle[] = [];\n\n            // check collisions with tiles sprite is moving towards horizontally\n            for (\n                let y = Fx.sub(sprite._hitbox.top, yDiff);\n                y < Fx.iadd(tileSize, Fx.sub(sprite._hitbox.bottom, yDiff));\n                y = Fx.iadd(tileSize, y)\n            ) {\n                const y0 = Fx.toIntShifted(\n                    Fx.add(\n                        Fx.min(\n                            y,\n                            Fx.sub(\n                                sprite._hitbox.bottom,\n                                yDiff\n                            )\n                        ),\n                        Fx.oneHalfFx8\n                    ),\n                    tileScale\n                );\n\n                if (tm.isObstacle(x0, y0)) {\n                    const obstacle = tm.getObstacle(x0, y0);\n                    if (!collidedTiles.some(o => o.tileIndex === obstacle.tileIndex)) {\n                        collidedTiles.push(obstacle);\n                    }\n                }\n            }\n\n            if (collidedTiles.length) {\n                const collisionDirection = right ? CollisionDirection.Right : CollisionDirection.Left;\n                sprite._x = Fx.iadd(\n                    -sprite._hitbox.ox,\n                    right ?\n                        Fx.sub(\n                            Fx8(x0 << tileScale),\n                            Fx8(sprite._hitbox.width)\n                        )\n                        :\n                        Fx8((x0 + 1) << tileScale)\n                );\n\n                for (const tile of collidedTiles) {\n                    sprite.registerObstacle(collisionDirection, tile);\n                }\n\n                if (sprite.flags & sprites.Flag.DestroyOnWall) {\n                    sprite.destroy();\n                } else if (sprite._vx === movingSprite.cachedVx){\n                    // sprite collision event didn't change velocity in this direction;\n                    // apply normal updates\n                    if (sprite.flags & sprites.Flag.BounceOnWall) {\n                        if ((!right && sprite.vx < 0) || (right && sprite.vx > 0)) {\n                            sprite._vx = Fx.neg(sprite._vx);\n                            movingSprite.xStep = Fx.neg(movingSprite.xStep);\n                            movingSprite.dx = Fx.neg(movingSprite.dx);\n                        }\n                    } else {\n                        movingSprite.dx = Fx.zeroFx8;\n                        sprite._vx = Fx.zeroFx8;\n                    }\n                } else if (Math.sign(Fx.toInt(sprite._vx)) === Math.sign(Fx.toInt(movingSprite.cachedVx))) {\n                    // sprite collision event changed velocity,\n                    // but still facing same direction; prevent further movement this update.\n                    movingSprite.dx = Fx.zeroFx8;\n                }\n            }\n        }\n\n        if (yDiff !== Fx.zeroFx8) {\n            const down = yDiff > Fx.zeroFx8;\n            const y0 = Fx.toIntShifted(\n                Fx.add(\n                    down ?\n                        Fx.iadd(1, sprite._hitbox.bottom)\n                        :\n                        Fx.iadd(-1, sprite._hitbox.top),\n                    Fx.oneHalfFx8\n                ),\n                tileScale\n            );\n            const collidedTiles: sprites.StaticObstacle[] = [];\n\n            // check collisions with tiles sprite is moving towards vertically\n            for (\n                let x = sprite._hitbox.left;\n                x < Fx.iadd(tileSize, sprite._hitbox.right);\n                x = Fx.iadd(tileSize, x)\n            ) {\n                const x0 = Fx.toIntShifted(\n                    Fx.add(\n                        Fx.min(\n                            x,\n                            sprite._hitbox.right\n                        ),\n                        Fx.oneHalfFx8\n                    ),\n                    tileScale\n                );\n\n                if (tm.isObstacle(x0, y0)) {\n                    const obstacle = tm.getObstacle(x0, y0);\n                    if (!collidedTiles.some(o => o.tileIndex === obstacle.tileIndex)) {\n                        collidedTiles.push(obstacle);\n                    }\n                }\n            }\n\n            if (collidedTiles.length) {\n                const collisionDirection = down ? CollisionDirection.Bottom : CollisionDirection.Top;\n                sprite._y = Fx.iadd(\n                    -sprite._hitbox.oy,\n                    down ?\n                        Fx.sub(\n                            Fx8(y0 << tileScale),\n                            Fx8(sprite._hitbox.height)\n                        )\n                        :\n                        Fx8((y0 + 1) << tileScale)\n                );\n\n                for (const tile of collidedTiles) {\n                    sprite.registerObstacle(collisionDirection, tile);\n                }\n\n                if (sprite.flags & sprites.Flag.DestroyOnWall) {\n                    sprite.destroy();\n                } else if (sprite._vy === movingSprite.cachedVy) {\n                    // sprite collision event didn't change velocity in this direction;\n                    // apply normal updates\n                    if (sprite.flags & sprites.Flag.BounceOnWall) {\n                        if ((!down && sprite.vy < 0) || (down && sprite.vy > 0)) {\n                            sprite._vy = Fx.neg(sprite._vy);\n                            movingSprite.yStep = Fx.neg(movingSprite.yStep);\n                            movingSprite.dy = Fx.neg(movingSprite.dy);\n                        }\n                    } else {\n                        movingSprite.dy = Fx.zeroFx8;\n                        sprite._vy = Fx.zeroFx8;\n                    }\n                } else if (Math.sign(Fx.toInt(sprite._vy)) === Math.sign(Fx.toInt(movingSprite.cachedVy))) {\n                    // sprite collision event changed velocity,\n                    // but still facing same direction; prevent further movement this update.\n                    movingSprite.dy = Fx.zeroFx8;\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns sprites that overlap with the given sprite. If type is non-zero, also filter by type.\n     * @param sprite\n     * @param layer\n     */\n    overlaps(sprite: Sprite): Sprite[] {\n        return this.map.overlaps(sprite);\n    }\n\n    /** moves a sprite explicitly outside of the normal velocity changes **/\n    public moveSprite(s: Sprite, dx: Fx8, dy: Fx8) {\n        s._lastX = s._x;\n        s._lastY = s._y;\n        s._x = Fx.add(s._x, dx);\n        s._y = Fx.add(s._y, dy);\n\n        // if the sprite can collide with things, check tile map\n        if (!(s.flags & SPRITE_CANNOT_COLLIDE)) {\n            const tm = game.currentScene().tileMap;\n            if (!(tm && tm.enabled)) return;\n\n            const tileSize = 1 << tm.scale;\n            // only check tile map if moving within a single tile\n            if (Math.abs(Fx.toInt(dx)) < tileSize && Math.abs(Fx.toInt(dy)) < tileSize) {\n                const ms = new MovingSprite(\n                    s,\n                    s._vx,\n                    s._vy,\n                    dx,\n                    dy,\n                    dx,\n                    dy\n                );\n                this.tilemapCollisions(ms, tm);\n            }\n        }\n    }\n\n    private constrain(v: Fx8) {\n        return Fx.max(\n            Fx.min(\n                this.maxVelocity,\n                v\n            ),\n            this.maxNegativeVelocity\n        );\n    }\n}\n",
            "prompt.ts": "namespace game {\n    export interface PromptTheme {\n        colorPrompt: number;\n        colorInput: number;\n        colorInputHighlighted: number;\n        colorInputText: number;\n        colorAlphabet: number;\n        colorCursor: number;\n        colorBackground: number;\n        colorBottomBackground: number;\n        colorBottomText: number;\n    }\n\n    /**\n     * Ask the player for a string value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of characters the user can enter (1 - 24)\n     */\n    //% group=\"Gameplay\"\n    //% weight=10 help=game/ask-for-string\n    //% blockId=gameaskforstring block=\"ask for string %message || and max length %answerLength\"\n    //% message.defl=\"\"\n    //% answerLength.defl=\"12\"\n    //% answerLength.min=1\n    //% answerLength.max=24\n    //% group=\"Prompt\"\n    export function askForString(message: string, answerLength = 12) {\n        let p = new game.Prompt();\n        const result = p.show(message, answerLength);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8; // FONT8-TODO\n    //% whenUsed=true\n    const PADDING = 4;\n    //% whenUsed=true\n    const PROMPT_LINE_SPACING = 2;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 26;\n    //% whenUsed=true\n    const ALPHABET_ROW_LENGTH = 12;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 2;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_WIDTH = Math.floor(CONTENT_WIDTH / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const CELL_HEIGHT = CELL_WIDTH;\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING + CELL_WIDTH / 2 + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * ALPHABET_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_ALPHABET_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING + BOTTOM_BAR_ALPHABET_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_TOP = screen.height - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_SHIFT_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 3) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n    //% whenUsed=true\n    const CONFIRM_BUTTON_LEFT = screen.width - BOTTOM_BAR_BUTTON_WIDTH;\n\n    // Dimensions of the alphabet area\n    //% whenUsed=true\n    const ALPHABET_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_TOP = CONTENT_TOP + CONTENT_HEIGHT - ALPHABET_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_INPUT_MARGIN = 10;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = ALPHABET_TOP - INPUT_HEIGHT - ALPHABET_INPUT_MARGIN;\n\n    // Dimensions of prompt message area\n    //% whenUsed=true\n    const PROMPT_HEIGHT = INPUT_TOP - CONTENT_TOP;\n\n    //% whenUsed=true\n    const lowerShiftText = \"ABC\";\n    //% whenUsed=true\n    const upperShiftText = \"abc\";\n    //% whenUsed=true\n    const digitsUpper = [\" \", \",\", \".\", \"?\", \"!\", \":\", \";\", \"\\\"\", \"(\", \")\"];\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class Prompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        private cursor: Sprite;\n        private shiftButton: Sprite;\n        private confirmButton: Sprite;\n\n        private letters: Sprite[];\n        private inputs: Sprite[];\n\n        private confirmPressed: boolean;\n        private cursorRow: number;\n        private cursorColumn: number;\n        private upper: boolean;\n        private inputIndex: number;\n        private blink: boolean;\n        private frameCount: number;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.upper = false;\n            this.inputIndex = 0;\n        }\n\n        show(message: string, answerLength: number) {\n            this.message = message;\n            this.answerLength = answerLength;\n            this.inputIndex = 0;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.draw();\n            this.registerHandlers();\n            this.confirmPressed = false;\n\n            pauseUntil(() => this.confirmPressed);\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return this.result;\n        }\n\n        private draw() {\n            this.drawPromptText();\n            this.drawKeyboard();\n            this.drawInputarea();\n            this.drawBottomBar();\n        }\n\n        private drawPromptText() {\n            const prompt = sprites.create(layoutText(this.message, CONTENT_WIDTH, PROMPT_HEIGHT, this.theme.colorPrompt), -1);\n            prompt.x = screen.width / 2\n            prompt.y = CONTENT_TOP + Math.floor((PROMPT_HEIGHT - prompt.height) / 2) + Math.floor(prompt.height / 2);\n        }\n\n        private drawInputarea() {\n            const answerLeft = ROW_LEFT + Math.floor(\n                ((CELL_WIDTH * ALPHABET_ROW_LENGTH) -\n                    CELL_WIDTH * Math.min(this.answerLength, ALPHABET_ROW_LENGTH)) / 2);\n\n            this.inputs = [];\n            for (let i = 0; i < this.answerLength; i++) {\n                const blank = image.create(CELL_WIDTH, CELL_HEIGHT);\n                this.drawInput(blank, \"\", this.theme.colorInput);\n\n                const col = i % ALPHABET_ROW_LENGTH;\n                const row = Math.floor(i / ALPHABET_ROW_LENGTH);\n\n                const s = sprites.create(blank, -1);\n                s.x = answerLeft + col * CELL_WIDTH;\n                s.y = INPUT_TOP + row * CELL_HEIGHT;\n                this.inputs.push(s);\n            }\n        }\n\n        private drawKeyboard() {\n            const cursorImage = image.create(CELL_WIDTH, CELL_HEIGHT);\n            cursorImage.fill(this.theme.colorCursor);\n            this.cursor = sprites.create(cursorImage, -1);\n            this.cursor.z = -1;\n            this.updateCursor();\n\n            this.letters = [];\n            for (let j = 0; j < 36; j++) {\n                const letter = image.create(CELL_WIDTH, CELL_HEIGHT);\n\n                const col2 = j % ALPHABET_ROW_LENGTH;\n                const row2 = Math.floor(j / ALPHABET_ROW_LENGTH);\n\n                const t = sprites.create(letter, -1);\n                t.x = ROW_LEFT + col2 * CELL_WIDTH;\n                t.y = ALPHABET_TOP + row2 * CELL_HEIGHT;\n\n                this.letters.push(t);\n            }\n            this.updateKeyboard();\n        }\n\n        private drawBottomBar() {\n            const bg = image.create(screen.width, BOTTOM_BAR_HEIGHT);\n            bg.fill(this.theme.colorBottomBackground);\n\n            const bgSprite = sprites.create(bg, -1);\n            bgSprite.x = screen.width / 2;\n            bgSprite.y = BOTTOM_BAR_TOP + BOTTOM_BAR_HEIGHT / 2;\n            bgSprite.z = -1;\n\n            this.shiftButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.shiftButton.x = Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.shiftButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.confirmButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.confirmButton.x = CONFIRM_BUTTON_LEFT + Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.confirmButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.updateButtons();\n        }\n\n        private updateButtons() {\n            if (this.cursorRow === 3 && this.cursorColumn % 2 !== 1) {\n                this.shiftButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.shiftButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            if (this.upper) {\n                this.shiftButton.image.print(upperShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n            else {\n                this.shiftButton.image.print(lowerShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n\n\n            if (this.cursorRow === 3 && this.cursorColumn % 2) {\n                this.confirmButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.confirmButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            this.confirmButton.image.print(confirmText, BOTTOM_BAR_CONFIRM_X, BOTTOM_BAR_TEXT_Y);\n        }\n\n        private updateCursor() {\n            if (this.cursorRow === 3) {\n                this.cursor.image.fill(0);\n                this.updateButtons();\n            }\n            else {\n                this.cursor.x = ROW_LEFT + this.cursorColumn * CELL_WIDTH;\n                this.cursor.y = ALPHABET_TOP + this.cursorRow * CELL_HEIGHT;\n            }\n        }\n\n        private updateSelectedInput() {\n            if (this.inputIndex < this.answerLength) {\n                const u = this.inputs[this.inputIndex];\n                if (this.blink) {\n                    this.drawInput(u.image, \"\", this.theme.colorInput);\n                }\n                else {\n                    this.drawInput(u.image, \"\", this.theme.colorInputHighlighted)\n                }\n            }\n        }\n\n        private updateKeyboard() {\n            const len = this.letters.length;\n            for (let k = 0; k < len; k++) {\n                const img = this.letters[k].image;\n                img.fill(0);\n                img.print(getCharForIndex(k, this.upper), LETTER_OFFSET_X, LETTER_OFFSET_Y);\n            }\n        }\n\n        private drawInput(img: Image, char: string, color: number) {\n            img.fill(0);\n            img.fillRect(BLANK_PADDING, CELL_HEIGHT - 1, CELL_WIDTH - BLANK_PADDING * 2, 1, color)\n\n            if (char) {\n                img.print(char, LETTER_OFFSET_X, LETTER_OFFSET_Y, this.theme.colorInputText, font);\n            }\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n\n\n            this.frameCount = 0;\n            this.blink = true;\n\n            game.onUpdate(() => {\n                this.frameCount = (this.frameCount + 1) % 30;\n\n                if (this.frameCount === 0) {\n                    this.blink = !this.blink;\n\n                    this.updateSelectedInput();\n                }\n            })\n        }\n\n        private moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === 3) {\n                    this.cursor.image.fill(this.theme.colorCursor);\n                    this.cursorRow = 2;\n\n                    if (this.cursorColumn % 2) {\n                        this.cursorColumn = ALPHABET_ROW_LENGTH - 1;\n                    }\n                    else {\n                        this.cursorColumn = 0;\n                    }\n\n                    this.updateButtons();\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(3, this.cursorRow + 1);\n\n                if (this.cursorRow === 3) {\n                    // Go to closest button\n                    this.cursorColumn = this.cursorColumn > 5 ? 1 : 0;\n                }\n            }\n\n            this.updateCursor();\n        }\n\n        private moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % ALPHABET_ROW_LENGTH;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (ALPHABET_ROW_LENGTH - 1)) % ALPHABET_ROW_LENGTH;\n            }\n\n            this.updateCursor();\n        }\n\n        private confirm() {\n            if (this.cursorRow === 3) {\n                if (this.cursorColumn % 2) {\n                    this.confirmPressed = true;\n                }\n                else {\n                    this.upper = !this.upper;\n                    this.updateKeyboard();\n                    this.updateButtons();\n                }\n            }\n            else {\n                if (this.inputIndex >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * ALPHABET_ROW_LENGTH\n                const letter = getCharForIndex(index, this.upper);\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                const sprite = this.inputs[this.inputIndex];\n                this.changeInputIndex(1);\n                this.drawInput(sprite.image, letter, this.theme.colorInput);\n            }\n        }\n\n        private delete() {\n            if (this.inputIndex <= 0) return;\n\n            if (this.inputIndex < this.answerLength) {\n                this.drawInput(this.inputs[this.inputIndex].image, \"\", this.theme.colorInput);\n            }\n\n            this.result = this.result.substr(0, this.result.length - 1);\n\n            this.changeInputIndex(-1);\n        }\n\n        private changeInputIndex(delta: number) {\n            this.inputIndex += delta;\n            this.frameCount = 0\n            this.blink = false;\n            this.updateSelectedInput();\n        }\n    }\n\n    function layoutText(message: string, width: number, height: number, color: number) {\n        const lineHeight = font.charHeight + PROMPT_LINE_SPACING;\n\n        const lineLength = Math.floor(width / font.charWidth);\n        const numLines = Math.floor(height / lineHeight);\n\n        let lines: string[] = [];\n        let word: string;\n        let line: string;\n\n        let pushWord = () => {\n            if (line) {\n                if (line.length + word.length + 1 > lineLength) {\n                    lines.push(line);\n                    line = word;\n                }\n                else {\n                    line = line + \" \" + word;\n                }\n            }\n            else {\n                line = word;\n            }\n\n            word = null;\n        }\n\n        for (let l = 0; l < message.length; l++) {\n            const char = message.charAt(l);\n\n            if (char === \" \") {\n                if (word) {\n                    pushWord();\n                }\n                else {\n                    word = \" \";\n                }\n            }\n            else if (!word) {\n                word = char;\n            }\n            else {\n                word += char;\n            }\n        }\n\n        if (word) {\n            pushWord();\n        }\n\n        if (line) {\n            lines.push(line);\n        }\n\n        let maxLineWidth = 0;\n        for (let m = 0; m < lines.length; m++) {\n            maxLineWidth = Math.max(maxLineWidth, lines[m].length);\n        }\n\n        const actualWidth = maxLineWidth * font.charWidth;\n        const actualHeight = lines.length * lineHeight;\n\n        const res = image.create(actualWidth, actualHeight);\n\n        for (let n = 0; n < lines.length; n++) {\n            if ((n + 1) > numLines) break;\n            res.print(lines[n], 0, n * lineHeight, color, font);\n        }\n\n        return res;\n    }\n\n    function getCharForIndex(index: number, upper: boolean) {\n        if (index < 26) {\n            return String.fromCharCode(index + (upper ? 65 : 97));\n        }\n        else {\n            if (upper) {\n                return digitsUpper[index - 26];\n            }\n            else {\n                return \"\" + (index - 26);\n            }\n        }\n    }\n}",
            "pxt.json": "{\n  \"name\": \"game\",\n  \"description\": \"The game and sprite library - beta\",\n  \"files\": [\n    \"gameoverrides.ts\",\n    \"basesprite.ts\",\n    \"constants.ts\",\n    \"controlleroverrides.ts\",\n    \"controller.ts\",\n    \"hitbox.ts\",\n    \"sprites.ts\",\n    \"sprite.ts\",\n    \"sprite.d.ts\",\n    \"spritemap.ts\",\n    \"spriteevents.ts\",\n    \"spriteset.ts\",\n    \"spritekind.ts\",\n    \"metrics.ts\",\n    \"obstacle.ts\",\n    \"physics.ts\",\n    \"info.ts\",\n    \"background.ts\",\n    \"tilemap.ts\",\n    \"camera.ts\",\n    \"renderable.ts\",\n    \"scene.ts\",\n    \"scenes.ts\",\n    \"textDialogs.ts\",\n    \"game.ts\",\n    \"prompt.ts\",\n    \"numberprompt.ts\",\n    \"ask.ts\",\n    \"targetoverrides.cpp\",\n    \"targetoverrides.ts\",\n    \"mathUtil.ts\",\n    \"systemmenu.ts\",\n    \"systemmenuicons.ts\",\n    \"console.ts\",\n    \"fieldeditors.ts\",\n    \"particles.ts\",\n    \"particlefactories.ts\",\n    \"particleeffects.ts\",\n    \"effects.ts\",\n    \"texteffects.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"settings\": \"*\",\n    \"screen\": \"*\",\n    \"mixer\": \"*\",\n    \"power\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "renderable.ts": "namespace scene {\n    export class Renderable extends sprites.BaseSprite {\n        public constructor(\n            protected handler: (target: Image, camera: Camera) => void,\n            protected shouldBeVisible: () => boolean,\n            z: number,\n        ) {\n            super(z);\n        }\n\n        __visible(): boolean {\n            return this.shouldBeVisible();\n        }\n\n        __drawCore(camera: scene.Camera) {\n            this.handler(screen, camera);\n        }\n\n        destroy() {\n            const s = game.currentScene();\n            s.allSprites.removeElement(this);\n        }\n    }\n\n    export function createRenderable(\n        z: number,\n        handler: (target: Image, camera: Camera) => void,\n        shouldBeVisible?: () => boolean\n    ): Renderable {\n        const renderable = new Renderable(\n            handler,\n            shouldBeVisible || (() => true),\n            z,\n        );\n\n        return renderable;\n    }\n}",
            "scene.ts": "interface SparseArray<T> {\n    [index: number]: T;\n}\n\n/**\n * Control the background, tiles and camera\n */\nnamespace scene {\n    export enum Flag {\n        NeedsSorting = 1 << 1,\n    }\n\n    export class SpriteHandler {\n        constructor(\n            public kind: number,\n            public handler: (sprite: Sprite) => void\n        ) { }\n    }\n\n    export class OverlapHandler {\n        constructor(\n            public kind: number,\n            public otherKind: number,\n            public handler: (sprite: Sprite, otherSprite: Sprite) => void\n        ) { }\n    }\n\n    export class GameForeverHandler {\n        public lock: boolean;\n        constructor(\n            public handler: () => void\n        ) { }\n    }\n\n    // frame handler priorities\n    export const CONTROLLER_PRIORITY = 8;\n    export const UPDATE_CONTROLLER_PRIORITY = 13;\n    export const FOLLOW_SPRITE_PRIORITY = 14;\n    export const PHYSICS_PRIORITY = 15;\n    export const ANIMATION_UPDATE_PRIORITY = 15;\n    export const CONTROLLER_SPRITES_PRIORITY = 13;\n    export const UPDATE_INTERVAL_PRIORITY = 19;\n    export const UPDATE_PRIORITY = 20;\n    export const RENDER_BACKGROUND_PRIORITY = 60;\n    export const RENDER_SPRITES_PRIORITY = 90;\n    export const RENDER_DIAGNOSTICS_PRIORITY = 150;\n    export const UPDATE_SCREEN_PRIORITY = 200;\n\n    // default rendering z indices\n    export const ON_PAINT_Z = -20;\n    export const TILE_MAP_Z = -1;\n    export const SPRITE_Z = 0;\n    export const ON_SHADE_Z = 80;\n    export const HUD_Z = 100;\n\n    export class Scene {\n        eventContext: control.EventContext;\n        background: Background;\n        tileMap: tiles.TileMap;\n        allSprites: SpriteLike[];\n        private spriteNextId: number;\n        spritesByKind: SparseArray<SpriteSet>;\n        physicsEngine: PhysicsEngine;\n        camera: scene.Camera;\n        flags: number;\n        destroyedHandlers: SpriteHandler[];\n        createdHandlers: SpriteHandler[];\n        overlapHandlers: OverlapHandler[];\n        overlapMap: SparseArray<number[]>;\n        collisionHandlers: SpriteHandler[][];\n        gameForeverHandlers: GameForeverHandler[];\n        particleSources: particles.ParticleSource[];\n        controlledSprites: controller.ControlledSprite[][];\n        followingSprites: sprites.FollowingSprite[]\n\n        private _millis: number;\n        private _data: any;\n\n        // a set of functions that need to be called when a scene is being initialized\n        static initializers: ((scene: Scene) => void)[] = [];\n\n        constructor(eventContext: control.EventContext) {\n            this.eventContext = eventContext;\n            this.flags = 0;\n            this.physicsEngine = new ArcadePhysicsEngine();\n            this.camera = new scene.Camera();\n            this.background = new Background(this.camera);\n            this.destroyedHandlers = [];\n            this.createdHandlers = [];\n            this.overlapHandlers = [];\n            this.overlapMap = {};\n            this.collisionHandlers = [];\n            this.gameForeverHandlers = [];\n            this.spritesByKind = {};\n            this.controlledSprites = [];\n            this._data = {};\n            this._millis = 0;\n        }\n\n        init() {\n            if (this.allSprites) return;\n\n            power.poke(); // keep game alive a little more\n            this.allSprites = [];\n            this.spriteNextId = 0;\n            // update controller state\n            this.eventContext.registerFrameHandler(CONTROLLER_PRIORITY, () => {\n                this._millis += this.eventContext.deltaTimeMillis;\n                control.enablePerfCounter(\"controller_update\")\n                controller.__update(this.eventContext.deltaTime);\n            })\n            // controller update 13\n            this.eventContext.registerFrameHandler(CONTROLLER_SPRITES_PRIORITY, controller._moveSprites);\n            // sprite following 14\n            // apply physics and collisions 15\n            this.eventContext.registerFrameHandler(PHYSICS_PRIORITY, () => {\n                control.enablePerfCounter(\"physics and collisions\")\n                const dt = this.eventContext.deltaTime;\n\n                this.physicsEngine.move(dt);\n                this.camera.update();\n\n                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n            })\n            // user update interval 19s\n\n            // user update 20\n\n            // render 90\n            this.eventContext.registerFrameHandler(RENDER_SPRITES_PRIORITY, () => {\n                control.enablePerfCounter(\"sprite_draw\")\n                this.cachedRender = undefined;\n                this.renderCore();\n            });\n            // render diagnostics\n            this.eventContext.registerFrameHandler(RENDER_DIAGNOSTICS_PRIORITY, () => {\n                if (game.stats && control.EventContext.onStats) {\n                    control.EventContext.onStats(\n                        control.EventContext.lastStats +\n                        ` sprites:${this.allSprites.length}`\n                    )\n                }\n                if (game.debug)\n                    this.physicsEngine.draw();\n                game.consoleOverlay.draw();\n                // clear flags\n                this.flags = 0;\n                // check for power deep sleep\n                power.checkDeepSleep();\n            });\n            // update screen\n            this.eventContext.registerFrameHandler(UPDATE_SCREEN_PRIORITY, control.__screen.update);\n            // register additional components\n            Scene.initializers.forEach(f => f(this));\n        }\n\n        get data() {\n            return this._data;\n        }\n\n        /**\n         * Gets the elapsed time in the scene\n         */\n        millis(): number {\n            return this._millis;\n        }\n\n        addSprite(sprite: SpriteLike) {\n            this.allSprites.push(sprite);\n            sprite.id = this.spriteNextId++;\n        }\n\n        destroy() {\n            this.eventContext = undefined;\n            this.background = undefined;\n            this.tileMap = undefined;\n            this.allSprites = undefined;\n            this.spriteNextId = undefined;\n            this.spritesByKind = undefined;\n            this.physicsEngine = undefined;\n            this.camera = undefined;\n            this.flags = undefined;\n            this.destroyedHandlers = undefined;\n            this.createdHandlers = undefined;\n            this.overlapHandlers = undefined;\n            this.collisionHandlers = undefined;\n            this.gameForeverHandlers = undefined;\n            this._data = undefined;\n        }\n\n        protected cachedRender: Image;\n        /**\n         * Renders the current frame as an image\n         */\n        render(): Image {\n            if (this.cachedRender) {\n                return this.cachedRender;\n            }\n\n            this.renderCore();\n\n            this.cachedRender = screen.clone();\n            return this.cachedRender;\n        }\n\n        private renderCore() {\n            control.enablePerfCounter(\"render background\")\n            this.background.draw();\n\n            control.enablePerfCounter(\"sprite sort\")\n            if (this.flags & Flag.NeedsSorting) {\n                this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n            }\n\n            control.enablePerfCounter(\"sprite draw\")\n            for (const s of this.allSprites) {\n                s.__draw(this.camera);\n            }\n        }\n    }\n}\n",
            "scenes.ts": "/**\n * Control the background, tiles and camera\n */\n//% weight=88 color=\"#401255\" icon=\"\\uf1bb\"\n//% groups='[\"Screen\", \"Effects\", \"Tiles\", \"Collisions\", \"Camera\"]'\n//% blockGap=8\nnamespace scene {\n    /**\n     * Get the width of the screen in pixels\n     */\n    //% blockId=scenescreenwidth block=\"screen width\"\n    //% group=\"Screen\"\n    //% weight=100 blockGap=8\n    //% help=scene/screen-width\n    export function screenWidth(): number {\n        return screen.width;\n    }\n\n    /**\n     * Gets the height of the screen in pixels\n     */\n    //% blockId=scenescreenheight block=\"screen height\"\n    //% group=\"Screen\"\n    //% weight=99\n    //% help=scene/screen-width\n    export function screenHeight(): number {\n        return screen.height;\n    }\n\n    /**\n     * Set the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=25\n    //% blockId=gamesetbackgroundcolor block=\"set background color to %color=colorindexpicker\"\n    //% help=scene/set-background-color\n    export function setBackgroundColor(color: number) {\n        const scene = game.currentScene();\n        scene.background.color = color;\n    }\n\n    /**\n     * Get the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=22\n    //% blockId=gamebackgroundcolor block=\"background color\"\n    //% help=scene/background-color\n    export function backgroundColor() : number {\n        const scene = game.currentScene();\n        return scene.background.color;\n    }\n\n    /**\n     * Set a picture as the background\n     */\n    //% group=\"Screen\"\n    //% weight=24\n    //% blockId=gamesetbackgroundimage block=\"set background image to %img=background_image_picker\"\n    //% help=scene/set-background-image\n    export function setBackgroundImage(img: Image) {\n        const scene = game.currentScene();\n        scene.background.image = img;\n    }\n\n    /**\n     * Get the current background image\n     */\n    //% weight=22\n    //% group=\"Screen\"\n    //% blockId=gamebackgroundimage block=\"background image\"\n    //% help=scene/background-image\n    export function backgroundImage(): Image {\n        const scene = game.currentScene();\n        return scene.background.image;\n    }\n\n    /**\n     * Adds a moving background layer\n     * @param distance distance of the layer which determines how fast it moves, eg: 10\n     * @param img\n     */\n    //% group=\"Screen\"\n    //% weight=10\n    export function addBackgroundLayer(image: Image, distance?: number, alignment?: BackgroundAlignment) {\n        const scene = game.currentScene();\n        if (image)\n            scene.background.addLayer(image, distance || 100, alignment || BackgroundAlignment.Bottom);\n    }\n\n    /**\n     * Set the map for placing tiles in the scene\n     * @param map\n     * @param scale\n     */\n    //% blockId=gamesettilemap block=\"set tile map to %map=tilemap_image_picker || with %scale pixel tiles\"\n    //% scale.defl=TileScale.Sixteen\n    //% group=\"Tiles\"\n    //% help=scene/set-tile-map\n    export function setTileMap(map: Image, scale = TileScale.Sixteen) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setMap(map);\n        scene.tileMap.scale = scale;\n    }\n\n    /**\n     * Set a tile at the given index\n     * @param tile\n     * @param index\n     */\n    //% blockId=gamesettileat block=\"set %tile=gamegettile to %index=colorindexpicker\"\n    //% group=\"Tiles\"\n    //% weight=30\n    //% help=scene/set-tile-at\n    export function setTileAt(tile: tiles.Tile, index: number) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        const scale = scene.tileMap.scale;\n        scene.tileMap.setTileAt(tile.x >> scale, tile.y >> scale, index);\n    }\n\n    /**\n     * Set an image as a tile at the given index. Tiles should be a 16x16 image\n     * @param index\n     * @param img\n     */\n    //% blockId=gamesettile block=\"set tile %index=colorindexpicker to %img=tile_image_picker with wall %wall=toggleOnOff\"\n    //% group=\"Tiles\"\n    //% help=scene/set-tile\n    export function setTile(index: number, img: Image, wall?: boolean) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setTile(index, img, !!wall);\n    }\n\n    /**\n     * Get the tile at a position in the tile map\n     * @param col\n     * @param row\n     */\n    //% blockId=gamegettile block=\"tile col %col row %row\"\n    //% group=\"Tiles\" blockSetVariable=\"myTile\"\n    //% help=scene/get-tile\n    export function getTile(col: number, row: number): tiles.Tile {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTile(col, row);\n    }\n\n    /**\n     * Get all tiles in the tile map with the given index.\n     * @param index\n     */\n    //% blockId=gamegettilestype block=\"array of all %index=colorindexpicker tiles\"\n    //% group=\"Tiles\" blockSetVariable=\"tile list\"\n    //% help=scene/get-tiles-by-type\n    export function getTilesByType(index: number): tiles.Tile[] {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTilesByType(index);\n    }\n\n    /**\n     * Center the given sprite on a random tile that is the given color\n     * @param sprite\n     * @param color\n     */\n    //% blockId=gameplaceonrandomtile block=\"place %sprite=variables_get(mySprite) on top of random $color tile\"\n    //% blockNamespace=\"scene\" group=\"Tiles\"\n    //% color.shadow=\"colorindexpicker\"\n    //% help=scene/place-on-random-tile\n    export function placeOnRandomTile(sprite: Sprite, color: number): void {\n        if (!sprite || !game.currentScene().tileMap) return;\n        const tiles = getTilesByType(color);\n        if (tiles.length > 0)\n            Math.pickRandom(tiles).place(sprite);\n    }\n\n    /**\n     * Shake the camera\n     * @param sprite\n     */\n    //% blockId=camerashake block=\"camera shake by %amplitude pixels for %duration ms\"\n    //% amplitude.min=1 amplitude.max=8 amplitude.defl=4\n    //% duration.shadow=timePicker duration.defl=500\n    //% group=\"Camera\"\n    //% help=scene/camera-shake\n    export function cameraShake(amplitude: number = 4, duration: number = 500) {\n        const scene = game.currentScene();\n        scene.camera.shake(amplitude, duration);\n    }\n\n    /**\n     * Set the game camera to follow a sprite\n     * @param sprite\n     */\n    //% blockId=camerafollow block=\"camera follow sprite %sprite=variables_get(mySprite)\"\n    //% group=\"Camera\"\n    //% help=scene/camera-follow-sprite\n    export function cameraFollowSprite(sprite: Sprite) {\n        const scene = game.currentScene();\n        scene.camera.sprite = sprite;\n    }\n\n    /**\n     * Moves the camera center to a coordinate position\n     * @param sprite\n     */\n    //% blockId=camerapos block=\"center camera at x %x y %y\"\n    //% group=\"Camera\"\n    //% help=scene/center-camera-at\n    export function centerCameraAt(x: number, y: number) {\n        const scene = game.currentScene();\n        scene.camera.sprite = undefined;\n        scene.camera.offsetX = x - (screen.width >> 1);\n        scene.camera.offsetY = y - (screen.height >> 1);\n    }\n}\n",
            "sprite.d.ts": "declare interface Sprite {\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    z: number;\n    // this is defined in the superclass BaseSprite, so it needs to be declared here to show up\n    // in the blocks for sprites.\n}",
            "sprite.ts": "enum SpriteFlag {\n    //% block=\"ghost\"\n    Ghost = sprites.Flag.Ghost,\n    //% block=\"auto destroy\"\n    AutoDestroy = sprites.Flag.AutoDestroy,\n    //% block=\"stay in screen\"\n    StayInScreen = sprites.Flag.StayInScreen,\n    //% block=\"destroy on wall\"\n    DestroyOnWall = sprites.Flag.DestroyOnWall,\n    //% block=\"bounce on wall\"\n    BounceOnWall = sprites.Flag.BounceOnWall,\n    //% block=\"show physics\"\n    ShowPhysics = sprites.Flag.ShowPhysics,\n    //% block=\"invisible\"\n    Invisible = sprites.Flag.Invisible,\n}\n\nenum CollisionDirection {\n    //% block=\"left\"\n    Left = 0,\n    //% block=\"top\"\n    Top = 1,\n    //% block=\"right\"\n    Right = 2,\n    //% block=\"bottom\"\n    Bottom = 3\n}\n\nenum FlipOption {\n    //% block=none\n    None,\n    //% block=\"flip x\"\n    FlipX,\n    //% block=\"flip y\"\n    FlipY,\n    //% block=\"flip x+y\"\n    FlipXY\n}\n\n/**\n * A sprite on the screen\n **/\n//% blockNamespace=sprites color=\"#3B6FEA\" blockGap=8\nclass Sprite extends sprites.BaseSprite {\n    _x: Fx8\n    _y: Fx8\n    _vx: Fx8\n    _vy: Fx8\n    _ax: Fx8\n    _ay: Fx8\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\" callInDebugger\n    get x(): number {\n        return Fx.toInt(this._x) + (this._image.width >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this.left = v - (this._image.width >> 1)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\" callInDebugger\n    get y(): number {\n        return Fx.toInt(this._y) + (this._image.height >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this.top = v - (this._image.height >> 1)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\" callInDebugger\n    get vx(): number {\n        return Fx.toFloat(this._vx)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    set vx(v: number) {\n        this._vx = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\" callInDebugger\n    get vy(): number {\n        return Fx.toFloat(this._vy)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    set vy(v: number) {\n        this._vy = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\" callInDebugger\n    get ax(): number {\n        return Fx.toFloat(this._ax)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    set ax(v: number) {\n        this._ax = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\" callInDebugger\n    get ay(): number {\n        return Fx.toFloat(this._ay)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    set ay(v: number) {\n        this._ay = Fx8(v)\n    }\n\n    private _data: any;\n    /**\n     * Custom data\n     */\n    //%\n    get data(): any {\n        if (!this._data) this._data = {};\n        return this._data;\n    }\n\n    set data(value: any) {\n        this._data = value;\n    }\n    _kind: number;\n\n    /**\n     * A bitset of layer. Each bit is a layer, default is 1.\n     */\n    //% group=\"Physics\"\n    layer: number;\n\n    _lastX: Fx8;\n    _lastY: Fx8;\n\n    _action: number; //Used with animation library\n\n    /**\n     * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n     * and the sprite gets destroyed when it reaches 0.\n     */\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"lifespan\"\n    lifespan: number;\n    private _image: Image;\n    private _obstacles: sprites.Obstacle[];\n\n    private updateSay: (dt: number, camera: scene.Camera) => void;\n    private sayBubbleSprite: Sprite;\n\n    _hitbox: game.Hitbox;\n    _overlappers: number[];\n    _kindsOverlappedWith: number[];\n\n    flags: number\n\n    private destroyHandler: () => void;\n\n    constructor(img: Image) {\n        super(scene.SPRITE_Z);\n\n        this._x = Fx8(screen.width - img.width >> 1);\n        this._y = Fx8(screen.height - img.height >> 1);\n        this._lastX = this._x;\n        this._lastY = this._y;\n        this.vx = 0\n        this.vy = 0\n        this.ax = 0\n        this.ay = 0\n        this.flags = 0\n        this.setImage(img);\n        this.setKind(-1); // not a member of any type by default\n        this.layer = 1; // by default, in layer 1\n        this.lifespan = undefined;\n        this._overlappers = [];\n        this._obstacles = [];\n    }\n\n    __serialize(offset: number): Buffer {\n        const buf = control.createBuffer(offset + 12);\n        let k = offset;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._x)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._y)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vx)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vy)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ax)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ay)); k += 2;\n        return buf;\n    }\n\n    /**\n     * Gets the current image\n     */\n    //% group=\"Image\"\n    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n    //% weight=8\n    get image(): Image {\n        return this._image;\n    }\n\n    /**\n     * Sets the image on the sprite\n     */\n    //% group=\"Image\"\n    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n    //% weight=7 help=sprites/sprite/set-image\n    setImage(img: Image) {\n        if (!img) return; // don't break the sprite\n\n        let oMinX = 0;\n        let oMinY = 0;\n        let oMaxX = 0;\n        let oMaxY = 0;\n\n        // Identify old upper left corner\n        if (this._hitbox) {\n            oMinX = this._hitbox.ox;\n            oMinY = this._hitbox.oy;\n            oMaxX = this._hitbox.ox + this._hitbox.width;\n            oMaxY = this._hitbox.oy + this._hitbox.height;\n        }\n\n        this._image = img;\n        this._hitbox = game.calculateHitBox(this);\n\n        // Identify new upper left corner\n        let nMinX = this._hitbox.ox;\n        let nMinY = this._hitbox.oy;\n        let nMaxX = this._hitbox.ox + this._hitbox.width;\n        let nMaxY = this._hitbox.oy + this._hitbox.height;\n\n        const minXDiff = oMinX - nMinX;\n        const minYDiff = oMinY - nMinY;\n        const maxXDiff = oMaxX - nMaxX;\n        const maxYDiff = oMaxY - nMaxY;\n\n        // If just a small change to the hitbox, don't change the hitbox\n        // Used for things like walking animations\n        if (oMaxX != oMinX && Math.abs(minXDiff) + Math.abs(maxXDiff) <= 2) {\n            this._hitbox.ox = oMinX;\n            this._hitbox.width = oMaxX - oMinX;\n        }\n        if (oMaxY != oMinY && Math.abs(minYDiff) + Math.abs(maxYDiff) <= 2) {\n            this._hitbox.oy = oMinY;\n            this._hitbox.height = oMaxY - oMinY;\n        }\n    }\n\n    __visible() {\n        return !(this.flags & SpriteFlag.Invisible);\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"width\"\n    get width() {\n        return this._image.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"height\"\n    get height() {\n        return this._image.height\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    get left() {\n        return Fx.toInt(this._x)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    set left(value: number) {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx.sub(\n                Fx8(value),\n                this._x\n            ),\n            Fx.zeroFx8\n        );\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    get right() {\n        return this.left + this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    set right(value: number) {\n        this.left = value - this.width\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    get top() {\n        return Fx.toInt(this._y);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    set top(value: number) {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx.zeroFx8,\n            Fx.sub(\n                Fx8(value),\n                this._y\n            )\n        );\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    get bottom() {\n        return this.top + this.height;\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    set bottom(value: number) {\n        this.top = value - this.height;\n    }\n\n    // The z field (``get z()`` / ``set z()``) is declared in sprite.d.ts\n    // as it is defnied in the superclass\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritegetkind\" block=\"%sprite(mySprite) kind\"\n    //% weight=79 help=sprites/sprite/kind\n    kind() {\n        return this._kind;\n    }\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritesetkind\" block=\"set %sprite(mySprite) kind to %kind\"\n    //% kind.shadow=spritekind\n    //% weight=80 help=sprites/sprite/set-kind\n    setKind(value: number) {\n        if (value == undefined || this._kind === value) return;\n\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (this._kind >= 0 && spritesByKind[this._kind])\n            spritesByKind[this._kind].remove(this);\n\n        if (value >= 0) {\n            if (!spritesByKind[value]) spritesByKind[value] = new SpriteSet();\n            spritesByKind[value].add(this);\n        }\n\n        const overlapMap = game.currentScene().overlapMap;\n        if (!overlapMap[value]) {\n            overlapMap[value] = [];\n        }\n\n        this._kindsOverlappedWith = overlapMap[value];\n\n        this._kind = value;\n    }\n\n    /**\n     * Set the sprite position in pixels starting from the top-left corner of the screen.\n     * @param x horizontal position in pixels\n     * @param y vertical position in pixels\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n    //% help=sprites/sprite/set-position\n    //% x.shadow=\"positionPicker\" y.shadow=\"positionPicker\"\n    setPosition(x: number, y: number): void {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx8(x - this.x),\n            Fx8(y - this.y)\n        );\n    }\n\n    /**\n     * Sets the sprite velocity in pixel / sec\n     * @param vx\n     * @param vy\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetvel block=\"set %sprite(mySprite) velocity to vx %vx vy %vy\"\n    //% help=sprites/sprite/set-velociy\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    setVelocity(vx: number, vy: number): void {\n        this.vx = vx;\n        this.vy = vy;\n    }\n\n    /**\n     * Display a speech bubble with the text, for the given time\n     * @param text the text to say, eg: \":)\"\n     * @param time time to keep text on\n     */\n    //% group=\"Effects\"\n    //% weight=60\n    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n    //% millis.shadow=timePicker\n    //% inlineInputMode=inline\n    //% help=sprites/sprite/say\n    say(text: string, timeOnScreen?: number, textColor = 15, textBoxColor = 1) {\n        // clear say\n        if (!text) {\n            this.updateSay = undefined;\n            if (this.sayBubbleSprite) {\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n            return;\n        }\n\n        // same text, color, time, etc...\n        const SAYKEY = \"__saykey\";\n        const key = JSON.stringify({\n            text: text,\n            textColor: textColor,\n            textBoxColor: textBoxColor\n        })\n        if (timeOnScreen === undefined\n            && this.sayBubbleSprite\n            && this.sayBubbleSprite.data[SAYKEY] == key) {\n            // do nothing!\n            return;\n        }\n\n        let pixelsOffset = 0;\n        let holdTextSeconds = 1.5;\n        let bubblePadding = 4;\n        let maxTextWidth = 100;\n        let font = image.getFontForText(text);\n        let startX = 2;\n        let startY = 2;\n        let bubbleWidth = text.length * font.charWidth + bubblePadding;\n        let maxOffset = text.length * font.charWidth - maxTextWidth;\n        let bubbleOffset: number = this._hitbox.oy;\n        let needsRedraw = true;\n\n        // sets the defaut scroll speed in pixels per second\n        let speed = 45;\n        const currentScene = game.currentScene();\n\n        // Calculates the speed of the scroll if scrolling is needed and a time is specified\n        if (timeOnScreen && maxOffset > 0) {\n            speed = (maxOffset + (2 * maxTextWidth)) / (timeOnScreen / 1000);\n            speed = Math.max(speed, 45);\n            holdTextSeconds = maxTextWidth / speed;\n            holdTextSeconds = Math.min(holdTextSeconds, 1.5);\n        }\n\n        if (timeOnScreen) {\n            timeOnScreen = timeOnScreen + currentScene.millis();\n        }\n\n        if (bubbleWidth > maxTextWidth + bubblePadding) {\n            bubbleWidth = maxTextWidth + bubblePadding;\n        } else {\n            maxOffset = -1;\n        }\n\n        // reuse previous sprite if possible\n        const imgh = font.charHeight + bubblePadding;\n        if (!this.sayBubbleSprite\n            || this.sayBubbleSprite.image.width != bubbleWidth\n            || this.sayBubbleSprite.image.height != imgh) {\n            const sayImg = image.create(bubbleWidth, imgh);\n            if (this.sayBubbleSprite) // sprite with same image size, we can reuse it\n                this.sayBubbleSprite.setImage(sayImg);\n            else { // needs a new sprite\n                this.sayBubbleSprite = sprites.create(sayImg, -1);\n                this.sayBubbleSprite.setFlag(SpriteFlag.Ghost, true);\n            }\n        }\n        this.sayBubbleSprite.data[SAYKEY] = key;\n        this.updateSay = (dt, camera) => {\n            // Update box stuff as long as timeOnScreen doesn't exist or it can still be on the screen\n            if (!timeOnScreen || timeOnScreen > currentScene.millis()) {\n                // move bubble\n                if (!this.isOutOfScreen(camera)) {\n                    const ox = camera.offsetX;\n                    const oy = camera.offsetY;\n\n                    if (this.sayBubbleSprite.left - ox < 0) {\n                        this.sayBubbleSprite.left = 0;\n                    }\n\n                    if (this.sayBubbleSprite.right - ox > screen.width) {\n                        this.sayBubbleSprite.right = screen.width;\n                    }\n\n                    // If sprite bubble above the sprite gets cut off on top, place the bubble below the sprite\n                    if (this.sayBubbleSprite.top - oy < 0) {\n                        this.sayBubbleSprite.y = (this.sayBubbleSprite.y - 2 * this.y) * -1;\n                    }\n                }\n\n                // Pauses at beginning of text for holdTextSeconds length\n                if (holdTextSeconds > 0) {\n                    holdTextSeconds -= game.eventContext().deltaTime;\n                    // If scrolling has reached the end, start back at the beginning\n                    if (holdTextSeconds <= 0 && pixelsOffset > 0) {\n                        pixelsOffset = 0;\n                        holdTextSeconds = maxTextWidth / speed;\n                        needsRedraw = true;\n                    }\n                } else {\n                    pixelsOffset += dt * speed;\n                    needsRedraw = true;\n\n                    // Pause at end of text for holdTextSeconds length\n                    if (pixelsOffset >= maxOffset) {\n                        pixelsOffset = maxOffset;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                }\n\n                if (needsRedraw) {\n                    needsRedraw = false;\n                    this.sayBubbleSprite.image.fill(textBoxColor);\n                    // The minus 2 is how much transparent padding there is under the sayBubbleSprite\n                    this.sayBubbleSprite.y = this.top + bubbleOffset - ((font.charHeight + bubblePadding) >> 1) - 2;\n                    this.sayBubbleSprite.x = this.x;\n                    // If maxOffset is negative it won't scroll\n                    if (maxOffset < 0) {\n                        this.sayBubbleSprite.image.print(text, startX, startY, textColor, font);\n\n                    } else {\n                        this.sayBubbleSprite.image.print(text, startX - pixelsOffset, startY, textColor, font);\n                    }\n\n                    // Left side padding\n                    this.sayBubbleSprite.image.fillRect(0, 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                    // Right side padding\n                    this.sayBubbleSprite.image.fillRect(bubbleWidth - (bubblePadding >> 1), 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                    // Corners removed\n                    this.sayBubbleSprite.image.setPixel(0, 0, 0);\n                    this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, 0, 0);\n                    this.sayBubbleSprite.image.setPixel(0, font.charHeight + bubblePadding - 1, 0);\n                    this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, font.charHeight + bubblePadding - 1, 0);\n                }\n            } else {\n                // If can't update because of timeOnScreen then destroy the sayBubbleSprite and reset updateSay\n                this.updateSay = undefined;\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n        }\n        this.updateSay(0, currentScene.camera);\n    }\n\n    /**\n     * Start an effect on this sprite\n     * @param effect the type of effect to create\n     */\n    //% group=\"Effects\"\n    //% weight=90\n    //% blockId=startEffectOnSprite block=\"%sprite(mySprite) start %effect effect || for %duration=timePicker|ms\"\n    //% help=sprites/sprite/start-effect\n    startEffect(effect: effects.ParticleEffect, duration?: number) {\n        effect.start(this, duration);\n    }\n\n    /**\n     * Indicates if the sprite is outside the screen\n     */\n    //%\n    isOutOfScreen(camera: scene.Camera): boolean {\n        const ox = camera.offsetX;\n        const oy = camera.offsetY;\n        return this.right - ox < 0 || this.bottom - oy < 0 || this.left - ox > screen.width || this.top - oy > screen.height;\n    }\n\n    __drawCore(camera: scene.Camera) {\n        if (this.isOutOfScreen(camera)) return;\n\n        const l = this.left - camera.drawOffsetX;\n        const t = this.top - camera.drawOffsetY;\n        screen.drawTransparentImage(this._image, l, t)\n\n        if (this.flags & SpriteFlag.ShowPhysics) {\n            const font = image.font5;\n            const margin = 2;\n            let tx = l;\n            let ty = this.bottom + margin - camera.drawOffsetY;\n            screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n            tx -= font.charWidth;\n            if (this.vx || this.vy) {\n                ty += font.charHeight + margin;\n                screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n            }\n            if (this.ax || this.ay) {\n                ty += font.charHeight + margin;\n                screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n            }\n        }\n\n        // debug info\n        if (game.debug) {\n            screen.drawRect(\n                Fx.toInt(this._hitbox.left) - camera.drawOffsetX,\n                Fx.toInt(this._hitbox.top) - camera.drawOffsetY,\n                this._hitbox.width,\n                this._hitbox.height,\n                1\n            );\n        }\n    }\n\n    __update(camera: scene.Camera, dt: number) {\n        if (this.lifespan !== undefined) {\n            this.lifespan -= dt * 1000;\n            if (this.lifespan <= 0) {\n                this.lifespan = undefined;\n                this._destroyCore();\n            }\n        }\n        if ((this.flags & sprites.Flag.AutoDestroy)\n            && this.isOutOfScreen(camera)) {\n            this.destroy()\n        }\n\n        const bounce = this.flags & sprites.Flag.BounceOnWall;\n        const tm = game.currentScene().tileMap;\n        if (this.flags & sprites.Flag.StayInScreen || (bounce && !tm)) {\n            if (this.left < camera.offsetX) {\n                this.left = camera.offsetX;\n                if (bounce) this.vx = -this.vx;\n            }\n            else if (this.right > camera.offsetX + screen.width) {\n                this.right = camera.offsetX + screen.width;\n                if (bounce) this.vx = -this.vx;\n            }\n\n            if (this.top < camera.offsetY) {\n                this.top = camera.offsetY;\n                if (bounce) this.vy = -this.vy;\n            }\n            else if (this.bottom > camera.offsetY + screen.height) {\n                this.bottom = camera.offsetY + screen.height;\n                if (bounce) this.vy = -this.vy;\n            }\n        }\n\n        // Say text\n        if (this.updateSay) {\n            this.updateSay(dt, camera);\n        }\n    }\n\n    /**\n     * Set a sprite flag\n     */\n    //% group=\"Effects\"\n    //% weight=30\n    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n    //% flag.defl=SpriteFlag.StayInScreen\n    //% help=sprites/sprite/set-flag\n    setFlag(flag: SpriteFlag, on: boolean) {\n        if (on) this.flags |= flag\n        else this.flags = ~(~this.flags | flag);\n    }\n\n    /**\n     * Check if this sprite overlaps another sprite\n     * @param other\n     */\n    //% group=\"Overlaps\"\n    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n    //% help=sprites/sprite/overlaps-with\n    //% weight=90\n    overlapsWith(other: Sprite) {\n        control.enablePerfCounter(\"overlapsCPP\")\n        if (other == this) return false;\n        if (this.flags & sprites.Flag.Ghost)\n            return false\n        if (other.flags & sprites.Flag.Ghost)\n            return false\n        return other._image.overlapsWith(this._image, this.left - other.left, this.top - other.top)\n    }\n\n    /**\n     * Check if there is an obstacle in the given direction\n     * @param direction\n     */\n    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/is-hitting-tile\n    isHittingTile(direction: CollisionDirection): boolean {\n        return this._obstacles && !!this._obstacles[direction];\n    }\n\n    /**\n     * Get the obstacle sprite in a given direction if any\n     * @param direction\n     */\n    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/tile-hit-from\n    tileHitFrom(direction: CollisionDirection): number {\n        return (this._obstacles && this._obstacles[direction]) ? this._obstacles[direction].tileIndex : -1;\n    }\n\n    clearObstacles() {\n        this._obstacles = [];\n    }\n\n    registerObstacle(direction: CollisionDirection, other: sprites.Obstacle) {\n        this._obstacles[direction] = other;\n        const collisionHandlers = game.currentScene().collisionHandlers[other.tileIndex];\n\n        if (collisionHandlers) {\n            collisionHandlers\n                .filter(h => h.kind == this.kind())\n                .forEach(h => h.handler(this));\n        }\n    }\n\n    /**\n     * Run code when the sprite is destroyed\n     * @param handler\n     */\n    //% group=\"Lifecycle\"\n    //% weight=9\n    onDestroyed(handler: () => void) {\n        this.destroyHandler = handler\n    }\n\n    /**\n     * Destroy the sprite\n     */\n    //% group=\"Effects\"\n    //% weight=80\n    //% blockId=spritedestroy block=\"destroy %sprite(mySprite) || with %effect effect for %duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"toggle\"\n    //% help=sprites/sprite/destroy\n    destroy(effect?: effects.ParticleEffect, duration?: number) {\n        if (this.flags & sprites.Flag.Destroyed)\n            return;\n        this.flags |= sprites.Flag.Destroyed;\n\n        if (effect)\n            effect.destroy(this, duration);\n        else\n            this._destroyCore();\n    }\n\n    _destroyCore() {\n        this.flags |= sprites.Flag.Destroyed;\n        const scene = game.currentScene();\n        // When current sprite is destroyed, destroys sayBubbleSprite if defined\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n        scene.allSprites.removeElement(this);\n        if (this.kind() >= 0 && scene.spritesByKind[this.kind()])\n            scene.spritesByKind[this.kind()].remove(this);\n        scene.physicsEngine.removeSprite(this);\n        if (this.destroyHandler)\n            this.destroyHandler();\n        scene.destroyedHandlers\n            .filter(h => h.kind == this.kind())\n            .forEach(h => h.handler(this));\n    }\n\n    /**\n     * Make this sprite follow the target sprite.\n     *\n     * @param target the sprite this one should follow\n     * @param speed the rate at which this sprite should move, eg: 100\n     * @param turnRate how quickly the sprite should turn while following, eg: 3\n     */\n    //% group=\"Physics\" weight=10\n    //% blockId=spriteFollowOtherSprite\n    //% block=\"set %sprite(myEnemy) follow %target=variables_get(mySprite) || with speed %speed\"\n    follow(target: Sprite, speed = 100, turnRate = 3) {\n        if (target === this) return;\n\n        const sc = game.currentScene();\n        if (!sc.followingSprites) {\n            sc.followingSprites = [];\n            let lastTime = game.runtime();\n            sc.eventContext.registerFrameHandler(scene.FOLLOW_SPRITE_PRIORITY, () => {\n                const currTime = game.runtime();\n                const timeDiff = (currTime - lastTime) / 1000;\n                let destroyedSprites = false;\n\n                sc.followingSprites.forEach(fs => {\n                    // one of the involved sprites has been destroyed, so exit and remove that later\n                    if ((fs.self.flags | fs.target.flags) & sprites.Flag.Destroyed) {\n                        destroyedSprites = true;\n                        return;\n                    }\n\n                    const dx = fs.target.x - fs.self.x;\n                    const dy = fs.target.y - fs.self.y;\n\n                    // already right on top of target; stop moving\n                    if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {\n                        fs.self.vx = 0;\n                        fs.self.vy = 0;\n                        return;\n                    }\n\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const turnPercentage = Math.clamp(0, 1, fs.turnRate * timeDiff);\n\n                    fs.self.vx += (fs.rate * dx / distance - fs.self.vx) * turnPercentage;\n                    fs.self.vy += (fs.rate * dy / distance - fs.self.vy) * turnPercentage;\n                });\n\n                lastTime = currTime;\n\n                // remove followers where one has been destroyed\n                if (destroyedSprites) {\n                    sc.followingSprites = sc.followingSprites\n                        .filter(fs => !((fs.self.flags | fs.target.flags) & sprites.Flag.Destroyed));\n                }\n            });\n        }\n\n        const fs = sc.followingSprites.find(fs => fs.self.id == this.id);\n\n        if (!target || !speed) {\n            if (fs) {\n                sc.followingSprites.removeElement(fs);\n            }\n        } else if (!fs) {\n            sc.followingSprites.push(new sprites.FollowingSprite(\n                this,\n                target,\n                speed,\n                turnRate\n            ));\n        } else {\n            fs.target = target;\n            fs.rate = speed;\n            fs.turnRate = turnRate;\n        }\n    }\n\n    toString() {\n        return `${this.id}(${this.x},${this.y})->(${this.vx},${this.vy})`;\n    }\n}",
            "spriteevents.ts": "namespace sprites {\n    /**\n     * Run code when a certain kind of sprite is created\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\" draggableParameters=\"reporter\" weight=97\n    //% blockId=spritesoncreated block=\"on created $sprite of kind $kind=spritekind\"\n    //% help=sprites/on-created\n    export function onCreated(kind: number, handler: (sprite: Sprite) => void): void {\n        if (!handler || kind == undefined) return;\n\n        const sc = game.currentScene();\n        sc.createdHandlers.push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        )\n    }\n\n    /**\n     * Run code when a certain kind of sprite is destroyed\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\"\n    //% weight=96 draggableParameters=\"reporter\"\n    //% blockId=spritesondestroyed block=\"on destroyed $sprite of kind $kind=spritekind \"\n    //% help=sprites/on-destroyed\n    export function onDestroyed(kind: number, handler: (sprite: Sprite) => void) {\n        if (!handler || kind == undefined) return;\n\n        const sc = game.currentScene();\n        sc.destroyedHandlers.push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        );\n    }\n\n    /**\n     * Run code when two kinds of sprites overlap\n     */\n    //% group=\"Overlaps\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% blockId=spritesoverlap block=\"on $sprite of kind $kind=spritekind overlaps $otherSprite of kind $otherKind=spritekind\"\n    //% help=sprites/on-overlap\n    //% blockGap=8\n    export function onOverlap(kind: number, otherKind: number, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n        if (kind == undefined || otherKind == undefined || !handler) return;\n        const sc = game.currentScene();\n        const overlapHandlers = sc.overlapHandlers;\n        const overlapMap = sc.overlapMap;\n\n        function associate(a: number, b: number) {\n            if (!overlapMap[a]) {\n                overlapMap[a] = [];\n            }\n\n            overlapMap[a].push(b);\n        }\n\n        associate(kind, otherKind);\n        associate(otherKind, kind);\n\n        overlapHandlers.push(\n            new scene.OverlapHandler(\n                kind,\n                otherKind,\n                handler\n            )\n        );\n    }\n}\n\nnamespace scene {\n    /**\n     * Run code when a certain kind of sprite hits a tile\n     * @param direction\n     * @param tile\n     * @param handler\n     */\n    //% group=\"Collisions\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% blockId=spritesollisions block=\"on $sprite of kind $kind=spritekind hits wall $tile=colorindexpicker\"\n    //% help=scene/on-hit-tile\n    export function onHitTile(kind: number, tile: number, handler: (sprite: Sprite) => void) {\n        if (kind == undefined || tile < 0 || tile > 0xF || !handler) return;\n\n        const collisionHandlers = game.currentScene().collisionHandlers;\n        if (!collisionHandlers[tile]) {\n            collisionHandlers[tile] = [];\n        }\n\n        collisionHandlers[tile].push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        );\n    }\n}",
            "spritekind.ts": "namespace sprites {\n    /**\n     * Gets the \"kind\" of sprite\n     */\n    //% shim=KIND_GET\n    //% blockId=spritekind block=\"$kind\"\n    //% kindNamespace=SpriteKind kindMemberName=kind kindPromptHint=\"e.g. Coin, Fireball, Asteroid...\"\n    export function _spriteKind(kind: number): number {\n        return kind;\n    }\n\n    /**\n     * Gets the sprite type\n     */\n    //% blockHidden=1 shim=ENUM_GET deprecated=true\n    //% blockId=spritetype block=\"$kind\" enumInitialMembers=\"Player,Projectile,Food,Enemy\"\n    //% enumName=SpriteKindLegacy enumMemberName=kind enumPromptHint=\"e.g. Coin, Fireball, Asteroid...\"\n    export function _spriteType(kind: number): number {\n        return kind;\n    }\n}\n\nnamespace SpriteKind {\n    let nextKind: number;\n\n    export function create() {\n        if (nextKind === undefined) nextKind = 1000;\n        return nextKind++;\n    }\n\n    //% isKind\n    export const Player = create();\n\n    //% isKind\n    export const Projectile = 1;\n\n    //% isKind\n    export const Food = create();\n\n    //% isKind\n    export const Enemy = create();\n}",
            "spritemap.ts": "namespace sprites {\n    export class SpriteMap {\n        private cellWidth: number;\n        private cellHeight: number;\n        private rowCount: number;\n        private columnCount: number;\n        private buckets: Sprite[][];\n\n        constructor() {\n            this.buckets = [];\n        }\n\n        /**\n         * Returns a potential list of neighbors\n         */\n        neighbors(sprite: Sprite): Sprite[] {\n            if (this.isOob(sprite)) return [];\n\n            const n: Sprite[] = [];\n            const layer = sprite.layer;\n            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n            n.removeElement(sprite);\n            return n;\n        }\n\n        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n        overlaps(sprite: Sprite): Sprite[] {\n            const n = this.neighbors(sprite);\n            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n        }\n\n        draw() {\n            for (let x = 0; x < this.columnCount; ++x) {\n                for (let y = 0; y < this.rowCount; ++y) {\n                    const left = x * this.cellWidth;\n                    const top = y * this.cellHeight;\n                    const k = this.key(left, top);\n                    const b = this.buckets[k];\n                    if (b && b.length)\n                        screen.drawRect(left, top, this.cellWidth, this.cellHeight, 5);\n                }\n            }\n        }\n\n        /**\n         * Recompute hashes for all objects\n         */\n        resizeBuckets(sprites: Sprite[]) {\n            // rescale buckets\n            let maxWidth = 0;\n            let maxHeight = 0;\n            for (const sprite of sprites) {\n                if (sprite.width > maxWidth) maxWidth = sprite.width;\n                if (sprite.height > maxHeight) maxHeight = sprite.height;\n            }\n\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n\n            this.cellWidth = Math.clamp(8, areaWidth >> 2, maxWidth * 2);\n            this.cellHeight = Math.clamp(8, areaHeight >> 2, maxHeight * 2);\n            this.rowCount = Math.idiv(areaHeight, this.cellHeight);\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth);\n        }\n\n        clear() {\n            this.buckets = [];\n        }\n\n        private key(x: number, y: number): number {\n            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n            return xi + yi * this.columnCount;\n        }\n\n        private insertAtKey(x: number, y: number, sprite: Sprite) {\n            const k = this.key(x, y);\n            let bucket = this.buckets[k];\n            if (!bucket)\n                bucket = this.buckets[k] = [];\n            if (bucket.indexOf(sprite) < 0)\n                bucket.push(sprite);\n        }\n\n        private isOob(sprite: Sprite): boolean {\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n            return sprite.right < 0 || sprite.left > areaWidth || sprite.bottom < 0 || sprite.top > areaHeight;\n        }\n\n        insertAABB(sprite: Sprite) {\n            // is object not collidable?\n            if (this.isOob(sprite))\n                return;\n\n            const left = sprite.left;\n            const top = sprite.top;\n            const xn = Math.idiv(sprite.width + this.cellWidth - 1, this.cellWidth);\n            const yn = Math.idiv(sprite.height + this.cellHeight - 1, this.cellHeight);\n            for (let x = 0; x <= xn; x++)\n                for (let y = 0; y <= yn; y++)\n                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n        }\n\n        private mergeAtKey(x: number, y: number, layer: number, n: Sprite[]) {\n            const k = this.key(x, y);\n            const bucket = this.buckets[k];\n            if (bucket) {\n                for (const sprite of bucket)\n                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n                        n.push(sprite);\n            }\n        }\n\n        toString() {\n            return `${this.buckets.length} buckets, ${this.buckets.filter(b => !!b).length} filled`;\n        }\n    }\n}",
            "sprites.ts": "/*\nFrame handlers:\n 10 - physics and collisions\n 20 - frame()\n 60 - screen/sprite background\n 90 - drawing sprites\n 95 - drawing score\n100 - loops.menu()\n200 - screen refresh\n*/\n\n/**\n * Sprites on screen\n */\n//% weight=99 color=\"#4B7BEC\" icon=\"\\uf1d8\"\n//% groups='[\"Create\", \"Physics\", \"Effects\", \"Projectiles\", \"Overlaps\", \"Lifecycle\"]'\nnamespace sprites {\n    export class FollowingSprite {\n        constructor(\n            public self: Sprite,\n            public target: Sprite,\n            public rate: number,\n            public turnRate: number\n        ) { }\n    }\n\n    /**\n     * Create a new sprite from an image\n     * @param img the image\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritekind\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=mySprite\n    //% weight=100 help=sprites/create\n    export function create(img: Image, kind?: number): Sprite {\n        const scene = game.currentScene();\n        const sprite = new Sprite(img)\n        sprite.setKind(kind);\n        scene.physicsEngine.addSprite(sprite);\n\n        // run on created handlers\n        scene.createdHandlers\n            .filter(h => h.kind == kind)\n            .forEach(h => h.handler(sprite));\n\n        return sprite\n    }\n\n    /**\n     * Return an array of all sprites of the given kind.\n     * @param kind the target kind\n     */\n    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritekind\"\n    //% blockNamespace=\"arrays\" blockSetVariable=\"sprite list\"\n    //% weight=87\n    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (!(kind >= 0) || !spritesByKind[kind]) return [];\n        else return spritesByKind[kind].sprites();\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromsprite block=\"projectile %img=screen_image_picker from %sprite=variables_get(mySprite) with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-sprite\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSprite(img: Image, sprite: Sprite, vx: number, vy: number): Sprite {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile, sprite);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritekind||from sprite %sprite=variables_get(mySprite)\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    //% vy.defl=100\n    //% deprecated=true blockHidden=true\n    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind || SpriteKind.Projectile);\n        const sc = game.currentScene();\n        s.vx = vx\n        s.vy = vy\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n\n        while(vx == 0 && vy == 0) {\n            vx = Math.randomRange(-100, 100);\n            vy = Math.randomRange(-100, 100);\n        }\n\n        if (vx < 0)\n            s.x = screen.width + xOff\n        else if (vx > 0)\n            s.x = -xOff\n\n        if (vy < 0)\n            s.y = screen.height + yOff\n        else if (vy > 0)\n            s.y = -yOff\n\n        s.flags |= sprites.Flag.AutoDestroy;\n        s.flags |= sprites.Flag.DestroyOnWall;\n\n        if (sprite) {\n            s.x = sprite.x;\n            s.y = sprite.y;\n        }\n\n        return s\n    }\n\n    export enum Flag {\n        None = 0, // no flags are set\n        Ghost = 1 << 0, // doesn't collide with other sprites\n        Destroyed = 1 << 1,\n        AutoDestroy = 1 << 2, // remove the sprite when no longer visible\n        StayInScreen = 1 << 3, // sprite cannot move outside the camera region\n        DestroyOnWall = 1 << 4, // destroy sprite on contact with wall\n        BounceOnWall = 1 << 5, // Bounce on walls\n        ShowPhysics = 1 << 6, // display position, velocity, acc\n        Invisible = 1 << 7, // makes the sprite invisible, so it does not show up on the screen\n    }\n}\n",
            "spriteset.ts": "/* \n* A set of sprites \n*/\nclass SpriteSet {\n    private _sprites: Sprite[];\n\n    /**\n     * Create a new set from an array of sprites\n     * @param sprites \n     */\n    static createFromArray(sprites: Sprite[]): SpriteSet {\n        const sp = new SpriteSet();\n        const n = sprites.length;\n        for(let i = 0; i < n; ++i)\n            sp.add(sprites[i]);\n        return sp;\n    }\n\n    constructor() {\n        this._sprites = [];\n    }\n\n    /**\n     * Gets the number of sprites in the set\n     */\n    get length() {\n        return this._sprites.length;\n    }\n\n    /**\n     * Gets the snapshot of the current list of sprites\n     */\n    sprites() {\n        return this._sprites.slice(0, this._sprites.length);\n    }\n\n    /**\n     * Adds the sprite, returns true if added; false if the sprite was already in the set\n     * @param sprite \n     */\n    add(sprite: Sprite): boolean {\n        if (!sprite) return false; // don't add nulls\n\n        // scan if in set\n        if (this.contains(sprite))\n            return false;\n        this._sprites.push(sprite);\n        return true;\n    }\n\n    /**\n     * Adds sprite and removes from old set. Returns true if sprite was in old set and not in new set.\n     * @param oldSet \n     * @param sprite \n     */\n    addFrom(oldSet: SpriteSet, sprite: Sprite): boolean {\n        const removed = oldSet.remove(sprite);\n        const added = this.add(sprite);\n        return removed && added;\n    }\n\n    /**\n     * Removes sprite from set. Returns true if the sprite was in the set\n     * @param sprite \n     */\n    remove(sprite: Sprite): boolean {\n        const i = this._sprites.indexOf(sprite);\n        if (i > -1) {\n            this._sprites.splice(i, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the sprite is part of the set\n     * @param sprite \n     */\n    contains(sprite: Sprite): boolean {\n        return this._sprites.indexOf(sprite) > -1;\n    }\n\n    /** \n     * Removes all the sprites from the set\n    */\n    clear() {\n        this._sprites.splice(0, this._sprites.length);\n    }\n\n    /**\n     * Removes the last sprite in the set\n     */\n    pop(): Sprite {\n        return this._sprites.pop();\n    }\n\n    toString() {\n        return `${this.length} sprites`\n    }\n}",
            "systemmenu.ts": "namespace scene.systemMenu {\n    let instance: PauseMenu;\n    let customMenuOptions: MenuOption[];\n\n    export enum CardState {\n        Selected,\n        Active,\n        None\n    }\n\n    export interface MenuTheme {\n        cardSpacing: number;\n        cardWidth: number;\n        cardsPerRow: number;\n        padding: number;\n        cardsTop: number;\n        infoTop: number;\n\n        // \"PAUSED\"\n        headerText: string;\n\n        headerFont: image.Font;\n        infoFont: image.Font;\n\n        selectedCard: Image;\n        activeCard: Image;\n        basicCard: Image;\n    }\n\n    export class MenuOption {\n        protected card: Sprite;\n        protected icon: Sprite;\n\n        protected top: number;\n        protected state: CardState;\n\n        protected theme: MenuTheme;\n\n        constructor(protected iconImage: Image, public getText: () => string, public action: () => void) {\n        }\n\n        show() {\n            this.card = sprites.create(this.theme ? this.theme.basicCard : CARD_NORMAL);\n            this.card.z = 1;\n\n            this.icon = sprites.create(this.iconImage);\n            this.icon.z = 2;\n\n            this.state = CardState.None;\n        }\n\n        position(left: number, top: number) {\n            this.top = top;\n\n            this.card.left = left;\n            this.card.top = top;\n\n            this.icon.x = this.card.x;\n            this.icon.y = this.card.y;\n        }\n\n        setOffset(offset: number) {\n            this.card.top = this.top + offset;\n            this.icon.y = this.card.y;\n        }\n\n        setTheme(theme: MenuTheme) {\n            this.theme = theme;\n            this.updateCard();\n        }\n\n        setState(state: CardState) {\n            if (this.state === state) return;\n            this.state = state;\n            this.updateCard();\n        }\n\n        dispose() {\n            if (this.card) {\n                this.card.destroy();\n                this.icon.destroy();\n                this.card = undefined;\n                this.icon = undefined;\n            }\n        }\n\n        protected updateCard() {\n            if (!this.theme) return;\n            switch (this.state) {\n                case CardState.None: this.card.setImage(this.theme.basicCard); break;\n                case CardState.Selected: this.card.setImage(this.theme.selectedCard); break;\n                case CardState.Active: this.card.setImage(this.theme.activeCard); break;\n            }\n\n            // Center the icon\n            this.icon.x = this.card.x;\n            this.icon.y = this.card.y;\n        }\n    }\n\n    export class PauseMenu {\n        protected options: MenuOption[];\n        protected theme: MenuTheme;\n\n        // Index of selected card\n        protected selection: number;\n\n        // The row that is currently at the top of the screen\n        protected scrollRow: number;\n\n        // The pixel offset for the scrollRow\n        protected scrollTarget: number;\n\n        // The current pixel offset of the scroll (might be animating)\n        protected scrollOffset: number;\n\n        constructor(protected generator: () => MenuOption[], theme?: MenuTheme) {\n            this.theme = theme || buildMenuTheme(CARD_NORMAL.width, 3);\n            this.scrollRow = 0;\n            this.scrollOffset = 0;\n            this.scrollTarget = 0;\n        }\n\n        show() {\n            this.options = this.generator();\n            this.selection = 0;\n\n            let current: MenuOption;\n            for (let i = 0; i < this.options.length; i++) {\n                current = this.options[i];\n                current.show();\n                current.setTheme(this.theme);\n                current.position(\n                    this.theme.padding + (i % this.theme.cardsPerRow) * (this.theme.cardWidth + this.theme.cardSpacing),\n                    this.theme.cardsTop + (Math.idiv(i, this.theme.cardsPerRow) * (this.theme.cardWidth + this.theme.cardSpacing))\n                );\n            }\n\n            controller._setUserEventsEnabled(false);\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                if (!this.options || !this.options[this.selection]) return;\n                this.options[this.selection].setState(CardState.Active);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_UP, () => {\n                if (!this.options || !this.options[this.selection]) return;\n                this.options[this.selection].setState(CardState.Selected);\n                control.runInParallel(this.options[this.selection].action)\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                closeMenu();\n            });\n\n            controller.menu.onEvent(SYSTEM_KEY_DOWN, () => {\n                closeMenu();\n            });\n\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.max(0, this.selection - this.theme.cardsPerRow));\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.max(0, this.selection - 1));\n            });\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.min(this.options.length - 1, this.selection + this.theme.cardsPerRow));\n            });\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.min(this.options.length - 1, this.selection + 1));\n            });\n\n            game.onShade(() => {\n                this.onUpdate();\n                this.drawText();\n            });\n\n            this.setSelection(0);\n        }\n\n        onUpdate() {\n            // Should probably factor out this animation\n            let t = control.millis() / 250;\n            for (let i = 0; i < this.options.length; i++) {\n                this.options[i].setOffset(2 * Math.sin(t - (i % this.theme.cardsPerRow) * (Math.PI / 2)))\n            }\n\n            const dt = game.currentScene().eventContext.deltaTime;\n            if (this.scrollOffset < this.scrollTarget) {\n                this.scrollOffset += dt * 100;\n            }\n            else if (this.scrollOffset > this.scrollTarget) {\n                this.scrollOffset -= dt * 100;\n            }\n            else {\n                return;\n            }\n\n            if (Math.abs(this.scrollOffset - this.scrollTarget) < 2) {\n                this.scrollOffset = this.scrollTarget;\n            }\n\n            game.currentScene().camera.offsetY = this.scrollOffset;\n        }\n\n        setSelection(selection: number) {\n            if (!this.options) return;\n\n            if (this.options[this.selection]) {\n                this.options[this.selection].setState(CardState.None);\n            }\n\n            this.selection = selection;\n\n            if (this.options[this.selection]) {\n                this.options[this.selection].setState(controller.A.isPressed() ? CardState.Active : CardState.Selected);\n            }\n\n            this.updateScrollTarget();\n        }\n\n        drawText() {\n            if (!this.options) return;\n\n            // Black bar to draw the header on\n            screen.fillRect(0, 0, screen.width, this.theme.cardsTop - 2, 15);\n\n            // Header text\n            screen.printCenter(this.theme.headerText, 2, 1, this.theme.headerFont);\n\n            // Black bar for the info box to draw on\n            screen.fillRect(0, this.theme.infoTop - 3, screen.width, screen.height - this.theme.infoTop + 6, 15);\n\n            // White info box\n            screen.fillRect(this.theme.padding, this.theme.infoTop, screen.width - (this.theme.padding << 1), this.theme.infoFont.charHeight + 1, 1);\n\n            // Info text\n            screen.printCenter(this.options[this.selection].getText(), this.theme.infoTop + 1, 15, this.theme.infoFont);\n        }\n\n        dispose() {\n            if (this.options) {\n                this.options.forEach(o => o.dispose());\n                this.options = undefined;\n            }\n        }\n\n        protected updateScrollTarget() {\n            const row = Math.idiv(this.selection, this.theme.cardsPerRow);\n\n            // FIXME: Assumes that there are always two rows on screen\n            if (row === this.scrollRow || row - 1 === this.scrollRow) return;\n\n            if (row > this.scrollRow) this.scrollRow++;\n            else this.scrollRow--;\n\n            this.scrollTarget = this.scrollRow * (this.theme.cardSpacing + this.theme.cardWidth);\n        }\n    }\n\n    // we intentionally only save volume when the user explicitly adjusts it\n    // we don't want to save it when adjusted programatically, because it could for example changing in a loop\n    function setVolume(newVolume: number) {\n        music.setVolume(newVolume);\n        music.playTone(440, 500);\n        settings.writeNumber(\"#volume\", newVolume)\n    }\n\n    function volumeUp() {\n        const v = music.volume();\n        const remainder = v % 32;\n        const newVolume = v + 32 - remainder;\n        setVolume(newVolume);\n    }\n\n    function volumeDown() {\n        const v = music.volume();\n        const remainder = v % 32;\n        const newVolume = v - (remainder ? remainder : 32);\n        setVolume(newVolume);\n    }\n\n    function brightnessUp() {\n        screen.setBrightness(screen.brightness() + 10);\n    }\n\n    function brightnessDown() {\n        screen.setBrightness(screen.brightness() - 10);\n    }\n\n    function toggleStats() {\n        game.stats = !game.stats;\n    }\n\n    function toggleConsole() {\n        if (game.consoleOverlay.isVisible())\n            game.consoleOverlay.setVisible(false);\n        else {\n            game.consoleOverlay.setVisible(true);\n            console.log(\"console\");\n        }\n    }\n\n    function sleep() {\n        power.deepSleep();\n    }\n\n    function closeMenu() {\n        if (instance) {\n            instance.dispose();\n            instance = undefined;\n            controller._setUserEventsEnabled(true);\n            game.popScene();\n        }\n    }\n\n    export function buildOptionList(): MenuOption[] {\n        let options: MenuOption[] = [];\n\n        options.push(new MenuOption(VOLUME_DOWN_ICON, () => `VOLUME DOWN (${music.volume()})`, volumeDown));\n        options.push(new MenuOption(VOLUME_UP_ICON, () => `VOLUME UP (${music.volume()})`, volumeUp));\n        options.push(new MenuOption(BRIGHTNESS_DOWN_ICON, () => `BRIGHTNESS DOWN (${screen.brightness()})`, brightnessDown));\n        options.push(new MenuOption(BRIGHTNESS_UP_ICON, () => `BRIGHTNESS UP (${screen.brightness()})`, brightnessUp));\n        options.push(new MenuOption(STATS_ICON, () => game.stats ? \"HIDE STATS\" : \"SHOW STATS\", toggleStats));\n        options.push(new MenuOption(CONSOLE_ICON, () => game.consoleOverlay.isVisible() ? \"HIDE CONSOLE\" : \"SHOW CONSOLE\", toggleConsole));\n        options.push(new MenuOption(SLEEP_ICON, () => \"SLEEP\", sleep));\n\n        if (customMenuOptions) {\n            options = options.concat(customMenuOptions);\n        }\n\n        options.push(new MenuOption(CLOSE_MENU_ICON, () => \"CLOSE\", closeMenu));\n\n        return options;\n    }\n\n    export function buildMenuTheme(cardWidth: number, cardSpacing: number, infoFont?: image.Font, headerFont?: image.Font): MenuTheme {\n        const cardsPerRow = Math.idiv(screen.width, cardWidth + cardSpacing);\n        infoFont = infoFont || image.font8;\n        headerFont = headerFont || image.doubledFont(infoFont);\n\n        return {\n            cardSpacing: cardSpacing,\n            cardWidth: cardWidth,\n            cardsPerRow: cardsPerRow,\n            padding: (screen.width - (cardsPerRow * cardWidth + (cardsPerRow - 1) * cardSpacing)) >> 1,\n            infoFont: infoFont,\n            headerFont: headerFont,\n            cardsTop: headerFont.charHeight + 2 + cardSpacing,\n            infoTop: screen.height - infoFont.charHeight - 2,\n            headerText: \"PAUSED\",\n            selectedCard: CARD_SELECTED,\n            activeCard: CARD_ACTIVE,\n            basicCard: CARD_NORMAL\n        };\n    }\n\n    export function addEntry(name: () => string, clickHandler: () => void, icon: Image) {\n        if (!customMenuOptions) customMenuOptions = [];\n        customMenuOptions.push(new MenuOption(icon, name, clickHandler));\n    }\n\n    export function register() {\n        if (instance) return; // don't show system menu, while in system menu\n\n        controller.menu.onEvent(ControllerButtonEvent.Pressed, showSystemMenu);\n    }\n\n    export function showSystemMenu() {\n        if (instance) return;\n        game.pushScene();\n        instance = new PauseMenu(buildOptionList);\n        instance.show();\n    }\n\n    export function isVisible() {\n        return !!instance;\n    }\n\n    function initVolume() {\n        const vol = settings.readNumber(\"#volume\")\n        if (vol != null)\n            music.setVolume(vol)\n    }\n\n    initVolume()\n    scene.Scene.initializers.push(register);\n}\n",
            "systemmenuicons.ts": "namespace scene.systemMenu {\n    export const CARD_NORMAL = img`\n        . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .\n        . 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 .\n        1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1\n        . 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 .\n        . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .\n    `;\n    export const CARD_SELECTED = img`\n        . . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .\n        . 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 .\n        2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2\n        2 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 3 2\n        2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2\n        . 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 .\n        . . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .\n    `;\n    export const CARD_ACTIVE = img`\n        . . 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 . .\n        . 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 .\n        4 4 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4\n        4 3 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 3 4\n        4 4 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4\n        . 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 .\n        . . 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 . .\n    `;\n    export const VOLUME_UP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . c c c b b . . . . . . . . . 6 6 7 . . . . .\n        . . . . . . . . . c b 1 1 d b b . . . . . . . . 6 6 6 6 . . . .\n        . . . . . . . . c d 1 d c b d b . . . . . 6 7 . . 6 6 6 7 . . .\n        . . . . . c c c b 1 d c c c b d b . . . . 6 6 6 . 7 6 6 6 . . .\n        . . c c c c b c 1 1 b c c c c d b . . . . 7 6 6 7 . 6 6 6 7 . .\n        . c b d c b 1 b 1 1 c c c c c b c . d 7 . . 6 6 6 . 7 6 6 6 . .\n        . c d b b 1 1 b 1 d c d b c c b c . 7 6 7 . 7 6 6 . 7 6 6 6 . .\n        . f d b b d 1 b d d b d d c c b c . . 6 6 . 7 6 6 . 7 6 6 6 . .\n        . f d b b d d b d d b d b c f b c . . 6 6 . 7 6 6 . 7 6 6 6 . .\n        . f d b b b d b d d f b c f f b c . 7 6 7 . 7 6 6 . 7 6 6 6 . .\n        . f b d c b b b d d f f f f f b c . d 7 . . 6 6 6 . 7 6 6 6 . .\n        . . f f f f b c d d c f f f c d b . . . . 7 6 6 7 . 6 6 6 7 . .\n        . . . . . f f f b 1 d f f f b d b . . . . 6 6 6 . 7 6 6 6 . . .\n        . . . . . . . . c d 1 d c b d b . . . . . 6 7 . . 6 6 6 7 . . .\n        . . . . . . . . . c b 1 1 d b b . . . . . . . . 6 6 6 6 . . . .\n        . . . . . . . . . . c c c c b . . . . . . . . . 6 6 7 . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const BRIGHTNESS_DOWN_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . b b b . . . . . . . . . . . . . .\n        . . . . . . . . . . . b . . . 4 5 4 . . . b . . . . . . . . . .\n        . . . . . . . . . . b 5 4 . . . 4 . . . 4 5 b . . . . . . . . .\n        . . . . . . . . . b 5 5 4 . . . . . . . 4 5 5 b . . . . . . . .\n        . . . . . . . . . . b 4 . . . 4 4 4 . . . 4 4 . . . . . . . . .\n        . . . . . . . . . . . . . 4 4 5 5 5 4 4 . . . . . . . . . . . .\n        . . . . . . . . . . . . . 4 5 5 1 1 5 4 . . . . . . . . . . . .\n        . . . . . . . . b 4 . . 4 d 5 5 1 1 5 d 4 . . 4 b . . . . . . .\n        . . . . . . . . b 5 4 . b d d 5 5 5 d d b . 4 5 b . . . . . . .\n        . . . . . . . . b 4 . . b d d d d d d d b . . 4 b . . . . . . .\n        . . . . . . . . . . . . . b d d d d d b . . . . . . . . . . . .\n        . . . . . . . . . . . . . b b d d d b b . . . . . . . . . . . .\n        . . . . . . . . . . 4 4 . . . b b b . . . 4 4 . . . . . . . . .\n        . . . . . . . . . b 5 5 4 . . . . . . . 4 5 5 b . . . . . . . .\n        . . . . . . . . . . b 5 4 . . . 4 . . . 4 5 b . . . . . . . . .\n        . . . . . . . . . . . b . . . 4 5 4 . . . b . . . . . . . . . .\n        . . . . . . . . . . . . . . . b b b . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const CLOSE_MENU_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . 2 2 . . . . . . . . . . . . . . 2 2 . . . . . . .\n        . . . . . . . 2 2 2 . . . . . . . . . . . . 2 2 2 . . . . . . .\n        . . . . . . . . 2 2 2 . . . . . . . . . . 2 2 2 . . . . . . . .\n        . . . . . . . . . 2 2 2 . . . . . . . . 2 2 2 . . . . . . . . .\n        . . . . . . . . . . 2 2 2 . . . . . . 2 2 2 . . . . . . . . . .\n        . . . . . . . . . . . 2 2 2 . . . . 2 2 2 . . . . . . . . . . .\n        . . . . . . . . . . . . 2 2 2 . . 2 2 2 . . . . . . . . . . . .\n        . . . . . . . . . . . . . 2 2 2 2 2 2 . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 2 2 2 2 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 2 2 2 2 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . 2 2 2 2 2 2 . . . . . . . . . . . . .\n        . . . . . . . . . . . . 2 2 2 . . 2 2 2 . . . . . . . . . . . .\n        . . . . . . . . . . . 2 2 2 . . . . 2 2 2 . . . . . . . . . . .\n        . . . . . . . . . . 2 2 2 . . . . . . 2 2 2 . . . . . . . . . .\n        . . . . . . . . . 2 2 2 . . . . . . . . 2 2 2 . . . . . . . . .\n        . . . . . . . . 2 2 2 . . . . . . . . . . 2 2 2 . . . . . . . .\n        . . . . . . . 2 2 2 . . . . . . . . . . . . 2 2 2 . . . . . . .\n        . . . . . . . 2 2 . . . . . . . . . . . . . . 2 2 . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const VOLUME_DOWN_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . c c c b b . . . . . . . . . . . .\n        . . . . . . . . . . . . . . c b 1 1 d b b . . . . . . . . . . .\n        . . . . . . . . . . . . . c d 1 d c b d b . . . . . . . . . . .\n        . . . . . . . . . . c c c b 1 d c c c b d b . . . . . . . . . .\n        . . . . . . . c c c c b c 1 1 b c c c c d b . . . . . . . . . .\n        . . . . . . c b d c b 1 b 1 1 c c c c c b c . d 7 . . . . . . .\n        . . . . . . c d b b 1 1 b 1 d c d b c c b c . 7 6 7 . . . . . .\n        . . . . . . f d b b d 1 b d d b d d c c b c . . 6 6 . . . . . .\n        . . . . . . f d b b d d b d d b d b c f b c . . 6 6 . . . . . .\n        . . . . . . f d b b b d b d d f b c f f b c . 7 6 7 . . . . . .\n        . . . . . . f b d c b b b d d f f f f f b c . d 7 . . . . . . .\n        . . . . . . . f f f f b c d d c f f f c d b . . . . . . . . . .\n        . . . . . . . . . . f f f b 1 d f f f b d b . . . . . . . . . .\n        . . . . . . . . . . . . . c d 1 d c b d b . . . . . . . . . . .\n        . . . . . . . . . . . . . . c b 1 1 d b b . . . . . . . . . . .\n        . . . . . . . . . . . . . . . c c c c b . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const SLEEP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . b b b b b b . . . . . . . . . . . . .\n        . . . . . . . . . . . b b d 5 5 5 5 d c c . . . . . . . . . . .\n        . . . . . . . . . . b d 5 5 5 b c c c c c c . . . . . . . . . .\n        . . . . . . . . . b 5 5 5 5 c c c c c c c c c . . . . . . . . .\n        . . . . . . . . b d 5 5 5 b c c c c c d c c c c . . . . . . . .\n        . . . . . . . . b 5 5 5 5 c c c c c b 5 b c c c . . . . . . . .\n        . . . . . . . b d 5 5 5 5 c c c c d 5 5 5 d c d c . . . . . . .\n        . . . . . . . b 5 5 5 5 5 c c c c b 5 5 5 b c d c . . . . . . .\n        . . . . . . . c 5 5 5 5 5 c c c c c 5 b 5 c c d c . . . . . . .\n        . . . . . . . c 5 5 5 5 5 b c c c c c c c c b d c . . . . . . .\n        . . . . . . . c d 5 5 5 5 5 c c c c c c c c d d c . . . . . . .\n        . . . . . . . c d d 5 5 5 d d b c c c c b d d d c . . . . . . .\n        . . . . . . . . c d d d d d d d d d d d d d d c . . . . . . . .\n        . . . . . . . . c d d d d d d d d d d d d d d c . . . . . . . .\n        . . . . . . . . . c 9 9 d d d d d d d d d 9 c . . . . . . . . .\n        . . . . . . . . . . b 9 9 9 d d d d d 9 9 c . . . . . . . . . .\n        . . . . . . . . . . . b b 9 9 9 9 9 9 c c . . . . . . . . . . .\n        . . . . . . . . . . . . . b b b b c c . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const CONSOLE_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . b b b b b b b b b b b c c . . . . . . . . .\n        . . . . . . . . . b 1 d d d d d d d d d d 1 b c . . . . . . . .\n        . . . . . . . . b 1 1 1 1 1 1 1 1 1 1 1 1 b b c . . . . . . . .\n        . . . . . . . . b d b c c c c c c c c c b b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 1 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 1 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 1 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 1 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 1 6 6 6 1 1 1 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c c c c c c c c c c c b b c . . . . . . . .\n        . . . . . . . . c b b b b b b b b b b b b b c . . . . . . . . .\n        . . . . . . . . . c c c c c c c c c c c c c . . . . . . . . . .\n        . . . . . . . . . . . . . c c c c c c . . . . . . . . . . . . .\n        . . . . . . . . . c c c c b b b b b b c c c c c . . . . . . . .\n        . . . . . . . . c 1 1 b 1 1 b 1 1 b 1 1 b d d c . . . . . . . .\n        . . . . . . . c d d d d d d d d d d d d d b c . . . . . . . . .\n        . . . . . . . c c c c c c c c c c c c c c c . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const BRIGHTNESS_UP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . 4 4 . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 4 5 5 4 . . . . . . . . . . . . . .\n        . . . . . . . . 4 4 b . . . b b b b . . . b 4 4 . . . . . . . .\n        . . . . . . . 4 5 5 b . . . . . . . . . . b 5 5 4 . . . . . . .\n        . . . . . . . 4 5 b . . . . 4 4 4 4 . . . . b 5 4 . . . . . . .\n        . . . . . . . b b . . . 4 4 5 5 5 5 4 4 . . . b b . . . . . . .\n        . . . . . . . . . . . 4 d 5 5 5 5 5 5 d 4 . . . . . . . . . . .\n        . . . . . . . . . . 4 d 5 5 5 5 5 1 1 5 d 4 . . . . . . . . . .\n        . . . . . . . . . . 4 5 5 5 5 5 5 1 1 5 5 4 . . . . . . . . . .\n        . . . . . . 4 b . 4 d 5 5 5 5 5 5 5 5 5 5 d 4 . b 4 . . . . . .\n        . . . . . 4 5 b . 4 d 5 5 5 5 5 5 5 5 5 5 d 4 . b 5 4 . . . . .\n        . . . . . 4 5 b . b d 5 5 5 5 5 5 5 5 5 5 d b . b 5 4 . . . . .\n        . . . . . . 4 b . b d d 5 5 5 5 5 5 5 5 d d b . b 4 . . . . . .\n        . . . . . . . . . . b d d 5 5 5 5 5 5 d d b . . . . . . . . . .\n        . . . . . . . . . . b d d d d d d d d d d b . . . . . . . . . .\n        . . . . . . . . . . . b d d d d d d d d b . . . . . . . . . . .\n        . . . . . . . b b . . . b b d d d d b b . . . b b . . . . . . .\n        . . . . . . . 4 5 b . . . . b b b b . . . . b 5 4 . . . . . . .\n        . . . . . . . 4 5 5 b . . . . . . . . . . b 5 5 4 . . . . . . .\n        . . . . . . . . 4 4 b . . . b b b b . . . b 4 4 . . . . . . . .\n        . . . . . . . . . . . . . . 4 5 5 4 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . 4 4 . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const STATS_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . b b b b . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . b 5 5 b b . b b b b b b . . . . . . . . . . . . . .\n        . . . . . . b 5 b d c c b d d d 5 5 b b . . . . . . . . . . . .\n        . . . . . . b b d b c d d b b b b d 5 5 b . . . . . . . . . . .\n        . . . . . . b b b c d d b 1 1 1 1 1 b d 5 b . . . . . . . . . .\n        . . . . . . . . c b d b 1 1 1 1 1 1 1 d b 5 b . . . . . . . . .\n        . . . . . . . . b 5 b d 1 1 b 1 1 1 1 1 d d 5 b . . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 d b 1 1 b 1 1 b 5 b . . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 1 b b 1 b 9 9 1 d 5 b . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 1 1 b b b 9 9 9 b 5 b . . . . . . .\n        . . . . . . . b b 5 5 d 1 1 1 9 9 b b 9 9 9 b 5 b . . . . . . .\n        . . . . . . . b d b 5 b 1 1 9 9 9 9 9 9 9 9 c 5 b . . . . . . .\n        . . . . . . . b d b 5 5 b 1 9 9 9 9 9 9 9 d b 5 b . . . . . . .\n        . . . . . . . . b d b 5 5 b 9 9 9 9 9 9 9 c 5 d . . . . . . . .\n        . . . . . . . . c d d b 5 5 b b 9 9 9 d c b 5 b . . . . . . . .\n        . . . . . . . . . c d d b 5 5 5 b c c b 5 5 b . . . . . . . . .\n        . . . . . . . . . . c b b b d 5 5 5 5 5 d b . . . . . . . . . .\n        . . . . . . . . . . . c c b b b b b b b b . . . . . . . . . . .\n        . . . . . . . . . . . . . c c c c c c . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n}",
            "targetoverrides.cpp": "// Overriden in target\n",
            "targetoverrides.ts": "// Overriden in target\n",
            "textDialogs.ts": "enum DialogLayout {\n    //% block=bottom\n    Bottom,\n    //% block=left\n    Left,\n    //% block=right\n    Right,\n    //% block=top\n    Top,\n    //% block=center\n    Center,\n    //% block=\"full screen\"\n    Full\n}\n\nnamespace game {\n    let dialogFrame: Image;\n    let dialogCursor: Image;\n    let dialogTextColor: number;\n\n    export class BaseDialog {\n        image: Image;\n        frame: Image;\n        cursor: Image;\n\n        columns: number;\n        rows: number;\n        unit: number;\n\n        innerLeft: number;\n        innerTop: number;\n        cursorCount: number;\n\n        font: image.Font;\n        textColor: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            this.image = image.create(width, height);\n\n            this.frame = frame || dialogFrame || (dialogFrame = defaultFrame());\n\n            this.font = font || image.font8;\n\n            this.cursor = cursor || dialogCursor || (dialogCursor = defaultCursorImage());\n\n            this.textColor = dialogTextColor == undefined ? dialogTextColor = 15 : dialogTextColor;\n\n            this.unit = Math.floor(this.frame.width / 3);\n            this.columns = Math.floor(width / this.unit);\n            this.rows = Math.floor(height / this.unit);\n\n            this.innerLeft = (width - (this.columns * this.unit)) >> 1;\n            this.innerTop = (height - (this.rows * this.unit)) >> 1;\n\n            this.cursorCount = 0;\n\n            this.drawBorder();\n            this.clearInterior();\n        }\n\n        update() {\n            this.clearInterior();\n            this.drawTextCore();\n            this.drawCursorRow();\n        }\n\n        setText(rawString: string) {\n            // implemented by subclass\n        }\n\n        drawTextCore() {\n            // Implemented by subclass\n        }\n\n        drawCursorRow() {\n            let offset = 0;\n            if (this.cursorCount > 20) {\n                offset = 1;\n            }\n\n            this.cursorCount = (this.cursorCount + 1) % 40;\n\n            this.image.drawTransparentImage(\n                this.cursor,\n                this.innerLeft + this.textAreaWidth() + this.unit + offset - this.cursor.width,\n                this.innerTop + this.unit + this.textAreaHeight() + 1 - this.cursorRowHeight()\n            )\n        }\n\n        protected drawBorder() {\n            for (let c = 0; c < this.columns; c++) {\n                if (c == 0) {\n                    this.drawPartial(0, 0, 0);\n                    this.drawPartial(6, 0, this.rows - 1);\n                }\n                else if (c === this.columns - 1) {\n                    this.drawPartial(2, c, 0);\n                    this.drawPartial(8, c, this.rows - 1);\n                }\n                else {\n                    this.drawPartial(1, c, 0);\n                    this.drawPartial(7, c, this.rows - 1);\n                }\n            }\n\n            for (let r = 1; r < this.rows - 1; r++) {\n                this.drawPartial(3, 0, r);\n                this.drawPartial(5, this.columns - 1, r);\n            }\n        }\n\n        protected clearInterior() {\n            for (let d = 1; d < this.columns - 1; d++) {\n                for (let s = 1; s < this.rows - 1; s++) {\n                    this.drawPartial(4, d, s)\n                }\n            }\n        }\n\n        protected drawPartial(index: number, colTo: number, rowTo: number) {\n            const x0 = this.innerLeft + colTo * this.unit;\n            const y0 = this.innerTop + rowTo * this.unit;\n\n            const xf = (index % 3) * this.unit;\n            const yf = Math.floor(index / 3) * this.unit;\n\n            for (let e = 0; e < this.unit; e++) {\n                for (let t = 0; t < this.unit; t++) {\n                    this.image.setPixel(\n                        x0 + e,\n                        y0 + t,\n                        this.frame.getPixel(xf + e, yf + t));\n                }\n            }\n        }\n\n        protected cursorRowHeight() {\n            return this.cursor.height + 1;\n        }\n\n        protected rowHeight() {\n            return this.font.charHeight + 1;\n        }\n\n        protected textAreaWidth() {\n            return this.image.width - ((this.innerLeft + this.unit) << 1) - 2;\n        }\n\n        protected textAreaHeight() {\n            return this.image.height - ((this.innerTop + this.unit) << 1) - 1;\n        }\n\n        protected setFont(font: image.Font) {\n            this.font = font;\n        }\n    }\n\n    export class Dialog extends BaseDialog {\n        chunks: string[];\n        chunkIndex: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            super(width, height, frame, font, cursor);\n\n            this.chunkIndex = 0;\n        }\n\n        hasNext() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex < this.chunks.length - 1;\n        }\n\n        hasPrev() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex > 0;\n        }\n\n        nextPage() {\n            if (this.hasNext()) {\n                this.chunkIndex++;\n            }\n        }\n\n        prevPage() {\n            if (this.hasPrev()) {\n                this.chunkIndex--;\n            }\n        }\n\n        chunkText(str: string): string[] {\n            const charactersPerRow = Math.floor(this.textAreaWidth() / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(this.textAreaHeight() / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const screens: string[] = [];\n\n            let strIndex = 0;\n            let rowIndex = 0;\n            let current = \"\";\n\n            while (strIndex < str.length) {\n                const currRowCharacters = rowIndex < rowsOfCharacters - rowsWithCursor ?\n                    charactersPerRow : charactersPerCursorRow;\n                const lastIndex = strIndex + currRowCharacters - 1;\n\n                if (str.charAt(lastIndex) === \" \" || lastIndex >= str.length - 1) {\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters;\n                }\n                else if (str.charAt(lastIndex + 1) === \" \") {\n                    // No need to break, but consume the space\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters + 1;\n                }\n                else if (str.charAt(lastIndex - 1) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 1) + \" \";\n                    strIndex += currRowCharacters - 1;\n                }\n                else if (str.charAt(lastIndex - 2) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 2) + \"  \";\n                    strIndex += currRowCharacters - 2;\n                }\n                else {\n                    // Insert a break\n                    current += str.substr(strIndex, currRowCharacters - 1) + \"-\";\n                    strIndex += currRowCharacters - 1;\n                }\n\n                rowIndex++;\n                if (rowIndex >= rowsOfCharacters) {\n                    rowIndex = 0;\n                    screens.push(current);\n                    current = \"\";\n                }\n            }\n\n            // Only pushes the last part of the message to the screen when current isn't empty\n            if (current) {\n                screens.push(current);\n            }\n\n            return screens;\n        }\n\n        setText(rawString: string) {\n            this.chunks = this.chunkText(rawString);\n            this.chunkIndex = 0;\n            this.setFont(image.getFontForText(rawString));\n        }\n\n        drawTextCore() {\n            if (!this.chunks || this.chunks.length === 0) return;\n            const str = this.chunks[this.chunkIndex];\n            const availableWidth = this.textAreaWidth();\n            const availableHeight = this.textAreaHeight();\n\n            const charactersPerRow = Math.floor(availableWidth / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(availableHeight / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const textLeft = 1 + this.innerLeft + this.unit + ((availableWidth - charactersPerRow * this.font.charWidth) >> 1);\n            const textTop = 1 + this.innerTop + this.unit + ((availableHeight - rowsOfCharacters * this.rowHeight()) >> 1);\n\n            let current = 0;\n            for (let row = 0; row < rowsOfCharacters; row++) {\n                const currRowCharacters = row % rowsOfCharacters < rowsOfCharacters - rowsWithCursor ?\n                    charactersPerRow : charactersPerCursorRow;\n\n                this.image.print(\n                    str.substr(current, currRowCharacters),\n                    textLeft,\n                    textTop + row * this.rowHeight(),\n                    this.textColor, this.font\n                )\n                current += currRowCharacters;\n            }\n        }\n    }\n\n    export class SplashDialog extends game.BaseDialog {\n        text: string;\n        subtext: string;\n\n        timer: number;\n        offset: number;\n        maxOffset: number;\n        maxSubOffset: number;\n\n        constructor(width: number, height: number) {\n            super(width, height, defaultSplashFrame())\n            this.maxOffset = -1;\n            this.maxSubOffset = -1;\n            this.textColor = 1;\n        }\n\n        private updateFont() {\n            this.setFont(image.getFontForText((this.text || \"\") + (this.subtext || \"\")));\n        }\n\n        setText(text: string) {\n            this.text = text;\n            this.updateFont();\n            this.offset = 0;\n            this.maxOffset = text.length * this.font.charWidth - screen.width + (this.unit << 1);\n            this.timer = 2;\n        }\n\n        setSubtext(sub: string) {\n            this.subtext = sub;\n            this.updateFont();\n            this.maxSubOffset = sub.length * (this.font.charWidth) - screen.width + (this.unit << 1);\n        }\n\n        drawTextCore() {\n            const scrollMax = Math.max(this.maxOffset, this.maxSubOffset);\n            if (this.timer > 0) {\n                this.timer -= game.eventContext().deltaTime;\n                if (this.timer <= 0) {\n                    if (this.offset > 0) {\n                        this.offset = 0;\n                        this.timer = 2;\n                    }\n                }\n            }\n            else {\n                this.offset++;\n                if (this.offset >= scrollMax) {\n                    this.offset = scrollMax;\n                    this.timer = 2;\n                }\n            }\n            const ytitle = 10;\n            if (this.maxOffset < 0) {\n                const left = (this.image.width >> 1) - (this.text.length * this.font.charWidth >> 1)\n                this.image.print(this.text, left, ytitle, this.textColor, this.font)\n            }\n            else {\n                this.image.print(this.text, this.unit - this.offset, ytitle, this.textColor, this.font)\n            }\n\n            if (this.subtext) {\n                const ysub = ytitle + this.font.charHeight + 2;\n                if (this.maxSubOffset < 0) {\n                    const left = (this.image.width >> 1) - (this.subtext.length * this.font.charWidth >> 1)\n                    this.image.print(this.subtext, left, ysub, this.textColor, this.font);\n                }\n                else {\n                    this.image.print(this.subtext, this.unit - (Math.min(this.offset, this.maxSubOffset)), ysub, this.textColor, this.font);\n                }\n            }\n            this.drawBorder();\n        }\n    }\n\n    export class GameOverDialog extends game.BaseDialog {\n        protected cursorOn: boolean;\n        protected isNewHighScore: boolean;\n\n        constructor(\n            protected win: boolean,\n            protected score?: number,\n            protected highScore?: number\n        ) {\n            super(screen.width(), 46, defaultSplashFrame());\n            this.cursorOn = false;\n            this.isNewHighScore = this.score > this.highScore;\n        }\n\n        displayCursor() {\n            this.cursorOn = true;\n        }\n\n        update() {\n            this.clearInterior();\n            this.drawTextCore();\n\n            if (this.cursorOn) {\n                this.drawCursorRow();\n            }\n        }\n\n        drawTextCore() {\n            const titleHeight = 8;\n            this.image.printCenter(\n                this.win ? \"YOU WIN!\" : \"GAME OVER!\",\n                titleHeight,\n                screen.isMono ? 1 : 5,\n                image.font8\n            );\n\n            if (this.score !== undefined) {\n                const scoreHeight = 23;\n                const highScoreHeight = 34;\n                const scoreColor = screen.isMono ? 1 : 2;\n\n                this.image.printCenter(\n                    \"Score:\" + this.score,\n                    scoreHeight,\n                    scoreColor,\n                    image.font8\n                );\n\n                if (this.isNewHighScore) {\n                    this.image.printCenter(\n                        \"New High Score!\",\n                        highScoreHeight,\n                        scoreColor,\n                        image.font5\n                    );\n                } else {\n                    this.image.printCenter(\n                        \"HI\" + this.highScore,\n                        highScoreHeight,\n                        scoreColor,\n                        image.font8\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Show a long text string in a dialog box that will scroll\n     * using the \"A\" or \"down\" buttons. The previous section of the\n     * text is shown using the \"up\" button. This function\n     * halts execution until the last page of text is dismissed.\n     *\n     * @param str The text to display\n     * @param layout The layout to use for the dialog box\n     */\n    //% blockId=game_show_long_text group=\"Dialogs\"\n    //% block=\"show long text %str %layout\"\n    //% help=game/show-long-text\n    export function showLongText(str: string, layout: DialogLayout) {\n        // Pause to cede control from this fiber just in case the user code created\n        // sprites and they haven't had a chance to render yet.\n        pause(1);\n\n        // Clone the current screen so that it shows up behind the dialog\n        let temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n        temp = null;\n\n        let width: number;\n        let height: number;\n        let top: number;\n        let left: number;\n\n        switch (layout) {\n            case DialogLayout.Bottom:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = screen.height - height;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Top:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = 0;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Left:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n            case DialogLayout.Right:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = screen.width - width;\n                break;\n            case DialogLayout.Center:\n                width = Math.idiv(screen.width << 1, 3);\n                height = Math.idiv(screen.width << 1, 3);\n                top = (screen.height - height) >> 1;\n                left = (screen.width - width) >> 1;\n                break;\n            case DialogLayout.Full:\n                width = screen.width;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n        }\n\n        const dialog = new Dialog(width, height);\n        const s = sprites.create(dialog.image, -1);\n        s.top = top;\n        s.left = left;\n\n        dialog.setText(str)\n        let pressed = true;\n        let done = false;\n\n        let upPressed = true;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed() || controller.down.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                if (dialog.hasNext()) {\n                    dialog.nextPage();\n                }\n                else {\n                    scene.setBackgroundImage(null); // GC it\n                    game.popScene();\n                    done = true;\n                }\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n\n            const moveBack = controller.up.isPressed();\n            if (moveBack && !upPressed) {\n                upPressed = true;\n                if (dialog.hasPrev()) {\n                    dialog.prevPage();\n                }\n            }\n            else if (upPressed && !moveBack) {\n                upPressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n\n    function defaultFrame() {\n        return screen.isMono ?\n            img`\n        1 1 1\n        1 . 1\n        1 1 1\n        `\n            :\n            img`\n        . . . . . . . . . . . .\n        . b b b b b b b b b b .\n        . b b b b b b b b b b c\n        . b b d 1 1 1 1 d b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b d 1 1 1 1 d b b c\n        . b b b b b b b b b b c\n        . b b b b b b b b b b c\n        . . c c c c c c c c c c\n        `\n    }\n\n    function defaultSplashFrame() {\n        return screen.isMono ?\n            img`\n        1 1 1\n        . . .\n        1 1 1\n        `\n            :\n            img`\n        1 1 1\n        f f f\n        1 1 1\n        `\n    }\n\n    function defaultCursorImage() {\n        return screen.isMono ?\n            img`\n        1 1 1 1 1 1 1 . . .\n        1 . . 1 . . . 1 . .\n        1 . 1 . 1 . . . 1 .\n        1 . 1 1 1 . . . . 1\n        1 . 1 . 1 . . . 1 .\n        1 . . . . . . 1 . .\n        1 1 1 1 1 1 1 . . .\n        . . . . . . . . . .\n        `\n            :\n            img`\n        0 0 0 6 6 6 6 6 0 0 0\n        0 6 6 7 7 7 7 7 6 6 0\n        0 6 7 7 1 1 1 7 7 6 0\n        6 7 7 1 7 7 7 1 7 7 6\n        6 7 7 1 7 7 7 1 7 7 6\n        6 7 7 1 1 1 1 1 7 7 6\n        6 6 7 1 7 7 7 1 7 6 6\n        8 6 6 1 7 7 7 1 6 6 8\n        8 6 6 7 6 6 6 7 6 6 8\n        0 8 6 6 6 6 6 6 6 8 0\n        0 0 8 8 8 8 8 8 8 0 0\n        `\n    }\n\n    /**\n     * Change the default dialog frame to a new image. Dialog frames\n     * are divided into three rows and three columns and are used to define\n     * the outer frame of the dialog box.\n     *\n     * @param frame A square image with a width and height divisible by three\n     */\n    //% blockId=game_dialog_set_frame group=\"Dialogs\"\n    //% block=\"set dialog frame to %frame=dialog_image_picker\"\n    //% help=game/set-dialog-frame\n    export function setDialogFrame(frame: Image) {\n        dialogFrame = frame;\n    }\n\n    /**\n     * Change the default image used for the cursor that appears in the\n     * bottom left of the dialog box.\n     *\n     * @param cursor The image to use for the cursor\n     */\n    //% blockId=game_dialog_set_cursor group=\"Dialogs\"\n    //% block=\"set dialog cursor to %frame=screen_image_picker\"\n    //% help=game/set-dialog-cursor\n    export function setDialogCursor(cursor: Image) {\n        dialogCursor = cursor;\n    }\n\n    /**\n     * Change the color for the text in dialog boxes.\n     *\n     * @param color The index of the color 0-15\n     */\n    //% blockId=game_dialog_set_text_color group=\"Dialogs\"\n    //% block=\"set dialog text color to %color=colorindexpicker\"\n    //% help=game/set-dialog-text-color\n    export function setDialogTextColor(color: number) {\n        dialogTextColor = Math.floor(Math.min(15, Math.max(0, color)));\n    }\n\n    // this function is deprecated\n    //% deprecated blockHidden\n    export function setDialogFont(font: image.Font) {\n    }\n\n    /**\n     * Show a title and an optional subtitle menu\n     * @param title\n     * @param subtitle\n     */\n    //% weight=90 help=game/splash\n    //% blockId=gameSplash block=\"splash %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function splash(title: string, subtitle?: string) {\n        const temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n\n        const dialog = new SplashDialog(screen.width, subtitle ? 42 : 35);\n        dialog.setText(title);\n        if (subtitle) dialog.setSubtext(subtitle);\n\n        const s = sprites.create(dialog.image, -1);\n        let pressed = true;\n        let done = false;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                scene.setBackgroundImage(null); // GC it\n                game.popScene();\n                done = true;\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n}\n\n",
            "texteffects.ts": "namespace texteffects {\n    export enum TextEffectKind {\n        //% block=none\n        None,\n        //% block=shake\n        Shake,\n        //% block=wave\n        Wave\n    }\n\n    export function getTextEffect(e: TextEffectKind) {\n        switch (e) {\n            case texteffects.TextEffectKind.Wave:\n                return texteffects.wave;\n            case texteffects.TextEffectKind.Shake:\n                return texteffects.shake;\n            default:\n                return null;\n        }\n    }\n \n    //% fixedInstances\n    export class TextEffect {\n        public getState: (index?: number, state?: TextEffectState) => TextEffectState;\n    \n        constructor(getState: (index?: number, state?: TextEffectState) => TextEffectState) {\n            this.getState = getState;\n        }\n    }\n\n    //% fixedInstance\n    export const shake = new TextEffect(() => { \n        return { xOffset: (Math.random() * 2 - 1),\n                 yOffset: (Math.random() * 2 - 1) }\n    });\n\n\n    interface WaveEffectState extends TextEffectState {\n        up: boolean;\n    }\n\n    //% fixedInstance\n    export const wave = new TextEffect((index?: number, state?: WaveEffectState) => {  // TODO cast state type\n        if (!state) {\n            state = {\n                xOffset: 0,\n                yOffset: Math.sin(index) * 2,\n                up: Math.sign(Math.sin(index)) < 0\n            };\n        }\n\n        state.yOffset += (state.up ? 1 : -1) * 0.5;\n        state.up = Math.abs(state.yOffset) > 2 ? !state.up : state.up;\n\n        return state\n    });\n\n    /**\n     * A text sprite on the screen\n     **/\n    export class TextSprite {\n        _str: string\n        _font: image.Font\n        _color: number;\n        _effect: TextEffect\n        _state: TextEffectState[]; // per-character state initialized and used by the effect\n\n        get color(): number {\n            return this._color;\n        }\n\n        get state(): TextEffectState[] {\n            return this._state;\n        }\n\n        constructor(str: string, font: image.Font, color: number, effect?: TextEffect) {\n            this._str = str;\n            this._font = font;\n            this._color = color;\n            this._effect = effect;\n            this._state = [];\n        }\n\n        updateState() {\n            if (!this._effect) return;\n    \n            let i = 0;\n            while (i < this._str.length) {\n                this._state[i] = this._effect.getState(i, (i < this._state.length ? this._state[i] : null));\n                i++;\n            }\n        }\n\n        draw(image: Image, x: number, y: number, start?: number, length?: number): void {\n            this.updateState();\n\n            let s = this._str.substr(Math.max(start, 0), Math.min(length, this._str.length - start));\n            image.print(s, x, y, this._color, this._font, this._state);\n        }\n    }\n}",
            "tilemap.ts": "enum TileScale {\n    //% block=\"8x8\"\n    Eight = 3,\n    //% block=\"16x16\"\n    Sixteen = 4,\n    //% block=\"32x32\"\n    ThirtyTwo = 5\n}\nnamespace tiles {\n\n    class TileSet {\n        obstacle: boolean;\n        private map: TileMap;\n        private originalImage: Image;\n        private cachedImage: Image;\n\n        constructor(image: Image, collisions: boolean, map: TileMap) {\n            this.originalImage = image;\n            this.obstacle = collisions;\n            this.map = map;\n        }\n\n        get image(): Image {\n            const size = 1 << this.map.scale;\n            if (!this.cachedImage || this.cachedImage.width != size || this.cachedImage.height != size) {\n                if (this.originalImage.width == size && this.originalImage.height == size) {\n                    this.cachedImage = this.originalImage;\n                } else {\n                    this.cachedImage = image.create(size, size);\n                    this.cachedImage.drawImage(this.originalImage, 0, 0);\n                }\n            }\n            return this.cachedImage;\n        }\n    }\n\n    /**\n     * A tile in the tilemap\n     **/\n    //% blockNamespace=scene color=\"#401255\" blockGap=8\n    export class Tile {\n        private _row: number;\n        private _col: number;\n        private tileMap: TileMap;\n\n        constructor(col: number, row: number, map: TileMap) {\n            this._col = col;\n            this._row = row;\n            this.tileMap = map;\n        }\n\n        get x(): number {\n            const scale = this.tileMap.scale;\n            return (this._col << scale) + (1 << (scale - 1));\n        }\n\n        get y(): number {\n            const scale = this.tileMap.scale;\n            return (this._row << scale) + (1 << (scale - 1));\n        }\n\n        get tileSet(): number {\n            return this.tileMap.image.getPixel(this._col, this._row) | 0;\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tiles\"\n        //% weight=25\n        //% help=scene/place\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n\n            mySprite.x = this.x;\n            mySprite.y = this.y;\n        }\n    }\n\n    export class TileMap {\n        scale: number\n\n        private _layer: number;\n        private _map: Image;\n        private _tileSets: TileSet[];\n\n        constructor(scale: TileScale = TileScale.Sixteen) {\n            this._tileSets = [];\n            this._layer = 1;\n            this.scale = scale;\n\n            scene.createRenderable(\n                scene.TILE_MAP_Z,\n                (t, c) => this.draw(t, c)\n            );\n        }\n\n        get image(): Image {\n            return this._map;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << this.scale) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << this.scale) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setTile(index: number, img: Image, collisions?: boolean) {\n            if (this.isInvalidIndex(index)) return;\n            this._tileSets[index] = new TileSet(img, collisions, this);\n        }\n\n        setMap(map: Image) {\n            this._map = map;\n        }\n\n        public getTile(col: number, row: number): Tile {\n            return new Tile(col, row, this);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setPixel(col, row, index);\n        }\n\n        public getTilesByType(index: number): Tile[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return [];\n\n            let output: Tile[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getPixel(col, row);\n                    if (currTile === index) {\n                        output.push(new Tile(col, row, this));\n                    }\n                }\n            }\n            return output;\n        }\n\n        private generateTile(index: number): TileSet {\n            const size = 1 << this.scale\n\n            const i = image.create(size, size);\n            i.fill(index);\n            return this._tileSets[index] = new TileSet(i, false, this);\n        }\n\n        private isOutsideMap(col: number, row: number): boolean {\n            return !this.enabled || col < 0 || col >= this._map.width\n                || row < 0 || row >= this._map.height;\n        }\n\n        private isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xf;\n        }\n\n        protected draw(target: Image, camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            // render tile map\n            const bitmask = (0x1 << this.scale) - 1;\n            const offsetX = camera.drawOffsetX & bitmask;\n            const offsetY = camera.drawOffsetY & bitmask;\n\n            const x0 = Math.max(0, camera.drawOffsetX >> this.scale);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + target.width) >> this.scale) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> this.scale);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + target.height) >> this.scale) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getPixel(x, y);\n                    const tile = this._tileSets[index] || this.generateTile(index);\n                    if (tile) {\n                        target.drawTransparentImage(\n                            tile.image,\n                            ((x - x0) << this.scale) - offsetX,\n                            ((y - y0) << this.scale) - offsetY\n                        );\n                    }\n                }\n            }\n\n            if (game.debug) {\n                // render debug grid overlay\n                for (let x = x0; x <= xn; ++x) {\n                    const xLine = ((x - x0) << this.scale) - offsetX;\n                    if (xLine >= 0 && xLine <= screen.width) {\n                        target.drawLine(\n                            xLine,\n                            0,\n                            xLine,\n                            target.height,\n                            1\n                        );\n                    }\n                }\n\n                for (let y = y0; y <= yn; ++y) {\n                    const yLine = ((y - y0) << this.scale) - offsetY;\n                    if (yLine >= 0 && yLine <= screen.height) {\n                        target.drawLine(\n                            0,\n                            yLine,\n                            target.width,\n                            yLine,\n                            1\n                        );\n                    }\n                }\n            }\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this.isOutsideMap(col, row)) return true;\n\n            let t = this._tileSets[this._map.getPixel(col, row)];\n            return t && t.obstacle;\n        }\n\n        public getObstacle(col: number, row: number) {\n            const index = this.isOutsideMap(col, row) ? 0 : this._map.getPixel(col, row);\n            const tile = this._tileSets[index] || this.generateTile(index);\n            return new sprites.StaticObstacle(\n                tile.image,\n                row << this.scale,\n                col << this.scale,\n                this.layer,\n                index\n            );\n        }\n    }\n}\n"
        },
        "game---hw": {
            "ask.ts": "namespace game {\n    /**\n     * Prompts the user for a boolean question\n     * @param title\n     * @param subtitle\n     */\n    //% group=\"Gameplay\"\n    //% weight=89 help=game/ask\n    //% blockId=gameask block=\"ask %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function ask(title: string, subtitle?: string): boolean {\n        game.eventContext(); // initialize the game\n        control.pushEventContext();\n        game.showDialog(title, subtitle, \"A = OK, B = CANCEL\");\n        let answer: boolean = null;\n        // short pause so that players don't skip through prompt\n        pause(500);\n\n        controller.A.onEvent(ControllerButtonEvent.Pressed, () => answer = true);\n        controller.B.onEvent(ControllerButtonEvent.Pressed, () => answer = false);\n        pauseUntil(() => answer !== null);\n        control.popEventContext();\n        return answer;\n    }\n}",
            "background.ts": "enum BackgroundAlignment {\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"right\"\n    Right,\n    //% block=\"top\"\n    Top,\n    //% block=\"bottom\"\n    Bottom,\n    //% block=\"center\"\n    Center\n}\n\nnamespace scene {\n    export class Background {\n        color: number;\n        _image: Image;\n        camera: Camera;\n        private _layers: BackgroundLayer[];\n\n        constructor(camera: Camera) {\n            this.color = 0;\n            this.camera = camera;\n            this._layers = [];\n        }\n\n        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignment) {\n            const layer = new BackgroundLayer(distance, alignment, pic);\n            this._layers.push(layer);\n            this._layers.sort((a, b) => b.distance - a.distance);\n            return layer;\n        }\n\n        get image() {\n            if (!this._image) {\n                this._image = image.create(screen.width, screen.height);\n            }\n            return this._image;\n        }\n        \n        set image(image: Image) {\n            this._image = image;\n        }\n\n        hasBackgroundImage(): boolean {\n            return !!this._image;\n        }\n\n        draw() {\n            screen.fill(this.color);\n            if (this._image)\n                screen.drawTransparentImage(this._image, 0, 0)\n            if (this._layers) {\n                this._layers.forEach(layer => {\n                    // compute displacement based on distance\n                    const ox = Math.round(this.camera.drawOffsetX / (1 + layer.distance));\n                    const oy = Math.round(this.camera.drawOffsetY / (1 + layer.distance));\n                    layer.draw(ox, oy);\n                });\n            }\n        }\n    }\n\n\n    export class BackgroundLayer {\n        distance: number;\n        img: Image;\n        repeatX: boolean;\n        repeatY: boolean;\n        alignX: BackgroundAlignment;\n        alignY: BackgroundAlignment;\n\n        constructor(distance: number, alignment: BackgroundAlignment, img: Image) {\n            this.distance = Math.max(1, distance);\n            this.img = img;\n            switch (alignment) {\n                case BackgroundAlignment.Center:\n                    this.repeatX = true;\n                    this.repeatY = true;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Left:\n                case BackgroundAlignment.Right:\n                    this.repeatX = false;\n                    this.repeatY = true;\n                    this.alignX = alignment;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Top:\n                case BackgroundAlignment.Bottom:\n                    this.repeatX = true;\n                    this.repeatY = false;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = alignment;\n                    break;\n            }\n        }\n\n        draw(offsetX: number, offsetY: number) {\n            const w = screen.width;\n            const h = screen.height;\n            const pw = this.img.width;\n            const ph = this.img.height;\n\n            if (!pw || !ph) return; // empty image.\n\n            // left, top aligned\n            let rx = -offsetX;\n            let ry = -offsetY;\n\n            switch (this.alignX) {\n                case BackgroundAlignment.Right: rx -= (w + pw); break;\n                case BackgroundAlignment.Center: rx -= (w + pw) >> 1; break;\n            }\n            switch (this.alignY) {\n                case BackgroundAlignment.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignment.Center: ry -= (h + ph) >> 1; break;\n            }\n\n            rx %= w; if (rx < 0) rx += w;\n            ry %= h; if (ry < 0) ry += h;\n\n            // avoid subpixel aliasing\n            rx = Math.floor(rx);\n            ry = Math.floor(ry);\n\n            let y = 0;\n            let py = 0;\n            while (y < h) {\n                py = y % ph;\n                let dh = Math.min(ph - py, h - ry);\n                let x = 0;\n                let rxl = rx;\n                while (x < w) {\n                    let px = x % pw;\n                    let dw = Math.min(pw - px, w - rxl);\n                    screen.drawImage(this.img, rxl, ry);\n                    rxl = (rxl + dw) % w;\n                    x += this.repeatX ? dw : w;\n                }\n                ry = (ry + dh) % h;\n                y += this.repeatY ? dh : h;\n            }\n        }\n    }\n}",
            "basesprite.ts": "interface SpriteLike {\n    z: number;\n    id: number;\n    flags?: number;\n\n    __update(camera: scene.Camera, dt: number): void;\n    __draw(camera: scene.Camera): void;\n    __serialize(offset: number): Buffer;\n}\n\nnamespace sprites {\n    export class BaseSprite implements SpriteLike {\n        protected _z: number;\n        id: number;\n\n        constructor(z: number) {\n            this.z = z;\n\n            // this assigns the sprite an id as a side effect\n            game.currentScene().addSprite(this);\n        }\n\n        __visible(): boolean {\n            return true;\n        }\n\n        get z(): number {\n            return this._z;\n        }\n\n        set z(v: number) {\n            if (this._z !== v) {\n                this._z = v;\n                game.currentScene().flags |= scene.Flag.NeedsSorting;\n            }\n        }\n\n        __draw(camera: scene.Camera) {\n            if (this.__visible()) {\n                this.__drawCore(camera);\n            }\n        }\n\n        __drawCore(camera: scene.Camera) { }\n\n        __update(camera: scene.Camera, dt: number) { }\n\n        __serialize(offset: number): Buffer { return undefined }\n    }\n}",
            "camera.ts": "namespace scene {\n    export class Camera {\n        // coordinate used for all physics computation\n        offsetX: number;\n        offsetY: number;\n        // coordinate used for draw sprites, may including shaking\n        drawOffsetX: number;\n        drawOffsetY: number;\n        sprite: Sprite;\n\n        private shakeStartTime: number;\n        private shakeDuration: number;\n        private shakeAmplitude: number;\n\n        constructor() {\n            this.offsetX = 0;\n            this.offsetY = 0;\n\n            this.drawOffsetX = 0;\n            this.drawOffsetY = 0;\n        }\n\n        shake(amplitude: number = 4, duration: number = 1000) {\n            if (amplitude <= 0 || duration <= 0) {\n                this.shakeStartTime = undefined;\n            } else {\n                // this overrides any existing shake operation            \n                this.shakeStartTime = control.millis();\n                this.shakeAmplitude = amplitude;\n                this.shakeDuration = duration;\n                // don't reset offset, will be recomputed in update\n            }\n        }\n\n        update() {\n            const scene = game.currentScene();\n\n            // if sprite, follow sprite\n            if (this.sprite) {\n                this.offsetX = this.sprite.x - (screen.width >> 1);\n                this.offsetY = this.sprite.y - (screen.height >> 1);\n            }\n\n            // don't escape tile map\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this.offsetX = scene.tileMap.offsetX(this.offsetX);\n                this.offsetY = scene.tileMap.offsetY(this.offsetY);\n            }\n\n            // normalize offset\n            this.offsetX |= 0;\n            this.offsetY |= 0;\n\n            this.drawOffsetX = this.offsetX;\n            this.drawOffsetY = this.offsetY;\n\n            // apply shake if needed\n            if (this.shakeStartTime !== undefined) {\n                const elapsed = control.millis() - this.shakeStartTime;\n                if (elapsed >= this.shakeDuration) {\n                    // we are done!\n                    this.shakeStartTime = undefined;\n                } else {\n                    // compute new shake\n                    const percentComplete = elapsed / this.shakeDuration;\n                    const dampStart = 0.75;\n                    let damp = 1;\n                    if (percentComplete >= dampStart)\n                        damp = Math.max(0, 1 - percentComplete);\n                    const f = this.shakeAmplitude * damp;\n                    const x = (Math.random() * f) >> 0;\n                    const y = (Math.random() * f) >> 0;\n                    // apply to offset\n                    this.drawOffsetX += x;\n                    this.drawOffsetY += y;\n                }\n            }\n        }\n    }\n}",
            "console.ts": "namespace game.consoleOverlay {\n    let consoleColor = 1;\n    let consoleStrings: string[];\n    let tabSize = 8;\n    const marginx = 4;\n    const marginy = 2;\n    const consoleFont = image.font5;\n    const consoleLines = Math.floor(screen.height / (consoleFont.charHeight + marginy)) - 1;\n    const consoleColumns = Math.floor((screen.width - 2 * marginx) / consoleFont.charWidth);\n    console.addListener(listener);\n\n    export function isVisible() {\n        return !!consoleStrings;\n    }\n\n    export function clear() {\n        consoleStrings = [];\n    }\n\n    export function setVisible(value: boolean, col?: number) {\n        if (value != !!consoleStrings)\n            consoleStrings = value ? [] : undefined;\n        if (col !== undefined)\n            consoleColor = col;\n    }\n\n    function listener(priority: ConsolePriority, text: string) {\n        if (!consoleStrings || !text)\n            return;\n\n        // split text into lines\n        text.split(\"\\n\")\n            .filter(line => !!line)\n            .forEach(line => {\n                for (let j = 0; j < line.length; j += consoleColumns) {\n                    consoleStrings.push(line.slice(j, j + consoleColumns));\n                }\n            });\n\n        if (consoleStrings.length > consoleLines) {\n            consoleStrings.splice(0, consoleStrings.length - consoleLines);\n        }\n    }\n\n    export function draw() {\n        if (!consoleStrings || scene.systemMenu.isVisible()) return;\n        const height = consoleFont.charHeight + marginy;\n        const top = 2 + (game.stats ? height : 0);\n        for (let i = 0; i < consoleStrings.length; ++i) {\n            if (consoleStrings[i].indexOf(\"\\t\") >= 0) {\n                const t = consoleStrings[i].split(\"\\t\");\n                let tOff = 0;\n                for (let tab of t) {\n                    let padding = tabSize - ((tOff + tab.length) % tabSize)\n                    screen.print(tab, marginx + (tOff * consoleFont.charWidth), top + i * height, consoleColor, consoleFont);\n                    tOff += tab.length + padding;\n                }\n            }\n            else\n                screen.print(consoleStrings[i], marginx, top + i * height, consoleColor, consoleFont);\n        }\n    }\n}",
            "constants.ts": "const KEY_UP = 2048;\nconst KEY_DOWN = 2049;\nconst INTERNAL_KEY_UP = 2050;\nconst INTERNAL_KEY_DOWN = 2051;\nconst SYSTEM_KEY_UP = 2052;\nconst SYSTEM_KEY_DOWN = 2053;\nconst KEY_REPEAT = 2054;\nconst SYSTEM_KEY_REPEAT = 2055;\n",
            "controller.ts": "enum ControllerButtonEvent {\n    //% block=\"pressed\"\n    Pressed = KEY_DOWN,\n    //% block=\"released\"\n    Released = KEY_UP,\n    //% block=\"repeat\"\n    Repeated = KEY_REPEAT\n}\n\n\nenum ControllerButton {\n    //% block=\"A\"\n    A = 5,\n    //% block=\"B\"\n    B = 6,\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"up\"\n    Up = 2,\n    //% block=\"right\"\n    Right = 3,\n    //% block=\"down\"\n    Down = 4\n}\n\nenum ControllerEvent {\n    //% block=\"connected\"\n    Connected = 1,\n    //% block=\"disconnected\"\n    Disconnected = 2\n}\n\n/**\n * Access to game controls\n */\n//% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n//% groups='[\"Single Player\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace controller {\n    let _userEventsEnabled = true;\n    let defaultRepeatDelay = 500;\n    let defaultRepeatInterval = 30;\n\n    //% fixedInstances\n    export class Button {\n        _owner: Controller;\n        public id: number;\n        //% help=controller/button/repeat-delay\n        public repeatDelay: number;\n        //% help=controller/button/repeat-interval\n        public repeatInterval: number;\n        private _pressed: boolean;\n        private _pressedElasped: number;\n        private _repeatCount: number;\n        private _buttonId: number;\n\n        toString(): string {\n            return `btn ${this.id} ${this._buttonId} ${this._pressed ? \"down\" : \"up\"}`;\n        }\n\n        constructor(id: number, buttonId: number) {\n            this.id = id;\n            this._buttonId = buttonId;\n            this._pressed = false;\n            this.repeatDelay = undefined;\n            this.repeatInterval = undefined;\n            this._repeatCount = 0;\n            if (id > 0) {\n                // this is to deal with the \"anyButton\" hack, which creates a button that is not visible\n                // in the UI, but used in event-handler to simulate the wildcard ANY for matching. As \n                // this button can't actually be pressed, we don't want it to propagate events\n                control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16)\n                control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16)\n            }\n            if (buttonId > -1) {\n                // only add these events when running on real hardware\n                control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_UP, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_DOWN, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n            }\n        }\n\n        private raiseButtonUp() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_UP, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_UP, this.id);\n        }\n\n        private raiseButtonDown() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_DOWN, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n        }\n\n        private raiseButtonRepeat() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_REPEAT, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8 help=controller/button/on-event\n        //% blockId=keyonevent block=\"on %button **button** %event\"\n        //% group=\"Single Player\"\n        onEvent(event: ControllerButtonEvent, handler: () => void) {\n            control.onEvent(event, this.id, handler);\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/pause-until\n        // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n        //% group=\"Single Player\"\n        pauseUntil(event: ControllerButtonEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=keyispressed block=\"is %button **button** pressed\"\n        //% group=\"Single Player\"\n        isPressed() {\n            return this._pressed;\n        }\n\n        setPressed(pressed: boolean) {\n            if (this._pressed != pressed) {\n                power.poke();\n                if (this._owner)\n                    this._owner.connected = true;\n                this._pressed = pressed;\n                if (this._pressed) {\n                    this._pressedElasped = 0;\n                    this.raiseButtonDown();\n                } else {\n                    this._repeatCount = 0;\n                    this.raiseButtonUp();\n                }\n            }\n        }\n\n        __update(dtms: number) {\n            if (!this._pressed) return;\n            this._pressedElasped += dtms;\n\n            const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n            const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n\n            // inital delay\n            if (this._pressedElasped < delay)\n                return;\n\n            // repeat count for this step\n            const count = Math.floor((this._pressedElasped - delay - interval) / interval);\n            if (count != this._repeatCount) {\n                this.raiseButtonRepeat();\n                this._repeatCount = count;\n            }\n        }\n    }\n\n    /**\n     * Configures the timing of the on button repeat event for all of the controller buttons\n     * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n     * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n     */\n    export function setRepeatDefault(delay: number, interval: number) {\n        defaultRepeatDelay = delay;\n        defaultRepeatInterval = interval;\n    }\n\n    let _players: Controller[];\n\n    function addController(ctrl: Controller) {\n        if (!_players) {\n            _players = [];\n        }\n        _players[ctrl.playerIndex - 1] = ctrl;\n    }\n\n    function player1(): Controller {\n        if (!_players || !_players[0])\n            new Controller(1, [controller.left, controller.up, controller.right, controller.down, controller.A, controller.B, controller.menu]);\n        return _players[0];\n    }\n\n    export function players(): Controller[] {\n        player1(); // ensure player1 is present\n        return _players.filter(ctrl => !!ctrl);\n    }\n\n    export class ControlledSprite {\n        public _inputLastFrame: boolean;\n        constructor(\n            public s: Sprite,\n            public vx: number,\n            public vy: number\n        ) { }\n    }\n\n    export function _moveSprites() {\n        // todo: move to currecnt sceane\n        control.enablePerfCounter(\"controller\")\n        players().forEach(ctrl => ctrl.__preUpdate());\n    }\n\n    //% fixedInstances\n    export class Controller {\n        playerIndex: number;\n        buttons: Button[];\n        private _id: number;\n        private _connected: boolean;\n\n        // array of left,up,right,down,a,b,menu buttons\n        constructor(playerIndex: number, buttons: Button[]) {\n            this._id = control.allocateNotifyEvent();\n            this._connected = false;\n            this.playerIndex = playerIndex;\n            if (buttons)\n                this.buttons = buttons;\n            else {\n                this.buttons = [];\n                const leftId = 1 + (this.playerIndex - 1) * 7;\n                for (let i = 0; i < 7; ++i) {\n                    this.buttons.push(new Button(leftId + i, -1));\n                }\n            }\n            for (let i = 0; i < this.buttons.length; ++i)\n                this.buttons[i]._owner = this;\n            addController(this);\n        }\n\n        get _controlledSprites(): ControlledSprite[] {\n            return game.currentScene().controlledSprites[this.playerIndex];\n        }\n\n        set _controlledSprites(cps: ControlledSprite[]) {\n            game.currentScene().controlledSprites[this.playerIndex] = cps;\n        }\n\n        get id() {\n            return this._id;\n        }\n\n        dump() {\n            this.buttons.forEach(b => console.log(b.toString()));\n        }\n\n        /**\n         * Gets the left button\n         */\n        //%\n        get left() {\n            return this.button(ControllerButton.Left);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get right() {\n            return this.button(ControllerButton.Right);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get up() {\n            return this.button(ControllerButton.Up);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get down() {\n            return this.button(ControllerButton.Down);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get A() {\n            return this.button(ControllerButton.A);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get B() {\n            return this.button(ControllerButton.B);\n        }\n\n        /**\n         * Gets the right button\n         */\n        //%\n        get menu() {\n            return this.button(7);\n        }\n\n        /**\n         * Control a sprite using the direction buttons from the controller. Note that this will overwrite\n         * the current velocity of the sprite whenever a directional button is pressed. To stop controlling\n         * a sprite, pass 0 for vx and vy.\n         *\n         * @param sprite The Sprite to control\n         * @param vx The velocity used for horizontal movement when left/right is pressed\n         * @param vy The velocity used for vertical movement when up/down is pressed\n         */\n        //% blockId=\"ctrlgame_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n        //% weight=100\n        //% expandableArgumentMode=\"toggle\"\n        //% vx.defl=100 vy.defl=100\n        //% help=controller/move-sprite\n        //% group=\"Multiplayer\"\n        moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            if (!sprite) return;\n            if (!this._controlledSprites) this._controlledSprites = [];\n            let cp = this._controlledSprites.find(cp => cp.s.id == sprite.id);\n            if (!cp) {\n                cp = new ControlledSprite(sprite, vx, vy);\n                this._controlledSprites.push(cp);\n            }\n            if (cp.vx && vx == 0) {\n                cp.s.vx = 0\n            }\n            if (cp.vy && vy == 0) {\n                cp.s.vy = 0\n            }\n            cp.vx = vx;\n            cp.vy = vy;\n        }\n\n        private button(button: ControllerButton): Button {\n            return this.buttons[button - 1];\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-button-event\n        onButtonEvent(btn: ControllerButton, event: ControllerButtonEvent, handler: () => void) {\n            this.button(btn).onEvent(event, handler);\n        }\n\n        /**\n         * Register code run when a controller event occurs\n         * @param event\n         * @param handler\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonevent block=\"on %controller %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-event\n        onEvent(event: ControllerEvent, handler: () => void) {\n            control.onEvent(this.id, event, handler);\n        }\n\n        get connected() {\n            return this._connected;\n        }\n\n        set connected(value: boolean) {\n            if (value != this._connected) {\n                this._connected = value;\n                control.raiseEvent(this.id, this._connected ? ControllerEvent.Connected : ControllerEvent.Disconnected);\n            }\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n        //% group=\"Multiplayer\"\n        isPressed(btn: ControllerButton): boolean {\n            return this.button(btn).isPressed();\n        }\n\n        /**\n         * Get the horizontal movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=50 blockGap=8 help=controller/dx\n        //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        dx(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.left.isPressed()) {\n                if (this.right.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.right.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        /**\n         * Get the vertical movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=49 help=keys/dy\n        //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        dy(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.up.isPressed()) {\n                if (this.down.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.down.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        __preUpdate() {\n            if (!this._controlledSprites) return;\n\n            let deadSprites = false;\n            let svx: number;\n            let svy: number;\n            this._controlledSprites.forEach(sprite => {\n                if (sprite.s.flags & sprites.Flag.Destroyed) {\n                    deadSprites = true;\n                    return;\n                }\n\n                svx = 0;\n                svy = 0;\n\n                if (sprite.vx) {\n                    if (this.right.isPressed()) {\n                        svx += sprite.vx;\n                    }\n                    if (this.left.isPressed()) {\n                        svx -=sprite.vx;\n                    }\n                }\n\n                if (sprite.vy) {\n                    if (this.down.isPressed()) {\n                        svy += sprite.vy;\n                    }\n                    if (this.up.isPressed()) {\n                        svy -= sprite.vy;\n                    }\n                }\n\n                if (sprite._inputLastFrame) {\n                    if (sprite.vx) sprite.s.vx = 0;\n                    if (sprite.vy) sprite.s.vy = 0;\n                }\n\n                if (svx || svy) {\n                    if (sprite.vx) sprite.s.vx = svx;\n                    if (sprite.vy) sprite.s.vy = svy;\n                    sprite._inputLastFrame = true;\n                }\n                else {\n                    sprite._inputLastFrame = false;\n                }\n            });\n\n            if (deadSprites)\n                this._controlledSprites = this._controlledSprites\n                    .filter(s => !(s.s.flags & sprites.Flag.Destroyed));\n        }\n\n        __update(dtms: number) {\n            dtms = dtms | 0;\n            this.buttons.forEach(btn => btn.__update(dtms));\n        }\n\n        serialize(offset: number): Buffer {\n            const buf = control.createBuffer(offset + 1);\n            let b = 0;\n            for (let i = 0; this.buttons.length; ++i)\n                b |= (this.buttons[i].isPressed() ? 1 : 0) << i;\n            buf[offset] = b\n            return buf;\n        }\n    }\n\n    /**\n     * Called by the game engine to update and/or raise events\n     */\n    export function __update(dt: number) {\n        const dtms = (dt * 1000) | 0\n        players().forEach(ctrl => ctrl.__update(dtms));\n    }\n\n    export function serialize(offset: number): Buffer {\n        return player1().serialize(offset);\n    }\n\n    /**\n     * Control a sprite using the direction buttons from the controller. Note that this\n     * control will take over the vx and vy of the sprite and overwrite any changes\n     * made unless a 0 is passed.\n     *\n     * @param sprite The Sprite to control\n     * @param vx The velocity used for horizontal movement when left/right is pressed\n     * @param vy The velocity used for vertical movement when up/down is pressed\n     */\n    //% blockId=\"game_control_sprite\" block=\"move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n    //% weight=100\n    //% expandableArgumentMode=\"toggle\"\n    //% vx.defl=100 vy.defl=100\n    //% help=controller/move-sprite\n    //% group=\"Single Player\"\n    export function moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n        player1().moveSprite(sprite, vx, vy);\n    }\n\n\n    /**\n     * Pause the program until a button is pressed\n     */\n    //% weight=10\n    export function pauseUntilAnyButtonIsPressed() {\n        control.waitForEvent(KEY_DOWN, 0)\n    }\n\n    export function _setUserEventsEnabled(enabled: boolean) {\n        _userEventsEnabled = enabled;\n    }\n\n    /**\n     * Get the horizontal movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=50 blockGap=8 help=controller/dx\n    //% blockId=keydx block=\"dx (left-right buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dx(step: number = 100) {\n        return player1().dx(step);\n    }\n\n    /**\n     * Get the vertical movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=49 help=keys/dy\n    //% blockId=keydy block=\"dy (up-down buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dy(step: number = 100) {\n        return player1().dy(step);\n    }\n\n\n    //% fixedInstance block=\"any\"\n    export const anyButton = new Button(0, -1);\n}\n",
            "controlleroverrides.ts": "namespace controller {\n    //% fixedInstance whenUsed block=\"A\"\n    export const A = new Button(ControllerButton.A, input.buttonA.id());\n    //% fixedInstance whenUsed block=\"B\"\n    export const B = new Button(ControllerButton.B, input.buttonB.id());\n    //% fixedInstance whenUsed block=\"left\"\n    export const left = new Button(ControllerButton.Left, input.buttonLeft.id());\n    //% fixedInstance whenUsed block=\"up\"\n    export const up = new Button(ControllerButton.Up, input.buttonUp.id());\n    //% fixedInstance whenUsed block=\"right\"\n    export const right = new Button(ControllerButton.Right, input.buttonRight.id());\n    //% fixedInstance whenUsed block=\"down\"\n    export const down = new Button(ControllerButton.Down, input.buttonDown.id());\n    //% fixedInstance whenUsed block=\"menu\"\n    export const menu = new Button(7, input.buttonMenu.id());\n\n    //% fixedInstance whenUsed block=\"player 2\"\n    export const player2 = new Controller(2, undefined);\n    //% fixedInstance whenUsed block=\"player 3\"\n    export const player3 = new Controller(3, undefined);\n    //% fixedInstance whenUsed block=\"player 4\"\n    export const player4 = new Controller(4, undefined);\n}",
            "effects.ts": "namespace effects {\n    //% fixedInstances\n    export class ImageEffect implements BackgroundEffect {\n\n        // If used in an animation, this should be used as the default delay between method calls\n        protected preferredDelay: number;\n        protected effect: (image: Image, fastRandom?: Math.FastRandom) => void;\n        protected fastRandom: Math.FastRandom;\n        private times: number;\n\n        constructor(defaultRate: number, effectFactory: (image: Image, fastRandom?: Math.FastRandom) => void) {\n            this.effect = effectFactory;\n            this.fastRandom = new Math.FastRandom();\n            this.preferredDelay = defaultRate;\n            this.times = undefined;\n        }\n\n        /**\n         * Apply this effect to the image of the current sprite\n         * @param sprite\n         */\n        applyTo(sprite: Sprite) {\n            if (!sprite || !sprite.image) return;\n            const clonedImage = sprite.image.clone();\n            this.change(clonedImage)\n            sprite.setImage(clonedImage);\n        }\n\n        /**\n         * Change the given image with this effect\n         * @param input \n         */\n        change(input: Image) {\n            this.effect(input, this.fastRandom);\n        }\n\n        /**\n         * Make this effect occur repeatedly on the background image\n         * @param times number of times effect should occur\n         * @param delay delay between instances of the effect\n         */\n        startScreenEffect(times?: number, delay?: number): void {\n            if (!game.currentScene().background.hasBackgroundImage()) return;\n            const wasRunning = this.times != undefined;\n            this.times = times ? times : 15;\n\n            if (!wasRunning) {\n                control.runInParallel(() => {\n                    while (this.times > 0) {\n                        this.change(scene.backgroundImage());\n                        pause(delay ? delay : this.preferredDelay);\n                        --this.times;\n                    }\n                    this.times = undefined;\n                });\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"dissolve\"\n    export const dissolve = new ImageEffect(100, (input: Image, r: Math.FastRandom) => {\n        for (let i = (input.width * input.height) >> 5; i > 0; --i) {\n            const x = r.randomRange(0, input.width)\n            const y = r.randomRange(0, input.height)\n            const w = r.randomRange(1, 3);\n            const h = r.randomRange(1, 3);\n\n            input.drawRect(x, y, w, h, 0);\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"melt\"\n    export const melt = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const rounds = (input.width * input.height) >> 5;\n        for (let j = 0; j < rounds; ++j) {\n            let x = r.randomRange(0, input.width - 1)\n            let y = r.randomRange(0, input.height - 3)\n            let c = input.getPixel(x, y)\n            input.setPixel(x, y + 1, c)\n            input.setPixel(x, y + 2, c)\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"slash\"\n    export const slash = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const rounds = 12;\n        for (let j = 0; j < rounds; ++j) {\n            let horizontal = r.randomBool();\n            let length = r.randomRange(5, 50);\n            let x = r.randomRange(0, input.width - (horizontal ? length : 1));\n            let y = r.randomRange(0, input.height - (horizontal ? 3 : length));\n            input.drawLine(x, y, horizontal ? x + length : x, horizontal ? y : y + length, 1);\n        }\n    });\n\n    //% fixedInstance whenUsed block=\"splatter\"\n    export const splatter = new ImageEffect(125, (input: Image, r: Math.FastRandom) => {\n        const imgs: Image[] = [\n            img`\n            . 1 .\n            1 1 1\n            . 1 1`,\n            img`\n            . 1 1 .\n            1 1 1 1\n            . 1 1 .`,\n            img`\n            . 1 1 1 .\n            1 1 1 1 1\n            1 1 1 1 1\n            1 1 1 1 1\n            . 1 1 1 .`,\n            img`\n            . . 1 1 . .\n            . 1 1 1 1 .\n            1 1 1 1 1 1\n            1 1 1 1 1 1\n            . 1 1 1 1 .\n            . . 1 1 . .`,\n            img`\n            . . 1 1 1. .\n            . 1 1 1 1 1 .\n            1 1 1 1 1 1 1\n            1 1 1 1 1 1 1\n            1 1 1 1 1 1 1\n            . 1 1 1 1 1 .\n            . . 1 1 1. .`,\n            img`\n            . . 1 1 1 1 . .\n            . 1 1 1 1 1 1 .\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n            . 1 1 1 1 1 1 .\n            . . 1 1 1 1 . .`,\n            img`\n            . . . 1 1 1 . . .\n            . . 1 1 1 1 1 . .\n            . 1 1 1 1 1 1 1 .\n            1 1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1 1\n            . 1 1 1 1 1 1 1 .\n            . . 1 1 1 1 1 . .\n            . . . 1 1 1 . . .`,\n        ];\n\n        const rounds = 12;\n        for (let j = 0; j < rounds; ++j) {\n            const im = imgs[r.randomRange(0, imgs.length - 1)];\n            const x = r.randomRange(0, input.width - im.width / 2);\n            const y = r.randomRange(0, input.height - im.height / 2);\n            input.drawTransparentImage(im, x, y);\n        }\n    });\n}",
            "fieldeditors.ts": "namespace __internal {\n\n    /**\n     * A speed picker\n     * @param speed the speed, eg: 50\n     */\n    //% blockId=spriteSpeedPicker block=\"%speed\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 \n    //% speed.fieldOptions.decompileLiterals=1\n    //% speed.fieldOptions.format=\"{0}pix/s\"\n    export function __spriteSpeedPicker(speed: number): number {\n        return speed;\n    }\n\n    /**\n     * A sprite acceleration picker\n     * @param acceleration the acceleration in pixel/sec^2\n     */\n    //% blockId=spriteAccPicker block=\"%acceleration\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 \n    //% speed.fieldOptions.decompileLiterals=1\n    //% speed.fieldOptions.format=\"{0}pix/s²\"\n    export function __accSpeedPicker(acceleration: number): number {\n        return acceleration;\n    }\n}",
            "game.ts": "/**\n * Game transitions and dialog\n **/\n//% color=#008272 weight=97 icon=\"\\uf111\"\n//% groups='[\"Gameplay\", \"Prompt\"]'\nnamespace game {\n    /**\n     * Determines if diagnostics are shown\n     */\n    export let debug = false;\n    export let stats = false;\n    export let winEffect: effects.BackgroundEffect = undefined;\n    export let loseEffect: effects.BackgroundEffect = undefined;\n    let loseSound: music.Melody = undefined;\n    let winSound: music.Melody = undefined;\n\n    let _scene: scene.Scene;\n    let _sceneStack: scene.Scene[];\n\n    let _scenePushHandlers: ((scene: scene.Scene) => void)[];\n    let _scenePopHandlers: ((scene: scene.Scene) => void)[];\n\n    export function currentScene(): scene.Scene {\n        init();\n        return _scene;\n    }\n\n    let __waitAnyButton: () => void;\n    let __gameOverHandler: (win: boolean) => void;\n    let __isOver = false;\n\n    export function setWaitAnyButton(f: () => void) {\n        __waitAnyButton = f\n    }\n\n    export function waitAnyButton() {\n        if (__waitAnyButton) __waitAnyButton()\n        else pause(3000)\n    }\n\n    export function eventContext(): control.EventContext {\n        init();\n        return _scene.eventContext;\n    }\n\n    function init() {\n        if (!_scene) _scene = new scene.Scene(control.pushEventContext());\n        _scene.init();\n\n        if (!winEffect)\n            winEffect = effects.confetti;\n        if (!loseEffect)\n            loseEffect = effects.melt;\n\n        if (!winSound)\n            winSound = music.powerUp;\n        if (!loseSound)\n            loseSound = music.wawawawaa;\n    }\n\n    export function pushScene() {\n        const oldScene = game.currentScene()\n        particles.clearAll();\n        particles.disableAll();\n        if (!_sceneStack) _sceneStack = [];\n        _sceneStack.push(_scene);\n        _scene = undefined;\n        init();\n\n        if (_scenePushHandlers) {\n            _scenePushHandlers.forEach(cb => cb(oldScene));\n        }\n    }\n\n    export function popScene() {\n        const oldScene = game.currentScene()\n        if (_sceneStack && _sceneStack.length) {\n            // pop scenes from the stack\n            _scene = _sceneStack.pop();\n            control.popEventContext();\n        } else if (_scene) {\n            // post last scene\n            control.popEventContext();\n            _scene = undefined;\n        }\n\n        if (_scene)\n            particles.enableAll();\n\n        if (_scenePopHandlers) {\n            _scenePopHandlers.forEach(cb => cb(oldScene));\n        }\n    }\n\n    function showDialogBackground(h: number, c: number) {\n        const top = (screen.height - h) >> 1;\n        screen.fillRect(0, top, screen.width, h, 0)\n        screen.drawLine(0, top, screen.width, top, 1)\n        screen.drawLine(0, top + h - 1, screen.width, top + h - 1, 1)\n\n        return top;\n    }\n\n    export function showDialog(title: string, subtitle: string, footer?: string) {\n        init();\n        const titleFont = image.getFontForText(title || \"\");\n        const subFont = image.getFontForText(subtitle || \"\")\n        const footerFont = image.getFontForText(footer || \"\");\n        let h = 8;\n        if (title)\n            h += titleFont.charHeight;\n        if (subtitle)\n            h += 2 + subFont.charHeight\n        h += 8;\n        const top = showDialogBackground(h, 9)\n        let y = top + 8;\n        if (title) {\n            screen.print(title, 8, y, screen.isMono ? 1 : 7, titleFont);\n            y += titleFont.charHeight + 2;\n        }\n        if (subtitle) {\n            screen.print(subtitle, 8, y, screen.isMono ? 1 : 6, subFont);\n            y += subFont.charHeight + 2;\n        }\n        if (footer) {\n            const footerTop = screen.height - footerFont.charHeight - 4;\n            screen.fillRect(0, footerTop, screen.width, footerFont.charHeight + 4, 0);\n            screen.drawLine(0, footerTop, screen.width, footerTop, 1);\n            screen.print(\n                footer,\n                screen.width - footer.length * footerFont.charWidth - 8,\n                screen.height - footerFont.charHeight - 2,\n                1,\n                footerFont\n            )\n        }\n    }\n\n    /**\n     * Set the effect that occurs when the game is over\n     * @param win whether the animation should run on a win (true)\n     * @param effect\n     */\n    export function setGameOverEffect(win: boolean, effect: effects.BackgroundEffect) {\n        init();\n        if (!effect) return;\n        if (win)\n            winEffect = effect;\n        else\n            loseEffect = effect;\n    }\n\n    /**\n     * Set the music that occurs when the player wins\n     * @param win\n     * @param effect\n     */\n    export function setGameOverSound(win: boolean, sound: music.Melody) {\n        init();\n        if (!sound) return;\n        if (win)\n            winSound = sound;\n        else\n            loseSound = sound;\n    }\n    /**\n     * Set the function to call on game over. The 'win' boolean is\n     * passed to the handler.\n     * @param handler\n     */\n    export function onGameOver(handler: (win: boolean) => void) {\n        __gameOverHandler = handler;\n    }\n\n    /**\n     * Finish the game and display the score\n     */\n    //% group=\"Gameplay\"\n    //% blockId=gameOver block=\"game over %win=toggleWinLose || with %effect effect\"\n    //% weight=80 help=game/over\n    export function over(win: boolean = false, effect?: effects.BackgroundEffect) {\n        init();\n        if (__isOver) return;\n        __isOver = true;\n\n        if (__gameOverHandler) {\n            __gameOverHandler(win);\n        } else {\n            if (!effect) {\n                effect = win ? winEffect : loseEffect;\n            }\n\n            // collect the scores before poping the scenes\n            const scoreInfo = info.player1.getState();\n            const highScore = info.highScore();\n            if (scoreInfo.score > highScore)\n                info.saveHighScore();\n\n            // releasing memory and clear fibers. Do not add anything that releases the fiber until background is set below,\n            // or screen will be cleared on the new frame and will not appear as background in the game over screen.\n            while (_sceneStack && _sceneStack.length) {\n                _scene.destroy();\n                popScene();\n            }\n            pushScene();\n            scene.setBackgroundImage(screen.clone());\n\n            if (win)\n                winSound.play();\n            else\n                loseSound.play();\n\n            effect.startScreenEffect();\n\n            pause(400);\n\n            const overDialog = new GameOverDialog(win, scoreInfo.score, highScore);\n            scene.createRenderable(scene.HUD_Z, target => {\n                overDialog.update();\n                target.drawTransparentImage(\n                    overDialog.image,\n                    0,\n                    (screen.height - overDialog.image.height()) >> 1\n                );\n            });\n\n            pause(500); // wait for users to stop pressing keys\n            overDialog.displayCursor();\n            waitAnyButton();\n            control.reset();\n        }\n    }\n\n    /**\n     * Update the position and velocities of sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update weight=100 afterOnStart=true\n    //% blockId=gameupdate block=\"on game update\"\n    //% blockAllowMultiple=1\n    export function onUpdate(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(scene.UPDATE_PRIORITY, a);\n    }\n\n    /**\n     * Run code on an interval of time. This executes before game.onUpdate()\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update-interval weight=99 afterOnStart=true\n    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n    //% blockAllowMultiple=1\n    export function onUpdateInterval(period: number, a: () => void): void {\n        init();\n        if (!a || period < 0) return;\n        let timer = 0;\n        game.eventContext().registerFrameHandler(scene.UPDATE_INTERVAL_PRIORITY, () => {\n            const time = game.currentScene().millis();\n            if (timer <= time) {\n                timer = time + period;\n                a();\n            }\n        });\n    }\n\n    // Indicates whether the fiber needs to be created\n    let foreverRunning = false;\n\n    /**\n     * Repeats the code forever in the background for this scene.\n     * On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    export function forever(action: () => void): void {\n        if (!foreverRunning) {\n            foreverRunning = true;\n            control.runInParallel(() => {\n                while (1) {\n                    const handlers = game.currentScene().gameForeverHandlers;\n                    handlers.forEach(h => {\n                        if (!h.lock) {\n                            h.lock = true;\n                            control.runInParallel(() => {\n                                h.handler();\n                                h.lock = false;\n                            });\n                        }\n                    });\n                    pause(20);\n                }\n            });\n        }\n\n        game.currentScene().gameForeverHandlers.push(\n            new scene.GameForeverHandler(action)\n        );\n    }\n\n    /**\n     * Draw on screen before sprites, after background\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/paint weight=10 afterOnStart=true\n    export function onPaint(a: () => void): void {\n        init();\n        if (!a) return;\n        scene.createRenderable(scene.ON_PAINT_Z, a);\n    }\n\n    /**\n     * Draw on screen after sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/shade weight=10 afterOnStart=true\n    export function onShade(a: () => void): void {\n        init();\n        if (!a) return;\n        scene.createRenderable(scene.ON_SHADE_Z, a);\n    }\n\n    /**\n     * Returns the time since the game started in milliseconds\n     */\n    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n    //% group=\"Gameplay\" weight=11\n    //% help=game/runtime\n    export function runtime(): number {\n        return currentScene().millis();\n    }\n\n    /**\n     * Register a handler that runs whenever a scene is pushed onto the scene\n     * stack. Useful for extensions that need to store/restore state as the\n     * event context changes. The handler is run AFTER the push operation (i.e.\n     * after game.currentScene() has changed)\n     *\n     * @param handler Code to run when a scene is pushed onto the stack\n     */\n    export function addScenePushHandler(handler: (oldScene: scene.Scene) => void) {\n        if (!_scenePushHandlers) _scenePushHandlers = [];\n        if (_scenePushHandlers.indexOf(handler) < 0)\n            _scenePushHandlers.push(handler);\n    }\n\n    /**\n     * Remove a scene push handler. Useful for extensions that need to store/restore state as the\n     * event context changes.\n     *\n     * @param handler The handler to remove\n     */\n    export function removeScenePushHandler(handler: (oldScene: scene.Scene) => void) {\n        if (_scenePushHandlers) _scenePushHandlers.removeElement(handler);\n    }\n\n    /**\n     * Register a handler that runs whenever a scene is popped off of the scene\n     * stack. Useful for extensions that need to store/restore state as the\n     * event context changes. The handler is run AFTER the pop operation. (i.e.\n     * after game.currentScene() has changed)\n     *\n     * @param handler Code to run when a scene is removed from the top of the stack\n     */\n    export function addScenePopHandler(handler: (oldScene: scene.Scene) => void) {\n        if (!_scenePopHandlers) _scenePopHandlers = [];\n        if (_scenePopHandlers.indexOf(handler) < 0)\n            _scenePopHandlers.push(handler);\n    }\n\n    /**\n     * Remove a scene pop handler. Useful for extensions that need to store/restore state as the\n     * event context changes.\n     *\n     * @param handler The handler to remove\n     */\n    export function removeScenePopHandler(handler: (oldScene: scene.Scene) => void) {\n        if (_scenePopHandlers) _scenePopHandlers.removeElement(handler);\n    }\n}\n",
            "gameoverrides.ts": "/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true blockNamespace=\"loops\"\n//% blockId=forever block=\"forever\" blockAllowMultiple=1\nfunction forever(a: () => void): void {\n    game.forever(a);\n}\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function forever(a: () => void) {\n        game.forever(a);\n    }\n}",
            "hitbox.ts": "namespace game {\n    export class Hitbox {\n        parent: Sprite;\n        ox: number;\n        oy: number;\n        width: number;\n        height: number;\n\n        constructor(parent: Sprite, width: number, height: number, ox: number, oy: number) {\n            this.width = width;\n            this.height = height;\n            this.parent = parent;\n            this.ox = ox;\n            this.oy = oy;\n        }\n\n        get left() {\n            return Fx.iadd(this.ox, this.parent._x)\n        }\n\n        get top() {\n            return Fx.iadd(this.oy, this.parent._y)\n        }\n\n        get right() {\n            return Fx.iadd(this.width - 1, this.left)\n        }\n\n        get bottom() {\n            return Fx.iadd(this.height - 1, this.top)\n        }\n    }\n\n\n    export function calculateHitBox(s: Sprite): Hitbox {\n        const i = s.image;\n        let minX = i.width;\n        let minY = i.height;\n        let maxX = 0;\n        let maxY = 0;\n\n        for (let c = 0; c < i.width; c++) {\n            for (let r = 0; r < i.height; r++) {\n                if (i.getPixel(c, r)) {\n                    minX = Math.min(minX, c);\n                    minY = Math.min(minY, r);\n                    maxX = Math.max(maxX, c);\n                    maxY = Math.max(maxY, r);\n                }\n            }\n        }\n\n        const width = maxX - minX + 1;\n        const height = maxY - minY + 1;\n        \n        return new Hitbox(s, width, height, minX, minY);\n    }\n}",
            "info.ts": "\n/**\n * Head-up display\n *\n*/\n//% color=#AA5585 weight=80 icon=\"\\uf2bb\" blockGap=8\n//% groups='[\"Score\", \"Life\", \"Countdown\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace info {\n\n    export enum Visibility {\n        None = 0,\n        Countdown = 1 << 0,\n        Score = 1 << 1,\n        Life = 1 << 2,\n        Hud = 1 << 3,\n        Multi = 1 << 4,\n        UserHeartImage = 1 << 5\n    }\n\n    class PlayerState {\n        public score: number;\n        // undefined: not used\n        // null: reached 0 and callback was invoked\n        public life: number;\n        public lifeZeroHandler: () => void;\n\n        constructor() { }\n    }\n\n    class InfoState {\n        public playerStates: PlayerState[];\n        public visibilityFlag: number;\n\n        public gameEnd: number;\n        public heartImage: Image;\n        public multiplierImage: Image;\n        public bgColor: number;\n        public borderColor: number;\n        public fontColor: number;\n        public countdownExpired: boolean;\n        public countdownEndHandler: () => void;\n\n        constructor() {\n            this.visibilityFlag = Visibility.Hud;\n            this.playerStates = [];\n            this.heartImage = defaultHeartImage();\n            this.multiplierImage = img`\n                1 . . . 1\n                . 1 . 1 .\n                . . 1 . .\n                . 1 . 1 .\n                1 . . . 1\n            `;\n            this.bgColor = screen.isMono ? 0 : 1;\n            this.borderColor = screen.isMono ? 1 : 3;\n            this.fontColor = screen.isMono ? 1 : 3;\n            this.countdownExpired = undefined;\n            this.countdownEndHandler = undefined;\n            this.gameEnd = undefined;\n            this.playerStates = [];\n        }\n    }\n\n    let infoState: InfoState = undefined;\n\n    let players: PlayerInfo[];\n\n    let infoStateStack: {\n        state: InfoState,\n        scene: scene.Scene\n    }[];\n\n    game.addScenePushHandler(oldScene => {\n        if (infoState) {\n            if (!infoStateStack) infoStateStack = [];\n            infoStateStack.push({\n                state: infoState,\n                scene: oldScene\n            });\n            infoState = undefined;\n        }\n    });\n\n    game.addScenePopHandler(() => {\n        const scene = game.currentScene();\n        infoState = undefined;\n        if (infoStateStack && infoStateStack.length) {\n            const nextState = infoStateStack.pop();\n            if (nextState.scene == scene) {\n                infoState = nextState.state;\n            } else {\n                infoStateStack.push(nextState);\n            }\n        }\n    });\n\n    function initHUD() {\n        if (infoState) return;\n\n        infoState = new InfoState();\n\n        scene.createRenderable(\n            scene.HUD_Z,\n            () => {\n                if (!infoState) return;\n                control.enablePerfCounter(\"info\")\n                // show score, lifes\n                if (infoState.visibilityFlag & Visibility.Multi) {\n                    const ps = players.filter(p => !!p);\n                    // First draw players\n                    ps.forEach(p => p.drawPlayer());\n                    // Then run life over events\n                    ps.forEach(p => p.raiseLifeZero(false));\n                } else { // single player\n                    // show score\n                    const p = player1;\n                    if (p.hasScore() && (infoState.visibilityFlag & Visibility.Score)) {\n                        p.drawScore();\n                    }\n                    // show life\n                    if (p.hasLife() && (infoState.visibilityFlag & Visibility.Life)) {\n                        p.drawLives();\n                    }\n                    p.raiseLifeZero(true);\n                }\n                // show countdown in both modes\n                if (infoState.gameEnd !== undefined && infoState.visibilityFlag & Visibility.Countdown) {\n                    const scene = game.currentScene();\n                    const elapsed = infoState.gameEnd - scene.millis();\n                    drawTimer(elapsed);\n                    let t = elapsed / 1000;\n                    if (t <= 0) {\n                        t = 0;\n                        if (!infoState.countdownExpired) {\n                            infoState.countdownExpired = true;\n                            if (infoState.countdownEndHandler) {\n                                infoState.countdownEndHandler();\n                                infoState.gameEnd = undefined;\n                            }\n                            else {\n                                game.over();\n                            }\n                        }\n                    }\n                }\n            }\n        );\n    }\n\n    function initMultiHUD() {\n        if (infoState.visibilityFlag & Visibility.Multi) return;\n\n        infoState.visibilityFlag |= Visibility.Multi;\n        if (!(infoState.visibilityFlag & Visibility.UserHeartImage))\n            infoState.heartImage = defaultMultiplayerHeartImage();\n        infoState.multiplierImage = img`\n            1 . 1\n            . 1 .\n            1 . 1\n        `;\n    }\n\n    function defaultHeartImage() {\n        return screen.isMono ?\n            img`\n                . 1 1 . 1 1 . .\n                1 . . 1 . . 1 .\n                1 . . . . . 1 .\n                1 . . . . . 1 .\n                . 1 . . . 1 . .\n                . . 1 . 1 . . .\n                . . . 1 . . . .\n            `\n            :\n            img`\n                . c 2 2 . 2 2 .\n                c 2 2 2 2 2 4 2\n                c 2 2 2 2 4 2 2\n                c 2 2 2 2 2 2 2\n                . c 2 2 2 2 2 .\n                . . c 2 2 2 . .\n                . . . c 2 . . .\n            `;\n    }\n\n    function defaultMultiplayerHeartImage() {\n        return screen.isMono ?\n            img`\n                    . . 1 . 1 . .\n                    . 1 . 1 . 1 .\n                    . 1 . . . 1 .\n                    . . 1 . 1 . .\n                    . . . 1 . . .\n                `\n            :\n            img`\n                    . . 1 . 1 . .\n                    . 1 2 1 4 1 .\n                    . 1 2 4 2 1 .\n                    . . 1 2 1 . .\n                    . . . 1 . . .\n                `;\n    }\n\n    export function saveHighScore() {\n        if (players) {\n            let hs = 0;\n            players\n                .filter(p => p && p.hasScore())\n                .forEach(p => hs = Math.max(hs, p.score()));\n            const curr = settings.readNumber(\"high-score\")\n            if (curr == null || hs > curr)\n                settings.writeNumber(\"high-score\", hs);\n        }\n    }\n\n    /**\n     * Get the current score if any\n     */\n    //% weight=95 blockGap=8\n    //% blockId=hudScore block=\"score\"\n    //% help=info/score\n    //% group=\"Score\"\n    export function score() {\n        return player1.score();\n    }\n\n    //%\n    //% group=\"Score\"\n    export function hasScore() {\n        return player1.hasScore();\n    }\n\n    /**\n     * Get the last recorded high score\n     */\n    //% weight=94\n    //% blockId=highScore block=\"high score\"\n    //% help=info/high-score\n    //% group=\"Score\"\n    export function highScore(): number {\n        return settings.readNumber(\"high-score\") || 0;\n    }\n\n    /**\n     * Set the score\n     */\n    //% weight=93 blockGap=8\n    //% blockId=hudsetScore block=\"set score to %value\"\n    //% help=info/set-score\n    //% group=\"Score\"\n    export function setScore(value: number) {\n        player1.setScore(value);\n    }\n\n    /**\n     * Change the score by the given amount\n     * @param value the amount of change, eg: 1\n     */\n    //% weight=92\n    //% blockId=hudChangeScoreBy block=\"change score by %value\"\n    //% help=info/change-score-by\n    //% group=\"Score\"\n    export function changeScoreBy(value: number) {\n        player1.changeScoreBy(value);\n    }\n\n    /**\n     * Get the number of lives\n     */\n    //% weight=85 blockGap=8\n    //% blockId=hudLife block=\"life\"\n    //% help=info/life\n    //% group=\"Life\"\n    export function life() {\n        return player1.life();\n    }\n\n    //% group=\"Life\"\n    export function hasLife() {\n        return player1.hasLife();\n    }\n\n    /**\n     * Set the number of lives\n     * @param value the number of lives, eg: 3\n     */\n    //% weight=84 blockGap=8\n    //% blockId=hudSetLife block=\"set life to %value\"\n    //% help=info/set-life\n    //% group=\"Life\"\n    export function setLife(value: number) {\n        player1.setLife(value);\n    }\n\n    /**\n     * Change the lives by the given amount\n     * @param value the change of lives, eg: -1\n     */\n    //% weight=83\n    //% blockId=hudChangeLifeBy block=\"change life by %value\"\n    //% help=info/change-life-by\n    //% group=\"Life\"\n    export function changeLifeBy(value: number) {\n        player1.changeLifeBy(value);\n    }\n\n    /**\n     * Run code when the player's life reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% weight=82\n    //% blockId=gamelifeevent block=\"on life zero\"\n    //% help=info/on-life-zero\n    //% group=\"Life\"\n    export function onLifeZero(handler: () => void) {\n        player1.onLifeZero(handler);\n    }\n\n    /**\n     * Start a countdown of the given duration in seconds\n     * @param duration the duration of the countdown, eg: 10\n     */\n    //% blockId=gamecountdown block=\"start countdown %duration (s)\"\n    //% help=info/start-countdown weight=79 blockGap=8\n    //% group=\"Countdown\"\n    export function startCountdown(duration: number) {\n        updateFlag(Visibility.Countdown, true);\n        infoState.gameEnd = game.currentScene().millis() + duration * 1000;\n        infoState.countdownExpired = false;\n    }\n\n    /**\n     * Stop the current countdown and hides the timer display\n     */\n    //% blockId=gamestopcountdown block=\"stop countdown\" weight=78\n    //% help=info/stop-countdown\n    //% group=\"Countdown\"\n    export function stopCountdown() {\n        updateFlag(Visibility.Countdown, false);\n        infoState.gameEnd = undefined;\n        infoState.countdownExpired = true;\n    }\n\n    /**\n     * Run code when the countdown reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% blockId=gamecountdownevent block=\"on countdown end\" weight=77\n    //% help=info/on-countdown-end\n    //% group=\"Countdown\"\n    export function onCountdownEnd(handler: () => void) {\n        initHUD();\n        infoState.countdownEndHandler = handler;\n    }\n\n    /**\n     * Replaces the image used to represent the player's lives. Images\n     * should be no larger than 8x8\n     */\n    //% group=\"Life\"\n    export function setLifeImage(image: Image) {\n        updateFlag(Visibility.UserHeartImage, true);\n        infoState.heartImage = image;\n    }\n\n    /**\n     * Set whether life should be displayed\n     * @param on if true, lives are shown; otherwise, lives are hidden\n     */\n    //% group=\"Life\"\n    export function showLife(on: boolean) {\n        updateFlag(Visibility.Life, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    //% group=\"Score\"\n    export function showScore(on: boolean) {\n        updateFlag(Visibility.Score, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    //% group=\"Countdown\"\n    export function showCountdown(on: boolean) {\n        updateFlag(Visibility.Countdown, on);\n    }\n\n    function updateFlag(flag: Visibility, on: boolean) {\n        initHUD();\n        if (on) infoState.visibilityFlag |= flag;\n        else infoState.visibilityFlag = ~(~infoState.visibilityFlag | flag);\n    }\n\n    /**\n     * Sets the color of the borders around the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setBorderColor(color: number) {\n        initHUD();\n        infoState.borderColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the background of the score, countdown, and life\n     * elements. Defaults to 1\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setBackgroundColor(color: number) {\n        initHUD();\n        infoState.bgColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the text used in the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    //% group=\"Theme\"\n    export function setFontColor(color: number) {\n        initHUD();\n        infoState.fontColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Get the current color of the borders around the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function borderColor(): number {\n        initHUD();\n        return infoState.borderColor ? infoState.borderColor : 3;\n    }\n\n    /**\n     * Get the current color of the background of the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function backgroundColor(): number {\n        initHUD();\n        return infoState.bgColor ? infoState.bgColor : 1;\n    }\n\n    /**\n     * Get the current color of the text usded in the score, countdown, and life\n     * elements\n     */\n    //% group=\"Theme\"\n    export function fontColor(): number {\n        initHUD();\n        return infoState.fontColor ? infoState.fontColor : 3;\n    }\n\n    function drawTimer(millis: number) {\n        if (millis < 0) millis = 0;\n        millis |= 0;\n\n        const font = image.font8;\n        const smallFont = image.font5;\n        const seconds = Math.idiv(millis, 1000);\n        const width = font.charWidth * 5 - 2;\n        let left = (screen.width >> 1) - (width >> 1) + 1;\n        let color1 = infoState.fontColor;\n        let color2 = infoState.bgColor;\n\n        if (seconds < 10 && (seconds & 1) && !screen.isMono) {\n            const temp = color1;\n            color1 = color2;\n            color2 = temp;\n        }\n\n        screen.fillRect(left - 3, 0, width + 6, font.charHeight + 3, infoState.borderColor)\n        screen.fillRect(left - 2, 0, width + 4, font.charHeight + 2, color2)\n\n\n        if (seconds < 60) {\n            const top = 1;\n            const remainder = Math.idiv(millis % 1000, 10);\n\n            screen.print(formatDecimal(seconds) + \".\", left, top, color1, font)\n            const decimalLeft = left + 3 * font.charWidth;\n            screen.print(formatDecimal(remainder), decimalLeft, top + 2, color1, smallFont)\n        }\n        else {\n            const minutes = Math.idiv(seconds, 60);\n            const remainder = seconds % 60;\n            screen.print(formatDecimal(minutes) + \":\" + formatDecimal(remainder), left, 1, color1, font);\n        }\n    }\n\n    //% fixedInstances\n    //% blockGap=8\n    export class PlayerInfo {\n        protected _player: number;\n        public bg: number; // background color\n        public border: number; // border color\n        public fc: number; // font color\n        public showScore?: boolean;\n        public showLife?: boolean;\n        public visilibity: Visibility;\n        public showPlayer?: boolean;\n        public x?: number;\n        public y?: number;\n        public left?: boolean; // if true banner goes from x to the left, else goes rightward\n        public up?: boolean; // if true banner goes from y up, else goes downward\n\n        constructor(player: number) {\n            this._player = player;\n            this.border = 1;\n            this.fc = 1;\n            this.visilibity = Visibility.None;\n            this.showScore = undefined;\n            this.showLife = undefined;\n            this.showPlayer = undefined;\n            this.left = undefined;\n            this.up = undefined;\n            if (this._player === 1) {\n                // Top left, and banner is white on red\n                this.bg = screen.isMono ? 0 : 2;\n                this.x = 0;\n                this.y = 0;\n            } else if (player === 2) {\n                // Top right, and banner is white on blue\n                this.bg = screen.isMono ? 0 : 8;\n                this.x = screen.width;\n                this.y = 0;\n                this.left = true;\n            } else if (player === 3) {\n                this.bg = screen.isMono ? 0 : 4;\n                this.x = 0;\n                this.y = screen.height;\n                this.up = true;\n            } else {\n                // bottom left, banner is white on green\n                this.bg = screen.isMono ? 0 : 7;\n                this.x = screen.width;\n                this.y = screen.height;\n                this.left = true;\n                this.up = true;\n            }\n\n            if (!players) players = [];\n            players[this._player - 1] = this;\n        }\n\n        private init() {\n            initHUD();\n            if (this._player > 1) initMultiHUD();\n            if (!infoState.playerStates[this._player - 1]) {\n                infoState.playerStates[this._player - 1] = new PlayerState();\n            }\n        }\n\n        getState(): PlayerState {\n            this.init();\n            return infoState.playerStates[this._player - 1];\n        }\n\n        // the id numbera of the player\n        id(): number {\n            return this._player;\n        }\n\n        /**\n         * Get the player score\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=piscore block=\"%player score\"\n        //% help=info/score\n        score(): number {\n            if (this.showScore === undefined) this.showScore = true;\n            if (this.showPlayer === undefined) this.showPlayer = true;\n\n            const state = this.getState();\n\n            if (state.score == null)\n                state.score = 0;\n            return state.score;\n        }\n\n        /**\n         * Set the player score\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pisetscore block=\"set %player score to %value\"\n        //% value.defl=0\n        //% help=info/set-score\n        setScore(value: number) {\n            const state = this.getState();\n            updateFlag(Visibility.Score, true);\n\n            this.score(); // invoked for side effects\n            state.score = (value | 0);\n        }\n\n        /**\n         * Change the score of a player\n         * @param value \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pichangescore block=\"change %player score by %value\"\n        //% value.defl=1\n        //% help=info/change-score-by\n        changeScoreBy(value: number): void {\n            this.setScore(this.score() + value);\n        }\n\n        hasScore() {\n            const state = this.getState();\n            return state.score !== undefined;\n        }\n\n        /**\n         * Get the player life\n         */\n        //% group=\"Multiplayer\"\n        //% blockid=piflife block=\"%player life\"\n        //% help=info/life\n        life(): number {\n            const state = this.getState();\n            if (this.showLife === undefined) this.showLife = true;\n            if (this.showPlayer === undefined) this.showPlayer = true;\n\n            if (state.life === undefined) {\n                state.life = 3;\n            }\n            return state.life || 0;\n        }\n\n        /**\n         * Set the player life\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pisetlife block=\"set %player life to %value\"\n        //% value.defl=3\n        //% help=info/set-life\n        setLife(value: number): void {\n            const state = this.getState();\n            updateFlag(Visibility.Life, true);\n\n            this.life(); // invoked for side effects\n            state.life = (value | 0);\n        }\n\n        /**\n         * Change the life of a player\n         * @param value \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pichangelife block=\"change %player life by %value\"\n        //% value.defl=-1\n        //% help=info/change-life-by\n        changeLifeBy(value: number): void {\n            this.setLife(this.life() + value);\n        }\n\n        /**\n         * Return true if the given player currently has a value set for health,\n         * and false otherwise.\n         * @param player player to check life of\n         */\n        //% group=\"Multiplayer\"\n        //% blockId=pihaslife block=\"%player has life\"\n        //% help=info/has-life\n        hasLife(): boolean {\n            const state = this.getState();\n            return state.life !== undefined && state.life !== null;\n        }\n\n        /**\n         * Runs code when life reaches zero\n         * @param handler \n         */\n        //% group=\"Multiplayer\"\n        //% blockId=playerinfoonlifezero block=\"on %player life zero\"\n        //% help=info/on-life-zero\n        onLifeZero(handler: () => void) {\n            const state = this.getState();\n            state.lifeZeroHandler = handler;\n        }\n\n        raiseLifeZero(gameOver: boolean) {\n            const state = this.getState();\n            if (state.life !== null && state.life <= 0) {\n                state.life = null;\n                if (state.lifeZeroHandler) {\n                    state.lifeZeroHandler();\n                } else if (gameOver) {\n                    game.over();\n                }\n            }\n        }\n\n        drawPlayer() {\n            const state = this.getState();\n\n            const font = image.font5;\n            let score: string;\n            let life: string;\n            let height = 4;\n            let scoreWidth = 0;\n            let lifeWidth = 0;\n            const offsetX = 1;\n            let offsetY = 2;\n            let showScore = this.showScore && state.score !== undefined;\n            let showLife = this.showLife && state.life !== undefined;\n\n            if (showScore) {\n                score = \"\" + state.score;\n                scoreWidth = score.length * font.charWidth + 3;\n                height += font.charHeight;\n                offsetY += font.charHeight + 1;\n            }\n\n            if (showLife) {\n                life = \"\" + (state.life || 0);\n                lifeWidth = infoState.heartImage.width + infoState.multiplierImage.width + life.length * font.charWidth + 3;\n                height += infoState.heartImage.height;\n            }\n\n            const width = Math.max(scoreWidth, lifeWidth);\n\n            // bump size for space between lines\n            if (showScore && showLife) height++;\n\n            const x = this.x - (this.left ? width : 0);\n            const y = this.y - (this.up ? height : 0);\n\n            // Bordered Box\n            if (showScore || showLife) {\n                screen.fillRect(x, y, width, height, this.border);\n                screen.fillRect(x + 1, y + 1, width - 2, height - 2, this.bg);\n            }\n\n            // print score\n            if (showScore) {\n                const bump = this.left ? width - scoreWidth : 0;\n                screen.print(score, x + offsetX + bump + 1, y + 2, this.fc, font);\n            }\n\n            // print life\n            if (showLife) {\n                const xLoc = x + offsetX + (this.left ? width - lifeWidth : 0);\n\n                let mult = infoState.multiplierImage.clone();\n                mult.replace(1, this.fc);\n\n                screen.drawTransparentImage(\n                    infoState.heartImage,\n                    xLoc,\n                    y + offsetY\n                );\n                screen.drawTransparentImage(\n                    mult,\n                    xLoc + infoState.heartImage.width,\n                    y + offsetY + font.charHeight - infoState.multiplierImage.height - 1\n                );\n                screen.print(\n                    life,\n                    xLoc + infoState.heartImage.width + infoState.multiplierImage.width + 1,\n                    y + offsetY,\n                    this.fc,\n                    font\n                );\n            }\n\n            // print player icon\n            if (this.showPlayer) {\n                const pNum = \"\" + this._player;\n\n                let iconWidth = pNum.length * font.charWidth + 1;\n                const iconHeight = Math.max(height, font.charHeight + 2);\n                let iconX = this.left ? (x - iconWidth + 1) : (x + width - 1);\n                let iconY = y;\n\n                // adjustments when only player icon shown\n                if (!showScore && !showLife) {\n                    iconX += this.left ? -1 : 1;\n                    if (this.up) iconY -= 3;\n                }\n\n                screen.fillRect(\n                    iconX,\n                    iconY,\n                    iconWidth,\n                    iconHeight,\n                    this.border\n                );\n                screen.print(\n                    pNum,\n                    iconX + 1,\n                    iconY + (iconHeight >> 1) - (font.charHeight >> 1),\n                    this.bg,\n                    font\n                );\n            }\n        }\n\n        drawScore() {\n            const s = this.score() | 0;\n\n            let font: image.Font;\n            let offsetY: number;\n            if (s >= 1000000) {\n                offsetY = 2;\n                font = image.font5;\n            }\n            else {\n                offsetY = 1;\n                font = image.font8;\n            }\n\n            const num = s.toString();\n            const width = num.length * font.charWidth;\n\n            screen.fillRect(\n                screen.width - width - 2,\n                0,\n                screen.width,\n                image.font8.charHeight + 3,\n                infoState.borderColor\n            );\n            screen.fillRect(\n                screen.width - width - 1,\n                0,\n                screen.width,\n                image.font8.charHeight + 2,\n                infoState.bgColor\n            );\n            screen.print(\n                num,\n                screen.width - width,\n                offsetY,\n                infoState.fontColor,\n                font\n            );\n        }\n\n        drawLives() {\n            const state = this.getState();\n            if (state.life < 0) return;\n            const font = image.font8;\n            if (state.life <= 4) {\n                screen.fillRect(\n                    0,\n                    0,\n                    state.life * (infoState.heartImage.width + 1) + 3,\n                    infoState.heartImage.height + 4,\n                    infoState.borderColor\n                );\n                screen.fillRect(\n                    0,\n                    0,\n                    state.life * (infoState.heartImage.width + 1) + 2,\n                    infoState.heartImage.height + 3,\n                    infoState.bgColor\n                );\n                for (let i = 0; i < state.life; i++) {\n                    screen.drawTransparentImage(\n                        infoState.heartImage,\n                        1 + i * (infoState.heartImage.width + 1),\n                        1\n                    );\n                }\n            }\n            else {\n                const num = state.life + \"\";\n                const textWidth = num.length * font.charWidth - 1;\n                screen.fillRect(\n                    0,\n                    0,\n                    infoState.heartImage.width + infoState.multiplierImage.width + textWidth + 5,\n                    infoState.heartImage.height + 4,\n                    infoState.borderColor\n                );\n                screen.fillRect(\n                    0,\n                    0,\n                    infoState.heartImage.width + infoState.multiplierImage.width + textWidth + 4,\n                    infoState.heartImage.height + 3,\n                    infoState.bgColor\n                );\n                screen.drawTransparentImage(\n                    infoState.heartImage,\n                    1,\n                    1\n                );\n\n                let mult = infoState.multiplierImage.clone();\n                mult.replace(1, infoState.fontColor);\n\n                screen.drawTransparentImage(\n                    mult,\n                    infoState.heartImage.width + 2,\n                    font.charHeight - infoState.multiplierImage.height - 1\n                );\n                screen.print(\n                    num,\n                    infoState.heartImage.width + 3 + infoState.multiplierImage.width,\n                    1,\n                    infoState.fontColor,\n                    font\n                );\n            }\n        }\n    }\n\n    function formatDecimal(val: number) {\n        val |= 0;\n        if (val < 10) {\n            return \"0\" + val;\n        }\n        return val.toString();\n    }\n\n    //% fixedInstance whenUsed block=\"player 2\"\n    export const player2 = new PlayerInfo(2);\n    //% fixedInstance whenUsed block=\"player 3\"\n    export const player3 = new PlayerInfo(3);\n    //% fixedInstance whenUsed block=\"player 4\"\n    export const player4 = new PlayerInfo(4);\n    //% fixedInstance whenUsed block=\"player 1\"\n    export const player1 = new PlayerInfo(1);\n}\n",
            "mathUtil.ts": "namespace Math {\n    /**\n     * Returns a random boolean that is true the given percentage of the time.\n     * @param percentage The percentage chance that the returned value will be true from 0 - 100\n     */\n    //% weight=2\n    //% blockId=percentchance block=\"%percentage|\\\\% chance\"\n    //% percentage.min=0 percentage.max=100;\n    export function percentChance(percentage: number): boolean {\n        if (percentage >= 100) {\n            return true;\n        }\n        else if (percentage <= 0) {\n            return false;\n        }\n        return Math.randomRange(0, 99) < percentage;\n    }\n\n    /**\n     * Returns a random element from the given list\n     * @param list The list to choose an element from\n     */\n    //% weight=1\n    export function pickRandom<T>(list: T[]) {\n        if (!list || list.length == 0) {\n            return undefined;\n        }\n        return list[Math.randomRange(0, list.length - 1)];\n    }\n\n    /**\n     * Fast, 16 bit, seedable (pseudo) random generator.\n     */\n    export class FastRandom {\n        // Implementation of the Galois Linear Feedback Shift Register\n        private lfsr: number;\n        // A value between 0x0001 and 0xFFFF to generate random values from\n        public seed: number;\n\n        /**\n         * Create a new Fast Random generator\n         * @param seed [Optional] initial seed between 0x0001 and 0xFFFF.\n         */\n        constructor(seed?: number) {\n            if (seed === undefined) seed = Math.randomRange(0x0001, 0xFFFF);\n            this.seed = seed;\n            this.lfsr = seed;\n        }\n\n        /**\n         * @returns the next random number between 0x0001 and 0xFFFF inclusive\n         */\n        next(): number {\n            return this.lfsr = (this.lfsr >> 1) ^ ((-(this.lfsr & 1)) & 0xb400);\n        }\n\n        /**\n         * @param min the minimum value to generate\n         * @param max the maximum value to generate\n         * @returns a random value between min and max (inclusive). If min is greater than or equal to max, returns min.\n         */\n        randomRange(min: number, max: number): number {\n            return min + (max > min ? this.next() % (max - min + 1) : 0);\n        }\n\n        /**\n         * Returns a random element from the given list\n         * @param list The list to choose an element from\n         */\n        pickRandom<T>(list: T[]) {\n            if (!list || list.length == 0) {\n                return undefined;\n            }\n            return list[this.randomRange(0, list.length - 1)];\n        }\n\n        /**\n         * @returns a random boolean value\n         */\n        randomBool(): boolean {\n            return !(this.next() & 1);\n        }\n\n        /**\n         * @param percent the percentage chance that the returned value will be true from 0 - 100\n         * @returns a boolean with approximately the given percent chance to be true or false\n         */\n        percentChance(percent: number): boolean {\n            return this.randomRange(0, 100) < percent;\n        }\n\n        /**\n         * Reset the state to the current seed\n         */\n        reset() {\n            this.lfsr = this.seed;\n        }\n    }\n}\n",
            "metrics.ts": "namespace performance {\n\n}",
            "numberprompt.ts": "namespace game {\n\n    /**\n     * Ask the player for a number value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of digits the user can enter (1 - 10)\n     */\n    //% group=\"Gameplay\"\n    //% weight=10 help=game/ask-for-number\n    //% blockId=gameaskfornumber block=\"ask for number %message || and max length %answerLength\"\n    //% message.defl=\"\"\n    //% answerLength.defl=\"6\"\n    //% answerLength.min=1\n    //% answerLength.max=10\n    //% group=\"Prompt\"\n    export function askForNumber(message: string, answerLength = 6) {\n        answerLength = Math.max(0, Math.min(10, answerLength));\n        let p = new game.NumberPrompt();\n        const result = p.show(message, answerLength);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8;\n    //% whenUsed=true\n    const PADDING_HORIZONTAL = 40;\n    //% whenUsed=true\n    const PADDING_VERTICAL = 4;\n    //% whenUsed=true\n    const PROMPT_LINE_SPACING = 2;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 12;\n    //% whenUsed=true\n    const NUMPAD_ROW_LENGTH = 3;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / NUMPAD_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 1;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING_HORIZONTAL * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING_VERTICAL * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING_VERTICAL;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_HEIGHT = Math.floor(CONTENT_HEIGHT / (NUM_ROWS + 4));\n    //% whenUsed=true\n    const CELL_WIDTH = CELL_HEIGHT//Math.floor(CONTENT_WIDTH / NUMPAD_ROW_LENGTH);\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING_HORIZONTAL + CELL_WIDTH / 2 + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * NUMPAD_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_NUMPAD_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING_VERTICAL + BOTTOM_BAR_NUMPAD_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_TOP = screen.height - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING_HORIZONTAL * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n\n    // Dimensions of the numpad area\n    //% whenUsed=true\n    const NUMPAD_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const NUMPAD_TOP = screen.height - NUMPAD_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const NUMPAD_INPUT_MARGIN = 4;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = NUMPAD_TOP - INPUT_HEIGHT - NUMPAD_INPUT_MARGIN;\n\n    // Pixels kept blank on left and right sides of prompt\n    //% whenUsed=true\n    const PROMPT_MARGIN_HORIZ = 3;\n\n    // Dimensions of prompt message area\n    //% whenUsed=true\n    const PROMPT_HEIGHT = INPUT_TOP - CONTENT_TOP;\n    //% whenUsed=true\n    const PROMPT_WIDTH = screen.width - PROMPT_MARGIN_HORIZ * 2\n\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class NumberPrompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        private cursor: Sprite;\n        private confirmButton: Sprite;\n\n        private numbers: Sprite[];\n        private inputs: Sprite[];\n\n        private confirmPressed: boolean;\n        private cursorRow: number;\n        private cursorColumn: number;\n        private hasDecimal: boolean;\n        private inputIndex: number;\n        private blink: boolean;\n        private frameCount: number;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.hasDecimal = false;\n            this.inputIndex = 0;\n        }\n\n        show(message: string, answerLength: number) : number {\n            this.message = message;\n            this.answerLength = answerLength;\n            this.inputIndex = 0;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.draw();\n            this.registerHandlers();\n            this.confirmPressed = false;\n\n            pauseUntil(() => this.confirmPressed);\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return parseFloat(this.result);\n        }\n\n        private draw() {\n            this.drawPromptText();\n            this.drawNumpad();\n            this.drawInputarea();\n            this.drawBottomBar();\n        }\n\n        private drawPromptText() {\n            const prompt = sprites.create(layoutText(this.message, PROMPT_WIDTH, PROMPT_HEIGHT, this.theme.colorPrompt), -1);\n            prompt.x = screen.width / 2\n            prompt.y = CONTENT_TOP + Math.floor((PROMPT_HEIGHT - prompt.height) / 2) + Math.floor(prompt.height / 2);\n        }\n\n        private drawInputarea() {\n            const answerLeft = (screen.width - this.answerLength * CELL_WIDTH) / 2\n\n            this.inputs = [];\n            for (let i = 0; i < this.answerLength; i++) {\n                const blank = image.create(CELL_WIDTH, CELL_HEIGHT);\n                this.drawInput(blank, \"\", this.theme.colorInput);\n\n                const s = sprites.create(blank, -1);\n                s.left = answerLeft + i * CELL_WIDTH;\n                s.y = INPUT_TOP;\n                this.inputs.push(s);\n            }\n        }\n\n        private drawNumpad() {\n            const cursorImage = image.create(CELL_WIDTH, CELL_HEIGHT);\n            cursorImage.fill(this.theme.colorCursor);\n            this.cursor = sprites.create(cursorImage, -1);\n            this.cursor.z = -1;\n            this.updateCursor();\n\n            this.numbers = [];\n            for (let j = 0; j < NUM_LETTERS; j++) {\n                const letter = image.create(CELL_WIDTH, CELL_HEIGHT);\n\n                const col2 = j % NUMPAD_ROW_LENGTH;\n                const row2 = Math.floor(j / NUMPAD_ROW_LENGTH);\n\n                const t = sprites.create(letter, -1);\n                t.x = ROW_LEFT + col2 * CELL_WIDTH;\n                t.y = NUMPAD_TOP + row2 * CELL_HEIGHT;\n\n                this.numbers.push(t);\n            }\n            this.updateKeyboard();\n        }\n\n        private drawBottomBar() {\n            const bg = image.create(screen.width, BOTTOM_BAR_HEIGHT);\n            bg.fill(this.theme.colorBottomBackground);\n\n            const bgSprite = sprites.create(bg, -1);\n            bgSprite.x = screen.width / 2;\n            bgSprite.y = BOTTOM_BAR_TOP + BOTTOM_BAR_HEIGHT / 2;\n            bgSprite.z = -1;\n\n            this.confirmButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.confirmButton.right = screen.width;\n            this.confirmButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.updateButtons();\n        }\n\n        private updateButtons() {\n            if (this.cursorRow === 4) {\n                this.confirmButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.confirmButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            this.confirmButton.image.print(confirmText, BOTTOM_BAR_CONFIRM_X, BOTTOM_BAR_TEXT_Y);\n        }\n\n        private updateCursor() {\n            if (this.cursorRow === 4) {\n                this.cursor.image.fill(0);\n                this.updateButtons();\n            }\n            else {\n                this.cursor.x = ROW_LEFT + this.cursorColumn * CELL_WIDTH;\n                this.cursor.y = NUMPAD_TOP + this.cursorRow * CELL_HEIGHT;\n            }\n        }\n\n        private updateSelectedInput() {\n            if (this.inputIndex < this.answerLength) {\n                const u = this.inputs[this.inputIndex];\n                if (this.blink) {\n                    this.drawInput(u.image, \"\", this.theme.colorInput);\n                }\n                else {\n                    this.drawInput(u.image, \"\", this.theme.colorInputHighlighted)\n                }\n            }\n        }\n\n        private updateKeyboard() {\n            const len = this.numbers.length;\n            for (let k = 0; k < len; k++) {\n                const img = this.numbers[k].image;\n                img.fill(0);\n                img.print(getSymbolFromIndex(k), LETTER_OFFSET_X, LETTER_OFFSET_Y);\n            }\n        }\n\n        private drawInput(img: Image, char: string, color: number) {\n            img.fill(0);\n            img.fillRect(BLANK_PADDING, CELL_HEIGHT - 1, CELL_WIDTH - BLANK_PADDING * 2, 1, color)\n\n            if (char) {\n                img.print(char, LETTER_OFFSET_X, LETTER_OFFSET_Y, this.theme.colorInputText, font);\n            }\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n\n\n            this.frameCount = 0;\n            this.blink = true;\n\n            game.onUpdate(() => {\n                this.frameCount = (this.frameCount + 1) % 30;\n\n                if (this.frameCount === 0) {\n                    this.blink = !this.blink;\n\n                    this.updateSelectedInput();\n                }\n            })\n        }\n\n        private moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === 4) {\n                    this.cursor.image.fill(this.theme.colorCursor);\n                    this.cursorRow = 3;\n\n                    this.updateButtons();\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(4, this.cursorRow + 1);\n            }\n\n            this.updateCursor();\n        }\n\n        private moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % NUMPAD_ROW_LENGTH;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (NUMPAD_ROW_LENGTH - 1)) % NUMPAD_ROW_LENGTH;\n            }\n\n            this.updateCursor();\n        }\n\n        private confirm() {\n            if (this.cursorRow === 4) {\n                this.confirmPressed = true;\n            } else {\n                if (this.inputIndex >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * NUMPAD_ROW_LENGTH\n                const letter = getSymbolFromIndex(index);\n\n                if (letter === \".\") {\n                    if(this.hasDecimal) {\n                        return;\n                    } else {\n                        this.hasDecimal = true;\n                    }\n                }\n\n                if (letter === \"-\" && (this.result && this.result.length > 0)) {\n                    return;\n                }\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                const sprite = this.inputs[this.inputIndex];\n                this.changeInputIndex(1);\n                this.drawInput(sprite.image, letter, this.theme.colorInput);\n            }\n        }\n\n        private delete() {\n            if (this.inputIndex <= 0) return;\n\n            if (this.inputIndex < this.answerLength) {\n                this.drawInput(this.inputs[this.inputIndex].image, \"\", this.theme.colorInput);\n            }\n\n            if (this.result.charAt(this.result.length - 1) === \".\") {\n                this.hasDecimal = false;\n            }\n\n            this.result = this.result.substr(0, this.result.length - 1);\n\n            this.changeInputIndex(-1);\n        }\n\n        private changeInputIndex(delta: number) {\n            this.inputIndex += delta;\n            this.frameCount = 0\n            this.blink = false;\n            this.updateSelectedInput();\n        }\n    }\n\n    function layoutText(message: string, width: number, height: number, color: number) {\n        const lineHeight = font.charHeight + PROMPT_LINE_SPACING;\n\n        const lineLength = Math.floor(width / font.charWidth);\n        const numLines = Math.floor(height / lineHeight);\n\n        let lines: string[] = [];\n        let word: string;\n        let line: string;\n\n        let pushWord = () => {\n            if (line) {\n                if (line.length + word.length + 1 > lineLength) {\n                    lines.push(line);\n                    line = word;\n                }\n                else {\n                    line = line + \" \" + word;\n                }\n            }\n            else {\n                line = word;\n            }\n\n            word = null;\n        }\n\n        for (let l = 0; l < message.length; l++) {\n            const char = message.charAt(l);\n\n            if (char === \" \") {\n                if (word) {\n                    pushWord();\n                }\n                else {\n                    word = \" \";\n                }\n            }\n            else if (!word) {\n                word = char;\n            }\n            else {\n                word += char;\n            }\n        }\n\n        if (word) {\n            pushWord();\n        }\n\n        if (line) {\n            lines.push(line);\n        }\n\n        let maxLineWidth = 0;\n        for (let m = 0; m < lines.length; m++) {\n            maxLineWidth = Math.max(maxLineWidth, lines[m].length);\n        }\n\n        const actualWidth = maxLineWidth * font.charWidth;\n        const actualHeight = lines.length * lineHeight;\n\n        const res = image.create(actualWidth, actualHeight);\n\n        for (let n = 0; n < lines.length; n++) {\n            if ((n + 1) > numLines) break;\n            res.print(lines[n], 0, n * lineHeight, color, font);\n        }\n\n        return res;\n    }\n\n    function getSymbolFromIndex(index: number) {\n        if (index < 9) {\n            // Calculator Layout\n            return \"\" + (3 * Math.idiv(9 - index - 1, 3) + index % 3 + 1);\n        } else if (index == 9) {\n            return \"-\";\n        } else if (index == 10) {\n            return \"0\";\n        } else if (index == 11) {\n            return \".\";\n        } else {\n            return \"\";\n        }\n    }\n\n}",
            "obstacle.ts": "namespace sprites {\n    enum ObstacleFlags {\n        Moved = 1 << 4,\n        Dead = 1 << 5\n    }\n\n    export interface Obstacle {\n        x: number;\n        y: number;\n        left: number;\n        right: number;\n        top: number;\n        bottom: number;\n        width: number;\n        height: number;\n        layer: number;\n        image: Image;\n        tileIndex: number;\n    }\n\n    export class StaticObstacle implements Obstacle {\n        layer: number;\n        image: Image;\n        tileIndex: number;\n\n        top: number;\n        left: number;\n\n        constructor(image: Image, top: number, left: number, layer: number, tileIndex?: number) {\n            this.image = image;\n            this.layer = layer;\n            this.top = top;\n            this.left = left;\n            this.tileIndex = tileIndex;\n        }\n\n        get x(): number {\n            return this.left + this.width >> 1;\n        }\n\n        get y(): number {\n            return this.top + this.height >> 1;\n        }\n\n        get height(): number {\n            return this.image.height;\n        }\n\n        get width(): number {\n            return this.image.width;\n        }\n\n        get bottom(): number {\n            return this.top + this.height;\n        }\n\n        get right(): number {\n            return this.left + this.width;\n        }\n    }\n}",
            "particleeffects.ts": "namespace effects {\n\n    //% fixedInstances\n    export interface BackgroundEffect {\n        startScreenEffect(): void;\n    }\n\n    //% fixedInstances\n    export class ParticleEffect {\n        protected sourceFactory: (anchor: particles.ParticleAnchor, pps: number) => particles.ParticleSource;\n        protected defaultRate: number;\n        protected defaultLifespan: number;\n\n        constructor(defaultParticlesPerSecond: number, defaultLifespan: number,\n                sourceFactory: (anchor: particles.ParticleAnchor, particlesPerSecond: number) => particles.ParticleSource) {\n            this.sourceFactory = sourceFactory;\n            this.defaultRate = defaultParticlesPerSecond;\n            this.defaultLifespan = defaultLifespan;\n        }\n\n        /**\n         * Attaches a new particle animation to the sprite or anchor for a short period of time\n         * @param anchor\n         * @param duration\n         * @param particlesPerSecond \n         */\n        start(anchor: particles.ParticleAnchor, duration?: number, particlesPerSecond?: number): void {\n            if (!this.sourceFactory) return;\n            const src = this.sourceFactory(anchor, particlesPerSecond ? particlesPerSecond : this.defaultRate);\n            if (duration)\n                src.lifespan = duration > 0 ? duration : this.defaultLifespan;\n        }\n\n        /**\n         * Destroy the provided sprite with an effect\n         * @param sprite\n         * @param duration how long the sprite will remain on the screen. If set to 0 or undefined,\n         *                  uses the default rate for this effect.\n         * @param particlesPerSecond\n         */\n        destroy(anchor: Sprite, duration?: number, particlesPerSecond?: number) {\n            anchor.setFlag(SpriteFlag.Ghost, true);\n            this.start(anchor, particlesPerSecond);\n            anchor.lifespan = duration ? duration : this.defaultLifespan >> 2;\n            effects.dissolve.applyTo(anchor);\n        }\n    }\n\n    /**\n     * Anchor used for effects that occur across the screen.\n     */\n    class SceneAnchor implements particles.ParticleAnchor {\n        private camera: scene.Camera;\n\n        constructor() {\n            this.camera = game.currentScene().camera;\n        }\n\n        get x() {\n            return this.camera.offsetX + (screen.width >> 1);\n        }\n\n        get y() {\n            return this.camera.offsetY + (screen.height >> 1);\n        }\n\n        get width() {\n            return screen.width;\n        }\n\n        get height() {\n            return screen.height;\n        }\n    }\n\n    //% fixedInstances\n    export class ScreenEffect extends ParticleEffect implements BackgroundEffect {\n        protected source: particles.ParticleSource;\n        protected sceneDefaultRate: number;\n\n        constructor(anchorDefault: number, sceneDefault: number, defaultLifespan: number,\n                sourceFactory: (anchor: particles.ParticleAnchor, particlesPerSecond: number) => particles.ParticleSource) {\n            super(anchorDefault, defaultLifespan, sourceFactory);\n            this.sceneDefaultRate = sceneDefault;\n        }\n\n        /**\n         * Creates a new effect that occurs over the entire screen\n         * @param particlesPerSecond \n         * @param duration\n         */\n        //% blockId=particlesStartScreenAnimation block=\"start screen %effect effect || for %duration ms\"\n        //% duration.shadow=timePicker\n        //% blockNamespace=scene\n        //% group=\"Effects\" blockGap=8\n        //% weight=90 help=effects/start-screen-effect\n        startScreenEffect(duration?: number, particlesPerSecond?: number): void {\n            if (!this.sourceFactory)\n                return;\n\n            if (this.source && this.source.enabled) {\n                if (duration)\n                    this.source.lifespan = duration;\n                return;\n            }\n\n            this.endScreenEffect();\n            this.source = this.sourceFactory(new SceneAnchor(), particlesPerSecond ? particlesPerSecond : this.sceneDefaultRate);\n            this.source.priority = 10;\n            if (duration)\n                this.source.lifespan = duration;\n        }\n\n        /**\n         * If this effect is currently occurring as a full screen effect, stop producing particles and end the effect\n         * @param particlesPerSecond \n         */\n        //% blockId=particlesEndScreenAnimation block=\"end screen %effect effect\"\n        //% blockNamespace=scene\n        //% group=\"Effects\" blockGap=8\n        //% weight=80 help=effects/end-screen-effect\n        endScreenEffect(): void {\n            if (this.source) {\n                this.source.destroy();\n                this.source = undefined;\n            }\n        }\n    }\n\n    /**\n     * Removes all effects at anchor's location\n     * @param anchor the anchor to remove effects from\n     */\n    //% blockId=particlesclearparticles block=\"clear effects on %anchor=variables_get(mySprite)\"\n    //% blockNamespace=sprites\n    //% group=\"Effects\" weight=89\n    //% help=effects/clear-particles\n    export function clearParticles(anchor: particles.ParticleAnchor) {\n        const sources = game.currentScene().particleSources;\n        if (!sources) return;\n        sources\n            .filter(ps => ps.anchor == anchor || ps.anchor.x == anchor.x && ps.anchor.y == anchor.y)\n            .forEach(ps => ps.destroy());\n    }\n\n    function createEffect(defaultParticlesPerSecond: number, defaultLifespan: number,\n            factoryFactory: (anchor?: particles.ParticleAnchor) => particles.ParticleFactory): ParticleEffect {\n        return new ParticleEffect(defaultParticlesPerSecond, defaultLifespan,\n                    (anchor: particles.ParticleAnchor, pps: number) =>\n                        new particles.ParticleSource(anchor, pps, factoryFactory()));\n    }\n\n    //% fixedInstance whenUsed block=\"spray\"\n    export const spray = createEffect(20, 2000, function () { return new particles.SprayFactory(100, 0, 120) });\n\n    //% fixedInstance whenUsed block=\"trail\"\n    export const trail = new ParticleEffect(20, 4000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.TrailFactory(anchor, 250, 1000);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"fountain\"\n    export const fountain = new ParticleEffect(20, 3000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        class FountainFactory extends particles.SprayFactory {\n            galois: Math.FastRandom;\n    \n            constructor() {\n                super(40, 180, 90);\n                this.galois = new Math.FastRandom(1234);\n            }\n    \n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.color = this.galois.randomBool() ? 8 : 9;\n                p.lifespan = 1500;\n                return p;\n            }\n    \n            drawParticle(p: particles.Particle, x: Fx8, y: Fx8) {\n                screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n            }\n        }\n\n        const factory = new FountainFactory();\n        const source = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        source.setAcceleration(0, 40);\n        return source;\n    });\n\n    //% fixedInstance whenUsed block=\"confetti\"\n    export const confetti = new ScreenEffect(10, 40, 4000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ConfettiFactory(anchor.width ? anchor.width : 16, 16);\n        factory.setSpeed(30);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"hearts\"\n    export const hearts = new ScreenEffect(5, 20, 2000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ShapeFactory(anchor.width ? anchor.width : 16, 16, img`\n            . F . F .\n            F . F . F\n            F . . . F\n            . F . F .\n            . . F . .\n        `);\n\n        // if large anchor, increase lifespan\n        if (factory.xRange > 50) {\n            factory.minLifespan = 1000;\n            factory.maxLifespan = 2000;\n        }\n\n        factory.setSpeed(90);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"smiles\"\n    export const smiles = new ScreenEffect(5, 25, 1500, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.ShapeFactory(anchor.width ? anchor.width : 16, 16, img`\n            . f . f . \n            . f . f . \n            . . . . . \n            f . . . f \n            . f f f . \n        `);\n        // if large anchor, increase lifespan\n        if (factory.xRange > 50) {\n            factory.minLifespan = 1250;\n            factory.maxLifespan = 2500;\n        }\n\n        factory.setSpeed(50);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"rings\"\n    export const rings = createEffect(5, 1000, function () {\n        return new particles.ShapeFactory(16, 16, img`\n            . F F F . \n            F . . . F \n            F . . . F \n            f . . . f \n            . f f f . \n        `);\n    });\n\n    //% fixedInstance whenUsed block=\"fire\"\n    export const fire = new ParticleEffect(50, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.FireFactory(5);\n        const src = new particles.FireSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, -20);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"warm radial\"\n    export const warmRadial = createEffect(30, 2500, function () { return new particles.RadialFactory(0, 30, 10) });\n\n    //% fixedInstance whenUsed block=\"cool radial\"\n    export const coolRadial = createEffect(30, 2000, function () { return new particles.RadialFactory(0, 30, 10, [0x6, 0x7, 0x8, 0x9, 0xA]) });\n\n    //% fixedInstance whenUsed block=\"halo\"\n    export const halo = createEffect(70, 3000, function () {\n        class RingFactory extends particles.RadialFactory {\n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.lifespan = this.galois.randomRange(200, 350);\n                return p;\n            }\n        }\n        return new RingFactory(30, 40, 10, [0x4, 0x4, 0x5]);\n    });\n\n    //% fixedInstance whenUsed block=\"ashes\"\n    export const ashes = new ParticleEffect(60, 2000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.AshFactory(anchor);\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, 500);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"disintegrate\"\n    export const disintegrate = new ParticleEffect(60, 1250, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.AshFactory(anchor, true, 30);\n        factory.minLifespan = 200;\n        factory.maxLifespan = 500;\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(0, 750);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"blizzard\"\n    export const blizzard = new ScreenEffect(15, 50, 3000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        class SnowFactory extends particles.ShapeFactory {\n            constructor(xRange: number, yRange: number) {\n                super(xRange, yRange, img`F`);\n                this.addShape(img`\n                    F\n                    F`\n                );\n                this.minLifespan = 200;\n                this.maxLifespan = this.xRange > 50 ? 1200: 700;\n            }\n\n            createParticle(anchor: particles.ParticleAnchor) {\n                const p = super.createParticle(anchor);\n                p.color = this.galois.percentChance(80) ? 0x1 : 0x9;\n                return p;\n            }\n        }\n\n        const factory = new SnowFactory(anchor.width ? anchor.width : 16, anchor.height ? anchor.height : 16);\n        const src = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n        src.setAcceleration(-300, -100);\n        return src;\n    });\n\n    //% fixedInstance whenUsed block=\"bubbles\"\n    export const bubbles = new ScreenEffect(15, 40, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const min = anchor.width > 50 ? 2000 : 500;\n        const factory = new particles.BubbleFactory(anchor, min, min * 2.5);\n        return new particles.BubbleSource(anchor, particlesPerSecond, factory.stateCount - 1, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"star field\"\n    export const starField = new ScreenEffect(2, 5, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.StarFactory([0x1, 0x3, 0x5, 0x9, 0xC]);\n        return new particles.ParticleSource(anchor, particlesPerSecond, factory);\n    });\n\n    //% fixedInstance whenUsed block=\"clouds\"\n    export const clouds = new ScreenEffect(.5, 1.5, 5000, function (anchor: particles.ParticleAnchor, particlesPerSecond: number) {\n        const factory = new particles.CloudFactory();\n        const source = new particles.ParticleSource(anchor, particlesPerSecond, factory);\n\n        // render behind tile map\n        source.z = -2;\n        return source;\n    });\n}",
            "particlefactories.ts": "namespace particles {\n    let cachedSin: Fx8[];\n    let cachedCos: Fx8[];\n\n    const NUM_SLICES = 100;\n    const galois = new Math.FastRandom();\n    let angleSlice = 2 * Math.PI / NUM_SLICES;\n\n    /**\n     * Initialize sin and cos values for each slice to minimize recomputation\n     */\n    function initTrig() {\n        if (!cachedSin) {\n            cachedSin = cacheSin(NUM_SLICES);\n            cachedCos = cacheCos(NUM_SLICES);\n        }\n    }\n\n    /**\n     * @param slices number of cached sin values to make\n     * @returns array of cached sin values between 0 and 360 degrees\n     */\n    export function cacheSin(slices: number): Fx8[] {\n        let sin: Fx8[] = [];\n        let anglePerSlice = 2 * Math.PI / slices;\n        for (let i = 0; i < slices; i++) {\n            sin.push(Fx8(Math.sin(i * anglePerSlice)));\n        }\n        return sin;\n    }\n\n    /**\n     * @param slices number of cached cos values to make\n     * @returns array of cached cos values between 0 and 360 degrees\n     */\n    export function cacheCos(slices: number): Fx8[] {\n        let cos: Fx8[] = [];\n        let anglePerSlice = 2 * Math.PI / slices;\n        for (let i = 0; i < slices; i++) {\n            cos.push(Fx8(Math.cos(i * anglePerSlice)));\n        }\n        return cos;\n    }\n\n    const ratio = Math.PI / 180;\n    function toRadians(degrees: number) {\n        if (degrees < 0)\n            degrees = 360 - (Math.abs(degrees) % 360);\n        else\n            degrees = degrees % 360;\n\n        return degrees * ratio;\n    }\n\n    /**\n     * A factory for generating particles\n     */\n    export class ParticleFactory {\n\n        constructor() {\n            // Compiler errors if this doesn't exist\n        }\n\n        /**\n         * Generate a particle at the position of the given anchor\n         * @param anchor \n         */\n        createParticle(anchor: ParticleAnchor): Particle {\n            const p = new Particle();\n\n            p._x = Fx8(anchor.x);\n            p._y = Fx8(anchor.y);\n            p.vx = Fx.zeroFx8;\n            p.vy = Fx.zeroFx8;\n            p.lifespan = 500;\n\n            return p;\n        }\n\n        /**\n         * Draw the given particle at the given location\n         * @param particle \n         * @param x \n         * @param y \n         */\n        drawParticle(particle: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), 1);\n        }\n    }\n\n    /**\n     * A factory for creating a spray of particles\n     */\n    export class SprayFactory extends ParticleFactory {\n        protected speed: Fx8;\n        protected minAngle: number;\n        protected spread: number;\n\n        constructor(speed: number, centerDegrees: number, arcDegrees: number) {\n            super();\n            initTrig();\n            this.setSpeed(speed);\n            this.setDirection(centerDegrees, arcDegrees);\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            const angle = (this.minAngle + galois.randomRange(0, this.spread)) % NUM_SLICES;\n            p.vx = Fx.mul(cachedSin[angle], this.speed);\n            p.vy = Fx.mul(cachedCos[angle], this.speed);\n\n            return p;\n        }\n\n        drawParticle(particle: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), 1);\n        }\n\n        setSpeed(pixelsPerSecond: number) {\n            this.speed = Fx8(pixelsPerSecond);\n        }\n\n        setDirection(centerDegrees: number, arcDegrees: number) {\n            this.minAngle = (toRadians(centerDegrees - (arcDegrees >> 1)) / angleSlice) | 0;\n            this.spread = (toRadians(arcDegrees) / angleSlice) | 0;\n        }\n    }\n\n    /**\n     * A factory for creating particles within rectangular area\n     */\n    export class AreaFactory extends SprayFactory {\n        xRange: number;\n        yRange: number;\n        minLifespan: number;\n        maxLifespan: number;\n        protected galois: Math.FastRandom;\n\n        constructor(xRange: number, yRange: number, minLifespan?: number, maxLifespan?: number) {\n            super(40, 0, 90);\n            this.xRange = xRange;\n            this.yRange = yRange;\n            this.minLifespan = minLifespan ? minLifespan : 150;\n            this.maxLifespan = maxLifespan ? maxLifespan : 850;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(0, this.yRange) - (anchor.height ? anchor.height >> 1 : 0), p._y);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const col = p.lifespan > 500 ?\n                4 : p.lifespan > 250 ?\n                    5 : 1;\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), col);\n        }\n    }\n\n    /**\n     * A factory for creating a trail that is emitted by sprites.\n     */\n    export class TrailFactory extends ParticleFactory {\n        minLifespan: number;\n        maxLifespan: number;\n        xRange: number;\n        yRange: number;\n        protected galois: Math.FastRandom;\n\n        constructor(sprite: ParticleAnchor, minLifespan: number, maxLifespan: number) {\n            super();\n            this.xRange = sprite.width ? sprite.width >> 1 : 8;\n            this.yRange = sprite.height ? sprite.height >> 1 : 8;\n            this.minLifespan = minLifespan;\n            this.maxLifespan = maxLifespan;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(0, this.yRange) - (this.yRange >> 1), p._y);\n            p.color = this.galois.randomRange(0x1, 0xF);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n        }\n    }\n\n    /**\n     * A factory for creating particles with the provided shapes fall down the screen.\n     * \n     * Any pixels assigned to 0xF (black) in the provided shape will be replaced with a\n     * random color for each particle.\n     */\n    export class ShapeFactory extends AreaFactory {\n        protected sources: Image[];\n        protected ox: Fx8;\n        protected oy: Fx8;\n\n        constructor(xRange: number, yRange: number, source: Image) {\n            super(xRange, yRange);\n            this.sources = [source];\n\n            // Base offsets off of initial shape\n            this.ox = Fx8(source.width >> 1);\n            this.oy = Fx8(source.height >> 1);\n        }\n\n        /**\n         * Add another possible shape for a particle to display as\n         * @param shape \n         */\n        addShape(shape: Image) {\n            if (shape) this.sources.push(shape);\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const pImage = this.galois.pickRandom(this.sources).clone();\n            pImage.replace(0xF, p.color);\n\n            screen.drawTransparentImage(pImage,\n                Fx.toInt(Fx.sub(x, this.ox)),\n                Fx.toInt(Fx.sub(y, this.oy))\n            );\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            p.color = this.galois.randomRange(1, 14);\n            return p;\n        }\n    }\n\n    export class ConfettiFactory extends ShapeFactory {\n        constructor(xRange: number, yRange: number) {\n            const confetti = [\n                img`\n                    F\n                `,\n                img`\n                    F\n                    F\n                `,\n                img`\n                    F F\n                `,\n                img`\n                    F F\n                    F .\n                `,\n                img`\n                    F F\n                    . F\n            `];\n            super(xRange, yRange, confetti[0]);\n            for (let i = 1; i < confetti.length; i++) {\n                this.addShape(confetti[i]);\n            }\n\n            this.minLifespan = 1000;\n            this.maxLifespan = 4500;\n        }\n    }\n\n    export class FireFactory extends ParticleFactory {\n        protected galois: Math.FastRandom;\n        protected minRadius: number;\n        protected maxRadius: number;\n    \n        constructor(radius: number) {\n            super();\n            initTrig();\n            this.galois = new Math.FastRandom();\n            this.minRadius = radius >> 1;\n            this.maxRadius = radius;\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            p.color = this.galois.randomBool() ?\n                2 : this.galois.randomBool() ?\n                    4 : 5;\n\n            const i = this.galois.randomRange(0, cachedCos.length);\n            const r = this.galois.randomRange(this.minRadius, this.maxRadius);\n\n            p._x = Fx.iadd(anchor.x, Fx.mul(Fx8(r), cachedCos[i]));\n            p._y = Fx.iadd(anchor.y, Fx.mul(Fx8(r), cachedSin[i]));\n            p.vy = Fx8(Math.randomRange(0, 10));\n            p.vx = Fx8(Math.randomRange(-5, 5));\n            p.lifespan = 1500;\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(\n                Fx.toInt(x),\n                Fx.toInt(y),\n                p.color\n            );\n        }\n    }\n\n    export class RadialFactory extends ParticleFactory {\n        protected r: Fx8;\n        protected speed: Fx8;\n        protected t: number;\n        protected spread: number;\n        protected galois: Math.FastRandom;\n        protected colors: number[];\n\n        constructor(radius: number, speed: number, spread: number, colors?: number[]) {\n            super();\n            initTrig();\n\n            if (colors && colors.length != 0)\n                this.colors = colors;\n            else\n                this.colors = [0x2, 0x3, 0x4, 0x5];\n\n            this.setRadius(radius)\n            this.speed = Fx8(-speed);\n            this.spread = spread;\n            this.t = 0;\n            this.galois = new Math.FastRandom();\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const time = ++this.t % cachedCos.length;\n            const offsetTime = (time + this.galois.randomRange(0, this.spread)) % cachedCos.length;\n\n            p._x = Fx.iadd(anchor.x, Fx.mul(this.r, cachedCos[time]));\n            p._y = Fx.iadd(anchor.y, Fx.mul(this.r, cachedSin[time]));\n            p.vx = Fx.mul(this.speed, Fx.neg(cachedSin[offsetTime]));\n            p.vy = Fx.mul(this.speed, cachedCos[offsetTime]);\n\n            p.lifespan = this.galois.randomRange(200, 1500);\n            p.color = this.galois.pickRandom(this.colors);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(\n                Fx.toInt(x),\n                Fx.toInt(y),\n                p.color\n            );\n        }\n\n        setRadius(r: number) {\n            this.r = Fx8(r >> 1);\n        }\n\n        setSpeed(s: number) {\n            this.speed = Fx8(-s);\n        }\n\n        setSpread(s: number) {\n            this.spread = s;\n        }\n    }\n\n    class ColorCount {\n        constructor(public color: number, public count: number) { }\n    }\n\n    export class AshFactory extends AreaFactory {\n        private colors: ColorCount[];\n        \n        constructor(anchor: ParticleAnchor, updateImage?: boolean, percentKept: number = 20) {\n            super(anchor.width ? anchor.width : 8, anchor.height ? anchor.height >> 1 : 8, 300, 700);\n\n            if (!anchor.image) {\n                this.colors = [new ColorCount(1, 20)];\n                return;\n            }\n\n            let counts: number[] = [];\n            for (let i = 0x0; i <= 0xF; i++) {\n                counts[i] = 0;\n            }\n            let result: Image = anchor.image.clone();\n\n            for (let x = 0; x < result.width; x++) {\n                for (let y = 0; y < result.height; y++) {\n                    const c = result.getPixel(x, y);\n                    if (c && this.galois.percentChance(percentKept)) {\n                        counts[c]++;\n                        result.setPixel(x, y, 0x0);\n                    }\n                }\n            }\n\n            /** TODO: The following should be:\n             * if (updateImage && anchor.setImage) {\n             *     anchor.setImage(result);\n             * }\n             * but this fails due to https://github.com/Microsoft/pxt-arcade/issues/515 .\n             * This is a temporary workaround.\n             */\n            if (updateImage) {\n                (anchor as Sprite).setImage(result);\n            }\n\n            this.colors = counts\n                .map((value: number, index: number) => new ColorCount(index, value))\n                .filter(v => v.count != 0);\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            if (this.colors.length === 0) return undefined;\n\n            const index = this.galois.randomRange(0, this.colors.length - 1);\n            const choice = this.colors[index];\n            const p = super.createParticle(anchor);\n\n            choice.count--;\n            if (choice.count === 0) this.colors.removeAt(index);\n\n            p.color = choice.color;\n\n            p._y = Fx.iadd(this.galois.randomRange(this.yRange >> 1, this.yRange), p._y);\n            p.vx = anchor.vx ? Fx.neg(Fx8(anchor.vx >> 2)): Fx.zeroFx8;\n            p.vy = Fx8(this.galois.randomRange(-150, -50));\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            screen.setPixel(Fx.toInt(x), Fx.toInt(y), p.color);\n        }\n    }\n\n    export class BubbleFactory extends ParticleFactory {\n        minLifespan: number;\n        maxLifespan: number;\n        xRange: number;\n        yRange: number;\n        protected galois: Math.FastRandom;\n        protected states: Image[];\n    \n        constructor(sprite: ParticleAnchor, minLifespan: number, maxLifespan: number) {\n            super();\n            initTrig();\n            this.galois = new Math.FastRandom();\n\n            this.xRange = sprite.width ? sprite.width : 16;\n            this.yRange = 8;\n            this.minLifespan = minLifespan;\n            this.maxLifespan = maxLifespan;\n\n            this.states = [\n                img`\n                    F\n                `, img`\n                    F F\n                `, img`\n                    F F\n                    F F\n                `, img`\n                    F F F\n                    F . F\n                    F F F\n                `, img`\n                    . F F .\n                    F . . F\n                    F . . F\n                    . F F .\n                `, img`\n                    . F F F .\n                    F . . . F\n                    F . . . F\n                    . F F F .\n                `\n            ];\n        }\n\n        get stateCount(): number {\n            return this.states.length;\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n\n            p.lifespan = this.galois.randomRange(this.minLifespan, this.maxLifespan);\n            p._x = Fx.iadd(this.galois.randomRange(0, this.xRange) - (this.xRange >> 1), p._x);\n            p._y = Fx.iadd(this.galois.randomRange(-this.yRange, 0) + (anchor.height ? anchor.height >> 1 : 0), p._y);\n\n            p.vy = Fx8(Math.randomRange(-30, -5));\n            p.vx = Fx8(Math.randomRange(-10, 10));\n\n            p.data = this.galois.percentChance(80) ? 0 : 2;\n            p.color = this.galois.percentChance(90) ?\n                0x9 : (this.galois.percentChance(50) ?\n                    0x6 : 0x8);\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            const toDraw = this.states[p.data].clone();\n            toDraw.replace(0xF, p.color);\n            screen.drawTransparentImage(toDraw, Fx.toInt(x), Fx.toInt(y));\n        }\n    }\n\n    export class StarFactory extends ParticleFactory {\n        protected galois: Math.FastRandom;\n        protected possibleColors: number[]\n        minRate: number;\n        maxRate: number;\n        images: Image[];\n\n        constructor(possibleColors?: number[], minRate: number = 15, maxRate: number = 25) {\n            super();\n            this.galois = new Math.FastRandom();\n            this.minRate = minRate;\n            this.maxRate = maxRate;\n            this.images = [\n                img`\n                    1\n                `,\n                img`\n                    1 . 1\n                    . 1 .\n                    1 . 1\n                `, img`\n                    . 1 .\n                    1 1 1\n                    . 1 .\n                `\n            ];\n\n            if (possibleColors && possibleColors.length)\n                this.possibleColors = possibleColors\n            else\n                this.possibleColors = [1];\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const xRange = anchor.width ? anchor.width >> 1 : 8;\n\n            p._x = Fx8(this.galois.randomRange(anchor.x - xRange, anchor.x + xRange));\n            p._y = Fx8(anchor.height ? anchor.y - (anchor.height >> 1) : anchor.y);\n            p.vy = Fx8(this.galois.randomRange(this.minRate, this.maxRate));\n\n            // set lifespan based off velocity and screen height (plus a little to make sure it doesn't disappear early)\n            p.lifespan = Fx.toInt(Fx.mul(Fx.div(Fx8(screen.height + 20), p.vy), Fx8(1000)));\n\n            const length = this.possibleColors.length - 1;\n            p.color = this.possibleColors[this.possibleColors.length - 1];\n            for (let i = 0; i < length; ++i) {\n                if (this.galois.percentChance(80 - (i * 10))) {\n                    p.color = this.possibleColors[i];\n                    break;\n                }\n            }\n\n            // images besides the first one are only used on occasion\n            p.data = this.galois.percentChance(15) ? this.galois.randomRange(1, this.images.length - 1) : 0;\n\n            return p;\n        }\n\n        drawParticle(p: Particle, x: Fx8, y: Fx8) {\n            // on occasion, twinkle from white to yellow\n            const twinkleFlag = 0x8000;\n            const rest = 0x7FFF;\n            if (twinkleFlag && p.data) {\n                if (this.galois.percentChance(10)) {\n                    p.color = 1;\n                    p.data &= rest;\n                }\n            } else if (p.color === 1 && this.galois.percentChance(1)) {\n                p.color = 5;\n                p.data |= twinkleFlag;\n            }\n\n            const selected = this.images[rest & p.data].clone();\n            selected.replace(0x1, p.color);\n            screen.drawTransparentImage(selected, Fx.toInt(x), Fx.toInt(y));\n        }\n    }\n\n    export class CloudFactory extends ParticleFactory {\n        minRate: number;\n        maxRate: number;\n        clouds: Image[];\n        camera: scene.Camera;\n\n        constructor(minRate: number = 8, maxRate: number = 12) {\n            super();\n\n            this.minRate = minRate;\n            this.maxRate = maxRate;\n            this.camera = game.currentScene().camera;\n\n            this.clouds = [\n                img`\n                    . . . . . . . . . . f f f . . .\n                    . . . . . . . . . f f 9 f f . .\n                    . f f f . f f f . f 9 9 9 f f .\n                    f f 1 f f f 1 f f f 1 1 1 9 f f\n                    f 1 9 1 9 9 1 9 9 1 1 1 1 9 9 f\n                    f 9 1 9 9 1 9 1 1 9 1 1 1 1 1 f\n                    f f 1 1 1 1 1 1 1 1 1 1 1 1 1 f\n                    . f 1 1 1 1 9 9 1 f f f 1 1 1 f\n                    . f 1 f f f 9 f f f . f f 1 f f\n                    . f f f . f f f . . . . f f f .\n                `, img`\n                    . . . . . f f f f f . .\n                    . . f f . f 1 1 1 f f .\n                    f f f 1 f f 9 9 1 1 f .\n                    f 9 9 1 1 1 1 1 9 9 f f\n                    . f 1 9 9 1 9 1 1 1 1 f\n                    f 1 f f f 1 1 1 1 9 9 f\n                    f f f . f f f f 9 f f f\n                    . . . . . . . f f f . .\n                `, img`\n                    . . . . . . . . f f f . .\n                    . . . . . . . f f 1 f . .\n                    . f f f . . . f 1 9 f f .\n                    f f 1 f f . f f 1 1 1 f f\n                    f 1 9 1 f f f 1 9 1 1 1 f\n                    f f 1 9 1 1 1 9 1 1 1 1 f\n                    . f f 9 1 1 9 9 1 1 1 f f\n                    . . f 1 1 9 9 1 1 1 f f .\n                    . . f f 1 1 1 1 1 f f . .\n                    . . . f f 1 f f f f . . .\n                    . . . . f f f . . . . . .\n                `, img`\n                    . f f f .\n                    f 1 9 1 f\n                    f 9 1 1 f\n                    f f 1 f f\n                    . f f f .\n                `, img`\n                    . . . . . f f f f f f .\n                    . . . f f f 1 1 1 1 f f\n                    . f f f 1 9 1 1 9 1 1 f\n                    f f 1 1 9 1 1 1 9 1 1 f\n                    f 1 1 9 1 1 1 9 1 1 1 f\n                    f f 1 9 1 1 1 1 1 1 1 f\n                    . f f 1 1 1 1 1 1 1 f f\n                    . . f f f f f f f f f .\n                `, img`\n                    . f f f . .\n                    f f 1 f . .\n                    f 1 1 f f f\n                    f 1 9 9 1 f\n                    f 9 1 1 1 f\n                    f f 1 1 1 f\n                    . f 1 1 1 f\n                    . f f f f f\n                `, img`\n                    . . . . . . . . . . . . f f f\n                    . . . . . . . . . . f f f 1 f\n                    f f f f f . f f f . f 1 1 1 f\n                    f 1 1 1 f f f 1 f . f 1 1 1 f\n                    f f 1 1 1 f 1 1 f f f 1 1 1 f\n                    . f f 1 9 1 1 9 1 1 1 1 1 1 f\n                    . . f 9 1 1 1 9 1 1 1 1 1 f f\n                    . . f 1 1 1 9 9 1 1 1 1 1 f .\n                    . . f 1 1 9 9 1 1 1 1 1 f f .\n                    . . f f f 1 1 1 1 f f f f . .\n                    . . . . f f 1 f f f . . . . .\n                    . . . . . f f f . . . . . . .\n                `\n            ];\n        }\n\n        createParticle(anchor: ParticleAnchor) {\n            const p = super.createParticle(anchor);\n            const yRange = anchor.height ? anchor.height >> 1 : 8;\n            p.data = Math.randomRange(0, this.clouds.length - 1);\n            p._x = Fx8(anchor.width ? anchor.x + (anchor.width >> 1) : anchor.x)\n            p._y = Fx.add(\n                Fx8(Math.randomRange(anchor.y - yRange, anchor.y + yRange)),\n                Fx8(this.clouds[p.data].width >> 1)\n            );\n            p.vx = Fx8(-Math.randomRange(this.minRate, this.maxRate));\n\n            // p.color stores information on conjoined clouds\n            p.color = 0;\n            if (Math.percentChance(30)) {\n                const isConjoined = 1 << 0;\n                const isOffsetX = Math.randomRange(0, 1) << 1;\n                const isOffsetY = Math.randomRange(0, 1) << 2;\n                const selection = Math.randomRange(0, this.clouds.length - 1) << 3;\n\n                p.color = isConjoined | isOffsetX | isOffsetY | selection;\n            }\n\n            p.lifespan = Fx.toInt(\n                Fx.mul(\n                    Fx.div(\n                        Fx8(screen.width + 30),\n                        Fx.abs(p.vx)\n                    ),\n                    Fx8(1000)\n                )\n            );\n\n            return p;\n        }\n\n        drawParticle(p: particles.Particle, x: Fx8, y: Fx8) {\n            const mainImage = this.clouds[p.data];\n            screen.drawTransparentImage(\n                mainImage,\n                Fx.toInt(x),\n                Fx.toInt(y)\n            );\n\n            if (p.color & 1) {\n                const isOffsetX = (p.color >> 1) & 1;\n                const isOffsetY = (p.color >> 2) & 1;\n                const selection = this.clouds[p.color >> 3];\n\n                const xOffset = isOffsetX ? Fx8(mainImage.width >> 2) : Fx.zeroFx8;\n                const yOffset = isOffsetY ? Fx8(mainImage.height >> 2) : Fx.zeroFx8;\n\n                screen.drawTransparentImage(\n                    selection,\n                    Fx.toInt(Fx.add(x, xOffset)),\n                    Fx.toInt(Fx.add(y, yOffset))\n                );\n            }\n        }\n    }\n}\n",
            "particles.ts": "namespace particles {\n    enum Flag {\n        enabled = 1 << 0,\n        destroyed = 1 << 1,\n    }\n\n    // maximum count of sources before removing previous sources\n    const MAX_SOURCES = (() => {\n        const sz = control.ramSize();\n        if (sz <= 1024 * 100) {\n            return 8;\n        } else if (sz <= 1024 * 200) {\n            return 16;\n        } else {\n            return 50;\n        }\n    })();\n    const TIME_PRECISION = 10; // time goes down to down to the 1<<10 seconds\n    let lastUpdate: number;\n\n    /**\n     * A single particle\n     */\n    export class Particle {\n        _x: Fx8;\n        _y: Fx8;\n        vx: Fx8;\n        vy: Fx8;\n        lifespan: number;\n        next: Particle;\n        data?: number;\n        color?: number;\n    }\n\n    /**\n     * An anchor for a Particle to originate from\n     */\n    export interface ParticleAnchor {\n        x: number;\n        y: number;\n        vx?: number;\n        vy?: number;\n        width?: number;\n        height?: number;\n        image?: Image;\n        flags?: number;\n        setImage?: (i: Image) => void;\n    }\n\n    /**\n     * A source of particles\n     */\n    export class ParticleSource extends sprites.BaseSprite {\n        /**\n         * A relative ranking of this sources priority\n         * When necessary, a source with a lower priority will\n         * be culled before a source with a higher priority.\n         */\n        priority: number;\n        _dt: number;\n        /**\n         * The anchor this source is currently attached to\n         */\n        anchor: ParticleAnchor;\n        /**\n         * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n         * and the source gets destroyed when it reaches 0.\n         */\n        lifespan: number;\n\n        protected pFlags: number;\n        protected head: Particle;\n        protected timer: number;\n        protected period: number;\n        protected _factory: ParticleFactory;\n\n        protected ax: Fx8;\n        protected ay: Fx8;\n\n        /**\n         * @param anchor to emit particles from\n         * @param particlesPerSecond rate at which particles are emitted\n         * @param factory [optional] factory to generate particles with; otherwise, \n         */\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, factory?: ParticleFactory) {\n            super(scene.SPRITE_Z)\n            init();\n            const sources = particleSources();\n\n            // remove and immediately destroy oldest source if over MAX_SOURCES\n            if (sources.length >= MAX_SOURCES) {\n                sortSources(sources);\n                const removedSource = sources.shift();\n                removedSource.clear();\n                removedSource.destroy();\n            }\n\n            this.pFlags = 0;\n            this.setRate(particlesPerSecond);\n            this.setAcceleration(0, 0);\n            this.setAnchor(anchor);\n            this.lifespan = undefined;\n            this._dt = 0;\n            this.priority = 0;\n            this.setFactory(factory || particles.defaultFactory);\n            sources.push(this);\n            this.enabled = true;\n        }\n\n        __draw(camera: scene.Camera) {\n            let current = this.head;\n            const left = Fx8(camera.drawOffsetX);\n            const top = Fx8(camera.drawOffsetY);\n\n            while (current) {\n                if (current.lifespan > 0)\n                    this.drawParticle(current, left, top);\n                current = current.next;\n            }\n        }\n\n        _update(dt: number) {\n            this.timer -= dt;\n\n            if (this.lifespan !== undefined) {\n                this.lifespan -= dt;\n                if (this.lifespan <= 0) {\n                    this.lifespan = undefined;\n                    this.destroy();\n                }\n            } else if (this.anchor && this.anchor.flags !== undefined && (this.anchor.flags & sprites.Flag.Destroyed)) {\n                this.lifespan = 750;\n            }\n\n            while (this.timer < 0 && this.enabled) {\n                this.timer += this.period;\n                const p = this._factory.createParticle(this.anchor);\n                if (!p) continue; // some factories can decide to not produce a particle\n                p.next = this.head;\n                this.head = p;\n            }\n\n            if (!this.head) return;\n\n            let current = this.head;\n\n            this._dt += dt;\n            let fixedDt = Fx8(this._dt);\n            if (fixedDt) {\n                do {\n                    if (current.lifespan > 0) {\n                        current.lifespan -= dt;\n                        this.updateParticle(current, fixedDt)\n                    }\n                } while (current = current.next);\n                this._dt = 0;\n            } else {\n                do {\n                    current.lifespan -= dt;\n                } while (current = current.next);\n            }\n        }\n\n        _prune() {\n            while (this.head && this.head.lifespan <= 0) {\n                this.head = this.head.next;\n            }\n\n            if ((this.pFlags & Flag.destroyed) && !this.head) {\n                const scene = game.currentScene();\n                if (scene)\n                    scene.allSprites.removeElement(this);\n                const sources = particleSources();\n                if (sources && sources.length)\n                    sources.removeElement(this);\n                this.anchor == undefined;\n            }\n\n            let current = this.head;\n            while (current && current.next) {\n                if (current.next.lifespan <= 0) {\n                    current.next = current.next.next;\n                } else {\n                    current = current.next;\n                }\n            }\n        }\n\n        /**\n         * Sets the acceleration applied to the particles\n         */\n        setAcceleration(ax: number, ay: number) {\n            this.ax = Fx8(ax);\n            this.ay = Fx8(ay);\n        }\n\n        /**\n         * Enables or disables particles\n         * @param on \n         */\n        setEnabled(on: boolean) {\n            this.enabled = on;\n        }\n\n        get enabled() {\n            return !!(this.pFlags & Flag.enabled);\n        }\n\n        /**\n         * Set whether this source is currently enabled (emitting particles) or not\n         */\n        set enabled(v: boolean) {\n            if (v !== this.enabled) {\n                this.pFlags = v ? (this.pFlags | Flag.enabled) : (this.pFlags ^ Flag.enabled);\n                this.timer = 0;\n            }\n        }\n\n        /**\n         * Destroy the source\n         */\n        destroy() {\n            // The `_prune` step will finishing destroying this Source once all emitted particles finish rendering\n            this.enabled = false;\n            this.pFlags |= Flag.destroyed;\n            this._prune();\n        }\n\n        /**\n         * Clear all particles emitted from this source\n         */\n        clear() {\n            this.head = undefined;\n        }\n\n        /**\n         * Set a anchor for particles to be emitted from\n         * @param anchor\n         */\n        setAnchor(anchor: ParticleAnchor) {\n            this.anchor = anchor;\n        }\n\n        /**\n         * Sets the number of particle created per second\n         * @param particlesPerSecond \n         */\n        setRate(particlesPerSecond: number) {\n            this.period = Math.ceil(1000 / particlesPerSecond);\n            this.timer = 0;\n        }\n\n        get factory(): ParticleFactory {\n            return this._factory;\n        }\n\n        /**\n         * Sets the particle factor\n         * @param factory \n         */\n        setFactory(factory: ParticleFactory) {\n            if (factory)\n                this._factory = factory;\n        }\n\n        protected updateParticle(p: Particle, fixedDt: Fx8) {\n            fixedDt = Fx.rightShift(fixedDt, TIME_PRECISION);\n\n            p.vx = Fx.add(p.vx, Fx.mul(this.ax, fixedDt));\n            p.vy = Fx.add(p.vy, Fx.mul(this.ay, fixedDt));\n\n            p._x = Fx.add(p._x, Fx.mul(p.vx, fixedDt));\n            p._y = Fx.add(p._y, Fx.mul(p.vy, fixedDt));\n        }\n\n        protected drawParticle(p: Particle, screenLeft: Fx8, screenTop: Fx8) {\n            this._factory.drawParticle(p, Fx.sub(p._x, screenLeft), Fx.sub(p._y, screenTop));\n        }\n    }\n\n    //% whenUsed\n    export const defaultFactory = new particles.SprayFactory(20, 0, 60);\n\n    /**\n     * Creates a new source of particles attached to a sprite\n     * @param sprite \n     * @param particlesPerSecond number of particles created per second\n     */\n    export function createParticleSource(sprite: Sprite, particlesPerSecond: number): ParticleSource {\n        return new ParticleSource(sprite, particlesPerSecond);\n    }\n\n    function init() {\n        const scene = game.currentScene();\n        if (scene.particleSources) return;\n        scene.particleSources = [];\n        lastUpdate = control.millis();\n        game.onUpdate(updateParticles);\n        game.onUpdateInterval(250, pruneParticles);\n    }\n\n    function updateParticles() {\n        const sources = particleSources();\n        if (!sources) return;\n        sortSources(sources);\n\n        const time = control.millis();\n        const dt = time - lastUpdate;\n        lastUpdate = time;\n\n        for (let i = 0; i < sources.length; i++) {\n            sources[i]._update(dt);\n        }\n    }\n\n    function pruneParticles() {\n        const sources = particleSources();\n        if (sources) sources.slice(0, sources.length).forEach(s => s._prune());\n    }\n    \n    function sortSources(sources: ParticleSource[]) {\n        sources.sort((a, b) => (a.priority - b.priority || a.id - b.id));\n    }\n\n    /**\n     * A source of particles where particles will occasionally change speed based off of each other\n     */\n    export class FireSource extends ParticleSource {\n        protected galois: Math.FastRandom;\n\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, factory?: ParticleFactory) {\n            super(anchor, particlesPerSecond, factory);\n            this.galois = new Math.FastRandom();\n            this.z = 20;\n        }\n\n        updateParticle(p: Particle, fixedDt: Fx8) {\n            super.updateParticle(p, fixedDt);\n            if (p.next && this.galois.percentChance(30)) {\n                p.vx = p.next.vx;\n                p.vy = p.next.vy;\n            }\n        }\n    }\n\n    /**\n     * A source of particles where the particles oscillate horizontally, and occasionally change\n     * between a given number of defined states\n     */\n    export class BubbleSource extends ParticleSource {\n        protected maxState: number;\n        protected galois: Math.FastRandom;\n        stateChangePercentage: number;\n        oscillationPercentage: number\n\n        constructor(anchor: ParticleAnchor, particlesPerSecond: number, maxState: number, factory?: ParticleFactory) {\n            super(anchor, particlesPerSecond, factory);\n            this.galois = new Math.FastRandom();\n            this.maxState = maxState;\n            this.stateChangePercentage = 3;\n            this.oscillationPercentage = 4;\n        }\n\n        updateParticle(p: Particle, fixedDt: Fx8) {\n            super.updateParticle(p, fixedDt);\n            if (this.galois.percentChance(this.stateChangePercentage)) {\n                if (p.data < this.maxState) {\n                    p.data++;\n                } else if (p.data > 0) {\n                    p.data--;\n                }\n            }\n\n            if (this.galois.percentChance(this.oscillationPercentage)) {\n                p.vx = Fx.neg(p.vx);\n            }\n        }\n    }\n\n    export function clearAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.clear());\n            pruneParticles();\n        }\n    }\n\n    /**\n     * Stop all particle sources from creating any new particles\n     */\n    export function disableAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.enabled = false);\n            pruneParticles();\n        }\n    }\n\n    /**\n     * Allow all particle sources to create any new particles\n     */\n    export function enableAll() {\n        const sources = particleSources();\n        if (sources) {\n            sources.forEach(s => s.enabled = true);\n            pruneParticles();\n        }\n    }\n\n    function particleSources() {\n        const sources = game.currentScene().particleSources;\n        return sources;\n    }\n}\n",
            "physics.ts": "class PhysicsEngine {\n    constructor() {\n    }\n\n    /**\n     * Adds sprite to the physics\n     * @param sprite\n     */\n    addSprite(sprite: Sprite) { }\n\n    removeSprite(sprite: Sprite) { }\n\n    /** move a single sprite **/\n    moveSprite(s: Sprite, dx: Fx8, dy: Fx8) { }\n\n    draw() { }\n\n    /** Apply physics and collisions to all sprites **/\n    move(dt: number) { }\n\n    overlaps(sprite: Sprite): Sprite[] { return []; }\n}\n\nconst MAX_TIME_STEP = Fx8(100); // milliseconds\nconst SPRITE_CANNOT_COLLIDE = sprites.Flag.Ghost | sprites.Flag.Destroyed;\nconst MIN_MOVE_GAP = Fx8(0.1);\n\nclass MovingSprite {\n    constructor(\n        public sprite: Sprite,\n        // vx and vy when last updated\n        public cachedVx: Fx8,\n        public cachedVy: Fx8,\n        // remaining x\n        public dx: Fx8,\n        public dy: Fx8,\n        // how much to move per step\n        public xStep: Fx8,\n        public yStep: Fx8\n    ) { }\n}\n\n/**\n * A physics engine that does simple AABB bounding box check\n */\nclass ArcadePhysicsEngine extends PhysicsEngine {\n    protected sprites: Sprite[];\n    protected map: sprites.SpriteMap;\n    protected maxVelocity: Fx8;\n    protected maxNegativeVelocity: Fx8;\n    protected minSingleStep: Fx8;\n    protected maxSingleStep: Fx8;\n\n    constructor(maxVelocity = 500, minSingleStep = 2, maxSingleStep = 4) {\n        super();\n        this.sprites = [];\n        this.maxVelocity = Fx8(maxVelocity);\n        this.maxNegativeVelocity = Fx.neg(this.maxVelocity);\n        this.map = new sprites.SpriteMap();\n        this.minSingleStep = Fx8(minSingleStep);\n        this.maxSingleStep = Fx8(maxSingleStep);\n    }\n\n    addSprite(sprite: Sprite) {\n        this.sprites.push(sprite);\n    }\n\n    removeSprite(sprite: Sprite) {\n        this.sprites.removeElement(sprite);\n    }\n\n    draw() {\n        this.map.draw();\n    }\n\n    move(dt: number) {\n        // Sprite movement logic is done in milliseconds to avoid rounding errors with Fx8 numbers\n        const dtf = Fx.min(\n            MAX_TIME_STEP,\n            Fx8(dt * 1000)\n        );\n        const dtSec = Fx.idiv(dtf, 1000);\n        const dt2 = Fx.idiv(dtf, 2);\n\n        const scene = game.currentScene();\n\n        const movingSprites = this.sprites\n            .map(sprite => this.createMovingSprite(sprite, dtSec, dt2));\n        const tileMap = scene.tileMap;\n\n        // clear obstacles if moving on that axis\n        this.sprites.forEach(s => {\n            if (s.vx || s.vy) s.clearObstacles();\n        });\n\n        this.map.clear();\n        this.map.resizeBuckets(this.sprites);\n\n        const MAX_STEP_COUNT = Fx.toInt(\n            Fx.mul(\n                Fx.div(\n                    this.maxVelocity,\n                    this.minSingleStep\n                ),\n                dtSec\n            )\n        );\n        const overlapHandlers = scene.overlapHandlers.slice();\n\n        // buffers store the moving sprites on each step; switch back and forth between the two\n        let selected = 0;\n        let buffers = [movingSprites, []];\n        for (let count = 0; count < MAX_STEP_COUNT && buffers[selected].length !== 0; ++count) {\n            const currMovers = buffers[selected];\n            selected ^= 1;\n            const remainingMovers = buffers[selected];\n\n            for (let ms of currMovers) {\n                const s = ms.sprite;\n                // if still moving and speed has changed from a collision or overlap;\n                // reverse direction if speed has reversed\n                if (ms.cachedVx !== s._vx) {\n                    if (s._vx == Fx.zeroFx8) {\n                        ms.dx = Fx.zeroFx8;\n                    } else if (s._vx < Fx.zeroFx8 && ms.cachedVx > Fx.zeroFx8\n                            || s._vx > Fx.zeroFx8 && ms.cachedVx < Fx.zeroFx8) {\n                        ms.dx = Fx.neg(ms.dx);\n                        ms.xStep = Fx.neg(ms.xStep);\n                    }\n\n                    ms.cachedVx = s._vx;\n                }\n                if (ms.cachedVy !== s._vy) {\n                    if (s._vy == Fx.zeroFx8) {\n                        ms.dy = Fx.zeroFx8;\n                    } else if (s._vy < Fx.zeroFx8 && ms.cachedVy > Fx.zeroFx8\n                            || s._vy > Fx.zeroFx8 && ms.cachedVy < Fx.zeroFx8) {\n                        ms.dy = Fx.neg(ms.dy);\n                        ms.yStep = Fx.neg(ms.yStep);\n                    }\n\n                    ms.cachedVy = s._vy;\n                }\n\n                // identify how much to move in this step\n                const stepX = Fx.abs(ms.xStep) > Fx.abs(ms.dx) ? ms.dx : ms.xStep;\n                const stepY = Fx.abs(ms.yStep) > Fx.abs(ms.dy) ? ms.dy : ms.yStep;\n                ms.dx = Fx.sub(ms.dx, stepX);\n                ms.dy = Fx.sub(ms.dy, stepY);\n\n                s._lastX = s._x;\n                s._lastY = s._y;\n                s._x = Fx.add(s._x, stepX);\n                s._y = Fx.add(s._y, stepY);\n\n                // if the sprite can collide with things, check tile map\n                // and add to collision detection\n                if (!(s.flags & SPRITE_CANNOT_COLLIDE)) {\n                    this.map.insertAABB(s);\n                    if (tileMap && tileMap.enabled) {\n                        this.tilemapCollisions(ms, tileMap);\n                    }\n                }\n\n                // if sprite still needs to move, add it to the next step of movements\n                if (Fx.abs(ms.dx) > MIN_MOVE_GAP || Fx.abs(ms.dy) > MIN_MOVE_GAP) {\n                    remainingMovers.push(ms);\n                }\n            }\n\n            // this step is done; check collisions between sprites\n            this.spriteCollisions(currMovers, overlapHandlers);\n            // clear moving sprites buffer for next step\n            while (currMovers.length) currMovers.pop();\n        }\n    }\n\n    private createMovingSprite(sprite: Sprite, dtSec: Fx8, dt2: Fx8): MovingSprite {\n        const ovx = this.constrain(sprite._vx);\n        const ovy = this.constrain(sprite._vy);\n        sprite._lastX = sprite._x;\n        sprite._lastY = sprite._y;\n\n        sprite._vx = this.constrain(\n            Fx.add(\n                sprite._vx,\n                Fx.mul(\n                    sprite._ax,\n                    dtSec\n                )\n            )\n        );\n        sprite._vy = this.constrain(\n            Fx.add(\n                sprite._vy,\n                Fx.mul(\n                    sprite._ay,\n                    dtSec\n                )\n            )\n        );\n\n        const dx = Fx.idiv(\n            Fx.mul(\n                Fx.add(\n                    sprite._vx,\n                    ovx\n                ),\n                dt2\n            ),\n            1000\n        );\n\n        const dy = Fx.idiv(\n            Fx.mul(\n                Fx.add(\n                    sprite._vy,\n                    ovy\n                ),\n                dt2\n            ),\n            1000\n        );\n\n        let xStep = dx;\n        let yStep = dy;\n\n        // make step increments smaller until under max step size\n        while (Fx.abs(xStep) > this.maxSingleStep || Fx.abs(yStep) > this.maxSingleStep) {\n            if (Fx.abs(xStep) > this.minSingleStep) {\n                xStep = Fx.idiv(xStep, 2);\n            }\n            if (Fx.abs(yStep) > this.minSingleStep) {\n                yStep = Fx.idiv(yStep, 2);\n            }\n        }\n\n        return new MovingSprite(\n            sprite,\n            sprite._vx,\n            sprite._vy,\n            dx,\n            dy,\n            xStep,\n            yStep\n        );\n    }\n\n    private spriteCollisions(movedSprites: MovingSprite[], handlers: scene.OverlapHandler[]) {\n        control.enablePerfCounter(\"phys_collisions\");\n        if (!handlers.length) return;\n\n        // sprites that have moved this step\n        for (const ms of movedSprites) {\n            const sprite = ms.sprite;\n            if (sprite.flags & SPRITE_CANNOT_COLLIDE) continue;\n            const overSprites = this.map.overlaps(ms.sprite);\n\n            for (const overlapper of overSprites) {\n                if (overlapper.flags & SPRITE_CANNOT_COLLIDE) continue;\n                const thisKind = sprite.kind();\n                const otherKind = overlapper.kind();\n\n                // skip if no overlap event between these two kinds of sprites\n                if (sprite._kindsOverlappedWith.indexOf(otherKind) === -1) continue;\n\n                // Maintaining invariant that the sprite with the higher ID has the other sprite as an overlapper\n                const higher = sprite.id > overlapper.id ? sprite : overlapper;\n                const lower = higher === sprite ? overlapper : sprite;\n\n                // if the two sprites are not currently engaged in an overlap event,\n                // apply all matching overlap events\n                if (higher._overlappers.indexOf(lower.id) === -1) {\n                    handlers\n                        .filter(h => (h.kind === thisKind && h.otherKind === otherKind)\n                                    || (h.kind === otherKind && h.otherKind === thisKind)\n                        )\n                        .forEach(h => {\n                            higher._overlappers.push(lower.id);\n                            control.runInParallel(() => {\n                                h.handler(\n                                    thisKind === h.kind ? sprite : overlapper,\n                                    thisKind === h.kind ? overlapper : sprite\n                                );\n                                higher._overlappers.removeElement(lower.id);\n                            });\n                        });\n                }\n            }\n        }\n    }\n\n    private tilemapCollisions(movingSprite: MovingSprite, tm: tiles.TileMap) {\n        const sprite = movingSprite.sprite;\n        const tileScale = tm ? tm.scale : 0;\n        const tileSize = tm ? 1 << tileScale : 0;\n\n        const xDiff = Fx.sub(\n            sprite._x,\n            sprite._lastX\n        );\n\n        const yDiff = Fx.sub(\n            sprite._y,\n            sprite._lastY\n        );\n\n        if (xDiff !== Fx.zeroFx8) {\n            const right = xDiff > Fx.zeroFx8;\n            const x0 = Fx.toIntShifted(\n                Fx.add(\n                    right ?\n                        Fx.iadd(1, sprite._hitbox.right)\n                        :\n                        Fx.iadd(-1, sprite._hitbox.left),\n                    Fx.oneHalfFx8\n                ),\n                tileScale\n            );\n            const collidedTiles: sprites.StaticObstacle[] = [];\n\n            // check collisions with tiles sprite is moving towards horizontally\n            for (\n                let y = Fx.sub(sprite._hitbox.top, yDiff);\n                y < Fx.iadd(tileSize, Fx.sub(sprite._hitbox.bottom, yDiff));\n                y = Fx.iadd(tileSize, y)\n            ) {\n                const y0 = Fx.toIntShifted(\n                    Fx.add(\n                        Fx.min(\n                            y,\n                            Fx.sub(\n                                sprite._hitbox.bottom,\n                                yDiff\n                            )\n                        ),\n                        Fx.oneHalfFx8\n                    ),\n                    tileScale\n                );\n\n                if (tm.isObstacle(x0, y0)) {\n                    const obstacle = tm.getObstacle(x0, y0);\n                    if (!collidedTiles.some(o => o.tileIndex === obstacle.tileIndex)) {\n                        collidedTiles.push(obstacle);\n                    }\n                }\n            }\n\n            if (collidedTiles.length) {\n                const collisionDirection = right ? CollisionDirection.Right : CollisionDirection.Left;\n                sprite._x = Fx.iadd(\n                    -sprite._hitbox.ox,\n                    right ?\n                        Fx.sub(\n                            Fx8(x0 << tileScale),\n                            Fx8(sprite._hitbox.width)\n                        )\n                        :\n                        Fx8((x0 + 1) << tileScale)\n                );\n\n                for (const tile of collidedTiles) {\n                    sprite.registerObstacle(collisionDirection, tile);\n                }\n\n                if (sprite.flags & sprites.Flag.DestroyOnWall) {\n                    sprite.destroy();\n                } else if (sprite._vx === movingSprite.cachedVx){\n                    // sprite collision event didn't change velocity in this direction;\n                    // apply normal updates\n                    if (sprite.flags & sprites.Flag.BounceOnWall) {\n                        if ((!right && sprite.vx < 0) || (right && sprite.vx > 0)) {\n                            sprite._vx = Fx.neg(sprite._vx);\n                            movingSprite.xStep = Fx.neg(movingSprite.xStep);\n                            movingSprite.dx = Fx.neg(movingSprite.dx);\n                        }\n                    } else {\n                        movingSprite.dx = Fx.zeroFx8;\n                        sprite._vx = Fx.zeroFx8;\n                    }\n                } else if (Math.sign(Fx.toInt(sprite._vx)) === Math.sign(Fx.toInt(movingSprite.cachedVx))) {\n                    // sprite collision event changed velocity,\n                    // but still facing same direction; prevent further movement this update.\n                    movingSprite.dx = Fx.zeroFx8;\n                }\n            }\n        }\n\n        if (yDiff !== Fx.zeroFx8) {\n            const down = yDiff > Fx.zeroFx8;\n            const y0 = Fx.toIntShifted(\n                Fx.add(\n                    down ?\n                        Fx.iadd(1, sprite._hitbox.bottom)\n                        :\n                        Fx.iadd(-1, sprite._hitbox.top),\n                    Fx.oneHalfFx8\n                ),\n                tileScale\n            );\n            const collidedTiles: sprites.StaticObstacle[] = [];\n\n            // check collisions with tiles sprite is moving towards vertically\n            for (\n                let x = sprite._hitbox.left;\n                x < Fx.iadd(tileSize, sprite._hitbox.right);\n                x = Fx.iadd(tileSize, x)\n            ) {\n                const x0 = Fx.toIntShifted(\n                    Fx.add(\n                        Fx.min(\n                            x,\n                            sprite._hitbox.right\n                        ),\n                        Fx.oneHalfFx8\n                    ),\n                    tileScale\n                );\n\n                if (tm.isObstacle(x0, y0)) {\n                    const obstacle = tm.getObstacle(x0, y0);\n                    if (!collidedTiles.some(o => o.tileIndex === obstacle.tileIndex)) {\n                        collidedTiles.push(obstacle);\n                    }\n                }\n            }\n\n            if (collidedTiles.length) {\n                const collisionDirection = down ? CollisionDirection.Bottom : CollisionDirection.Top;\n                sprite._y = Fx.iadd(\n                    -sprite._hitbox.oy,\n                    down ?\n                        Fx.sub(\n                            Fx8(y0 << tileScale),\n                            Fx8(sprite._hitbox.height)\n                        )\n                        :\n                        Fx8((y0 + 1) << tileScale)\n                );\n\n                for (const tile of collidedTiles) {\n                    sprite.registerObstacle(collisionDirection, tile);\n                }\n\n                if (sprite.flags & sprites.Flag.DestroyOnWall) {\n                    sprite.destroy();\n                } else if (sprite._vy === movingSprite.cachedVy) {\n                    // sprite collision event didn't change velocity in this direction;\n                    // apply normal updates\n                    if (sprite.flags & sprites.Flag.BounceOnWall) {\n                        if ((!down && sprite.vy < 0) || (down && sprite.vy > 0)) {\n                            sprite._vy = Fx.neg(sprite._vy);\n                            movingSprite.yStep = Fx.neg(movingSprite.yStep);\n                            movingSprite.dy = Fx.neg(movingSprite.dy);\n                        }\n                    } else {\n                        movingSprite.dy = Fx.zeroFx8;\n                        sprite._vy = Fx.zeroFx8;\n                    }\n                } else if (Math.sign(Fx.toInt(sprite._vy)) === Math.sign(Fx.toInt(movingSprite.cachedVy))) {\n                    // sprite collision event changed velocity,\n                    // but still facing same direction; prevent further movement this update.\n                    movingSprite.dy = Fx.zeroFx8;\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns sprites that overlap with the given sprite. If type is non-zero, also filter by type.\n     * @param sprite\n     * @param layer\n     */\n    overlaps(sprite: Sprite): Sprite[] {\n        return this.map.overlaps(sprite);\n    }\n\n    /** moves a sprite explicitly outside of the normal velocity changes **/\n    public moveSprite(s: Sprite, dx: Fx8, dy: Fx8) {\n        s._lastX = s._x;\n        s._lastY = s._y;\n        s._x = Fx.add(s._x, dx);\n        s._y = Fx.add(s._y, dy);\n\n        // if the sprite can collide with things, check tile map\n        if (!(s.flags & SPRITE_CANNOT_COLLIDE)) {\n            const tm = game.currentScene().tileMap;\n            if (!(tm && tm.enabled)) return;\n\n            const tileSize = 1 << tm.scale;\n            // only check tile map if moving within a single tile\n            if (Math.abs(Fx.toInt(dx)) < tileSize && Math.abs(Fx.toInt(dy)) < tileSize) {\n                const ms = new MovingSprite(\n                    s,\n                    s._vx,\n                    s._vy,\n                    dx,\n                    dy,\n                    dx,\n                    dy\n                );\n                this.tilemapCollisions(ms, tm);\n            }\n        }\n    }\n\n    private constrain(v: Fx8) {\n        return Fx.max(\n            Fx.min(\n                this.maxVelocity,\n                v\n            ),\n            this.maxNegativeVelocity\n        );\n    }\n}\n",
            "prompt.ts": "namespace game {\n    export interface PromptTheme {\n        colorPrompt: number;\n        colorInput: number;\n        colorInputHighlighted: number;\n        colorInputText: number;\n        colorAlphabet: number;\n        colorCursor: number;\n        colorBackground: number;\n        colorBottomBackground: number;\n        colorBottomText: number;\n    }\n\n    /**\n     * Ask the player for a string value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of characters the user can enter (1 - 24)\n     */\n    //% group=\"Gameplay\"\n    //% weight=10 help=game/ask-for-string\n    //% blockId=gameaskforstring block=\"ask for string %message || and max length %answerLength\"\n    //% message.defl=\"\"\n    //% answerLength.defl=\"12\"\n    //% answerLength.min=1\n    //% answerLength.max=24\n    //% group=\"Prompt\"\n    export function askForString(message: string, answerLength = 12) {\n        let p = new game.Prompt();\n        const result = p.show(message, answerLength);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8; // FONT8-TODO\n    //% whenUsed=true\n    const PADDING = 4;\n    //% whenUsed=true\n    const PROMPT_LINE_SPACING = 2;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 26;\n    //% whenUsed=true\n    const ALPHABET_ROW_LENGTH = 12;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 2;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_WIDTH = Math.floor(CONTENT_WIDTH / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const CELL_HEIGHT = CELL_WIDTH;\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING + CELL_WIDTH / 2 + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * ALPHABET_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_ALPHABET_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING + BOTTOM_BAR_ALPHABET_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_TOP = screen.height - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_SHIFT_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 3) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n    //% whenUsed=true\n    const CONFIRM_BUTTON_LEFT = screen.width - BOTTOM_BAR_BUTTON_WIDTH;\n\n    // Dimensions of the alphabet area\n    //% whenUsed=true\n    const ALPHABET_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_TOP = CONTENT_TOP + CONTENT_HEIGHT - ALPHABET_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_INPUT_MARGIN = 10;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = ALPHABET_TOP - INPUT_HEIGHT - ALPHABET_INPUT_MARGIN;\n\n    // Dimensions of prompt message area\n    //% whenUsed=true\n    const PROMPT_HEIGHT = INPUT_TOP - CONTENT_TOP;\n\n    //% whenUsed=true\n    const lowerShiftText = \"ABC\";\n    //% whenUsed=true\n    const upperShiftText = \"abc\";\n    //% whenUsed=true\n    const digitsUpper = [\" \", \",\", \".\", \"?\", \"!\", \":\", \";\", \"\\\"\", \"(\", \")\"];\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class Prompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        private cursor: Sprite;\n        private shiftButton: Sprite;\n        private confirmButton: Sprite;\n\n        private letters: Sprite[];\n        private inputs: Sprite[];\n\n        private confirmPressed: boolean;\n        private cursorRow: number;\n        private cursorColumn: number;\n        private upper: boolean;\n        private inputIndex: number;\n        private blink: boolean;\n        private frameCount: number;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.upper = false;\n            this.inputIndex = 0;\n        }\n\n        show(message: string, answerLength: number) {\n            this.message = message;\n            this.answerLength = answerLength;\n            this.inputIndex = 0;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.draw();\n            this.registerHandlers();\n            this.confirmPressed = false;\n\n            pauseUntil(() => this.confirmPressed);\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return this.result;\n        }\n\n        private draw() {\n            this.drawPromptText();\n            this.drawKeyboard();\n            this.drawInputarea();\n            this.drawBottomBar();\n        }\n\n        private drawPromptText() {\n            const prompt = sprites.create(layoutText(this.message, CONTENT_WIDTH, PROMPT_HEIGHT, this.theme.colorPrompt), -1);\n            prompt.x = screen.width / 2\n            prompt.y = CONTENT_TOP + Math.floor((PROMPT_HEIGHT - prompt.height) / 2) + Math.floor(prompt.height / 2);\n        }\n\n        private drawInputarea() {\n            const answerLeft = ROW_LEFT + Math.floor(\n                ((CELL_WIDTH * ALPHABET_ROW_LENGTH) -\n                    CELL_WIDTH * Math.min(this.answerLength, ALPHABET_ROW_LENGTH)) / 2);\n\n            this.inputs = [];\n            for (let i = 0; i < this.answerLength; i++) {\n                const blank = image.create(CELL_WIDTH, CELL_HEIGHT);\n                this.drawInput(blank, \"\", this.theme.colorInput);\n\n                const col = i % ALPHABET_ROW_LENGTH;\n                const row = Math.floor(i / ALPHABET_ROW_LENGTH);\n\n                const s = sprites.create(blank, -1);\n                s.x = answerLeft + col * CELL_WIDTH;\n                s.y = INPUT_TOP + row * CELL_HEIGHT;\n                this.inputs.push(s);\n            }\n        }\n\n        private drawKeyboard() {\n            const cursorImage = image.create(CELL_WIDTH, CELL_HEIGHT);\n            cursorImage.fill(this.theme.colorCursor);\n            this.cursor = sprites.create(cursorImage, -1);\n            this.cursor.z = -1;\n            this.updateCursor();\n\n            this.letters = [];\n            for (let j = 0; j < 36; j++) {\n                const letter = image.create(CELL_WIDTH, CELL_HEIGHT);\n\n                const col2 = j % ALPHABET_ROW_LENGTH;\n                const row2 = Math.floor(j / ALPHABET_ROW_LENGTH);\n\n                const t = sprites.create(letter, -1);\n                t.x = ROW_LEFT + col2 * CELL_WIDTH;\n                t.y = ALPHABET_TOP + row2 * CELL_HEIGHT;\n\n                this.letters.push(t);\n            }\n            this.updateKeyboard();\n        }\n\n        private drawBottomBar() {\n            const bg = image.create(screen.width, BOTTOM_BAR_HEIGHT);\n            bg.fill(this.theme.colorBottomBackground);\n\n            const bgSprite = sprites.create(bg, -1);\n            bgSprite.x = screen.width / 2;\n            bgSprite.y = BOTTOM_BAR_TOP + BOTTOM_BAR_HEIGHT / 2;\n            bgSprite.z = -1;\n\n            this.shiftButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.shiftButton.x = Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.shiftButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.confirmButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.confirmButton.x = CONFIRM_BUTTON_LEFT + Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.confirmButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.updateButtons();\n        }\n\n        private updateButtons() {\n            if (this.cursorRow === 3 && this.cursorColumn % 2 !== 1) {\n                this.shiftButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.shiftButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            if (this.upper) {\n                this.shiftButton.image.print(upperShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n            else {\n                this.shiftButton.image.print(lowerShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n\n\n            if (this.cursorRow === 3 && this.cursorColumn % 2) {\n                this.confirmButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.confirmButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            this.confirmButton.image.print(confirmText, BOTTOM_BAR_CONFIRM_X, BOTTOM_BAR_TEXT_Y);\n        }\n\n        private updateCursor() {\n            if (this.cursorRow === 3) {\n                this.cursor.image.fill(0);\n                this.updateButtons();\n            }\n            else {\n                this.cursor.x = ROW_LEFT + this.cursorColumn * CELL_WIDTH;\n                this.cursor.y = ALPHABET_TOP + this.cursorRow * CELL_HEIGHT;\n            }\n        }\n\n        private updateSelectedInput() {\n            if (this.inputIndex < this.answerLength) {\n                const u = this.inputs[this.inputIndex];\n                if (this.blink) {\n                    this.drawInput(u.image, \"\", this.theme.colorInput);\n                }\n                else {\n                    this.drawInput(u.image, \"\", this.theme.colorInputHighlighted)\n                }\n            }\n        }\n\n        private updateKeyboard() {\n            const len = this.letters.length;\n            for (let k = 0; k < len; k++) {\n                const img = this.letters[k].image;\n                img.fill(0);\n                img.print(getCharForIndex(k, this.upper), LETTER_OFFSET_X, LETTER_OFFSET_Y);\n            }\n        }\n\n        private drawInput(img: Image, char: string, color: number) {\n            img.fill(0);\n            img.fillRect(BLANK_PADDING, CELL_HEIGHT - 1, CELL_WIDTH - BLANK_PADDING * 2, 1, color)\n\n            if (char) {\n                img.print(char, LETTER_OFFSET_X, LETTER_OFFSET_Y, this.theme.colorInputText, font);\n            }\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n\n\n            this.frameCount = 0;\n            this.blink = true;\n\n            game.onUpdate(() => {\n                this.frameCount = (this.frameCount + 1) % 30;\n\n                if (this.frameCount === 0) {\n                    this.blink = !this.blink;\n\n                    this.updateSelectedInput();\n                }\n            })\n        }\n\n        private moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === 3) {\n                    this.cursor.image.fill(this.theme.colorCursor);\n                    this.cursorRow = 2;\n\n                    if (this.cursorColumn % 2) {\n                        this.cursorColumn = ALPHABET_ROW_LENGTH - 1;\n                    }\n                    else {\n                        this.cursorColumn = 0;\n                    }\n\n                    this.updateButtons();\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(3, this.cursorRow + 1);\n\n                if (this.cursorRow === 3) {\n                    // Go to closest button\n                    this.cursorColumn = this.cursorColumn > 5 ? 1 : 0;\n                }\n            }\n\n            this.updateCursor();\n        }\n\n        private moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % ALPHABET_ROW_LENGTH;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (ALPHABET_ROW_LENGTH - 1)) % ALPHABET_ROW_LENGTH;\n            }\n\n            this.updateCursor();\n        }\n\n        private confirm() {\n            if (this.cursorRow === 3) {\n                if (this.cursorColumn % 2) {\n                    this.confirmPressed = true;\n                }\n                else {\n                    this.upper = !this.upper;\n                    this.updateKeyboard();\n                    this.updateButtons();\n                }\n            }\n            else {\n                if (this.inputIndex >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * ALPHABET_ROW_LENGTH\n                const letter = getCharForIndex(index, this.upper);\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                const sprite = this.inputs[this.inputIndex];\n                this.changeInputIndex(1);\n                this.drawInput(sprite.image, letter, this.theme.colorInput);\n            }\n        }\n\n        private delete() {\n            if (this.inputIndex <= 0) return;\n\n            if (this.inputIndex < this.answerLength) {\n                this.drawInput(this.inputs[this.inputIndex].image, \"\", this.theme.colorInput);\n            }\n\n            this.result = this.result.substr(0, this.result.length - 1);\n\n            this.changeInputIndex(-1);\n        }\n\n        private changeInputIndex(delta: number) {\n            this.inputIndex += delta;\n            this.frameCount = 0\n            this.blink = false;\n            this.updateSelectedInput();\n        }\n    }\n\n    function layoutText(message: string, width: number, height: number, color: number) {\n        const lineHeight = font.charHeight + PROMPT_LINE_SPACING;\n\n        const lineLength = Math.floor(width / font.charWidth);\n        const numLines = Math.floor(height / lineHeight);\n\n        let lines: string[] = [];\n        let word: string;\n        let line: string;\n\n        let pushWord = () => {\n            if (line) {\n                if (line.length + word.length + 1 > lineLength) {\n                    lines.push(line);\n                    line = word;\n                }\n                else {\n                    line = line + \" \" + word;\n                }\n            }\n            else {\n                line = word;\n            }\n\n            word = null;\n        }\n\n        for (let l = 0; l < message.length; l++) {\n            const char = message.charAt(l);\n\n            if (char === \" \") {\n                if (word) {\n                    pushWord();\n                }\n                else {\n                    word = \" \";\n                }\n            }\n            else if (!word) {\n                word = char;\n            }\n            else {\n                word += char;\n            }\n        }\n\n        if (word) {\n            pushWord();\n        }\n\n        if (line) {\n            lines.push(line);\n        }\n\n        let maxLineWidth = 0;\n        for (let m = 0; m < lines.length; m++) {\n            maxLineWidth = Math.max(maxLineWidth, lines[m].length);\n        }\n\n        const actualWidth = maxLineWidth * font.charWidth;\n        const actualHeight = lines.length * lineHeight;\n\n        const res = image.create(actualWidth, actualHeight);\n\n        for (let n = 0; n < lines.length; n++) {\n            if ((n + 1) > numLines) break;\n            res.print(lines[n], 0, n * lineHeight, color, font);\n        }\n\n        return res;\n    }\n\n    function getCharForIndex(index: number, upper: boolean) {\n        if (index < 26) {\n            return String.fromCharCode(index + (upper ? 65 : 97));\n        }\n        else {\n            if (upper) {\n                return digitsUpper[index - 26];\n            }\n            else {\n                return \"\" + (index - 26);\n            }\n        }\n    }\n}",
            "pxt.json": "{\n  \"name\": \"game\",\n  \"dependencies\": {\n    \"settings\": \"*\",\n    \"screen---st7735\": \"*\",\n    \"buttons\": \"*\",\n    \"power\": \"*\"\n  },\n  \"description\": \"The game and sprite library - beta\",\n  \"files\": [\n    \"gameoverrides.ts\",\n    \"basesprite.ts\",\n    \"constants.ts\",\n    \"controlleroverrides.ts\",\n    \"controller.ts\",\n    \"hitbox.ts\",\n    \"sprites.ts\",\n    \"sprite.ts\",\n    \"sprite.d.ts\",\n    \"spritemap.ts\",\n    \"spriteevents.ts\",\n    \"spriteset.ts\",\n    \"spritekind.ts\",\n    \"metrics.ts\",\n    \"obstacle.ts\",\n    \"physics.ts\",\n    \"info.ts\",\n    \"background.ts\",\n    \"tilemap.ts\",\n    \"camera.ts\",\n    \"renderable.ts\",\n    \"scene.ts\",\n    \"scenes.ts\",\n    \"textDialogs.ts\",\n    \"game.ts\",\n    \"prompt.ts\",\n    \"numberprompt.ts\",\n    \"ask.ts\",\n    \"targetoverrides.cpp\",\n    \"targetoverrides.ts\",\n    \"mathUtil.ts\",\n    \"systemmenu.ts\",\n    \"systemmenuicons.ts\",\n    \"console.ts\",\n    \"fieldeditors.ts\",\n    \"particles.ts\",\n    \"particlefactories.ts\",\n    \"particleeffects.ts\",\n    \"effects.ts\",\n    \"texteffects.ts\"\n  ],\n  \"public\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "renderable.ts": "namespace scene {\n    export class Renderable extends sprites.BaseSprite {\n        public constructor(\n            protected handler: (target: Image, camera: Camera) => void,\n            protected shouldBeVisible: () => boolean,\n            z: number,\n        ) {\n            super(z);\n        }\n\n        __visible(): boolean {\n            return this.shouldBeVisible();\n        }\n\n        __drawCore(camera: scene.Camera) {\n            this.handler(screen, camera);\n        }\n\n        destroy() {\n            const s = game.currentScene();\n            s.allSprites.removeElement(this);\n        }\n    }\n\n    export function createRenderable(\n        z: number,\n        handler: (target: Image, camera: Camera) => void,\n        shouldBeVisible?: () => boolean\n    ): Renderable {\n        const renderable = new Renderable(\n            handler,\n            shouldBeVisible || (() => true),\n            z,\n        );\n\n        return renderable;\n    }\n}",
            "scene.ts": "interface SparseArray<T> {\n    [index: number]: T;\n}\n\n/**\n * Control the background, tiles and camera\n */\nnamespace scene {\n    export enum Flag {\n        NeedsSorting = 1 << 1,\n    }\n\n    export class SpriteHandler {\n        constructor(\n            public kind: number,\n            public handler: (sprite: Sprite) => void\n        ) { }\n    }\n\n    export class OverlapHandler {\n        constructor(\n            public kind: number,\n            public otherKind: number,\n            public handler: (sprite: Sprite, otherSprite: Sprite) => void\n        ) { }\n    }\n\n    export class GameForeverHandler {\n        public lock: boolean;\n        constructor(\n            public handler: () => void\n        ) { }\n    }\n\n    // frame handler priorities\n    export const CONTROLLER_PRIORITY = 8;\n    export const UPDATE_CONTROLLER_PRIORITY = 13;\n    export const FOLLOW_SPRITE_PRIORITY = 14;\n    export const PHYSICS_PRIORITY = 15;\n    export const ANIMATION_UPDATE_PRIORITY = 15;\n    export const CONTROLLER_SPRITES_PRIORITY = 13;\n    export const UPDATE_INTERVAL_PRIORITY = 19;\n    export const UPDATE_PRIORITY = 20;\n    export const RENDER_BACKGROUND_PRIORITY = 60;\n    export const RENDER_SPRITES_PRIORITY = 90;\n    export const RENDER_DIAGNOSTICS_PRIORITY = 150;\n    export const UPDATE_SCREEN_PRIORITY = 200;\n\n    // default rendering z indices\n    export const ON_PAINT_Z = -20;\n    export const TILE_MAP_Z = -1;\n    export const SPRITE_Z = 0;\n    export const ON_SHADE_Z = 80;\n    export const HUD_Z = 100;\n\n    export class Scene {\n        eventContext: control.EventContext;\n        background: Background;\n        tileMap: tiles.TileMap;\n        allSprites: SpriteLike[];\n        private spriteNextId: number;\n        spritesByKind: SparseArray<SpriteSet>;\n        physicsEngine: PhysicsEngine;\n        camera: scene.Camera;\n        flags: number;\n        destroyedHandlers: SpriteHandler[];\n        createdHandlers: SpriteHandler[];\n        overlapHandlers: OverlapHandler[];\n        overlapMap: SparseArray<number[]>;\n        collisionHandlers: SpriteHandler[][];\n        gameForeverHandlers: GameForeverHandler[];\n        particleSources: particles.ParticleSource[];\n        controlledSprites: controller.ControlledSprite[][];\n        followingSprites: sprites.FollowingSprite[]\n\n        private _millis: number;\n        private _data: any;\n\n        // a set of functions that need to be called when a scene is being initialized\n        static initializers: ((scene: Scene) => void)[] = [];\n\n        constructor(eventContext: control.EventContext) {\n            this.eventContext = eventContext;\n            this.flags = 0;\n            this.physicsEngine = new ArcadePhysicsEngine();\n            this.camera = new scene.Camera();\n            this.background = new Background(this.camera);\n            this.destroyedHandlers = [];\n            this.createdHandlers = [];\n            this.overlapHandlers = [];\n            this.overlapMap = {};\n            this.collisionHandlers = [];\n            this.gameForeverHandlers = [];\n            this.spritesByKind = {};\n            this.controlledSprites = [];\n            this._data = {};\n            this._millis = 0;\n        }\n\n        init() {\n            if (this.allSprites) return;\n\n            power.poke(); // keep game alive a little more\n            this.allSprites = [];\n            this.spriteNextId = 0;\n            // update controller state\n            this.eventContext.registerFrameHandler(CONTROLLER_PRIORITY, () => {\n                this._millis += this.eventContext.deltaTimeMillis;\n                control.enablePerfCounter(\"controller_update\")\n                controller.__update(this.eventContext.deltaTime);\n            })\n            // controller update 13\n            this.eventContext.registerFrameHandler(CONTROLLER_SPRITES_PRIORITY, controller._moveSprites);\n            // sprite following 14\n            // apply physics and collisions 15\n            this.eventContext.registerFrameHandler(PHYSICS_PRIORITY, () => {\n                control.enablePerfCounter(\"physics and collisions\")\n                const dt = this.eventContext.deltaTime;\n\n                this.physicsEngine.move(dt);\n                this.camera.update();\n\n                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n            })\n            // user update interval 19s\n\n            // user update 20\n\n            // render 90\n            this.eventContext.registerFrameHandler(RENDER_SPRITES_PRIORITY, () => {\n                control.enablePerfCounter(\"sprite_draw\")\n                this.cachedRender = undefined;\n                this.renderCore();\n            });\n            // render diagnostics\n            this.eventContext.registerFrameHandler(RENDER_DIAGNOSTICS_PRIORITY, () => {\n                if (game.stats && control.EventContext.onStats) {\n                    control.EventContext.onStats(\n                        control.EventContext.lastStats +\n                        ` sprites:${this.allSprites.length}`\n                    )\n                }\n                if (game.debug)\n                    this.physicsEngine.draw();\n                game.consoleOverlay.draw();\n                // clear flags\n                this.flags = 0;\n                // check for power deep sleep\n                power.checkDeepSleep();\n            });\n            // update screen\n            this.eventContext.registerFrameHandler(UPDATE_SCREEN_PRIORITY, control.__screen.update);\n            // register additional components\n            Scene.initializers.forEach(f => f(this));\n        }\n\n        get data() {\n            return this._data;\n        }\n\n        /**\n         * Gets the elapsed time in the scene\n         */\n        millis(): number {\n            return this._millis;\n        }\n\n        addSprite(sprite: SpriteLike) {\n            this.allSprites.push(sprite);\n            sprite.id = this.spriteNextId++;\n        }\n\n        destroy() {\n            this.eventContext = undefined;\n            this.background = undefined;\n            this.tileMap = undefined;\n            this.allSprites = undefined;\n            this.spriteNextId = undefined;\n            this.spritesByKind = undefined;\n            this.physicsEngine = undefined;\n            this.camera = undefined;\n            this.flags = undefined;\n            this.destroyedHandlers = undefined;\n            this.createdHandlers = undefined;\n            this.overlapHandlers = undefined;\n            this.collisionHandlers = undefined;\n            this.gameForeverHandlers = undefined;\n            this._data = undefined;\n        }\n\n        protected cachedRender: Image;\n        /**\n         * Renders the current frame as an image\n         */\n        render(): Image {\n            if (this.cachedRender) {\n                return this.cachedRender;\n            }\n\n            this.renderCore();\n\n            this.cachedRender = screen.clone();\n            return this.cachedRender;\n        }\n\n        private renderCore() {\n            control.enablePerfCounter(\"render background\")\n            this.background.draw();\n\n            control.enablePerfCounter(\"sprite sort\")\n            if (this.flags & Flag.NeedsSorting) {\n                this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n            }\n\n            control.enablePerfCounter(\"sprite draw\")\n            for (const s of this.allSprites) {\n                s.__draw(this.camera);\n            }\n        }\n    }\n}\n",
            "scenes.ts": "/**\n * Control the background, tiles and camera\n */\n//% weight=88 color=\"#401255\" icon=\"\\uf1bb\"\n//% groups='[\"Screen\", \"Effects\", \"Tiles\", \"Collisions\", \"Camera\"]'\n//% blockGap=8\nnamespace scene {\n    /**\n     * Get the width of the screen in pixels\n     */\n    //% blockId=scenescreenwidth block=\"screen width\"\n    //% group=\"Screen\"\n    //% weight=100 blockGap=8\n    //% help=scene/screen-width\n    export function screenWidth(): number {\n        return screen.width;\n    }\n\n    /**\n     * Gets the height of the screen in pixels\n     */\n    //% blockId=scenescreenheight block=\"screen height\"\n    //% group=\"Screen\"\n    //% weight=99\n    //% help=scene/screen-width\n    export function screenHeight(): number {\n        return screen.height;\n    }\n\n    /**\n     * Set the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=25\n    //% blockId=gamesetbackgroundcolor block=\"set background color to %color=colorindexpicker\"\n    //% help=scene/set-background-color\n    export function setBackgroundColor(color: number) {\n        const scene = game.currentScene();\n        scene.background.color = color;\n    }\n\n    /**\n     * Get the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=22\n    //% blockId=gamebackgroundcolor block=\"background color\"\n    //% help=scene/background-color\n    export function backgroundColor() : number {\n        const scene = game.currentScene();\n        return scene.background.color;\n    }\n\n    /**\n     * Set a picture as the background\n     */\n    //% group=\"Screen\"\n    //% weight=24\n    //% blockId=gamesetbackgroundimage block=\"set background image to %img=background_image_picker\"\n    //% help=scene/set-background-image\n    export function setBackgroundImage(img: Image) {\n        const scene = game.currentScene();\n        scene.background.image = img;\n    }\n\n    /**\n     * Get the current background image\n     */\n    //% weight=22\n    //% group=\"Screen\"\n    //% blockId=gamebackgroundimage block=\"background image\"\n    //% help=scene/background-image\n    export function backgroundImage(): Image {\n        const scene = game.currentScene();\n        return scene.background.image;\n    }\n\n    /**\n     * Adds a moving background layer\n     * @param distance distance of the layer which determines how fast it moves, eg: 10\n     * @param img\n     */\n    //% group=\"Screen\"\n    //% weight=10\n    export function addBackgroundLayer(image: Image, distance?: number, alignment?: BackgroundAlignment) {\n        const scene = game.currentScene();\n        if (image)\n            scene.background.addLayer(image, distance || 100, alignment || BackgroundAlignment.Bottom);\n    }\n\n    /**\n     * Set the map for placing tiles in the scene\n     * @param map\n     * @param scale\n     */\n    //% blockId=gamesettilemap block=\"set tile map to %map=tilemap_image_picker || with %scale pixel tiles\"\n    //% scale.defl=TileScale.Sixteen\n    //% group=\"Tiles\"\n    //% help=scene/set-tile-map\n    export function setTileMap(map: Image, scale = TileScale.Sixteen) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setMap(map);\n        scene.tileMap.scale = scale;\n    }\n\n    /**\n     * Set a tile at the given index\n     * @param tile\n     * @param index\n     */\n    //% blockId=gamesettileat block=\"set %tile=gamegettile to %index=colorindexpicker\"\n    //% group=\"Tiles\"\n    //% weight=30\n    //% help=scene/set-tile-at\n    export function setTileAt(tile: tiles.Tile, index: number) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        const scale = scene.tileMap.scale;\n        scene.tileMap.setTileAt(tile.x >> scale, tile.y >> scale, index);\n    }\n\n    /**\n     * Set an image as a tile at the given index. Tiles should be a 16x16 image\n     * @param index\n     * @param img\n     */\n    //% blockId=gamesettile block=\"set tile %index=colorindexpicker to %img=tile_image_picker with wall %wall=toggleOnOff\"\n    //% group=\"Tiles\"\n    //% help=scene/set-tile\n    export function setTile(index: number, img: Image, wall?: boolean) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setTile(index, img, !!wall);\n    }\n\n    /**\n     * Get the tile at a position in the tile map\n     * @param col\n     * @param row\n     */\n    //% blockId=gamegettile block=\"tile col %col row %row\"\n    //% group=\"Tiles\" blockSetVariable=\"myTile\"\n    //% help=scene/get-tile\n    export function getTile(col: number, row: number): tiles.Tile {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTile(col, row);\n    }\n\n    /**\n     * Get all tiles in the tile map with the given index.\n     * @param index\n     */\n    //% blockId=gamegettilestype block=\"array of all %index=colorindexpicker tiles\"\n    //% group=\"Tiles\" blockSetVariable=\"tile list\"\n    //% help=scene/get-tiles-by-type\n    export function getTilesByType(index: number): tiles.Tile[] {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTilesByType(index);\n    }\n\n    /**\n     * Center the given sprite on a random tile that is the given color\n     * @param sprite\n     * @param color\n     */\n    //% blockId=gameplaceonrandomtile block=\"place %sprite=variables_get(mySprite) on top of random $color tile\"\n    //% blockNamespace=\"scene\" group=\"Tiles\"\n    //% color.shadow=\"colorindexpicker\"\n    //% help=scene/place-on-random-tile\n    export function placeOnRandomTile(sprite: Sprite, color: number): void {\n        if (!sprite || !game.currentScene().tileMap) return;\n        const tiles = getTilesByType(color);\n        if (tiles.length > 0)\n            Math.pickRandom(tiles).place(sprite);\n    }\n\n    /**\n     * Shake the camera\n     * @param sprite\n     */\n    //% blockId=camerashake block=\"camera shake by %amplitude pixels for %duration ms\"\n    //% amplitude.min=1 amplitude.max=8 amplitude.defl=4\n    //% duration.shadow=timePicker duration.defl=500\n    //% group=\"Camera\"\n    //% help=scene/camera-shake\n    export function cameraShake(amplitude: number = 4, duration: number = 500) {\n        const scene = game.currentScene();\n        scene.camera.shake(amplitude, duration);\n    }\n\n    /**\n     * Set the game camera to follow a sprite\n     * @param sprite\n     */\n    //% blockId=camerafollow block=\"camera follow sprite %sprite=variables_get(mySprite)\"\n    //% group=\"Camera\"\n    //% help=scene/camera-follow-sprite\n    export function cameraFollowSprite(sprite: Sprite) {\n        const scene = game.currentScene();\n        scene.camera.sprite = sprite;\n    }\n\n    /**\n     * Moves the camera center to a coordinate position\n     * @param sprite\n     */\n    //% blockId=camerapos block=\"center camera at x %x y %y\"\n    //% group=\"Camera\"\n    //% help=scene/center-camera-at\n    export function centerCameraAt(x: number, y: number) {\n        const scene = game.currentScene();\n        scene.camera.sprite = undefined;\n        scene.camera.offsetX = x - (screen.width >> 1);\n        scene.camera.offsetY = y - (screen.height >> 1);\n    }\n}\n",
            "sprite.d.ts": "declare interface Sprite {\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    z: number;\n    // this is defined in the superclass BaseSprite, so it needs to be declared here to show up\n    // in the blocks for sprites.\n}",
            "sprite.ts": "enum SpriteFlag {\n    //% block=\"ghost\"\n    Ghost = sprites.Flag.Ghost,\n    //% block=\"auto destroy\"\n    AutoDestroy = sprites.Flag.AutoDestroy,\n    //% block=\"stay in screen\"\n    StayInScreen = sprites.Flag.StayInScreen,\n    //% block=\"destroy on wall\"\n    DestroyOnWall = sprites.Flag.DestroyOnWall,\n    //% block=\"bounce on wall\"\n    BounceOnWall = sprites.Flag.BounceOnWall,\n    //% block=\"show physics\"\n    ShowPhysics = sprites.Flag.ShowPhysics,\n    //% block=\"invisible\"\n    Invisible = sprites.Flag.Invisible,\n}\n\nenum CollisionDirection {\n    //% block=\"left\"\n    Left = 0,\n    //% block=\"top\"\n    Top = 1,\n    //% block=\"right\"\n    Right = 2,\n    //% block=\"bottom\"\n    Bottom = 3\n}\n\nenum FlipOption {\n    //% block=none\n    None,\n    //% block=\"flip x\"\n    FlipX,\n    //% block=\"flip y\"\n    FlipY,\n    //% block=\"flip x+y\"\n    FlipXY\n}\n\n/**\n * A sprite on the screen\n **/\n//% blockNamespace=sprites color=\"#3B6FEA\" blockGap=8\nclass Sprite extends sprites.BaseSprite {\n    _x: Fx8\n    _y: Fx8\n    _vx: Fx8\n    _vy: Fx8\n    _ax: Fx8\n    _ay: Fx8\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\" callInDebugger\n    get x(): number {\n        return Fx.toInt(this._x) + (this._image.width >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this.left = v - (this._image.width >> 1)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\" callInDebugger\n    get y(): number {\n        return Fx.toInt(this._y) + (this._image.height >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this.top = v - (this._image.height >> 1)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\" callInDebugger\n    get vx(): number {\n        return Fx.toFloat(this._vx)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    set vx(v: number) {\n        this._vx = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\" callInDebugger\n    get vy(): number {\n        return Fx.toFloat(this._vy)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    set vy(v: number) {\n        this._vy = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\" callInDebugger\n    get ax(): number {\n        return Fx.toFloat(this._ax)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    set ax(v: number) {\n        this._ax = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\" callInDebugger\n    get ay(): number {\n        return Fx.toFloat(this._ay)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    set ay(v: number) {\n        this._ay = Fx8(v)\n    }\n\n    private _data: any;\n    /**\n     * Custom data\n     */\n    //%\n    get data(): any {\n        if (!this._data) this._data = {};\n        return this._data;\n    }\n\n    set data(value: any) {\n        this._data = value;\n    }\n    _kind: number;\n\n    /**\n     * A bitset of layer. Each bit is a layer, default is 1.\n     */\n    //% group=\"Physics\"\n    layer: number;\n\n    _lastX: Fx8;\n    _lastY: Fx8;\n\n    _action: number; //Used with animation library\n\n    /**\n     * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n     * and the sprite gets destroyed when it reaches 0.\n     */\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"lifespan\"\n    lifespan: number;\n    private _image: Image;\n    private _obstacles: sprites.Obstacle[];\n\n    private updateSay: (dt: number, camera: scene.Camera) => void;\n    private sayBubbleSprite: Sprite;\n\n    _hitbox: game.Hitbox;\n    _overlappers: number[];\n    _kindsOverlappedWith: number[];\n\n    flags: number\n\n    private destroyHandler: () => void;\n\n    constructor(img: Image) {\n        super(scene.SPRITE_Z);\n\n        this._x = Fx8(screen.width - img.width >> 1);\n        this._y = Fx8(screen.height - img.height >> 1);\n        this._lastX = this._x;\n        this._lastY = this._y;\n        this.vx = 0\n        this.vy = 0\n        this.ax = 0\n        this.ay = 0\n        this.flags = 0\n        this.setImage(img);\n        this.setKind(-1); // not a member of any type by default\n        this.layer = 1; // by default, in layer 1\n        this.lifespan = undefined;\n        this._overlappers = [];\n        this._obstacles = [];\n    }\n\n    __serialize(offset: number): Buffer {\n        const buf = control.createBuffer(offset + 12);\n        let k = offset;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._x)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._y)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vx)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vy)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ax)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ay)); k += 2;\n        return buf;\n    }\n\n    /**\n     * Gets the current image\n     */\n    //% group=\"Image\"\n    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n    //% weight=8\n    get image(): Image {\n        return this._image;\n    }\n\n    /**\n     * Sets the image on the sprite\n     */\n    //% group=\"Image\"\n    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n    //% weight=7 help=sprites/sprite/set-image\n    setImage(img: Image) {\n        if (!img) return; // don't break the sprite\n\n        let oMinX = 0;\n        let oMinY = 0;\n        let oMaxX = 0;\n        let oMaxY = 0;\n\n        // Identify old upper left corner\n        if (this._hitbox) {\n            oMinX = this._hitbox.ox;\n            oMinY = this._hitbox.oy;\n            oMaxX = this._hitbox.ox + this._hitbox.width;\n            oMaxY = this._hitbox.oy + this._hitbox.height;\n        }\n\n        this._image = img;\n        this._hitbox = game.calculateHitBox(this);\n\n        // Identify new upper left corner\n        let nMinX = this._hitbox.ox;\n        let nMinY = this._hitbox.oy;\n        let nMaxX = this._hitbox.ox + this._hitbox.width;\n        let nMaxY = this._hitbox.oy + this._hitbox.height;\n\n        const minXDiff = oMinX - nMinX;\n        const minYDiff = oMinY - nMinY;\n        const maxXDiff = oMaxX - nMaxX;\n        const maxYDiff = oMaxY - nMaxY;\n\n        // If just a small change to the hitbox, don't change the hitbox\n        // Used for things like walking animations\n        if (oMaxX != oMinX && Math.abs(minXDiff) + Math.abs(maxXDiff) <= 2) {\n            this._hitbox.ox = oMinX;\n            this._hitbox.width = oMaxX - oMinX;\n        }\n        if (oMaxY != oMinY && Math.abs(minYDiff) + Math.abs(maxYDiff) <= 2) {\n            this._hitbox.oy = oMinY;\n            this._hitbox.height = oMaxY - oMinY;\n        }\n    }\n\n    __visible() {\n        return !(this.flags & SpriteFlag.Invisible);\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"width\"\n    get width() {\n        return this._image.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"height\"\n    get height() {\n        return this._image.height\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    get left() {\n        return Fx.toInt(this._x)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    set left(value: number) {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx.sub(\n                Fx8(value),\n                this._x\n            ),\n            Fx.zeroFx8\n        );\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    get right() {\n        return this.left + this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    set right(value: number) {\n        this.left = value - this.width\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    get top() {\n        return Fx.toInt(this._y);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    set top(value: number) {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx.zeroFx8,\n            Fx.sub(\n                Fx8(value),\n                this._y\n            )\n        );\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    get bottom() {\n        return this.top + this.height;\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    set bottom(value: number) {\n        this.top = value - this.height;\n    }\n\n    // The z field (``get z()`` / ``set z()``) is declared in sprite.d.ts\n    // as it is defnied in the superclass\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritegetkind\" block=\"%sprite(mySprite) kind\"\n    //% weight=79 help=sprites/sprite/kind\n    kind() {\n        return this._kind;\n    }\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritesetkind\" block=\"set %sprite(mySprite) kind to %kind\"\n    //% kind.shadow=spritekind\n    //% weight=80 help=sprites/sprite/set-kind\n    setKind(value: number) {\n        if (value == undefined || this._kind === value) return;\n\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (this._kind >= 0 && spritesByKind[this._kind])\n            spritesByKind[this._kind].remove(this);\n\n        if (value >= 0) {\n            if (!spritesByKind[value]) spritesByKind[value] = new SpriteSet();\n            spritesByKind[value].add(this);\n        }\n\n        const overlapMap = game.currentScene().overlapMap;\n        if (!overlapMap[value]) {\n            overlapMap[value] = [];\n        }\n\n        this._kindsOverlappedWith = overlapMap[value];\n\n        this._kind = value;\n    }\n\n    /**\n     * Set the sprite position in pixels starting from the top-left corner of the screen.\n     * @param x horizontal position in pixels\n     * @param y vertical position in pixels\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n    //% help=sprites/sprite/set-position\n    //% x.shadow=\"positionPicker\" y.shadow=\"positionPicker\"\n    setPosition(x: number, y: number): void {\n        const physics = game.currentScene().physicsEngine;\n        physics.moveSprite(\n            this,\n            Fx8(x - this.x),\n            Fx8(y - this.y)\n        );\n    }\n\n    /**\n     * Sets the sprite velocity in pixel / sec\n     * @param vx\n     * @param vy\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetvel block=\"set %sprite(mySprite) velocity to vx %vx vy %vy\"\n    //% help=sprites/sprite/set-velociy\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    setVelocity(vx: number, vy: number): void {\n        this.vx = vx;\n        this.vy = vy;\n    }\n\n    /**\n     * Display a speech bubble with the text, for the given time\n     * @param text the text to say, eg: \":)\"\n     * @param time time to keep text on\n     */\n    //% group=\"Effects\"\n    //% weight=60\n    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n    //% millis.shadow=timePicker\n    //% inlineInputMode=inline\n    //% help=sprites/sprite/say\n    say(text: string, timeOnScreen?: number, textColor = 15, textBoxColor = 1) {\n        // clear say\n        if (!text) {\n            this.updateSay = undefined;\n            if (this.sayBubbleSprite) {\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n            return;\n        }\n\n        // same text, color, time, etc...\n        const SAYKEY = \"__saykey\";\n        const key = JSON.stringify({\n            text: text,\n            textColor: textColor,\n            textBoxColor: textBoxColor\n        })\n        if (timeOnScreen === undefined\n            && this.sayBubbleSprite\n            && this.sayBubbleSprite.data[SAYKEY] == key) {\n            // do nothing!\n            return;\n        }\n\n        let pixelsOffset = 0;\n        let holdTextSeconds = 1.5;\n        let bubblePadding = 4;\n        let maxTextWidth = 100;\n        let font = image.getFontForText(text);\n        let startX = 2;\n        let startY = 2;\n        let bubbleWidth = text.length * font.charWidth + bubblePadding;\n        let maxOffset = text.length * font.charWidth - maxTextWidth;\n        let bubbleOffset: number = this._hitbox.oy;\n        let needsRedraw = true;\n\n        // sets the defaut scroll speed in pixels per second\n        let speed = 45;\n        const currentScene = game.currentScene();\n\n        // Calculates the speed of the scroll if scrolling is needed and a time is specified\n        if (timeOnScreen && maxOffset > 0) {\n            speed = (maxOffset + (2 * maxTextWidth)) / (timeOnScreen / 1000);\n            speed = Math.max(speed, 45);\n            holdTextSeconds = maxTextWidth / speed;\n            holdTextSeconds = Math.min(holdTextSeconds, 1.5);\n        }\n\n        if (timeOnScreen) {\n            timeOnScreen = timeOnScreen + currentScene.millis();\n        }\n\n        if (bubbleWidth > maxTextWidth + bubblePadding) {\n            bubbleWidth = maxTextWidth + bubblePadding;\n        } else {\n            maxOffset = -1;\n        }\n\n        // reuse previous sprite if possible\n        const imgh = font.charHeight + bubblePadding;\n        if (!this.sayBubbleSprite\n            || this.sayBubbleSprite.image.width != bubbleWidth\n            || this.sayBubbleSprite.image.height != imgh) {\n            const sayImg = image.create(bubbleWidth, imgh);\n            if (this.sayBubbleSprite) // sprite with same image size, we can reuse it\n                this.sayBubbleSprite.setImage(sayImg);\n            else { // needs a new sprite\n                this.sayBubbleSprite = sprites.create(sayImg, -1);\n                this.sayBubbleSprite.setFlag(SpriteFlag.Ghost, true);\n            }\n        }\n        this.sayBubbleSprite.data[SAYKEY] = key;\n        this.updateSay = (dt, camera) => {\n            // Update box stuff as long as timeOnScreen doesn't exist or it can still be on the screen\n            if (!timeOnScreen || timeOnScreen > currentScene.millis()) {\n                // move bubble\n                if (!this.isOutOfScreen(camera)) {\n                    const ox = camera.offsetX;\n                    const oy = camera.offsetY;\n\n                    if (this.sayBubbleSprite.left - ox < 0) {\n                        this.sayBubbleSprite.left = 0;\n                    }\n\n                    if (this.sayBubbleSprite.right - ox > screen.width) {\n                        this.sayBubbleSprite.right = screen.width;\n                    }\n\n                    // If sprite bubble above the sprite gets cut off on top, place the bubble below the sprite\n                    if (this.sayBubbleSprite.top - oy < 0) {\n                        this.sayBubbleSprite.y = (this.sayBubbleSprite.y - 2 * this.y) * -1;\n                    }\n                }\n\n                // Pauses at beginning of text for holdTextSeconds length\n                if (holdTextSeconds > 0) {\n                    holdTextSeconds -= game.eventContext().deltaTime;\n                    // If scrolling has reached the end, start back at the beginning\n                    if (holdTextSeconds <= 0 && pixelsOffset > 0) {\n                        pixelsOffset = 0;\n                        holdTextSeconds = maxTextWidth / speed;\n                        needsRedraw = true;\n                    }\n                } else {\n                    pixelsOffset += dt * speed;\n                    needsRedraw = true;\n\n                    // Pause at end of text for holdTextSeconds length\n                    if (pixelsOffset >= maxOffset) {\n                        pixelsOffset = maxOffset;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                }\n\n                if (needsRedraw) {\n                    needsRedraw = false;\n                    this.sayBubbleSprite.image.fill(textBoxColor);\n                    // The minus 2 is how much transparent padding there is under the sayBubbleSprite\n                    this.sayBubbleSprite.y = this.top + bubbleOffset - ((font.charHeight + bubblePadding) >> 1) - 2;\n                    this.sayBubbleSprite.x = this.x;\n                    // If maxOffset is negative it won't scroll\n                    if (maxOffset < 0) {\n                        this.sayBubbleSprite.image.print(text, startX, startY, textColor, font);\n\n                    } else {\n                        this.sayBubbleSprite.image.print(text, startX - pixelsOffset, startY, textColor, font);\n                    }\n\n                    // Left side padding\n                    this.sayBubbleSprite.image.fillRect(0, 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                    // Right side padding\n                    this.sayBubbleSprite.image.fillRect(bubbleWidth - (bubblePadding >> 1), 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                    // Corners removed\n                    this.sayBubbleSprite.image.setPixel(0, 0, 0);\n                    this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, 0, 0);\n                    this.sayBubbleSprite.image.setPixel(0, font.charHeight + bubblePadding - 1, 0);\n                    this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, font.charHeight + bubblePadding - 1, 0);\n                }\n            } else {\n                // If can't update because of timeOnScreen then destroy the sayBubbleSprite and reset updateSay\n                this.updateSay = undefined;\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n        }\n        this.updateSay(0, currentScene.camera);\n    }\n\n    /**\n     * Start an effect on this sprite\n     * @param effect the type of effect to create\n     */\n    //% group=\"Effects\"\n    //% weight=90\n    //% blockId=startEffectOnSprite block=\"%sprite(mySprite) start %effect effect || for %duration=timePicker|ms\"\n    //% help=sprites/sprite/start-effect\n    startEffect(effect: effects.ParticleEffect, duration?: number) {\n        effect.start(this, duration);\n    }\n\n    /**\n     * Indicates if the sprite is outside the screen\n     */\n    //%\n    isOutOfScreen(camera: scene.Camera): boolean {\n        const ox = camera.offsetX;\n        const oy = camera.offsetY;\n        return this.right - ox < 0 || this.bottom - oy < 0 || this.left - ox > screen.width || this.top - oy > screen.height;\n    }\n\n    __drawCore(camera: scene.Camera) {\n        if (this.isOutOfScreen(camera)) return;\n\n        const l = this.left - camera.drawOffsetX;\n        const t = this.top - camera.drawOffsetY;\n        screen.drawTransparentImage(this._image, l, t)\n\n        if (this.flags & SpriteFlag.ShowPhysics) {\n            const font = image.font5;\n            const margin = 2;\n            let tx = l;\n            let ty = this.bottom + margin - camera.drawOffsetY;\n            screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n            tx -= font.charWidth;\n            if (this.vx || this.vy) {\n                ty += font.charHeight + margin;\n                screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n            }\n            if (this.ax || this.ay) {\n                ty += font.charHeight + margin;\n                screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n            }\n        }\n\n        // debug info\n        if (game.debug) {\n            screen.drawRect(\n                Fx.toInt(this._hitbox.left) - camera.drawOffsetX,\n                Fx.toInt(this._hitbox.top) - camera.drawOffsetY,\n                this._hitbox.width,\n                this._hitbox.height,\n                1\n            );\n        }\n    }\n\n    __update(camera: scene.Camera, dt: number) {\n        if (this.lifespan !== undefined) {\n            this.lifespan -= dt * 1000;\n            if (this.lifespan <= 0) {\n                this.lifespan = undefined;\n                this._destroyCore();\n            }\n        }\n        if ((this.flags & sprites.Flag.AutoDestroy)\n            && this.isOutOfScreen(camera)) {\n            this.destroy()\n        }\n\n        const bounce = this.flags & sprites.Flag.BounceOnWall;\n        const tm = game.currentScene().tileMap;\n        if (this.flags & sprites.Flag.StayInScreen || (bounce && !tm)) {\n            if (this.left < camera.offsetX) {\n                this.left = camera.offsetX;\n                if (bounce) this.vx = -this.vx;\n            }\n            else if (this.right > camera.offsetX + screen.width) {\n                this.right = camera.offsetX + screen.width;\n                if (bounce) this.vx = -this.vx;\n            }\n\n            if (this.top < camera.offsetY) {\n                this.top = camera.offsetY;\n                if (bounce) this.vy = -this.vy;\n            }\n            else if (this.bottom > camera.offsetY + screen.height) {\n                this.bottom = camera.offsetY + screen.height;\n                if (bounce) this.vy = -this.vy;\n            }\n        }\n\n        // Say text\n        if (this.updateSay) {\n            this.updateSay(dt, camera);\n        }\n    }\n\n    /**\n     * Set a sprite flag\n     */\n    //% group=\"Effects\"\n    //% weight=30\n    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n    //% flag.defl=SpriteFlag.StayInScreen\n    //% help=sprites/sprite/set-flag\n    setFlag(flag: SpriteFlag, on: boolean) {\n        if (on) this.flags |= flag\n        else this.flags = ~(~this.flags | flag);\n    }\n\n    /**\n     * Check if this sprite overlaps another sprite\n     * @param other\n     */\n    //% group=\"Overlaps\"\n    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n    //% help=sprites/sprite/overlaps-with\n    //% weight=90\n    overlapsWith(other: Sprite) {\n        control.enablePerfCounter(\"overlapsCPP\")\n        if (other == this) return false;\n        if (this.flags & sprites.Flag.Ghost)\n            return false\n        if (other.flags & sprites.Flag.Ghost)\n            return false\n        return other._image.overlapsWith(this._image, this.left - other.left, this.top - other.top)\n    }\n\n    /**\n     * Check if there is an obstacle in the given direction\n     * @param direction\n     */\n    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/is-hitting-tile\n    isHittingTile(direction: CollisionDirection): boolean {\n        return this._obstacles && !!this._obstacles[direction];\n    }\n\n    /**\n     * Get the obstacle sprite in a given direction if any\n     * @param direction\n     */\n    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/tile-hit-from\n    tileHitFrom(direction: CollisionDirection): number {\n        return (this._obstacles && this._obstacles[direction]) ? this._obstacles[direction].tileIndex : -1;\n    }\n\n    clearObstacles() {\n        this._obstacles = [];\n    }\n\n    registerObstacle(direction: CollisionDirection, other: sprites.Obstacle) {\n        this._obstacles[direction] = other;\n        const collisionHandlers = game.currentScene().collisionHandlers[other.tileIndex];\n\n        if (collisionHandlers) {\n            collisionHandlers\n                .filter(h => h.kind == this.kind())\n                .forEach(h => h.handler(this));\n        }\n    }\n\n    /**\n     * Run code when the sprite is destroyed\n     * @param handler\n     */\n    //% group=\"Lifecycle\"\n    //% weight=9\n    onDestroyed(handler: () => void) {\n        this.destroyHandler = handler\n    }\n\n    /**\n     * Destroy the sprite\n     */\n    //% group=\"Effects\"\n    //% weight=80\n    //% blockId=spritedestroy block=\"destroy %sprite(mySprite) || with %effect effect for %duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"toggle\"\n    //% help=sprites/sprite/destroy\n    destroy(effect?: effects.ParticleEffect, duration?: number) {\n        if (this.flags & sprites.Flag.Destroyed)\n            return;\n        this.flags |= sprites.Flag.Destroyed;\n\n        if (effect)\n            effect.destroy(this, duration);\n        else\n            this._destroyCore();\n    }\n\n    _destroyCore() {\n        this.flags |= sprites.Flag.Destroyed;\n        const scene = game.currentScene();\n        // When current sprite is destroyed, destroys sayBubbleSprite if defined\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n        scene.allSprites.removeElement(this);\n        if (this.kind() >= 0 && scene.spritesByKind[this.kind()])\n            scene.spritesByKind[this.kind()].remove(this);\n        scene.physicsEngine.removeSprite(this);\n        if (this.destroyHandler)\n            this.destroyHandler();\n        scene.destroyedHandlers\n            .filter(h => h.kind == this.kind())\n            .forEach(h => h.handler(this));\n    }\n\n    /**\n     * Make this sprite follow the target sprite.\n     *\n     * @param target the sprite this one should follow\n     * @param speed the rate at which this sprite should move, eg: 100\n     * @param turnRate how quickly the sprite should turn while following, eg: 3\n     */\n    //% group=\"Physics\" weight=10\n    //% blockId=spriteFollowOtherSprite\n    //% block=\"set %sprite(myEnemy) follow %target=variables_get(mySprite) || with speed %speed\"\n    follow(target: Sprite, speed = 100, turnRate = 3) {\n        if (target === this) return;\n\n        const sc = game.currentScene();\n        if (!sc.followingSprites) {\n            sc.followingSprites = [];\n            let lastTime = game.runtime();\n            sc.eventContext.registerFrameHandler(scene.FOLLOW_SPRITE_PRIORITY, () => {\n                const currTime = game.runtime();\n                const timeDiff = (currTime - lastTime) / 1000;\n                let destroyedSprites = false;\n\n                sc.followingSprites.forEach(fs => {\n                    // one of the involved sprites has been destroyed, so exit and remove that later\n                    if ((fs.self.flags | fs.target.flags) & sprites.Flag.Destroyed) {\n                        destroyedSprites = true;\n                        return;\n                    }\n\n                    const dx = fs.target.x - fs.self.x;\n                    const dy = fs.target.y - fs.self.y;\n\n                    // already right on top of target; stop moving\n                    if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {\n                        fs.self.vx = 0;\n                        fs.self.vy = 0;\n                        return;\n                    }\n\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const turnPercentage = Math.clamp(0, 1, fs.turnRate * timeDiff);\n\n                    fs.self.vx += (fs.rate * dx / distance - fs.self.vx) * turnPercentage;\n                    fs.self.vy += (fs.rate * dy / distance - fs.self.vy) * turnPercentage;\n                });\n\n                lastTime = currTime;\n\n                // remove followers where one has been destroyed\n                if (destroyedSprites) {\n                    sc.followingSprites = sc.followingSprites\n                        .filter(fs => !((fs.self.flags | fs.target.flags) & sprites.Flag.Destroyed));\n                }\n            });\n        }\n\n        const fs = sc.followingSprites.find(fs => fs.self.id == this.id);\n\n        if (!target || !speed) {\n            if (fs) {\n                sc.followingSprites.removeElement(fs);\n            }\n        } else if (!fs) {\n            sc.followingSprites.push(new sprites.FollowingSprite(\n                this,\n                target,\n                speed,\n                turnRate\n            ));\n        } else {\n            fs.target = target;\n            fs.rate = speed;\n            fs.turnRate = turnRate;\n        }\n    }\n\n    toString() {\n        return `${this.id}(${this.x},${this.y})->(${this.vx},${this.vy})`;\n    }\n}",
            "spriteevents.ts": "namespace sprites {\n    /**\n     * Run code when a certain kind of sprite is created\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\" draggableParameters=\"reporter\" weight=97\n    //% blockId=spritesoncreated block=\"on created $sprite of kind $kind=spritekind\"\n    //% help=sprites/on-created\n    export function onCreated(kind: number, handler: (sprite: Sprite) => void): void {\n        if (!handler || kind == undefined) return;\n\n        const sc = game.currentScene();\n        sc.createdHandlers.push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        )\n    }\n\n    /**\n     * Run code when a certain kind of sprite is destroyed\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\"\n    //% weight=96 draggableParameters=\"reporter\"\n    //% blockId=spritesondestroyed block=\"on destroyed $sprite of kind $kind=spritekind \"\n    //% help=sprites/on-destroyed\n    export function onDestroyed(kind: number, handler: (sprite: Sprite) => void) {\n        if (!handler || kind == undefined) return;\n\n        const sc = game.currentScene();\n        sc.destroyedHandlers.push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        );\n    }\n\n    /**\n     * Run code when two kinds of sprites overlap\n     */\n    //% group=\"Overlaps\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% blockId=spritesoverlap block=\"on $sprite of kind $kind=spritekind overlaps $otherSprite of kind $otherKind=spritekind\"\n    //% help=sprites/on-overlap\n    //% blockGap=8\n    export function onOverlap(kind: number, otherKind: number, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n        if (kind == undefined || otherKind == undefined || !handler) return;\n        const sc = game.currentScene();\n        const overlapHandlers = sc.overlapHandlers;\n        const overlapMap = sc.overlapMap;\n\n        function associate(a: number, b: number) {\n            if (!overlapMap[a]) {\n                overlapMap[a] = [];\n            }\n\n            overlapMap[a].push(b);\n        }\n\n        associate(kind, otherKind);\n        associate(otherKind, kind);\n\n        overlapHandlers.push(\n            new scene.OverlapHandler(\n                kind,\n                otherKind,\n                handler\n            )\n        );\n    }\n}\n\nnamespace scene {\n    /**\n     * Run code when a certain kind of sprite hits a tile\n     * @param direction\n     * @param tile\n     * @param handler\n     */\n    //% group=\"Collisions\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% blockId=spritesollisions block=\"on $sprite of kind $kind=spritekind hits wall $tile=colorindexpicker\"\n    //% help=scene/on-hit-tile\n    export function onHitTile(kind: number, tile: number, handler: (sprite: Sprite) => void) {\n        if (kind == undefined || tile < 0 || tile > 0xF || !handler) return;\n\n        const collisionHandlers = game.currentScene().collisionHandlers;\n        if (!collisionHandlers[tile]) {\n            collisionHandlers[tile] = [];\n        }\n\n        collisionHandlers[tile].push(\n            new scene.SpriteHandler(\n                kind,\n                handler\n            )\n        );\n    }\n}",
            "spritekind.ts": "namespace sprites {\n    /**\n     * Gets the \"kind\" of sprite\n     */\n    //% shim=KIND_GET\n    //% blockId=spritekind block=\"$kind\"\n    //% kindNamespace=SpriteKind kindMemberName=kind kindPromptHint=\"e.g. Coin, Fireball, Asteroid...\"\n    export function _spriteKind(kind: number): number {\n        return kind;\n    }\n\n    /**\n     * Gets the sprite type\n     */\n    //% blockHidden=1 shim=ENUM_GET deprecated=true\n    //% blockId=spritetype block=\"$kind\" enumInitialMembers=\"Player,Projectile,Food,Enemy\"\n    //% enumName=SpriteKindLegacy enumMemberName=kind enumPromptHint=\"e.g. Coin, Fireball, Asteroid...\"\n    export function _spriteType(kind: number): number {\n        return kind;\n    }\n}\n\nnamespace SpriteKind {\n    let nextKind: number;\n\n    export function create() {\n        if (nextKind === undefined) nextKind = 1000;\n        return nextKind++;\n    }\n\n    //% isKind\n    export const Player = create();\n\n    //% isKind\n    export const Projectile = 1;\n\n    //% isKind\n    export const Food = create();\n\n    //% isKind\n    export const Enemy = create();\n}",
            "spritemap.ts": "namespace sprites {\n    export class SpriteMap {\n        private cellWidth: number;\n        private cellHeight: number;\n        private rowCount: number;\n        private columnCount: number;\n        private buckets: Sprite[][];\n\n        constructor() {\n            this.buckets = [];\n        }\n\n        /**\n         * Returns a potential list of neighbors\n         */\n        neighbors(sprite: Sprite): Sprite[] {\n            if (this.isOob(sprite)) return [];\n\n            const n: Sprite[] = [];\n            const layer = sprite.layer;\n            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n            n.removeElement(sprite);\n            return n;\n        }\n\n        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n        overlaps(sprite: Sprite): Sprite[] {\n            const n = this.neighbors(sprite);\n            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n        }\n\n        draw() {\n            for (let x = 0; x < this.columnCount; ++x) {\n                for (let y = 0; y < this.rowCount; ++y) {\n                    const left = x * this.cellWidth;\n                    const top = y * this.cellHeight;\n                    const k = this.key(left, top);\n                    const b = this.buckets[k];\n                    if (b && b.length)\n                        screen.drawRect(left, top, this.cellWidth, this.cellHeight, 5);\n                }\n            }\n        }\n\n        /**\n         * Recompute hashes for all objects\n         */\n        resizeBuckets(sprites: Sprite[]) {\n            // rescale buckets\n            let maxWidth = 0;\n            let maxHeight = 0;\n            for (const sprite of sprites) {\n                if (sprite.width > maxWidth) maxWidth = sprite.width;\n                if (sprite.height > maxHeight) maxHeight = sprite.height;\n            }\n\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n\n            this.cellWidth = Math.clamp(8, areaWidth >> 2, maxWidth * 2);\n            this.cellHeight = Math.clamp(8, areaHeight >> 2, maxHeight * 2);\n            this.rowCount = Math.idiv(areaHeight, this.cellHeight);\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth);\n        }\n\n        clear() {\n            this.buckets = [];\n        }\n\n        private key(x: number, y: number): number {\n            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n            return xi + yi * this.columnCount;\n        }\n\n        private insertAtKey(x: number, y: number, sprite: Sprite) {\n            const k = this.key(x, y);\n            let bucket = this.buckets[k];\n            if (!bucket)\n                bucket = this.buckets[k] = [];\n            if (bucket.indexOf(sprite) < 0)\n                bucket.push(sprite);\n        }\n\n        private isOob(sprite: Sprite): boolean {\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n            return sprite.right < 0 || sprite.left > areaWidth || sprite.bottom < 0 || sprite.top > areaHeight;\n        }\n\n        insertAABB(sprite: Sprite) {\n            // is object not collidable?\n            if (this.isOob(sprite))\n                return;\n\n            const left = sprite.left;\n            const top = sprite.top;\n            const xn = Math.idiv(sprite.width + this.cellWidth - 1, this.cellWidth);\n            const yn = Math.idiv(sprite.height + this.cellHeight - 1, this.cellHeight);\n            for (let x = 0; x <= xn; x++)\n                for (let y = 0; y <= yn; y++)\n                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n        }\n\n        private mergeAtKey(x: number, y: number, layer: number, n: Sprite[]) {\n            const k = this.key(x, y);\n            const bucket = this.buckets[k];\n            if (bucket) {\n                for (const sprite of bucket)\n                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n                        n.push(sprite);\n            }\n        }\n\n        toString() {\n            return `${this.buckets.length} buckets, ${this.buckets.filter(b => !!b).length} filled`;\n        }\n    }\n}",
            "sprites.ts": "/*\nFrame handlers:\n 10 - physics and collisions\n 20 - frame()\n 60 - screen/sprite background\n 90 - drawing sprites\n 95 - drawing score\n100 - loops.menu()\n200 - screen refresh\n*/\n\n/**\n * Sprites on screen\n */\n//% weight=99 color=\"#4B7BEC\" icon=\"\\uf1d8\"\n//% groups='[\"Create\", \"Physics\", \"Effects\", \"Projectiles\", \"Overlaps\", \"Lifecycle\"]'\nnamespace sprites {\n    export class FollowingSprite {\n        constructor(\n            public self: Sprite,\n            public target: Sprite,\n            public rate: number,\n            public turnRate: number\n        ) { }\n    }\n\n    /**\n     * Create a new sprite from an image\n     * @param img the image\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritekind\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=mySprite\n    //% weight=100 help=sprites/create\n    export function create(img: Image, kind?: number): Sprite {\n        const scene = game.currentScene();\n        const sprite = new Sprite(img)\n        sprite.setKind(kind);\n        scene.physicsEngine.addSprite(sprite);\n\n        // run on created handlers\n        scene.createdHandlers\n            .filter(h => h.kind == kind)\n            .forEach(h => h.handler(sprite));\n\n        return sprite\n    }\n\n    /**\n     * Return an array of all sprites of the given kind.\n     * @param kind the target kind\n     */\n    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritekind\"\n    //% blockNamespace=\"arrays\" blockSetVariable=\"sprite list\"\n    //% weight=87\n    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (!(kind >= 0) || !spritesByKind[kind]) return [];\n        else return spritesByKind[kind].sprites();\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromsprite block=\"projectile %img=screen_image_picker from %sprite=variables_get(mySprite) with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-sprite\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSprite(img: Image, sprite: Sprite, vx: number, vy: number): Sprite {\n        return createProjectile(img, vx, vy, SpriteKind.Projectile, sprite);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritekind||from sprite %sprite=variables_get(mySprite)\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    //% vy.defl=100\n    //% deprecated=true blockHidden=true\n    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind || SpriteKind.Projectile);\n        const sc = game.currentScene();\n        s.vx = vx\n        s.vy = vy\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n\n        while(vx == 0 && vy == 0) {\n            vx = Math.randomRange(-100, 100);\n            vy = Math.randomRange(-100, 100);\n        }\n\n        if (vx < 0)\n            s.x = screen.width + xOff\n        else if (vx > 0)\n            s.x = -xOff\n\n        if (vy < 0)\n            s.y = screen.height + yOff\n        else if (vy > 0)\n            s.y = -yOff\n\n        s.flags |= sprites.Flag.AutoDestroy;\n        s.flags |= sprites.Flag.DestroyOnWall;\n\n        if (sprite) {\n            s.x = sprite.x;\n            s.y = sprite.y;\n        }\n\n        return s\n    }\n\n    export enum Flag {\n        None = 0, // no flags are set\n        Ghost = 1 << 0, // doesn't collide with other sprites\n        Destroyed = 1 << 1,\n        AutoDestroy = 1 << 2, // remove the sprite when no longer visible\n        StayInScreen = 1 << 3, // sprite cannot move outside the camera region\n        DestroyOnWall = 1 << 4, // destroy sprite on contact with wall\n        BounceOnWall = 1 << 5, // Bounce on walls\n        ShowPhysics = 1 << 6, // display position, velocity, acc\n        Invisible = 1 << 7, // makes the sprite invisible, so it does not show up on the screen\n    }\n}\n",
            "spriteset.ts": "/* \n* A set of sprites \n*/\nclass SpriteSet {\n    private _sprites: Sprite[];\n\n    /**\n     * Create a new set from an array of sprites\n     * @param sprites \n     */\n    static createFromArray(sprites: Sprite[]): SpriteSet {\n        const sp = new SpriteSet();\n        const n = sprites.length;\n        for(let i = 0; i < n; ++i)\n            sp.add(sprites[i]);\n        return sp;\n    }\n\n    constructor() {\n        this._sprites = [];\n    }\n\n    /**\n     * Gets the number of sprites in the set\n     */\n    get length() {\n        return this._sprites.length;\n    }\n\n    /**\n     * Gets the snapshot of the current list of sprites\n     */\n    sprites() {\n        return this._sprites.slice(0, this._sprites.length);\n    }\n\n    /**\n     * Adds the sprite, returns true if added; false if the sprite was already in the set\n     * @param sprite \n     */\n    add(sprite: Sprite): boolean {\n        if (!sprite) return false; // don't add nulls\n\n        // scan if in set\n        if (this.contains(sprite))\n            return false;\n        this._sprites.push(sprite);\n        return true;\n    }\n\n    /**\n     * Adds sprite and removes from old set. Returns true if sprite was in old set and not in new set.\n     * @param oldSet \n     * @param sprite \n     */\n    addFrom(oldSet: SpriteSet, sprite: Sprite): boolean {\n        const removed = oldSet.remove(sprite);\n        const added = this.add(sprite);\n        return removed && added;\n    }\n\n    /**\n     * Removes sprite from set. Returns true if the sprite was in the set\n     * @param sprite \n     */\n    remove(sprite: Sprite): boolean {\n        const i = this._sprites.indexOf(sprite);\n        if (i > -1) {\n            this._sprites.splice(i, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the sprite is part of the set\n     * @param sprite \n     */\n    contains(sprite: Sprite): boolean {\n        return this._sprites.indexOf(sprite) > -1;\n    }\n\n    /** \n     * Removes all the sprites from the set\n    */\n    clear() {\n        this._sprites.splice(0, this._sprites.length);\n    }\n\n    /**\n     * Removes the last sprite in the set\n     */\n    pop(): Sprite {\n        return this._sprites.pop();\n    }\n\n    toString() {\n        return `${this.length} sprites`\n    }\n}",
            "systemmenu.ts": "namespace scene.systemMenu {\n    let instance: PauseMenu;\n    let customMenuOptions: MenuOption[];\n\n    export enum CardState {\n        Selected,\n        Active,\n        None\n    }\n\n    export interface MenuTheme {\n        cardSpacing: number;\n        cardWidth: number;\n        cardsPerRow: number;\n        padding: number;\n        cardsTop: number;\n        infoTop: number;\n\n        // \"PAUSED\"\n        headerText: string;\n\n        headerFont: image.Font;\n        infoFont: image.Font;\n\n        selectedCard: Image;\n        activeCard: Image;\n        basicCard: Image;\n    }\n\n    export class MenuOption {\n        protected card: Sprite;\n        protected icon: Sprite;\n\n        protected top: number;\n        protected state: CardState;\n\n        protected theme: MenuTheme;\n\n        constructor(protected iconImage: Image, public getText: () => string, public action: () => void) {\n        }\n\n        show() {\n            this.card = sprites.create(this.theme ? this.theme.basicCard : CARD_NORMAL);\n            this.card.z = 1;\n\n            this.icon = sprites.create(this.iconImage);\n            this.icon.z = 2;\n\n            this.state = CardState.None;\n        }\n\n        position(left: number, top: number) {\n            this.top = top;\n\n            this.card.left = left;\n            this.card.top = top;\n\n            this.icon.x = this.card.x;\n            this.icon.y = this.card.y;\n        }\n\n        setOffset(offset: number) {\n            this.card.top = this.top + offset;\n            this.icon.y = this.card.y;\n        }\n\n        setTheme(theme: MenuTheme) {\n            this.theme = theme;\n            this.updateCard();\n        }\n\n        setState(state: CardState) {\n            if (this.state === state) return;\n            this.state = state;\n            this.updateCard();\n        }\n\n        dispose() {\n            if (this.card) {\n                this.card.destroy();\n                this.icon.destroy();\n                this.card = undefined;\n                this.icon = undefined;\n            }\n        }\n\n        protected updateCard() {\n            if (!this.theme) return;\n            switch (this.state) {\n                case CardState.None: this.card.setImage(this.theme.basicCard); break;\n                case CardState.Selected: this.card.setImage(this.theme.selectedCard); break;\n                case CardState.Active: this.card.setImage(this.theme.activeCard); break;\n            }\n\n            // Center the icon\n            this.icon.x = this.card.x;\n            this.icon.y = this.card.y;\n        }\n    }\n\n    export class PauseMenu {\n        protected options: MenuOption[];\n        protected theme: MenuTheme;\n\n        // Index of selected card\n        protected selection: number;\n\n        // The row that is currently at the top of the screen\n        protected scrollRow: number;\n\n        // The pixel offset for the scrollRow\n        protected scrollTarget: number;\n\n        // The current pixel offset of the scroll (might be animating)\n        protected scrollOffset: number;\n\n        constructor(protected generator: () => MenuOption[], theme?: MenuTheme) {\n            this.theme = theme || buildMenuTheme(CARD_NORMAL.width, 3);\n            this.scrollRow = 0;\n            this.scrollOffset = 0;\n            this.scrollTarget = 0;\n        }\n\n        show() {\n            this.options = this.generator();\n            this.selection = 0;\n\n            let current: MenuOption;\n            for (let i = 0; i < this.options.length; i++) {\n                current = this.options[i];\n                current.show();\n                current.setTheme(this.theme);\n                current.position(\n                    this.theme.padding + (i % this.theme.cardsPerRow) * (this.theme.cardWidth + this.theme.cardSpacing),\n                    this.theme.cardsTop + (Math.idiv(i, this.theme.cardsPerRow) * (this.theme.cardWidth + this.theme.cardSpacing))\n                );\n            }\n\n            controller._setUserEventsEnabled(false);\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                if (!this.options || !this.options[this.selection]) return;\n                this.options[this.selection].setState(CardState.Active);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_UP, () => {\n                if (!this.options || !this.options[this.selection]) return;\n                this.options[this.selection].setState(CardState.Selected);\n                control.runInParallel(this.options[this.selection].action)\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                closeMenu();\n            });\n\n            controller.menu.onEvent(SYSTEM_KEY_DOWN, () => {\n                closeMenu();\n            });\n\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.max(0, this.selection - this.theme.cardsPerRow));\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.max(0, this.selection - 1));\n            });\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.min(this.options.length - 1, this.selection + this.theme.cardsPerRow));\n            });\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.setSelection(Math.min(this.options.length - 1, this.selection + 1));\n            });\n\n            game.onShade(() => {\n                this.onUpdate();\n                this.drawText();\n            });\n\n            this.setSelection(0);\n        }\n\n        onUpdate() {\n            // Should probably factor out this animation\n            let t = control.millis() / 250;\n            for (let i = 0; i < this.options.length; i++) {\n                this.options[i].setOffset(2 * Math.sin(t - (i % this.theme.cardsPerRow) * (Math.PI / 2)))\n            }\n\n            const dt = game.currentScene().eventContext.deltaTime;\n            if (this.scrollOffset < this.scrollTarget) {\n                this.scrollOffset += dt * 100;\n            }\n            else if (this.scrollOffset > this.scrollTarget) {\n                this.scrollOffset -= dt * 100;\n            }\n            else {\n                return;\n            }\n\n            if (Math.abs(this.scrollOffset - this.scrollTarget) < 2) {\n                this.scrollOffset = this.scrollTarget;\n            }\n\n            game.currentScene().camera.offsetY = this.scrollOffset;\n        }\n\n        setSelection(selection: number) {\n            if (!this.options) return;\n\n            if (this.options[this.selection]) {\n                this.options[this.selection].setState(CardState.None);\n            }\n\n            this.selection = selection;\n\n            if (this.options[this.selection]) {\n                this.options[this.selection].setState(controller.A.isPressed() ? CardState.Active : CardState.Selected);\n            }\n\n            this.updateScrollTarget();\n        }\n\n        drawText() {\n            if (!this.options) return;\n\n            // Black bar to draw the header on\n            screen.fillRect(0, 0, screen.width, this.theme.cardsTop - 2, 15);\n\n            // Header text\n            screen.printCenter(this.theme.headerText, 2, 1, this.theme.headerFont);\n\n            // Black bar for the info box to draw on\n            screen.fillRect(0, this.theme.infoTop - 3, screen.width, screen.height - this.theme.infoTop + 6, 15);\n\n            // White info box\n            screen.fillRect(this.theme.padding, this.theme.infoTop, screen.width - (this.theme.padding << 1), this.theme.infoFont.charHeight + 1, 1);\n\n            // Info text\n            screen.printCenter(this.options[this.selection].getText(), this.theme.infoTop + 1, 15, this.theme.infoFont);\n        }\n\n        dispose() {\n            if (this.options) {\n                this.options.forEach(o => o.dispose());\n                this.options = undefined;\n            }\n        }\n\n        protected updateScrollTarget() {\n            const row = Math.idiv(this.selection, this.theme.cardsPerRow);\n\n            // FIXME: Assumes that there are always two rows on screen\n            if (row === this.scrollRow || row - 1 === this.scrollRow) return;\n\n            if (row > this.scrollRow) this.scrollRow++;\n            else this.scrollRow--;\n\n            this.scrollTarget = this.scrollRow * (this.theme.cardSpacing + this.theme.cardWidth);\n        }\n    }\n\n    // we intentionally only save volume when the user explicitly adjusts it\n    // we don't want to save it when adjusted programatically, because it could for example changing in a loop\n    function setVolume(newVolume: number) {\n        music.setVolume(newVolume);\n        music.playTone(440, 500);\n        settings.writeNumber(\"#volume\", newVolume)\n    }\n\n    function volumeUp() {\n        const v = music.volume();\n        const remainder = v % 32;\n        const newVolume = v + 32 - remainder;\n        setVolume(newVolume);\n    }\n\n    function volumeDown() {\n        const v = music.volume();\n        const remainder = v % 32;\n        const newVolume = v - (remainder ? remainder : 32);\n        setVolume(newVolume);\n    }\n\n    function brightnessUp() {\n        screen.setBrightness(screen.brightness() + 10);\n    }\n\n    function brightnessDown() {\n        screen.setBrightness(screen.brightness() - 10);\n    }\n\n    function toggleStats() {\n        game.stats = !game.stats;\n    }\n\n    function toggleConsole() {\n        if (game.consoleOverlay.isVisible())\n            game.consoleOverlay.setVisible(false);\n        else {\n            game.consoleOverlay.setVisible(true);\n            console.log(\"console\");\n        }\n    }\n\n    function sleep() {\n        power.deepSleep();\n    }\n\n    function closeMenu() {\n        if (instance) {\n            instance.dispose();\n            instance = undefined;\n            controller._setUserEventsEnabled(true);\n            game.popScene();\n        }\n    }\n\n    export function buildOptionList(): MenuOption[] {\n        let options: MenuOption[] = [];\n\n        options.push(new MenuOption(VOLUME_DOWN_ICON, () => `VOLUME DOWN (${music.volume()})`, volumeDown));\n        options.push(new MenuOption(VOLUME_UP_ICON, () => `VOLUME UP (${music.volume()})`, volumeUp));\n        options.push(new MenuOption(BRIGHTNESS_DOWN_ICON, () => `BRIGHTNESS DOWN (${screen.brightness()})`, brightnessDown));\n        options.push(new MenuOption(BRIGHTNESS_UP_ICON, () => `BRIGHTNESS UP (${screen.brightness()})`, brightnessUp));\n        options.push(new MenuOption(STATS_ICON, () => game.stats ? \"HIDE STATS\" : \"SHOW STATS\", toggleStats));\n        options.push(new MenuOption(CONSOLE_ICON, () => game.consoleOverlay.isVisible() ? \"HIDE CONSOLE\" : \"SHOW CONSOLE\", toggleConsole));\n        options.push(new MenuOption(SLEEP_ICON, () => \"SLEEP\", sleep));\n\n        if (customMenuOptions) {\n            options = options.concat(customMenuOptions);\n        }\n\n        options.push(new MenuOption(CLOSE_MENU_ICON, () => \"CLOSE\", closeMenu));\n\n        return options;\n    }\n\n    export function buildMenuTheme(cardWidth: number, cardSpacing: number, infoFont?: image.Font, headerFont?: image.Font): MenuTheme {\n        const cardsPerRow = Math.idiv(screen.width, cardWidth + cardSpacing);\n        infoFont = infoFont || image.font8;\n        headerFont = headerFont || image.doubledFont(infoFont);\n\n        return {\n            cardSpacing: cardSpacing,\n            cardWidth: cardWidth,\n            cardsPerRow: cardsPerRow,\n            padding: (screen.width - (cardsPerRow * cardWidth + (cardsPerRow - 1) * cardSpacing)) >> 1,\n            infoFont: infoFont,\n            headerFont: headerFont,\n            cardsTop: headerFont.charHeight + 2 + cardSpacing,\n            infoTop: screen.height - infoFont.charHeight - 2,\n            headerText: \"PAUSED\",\n            selectedCard: CARD_SELECTED,\n            activeCard: CARD_ACTIVE,\n            basicCard: CARD_NORMAL\n        };\n    }\n\n    export function addEntry(name: () => string, clickHandler: () => void, icon: Image) {\n        if (!customMenuOptions) customMenuOptions = [];\n        customMenuOptions.push(new MenuOption(icon, name, clickHandler));\n    }\n\n    export function register() {\n        if (instance) return; // don't show system menu, while in system menu\n\n        controller.menu.onEvent(ControllerButtonEvent.Pressed, showSystemMenu);\n    }\n\n    export function showSystemMenu() {\n        if (instance) return;\n        game.pushScene();\n        instance = new PauseMenu(buildOptionList);\n        instance.show();\n    }\n\n    export function isVisible() {\n        return !!instance;\n    }\n\n    function initVolume() {\n        const vol = settings.readNumber(\"#volume\")\n        if (vol != null)\n            music.setVolume(vol)\n    }\n\n    initVolume()\n    scene.Scene.initializers.push(register);\n}\n",
            "systemmenuicons.ts": "namespace scene.systemMenu {\n    export const CARD_NORMAL = img`\n        . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .\n        . 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 .\n        1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1\n        1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1\n        . 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 .\n        . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . .\n    `;\n    export const CARD_SELECTED = img`\n        . . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .\n        . 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 .\n        2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2\n        2 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 2\n        2 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 3 2\n        2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2\n        . 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 .\n        . . 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 . .\n    `;\n    export const CARD_ACTIVE = img`\n        . . 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 . .\n        . 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 .\n        4 4 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4\n        4 3 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 3 4\n        4 3 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 3 4\n        4 4 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4\n        . 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 .\n        . . 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 . .\n    `;\n    export const VOLUME_UP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . c c c b b . . . . . . . . . 6 6 7 . . . . .\n        . . . . . . . . . c b 1 1 d b b . . . . . . . . 6 6 6 6 . . . .\n        . . . . . . . . c d 1 d c b d b . . . . . 6 7 . . 6 6 6 7 . . .\n        . . . . . c c c b 1 d c c c b d b . . . . 6 6 6 . 7 6 6 6 . . .\n        . . c c c c b c 1 1 b c c c c d b . . . . 7 6 6 7 . 6 6 6 7 . .\n        . c b d c b 1 b 1 1 c c c c c b c . d 7 . . 6 6 6 . 7 6 6 6 . .\n        . c d b b 1 1 b 1 d c d b c c b c . 7 6 7 . 7 6 6 . 7 6 6 6 . .\n        . f d b b d 1 b d d b d d c c b c . . 6 6 . 7 6 6 . 7 6 6 6 . .\n        . f d b b d d b d d b d b c f b c . . 6 6 . 7 6 6 . 7 6 6 6 . .\n        . f d b b b d b d d f b c f f b c . 7 6 7 . 7 6 6 . 7 6 6 6 . .\n        . f b d c b b b d d f f f f f b c . d 7 . . 6 6 6 . 7 6 6 6 . .\n        . . f f f f b c d d c f f f c d b . . . . 7 6 6 7 . 6 6 6 7 . .\n        . . . . . f f f b 1 d f f f b d b . . . . 6 6 6 . 7 6 6 6 . . .\n        . . . . . . . . c d 1 d c b d b . . . . . 6 7 . . 6 6 6 7 . . .\n        . . . . . . . . . c b 1 1 d b b . . . . . . . . 6 6 6 6 . . . .\n        . . . . . . . . . . c c c c b . . . . . . . . . 6 6 7 . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const BRIGHTNESS_DOWN_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . b b b . . . . . . . . . . . . . .\n        . . . . . . . . . . . b . . . 4 5 4 . . . b . . . . . . . . . .\n        . . . . . . . . . . b 5 4 . . . 4 . . . 4 5 b . . . . . . . . .\n        . . . . . . . . . b 5 5 4 . . . . . . . 4 5 5 b . . . . . . . .\n        . . . . . . . . . . b 4 . . . 4 4 4 . . . 4 4 . . . . . . . . .\n        . . . . . . . . . . . . . 4 4 5 5 5 4 4 . . . . . . . . . . . .\n        . . . . . . . . . . . . . 4 5 5 1 1 5 4 . . . . . . . . . . . .\n        . . . . . . . . b 4 . . 4 d 5 5 1 1 5 d 4 . . 4 b . . . . . . .\n        . . . . . . . . b 5 4 . b d d 5 5 5 d d b . 4 5 b . . . . . . .\n        . . . . . . . . b 4 . . b d d d d d d d b . . 4 b . . . . . . .\n        . . . . . . . . . . . . . b d d d d d b . . . . . . . . . . . .\n        . . . . . . . . . . . . . b b d d d b b . . . . . . . . . . . .\n        . . . . . . . . . . 4 4 . . . b b b . . . 4 4 . . . . . . . . .\n        . . . . . . . . . b 5 5 4 . . . . . . . 4 5 5 b . . . . . . . .\n        . . . . . . . . . . b 5 4 . . . 4 . . . 4 5 b . . . . . . . . .\n        . . . . . . . . . . . b . . . 4 5 4 . . . b . . . . . . . . . .\n        . . . . . . . . . . . . . . . b b b . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const CLOSE_MENU_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . 2 2 . . . . . . . . . . . . . . 2 2 . . . . . . .\n        . . . . . . . 2 2 2 . . . . . . . . . . . . 2 2 2 . . . . . . .\n        . . . . . . . . 2 2 2 . . . . . . . . . . 2 2 2 . . . . . . . .\n        . . . . . . . . . 2 2 2 . . . . . . . . 2 2 2 . . . . . . . . .\n        . . . . . . . . . . 2 2 2 . . . . . . 2 2 2 . . . . . . . . . .\n        . . . . . . . . . . . 2 2 2 . . . . 2 2 2 . . . . . . . . . . .\n        . . . . . . . . . . . . 2 2 2 . . 2 2 2 . . . . . . . . . . . .\n        . . . . . . . . . . . . . 2 2 2 2 2 2 . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 2 2 2 2 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 2 2 2 2 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . 2 2 2 2 2 2 . . . . . . . . . . . . .\n        . . . . . . . . . . . . 2 2 2 . . 2 2 2 . . . . . . . . . . . .\n        . . . . . . . . . . . 2 2 2 . . . . 2 2 2 . . . . . . . . . . .\n        . . . . . . . . . . 2 2 2 . . . . . . 2 2 2 . . . . . . . . . .\n        . . . . . . . . . 2 2 2 . . . . . . . . 2 2 2 . . . . . . . . .\n        . . . . . . . . 2 2 2 . . . . . . . . . . 2 2 2 . . . . . . . .\n        . . . . . . . 2 2 2 . . . . . . . . . . . . 2 2 2 . . . . . . .\n        . . . . . . . 2 2 . . . . . . . . . . . . . . 2 2 . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const VOLUME_DOWN_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . c c c b b . . . . . . . . . . . .\n        . . . . . . . . . . . . . . c b 1 1 d b b . . . . . . . . . . .\n        . . . . . . . . . . . . . c d 1 d c b d b . . . . . . . . . . .\n        . . . . . . . . . . c c c b 1 d c c c b d b . . . . . . . . . .\n        . . . . . . . c c c c b c 1 1 b c c c c d b . . . . . . . . . .\n        . . . . . . c b d c b 1 b 1 1 c c c c c b c . d 7 . . . . . . .\n        . . . . . . c d b b 1 1 b 1 d c d b c c b c . 7 6 7 . . . . . .\n        . . . . . . f d b b d 1 b d d b d d c c b c . . 6 6 . . . . . .\n        . . . . . . f d b b d d b d d b d b c f b c . . 6 6 . . . . . .\n        . . . . . . f d b b b d b d d f b c f f b c . 7 6 7 . . . . . .\n        . . . . . . f b d c b b b d d f f f f f b c . d 7 . . . . . . .\n        . . . . . . . f f f f b c d d c f f f c d b . . . . . . . . . .\n        . . . . . . . . . . f f f b 1 d f f f b d b . . . . . . . . . .\n        . . . . . . . . . . . . . c d 1 d c b d b . . . . . . . . . . .\n        . . . . . . . . . . . . . . c b 1 1 d b b . . . . . . . . . . .\n        . . . . . . . . . . . . . . . c c c c b . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const SLEEP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . b b b b b b . . . . . . . . . . . . .\n        . . . . . . . . . . . b b d 5 5 5 5 d c c . . . . . . . . . . .\n        . . . . . . . . . . b d 5 5 5 b c c c c c c . . . . . . . . . .\n        . . . . . . . . . b 5 5 5 5 c c c c c c c c c . . . . . . . . .\n        . . . . . . . . b d 5 5 5 b c c c c c d c c c c . . . . . . . .\n        . . . . . . . . b 5 5 5 5 c c c c c b 5 b c c c . . . . . . . .\n        . . . . . . . b d 5 5 5 5 c c c c d 5 5 5 d c d c . . . . . . .\n        . . . . . . . b 5 5 5 5 5 c c c c b 5 5 5 b c d c . . . . . . .\n        . . . . . . . c 5 5 5 5 5 c c c c c 5 b 5 c c d c . . . . . . .\n        . . . . . . . c 5 5 5 5 5 b c c c c c c c c b d c . . . . . . .\n        . . . . . . . c d 5 5 5 5 5 c c c c c c c c d d c . . . . . . .\n        . . . . . . . c d d 5 5 5 d d b c c c c b d d d c . . . . . . .\n        . . . . . . . . c d d d d d d d d d d d d d d c . . . . . . . .\n        . . . . . . . . c d d d d d d d d d d d d d d c . . . . . . . .\n        . . . . . . . . . c 9 9 d d d d d d d d d 9 c . . . . . . . . .\n        . . . . . . . . . . b 9 9 9 d d d d d 9 9 c . . . . . . . . . .\n        . . . . . . . . . . . b b 9 9 9 9 9 9 c c . . . . . . . . . . .\n        . . . . . . . . . . . . . b b b b c c . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const CONSOLE_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . b b b b b b b b b b b c c . . . . . . . . .\n        . . . . . . . . . b 1 d d d d d d d d d d 1 b c . . . . . . . .\n        . . . . . . . . b 1 1 1 1 1 1 1 1 1 1 1 1 b b c . . . . . . . .\n        . . . . . . . . b d b c c c c c c c c c b b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 1 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 1 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 1 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 1 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 1 6 6 6 1 1 1 6 c b b c . . . . . . . .\n        . . . . . . . . b d c 6 6 6 6 6 6 6 6 6 c b b c . . . . . . . .\n        . . . . . . . . b d c c c c c c c c c c c b b c . . . . . . . .\n        . . . . . . . . c b b b b b b b b b b b b b c . . . . . . . . .\n        . . . . . . . . . c c c c c c c c c c c c c . . . . . . . . . .\n        . . . . . . . . . . . . . c c c c c c . . . . . . . . . . . . .\n        . . . . . . . . . c c c c b b b b b b c c c c c . . . . . . . .\n        . . . . . . . . c 1 1 b 1 1 b 1 1 b 1 1 b d d c . . . . . . . .\n        . . . . . . . c d d d d d d d d d d d d d b c . . . . . . . . .\n        . . . . . . . c c c c c c c c c c c c c c c . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const BRIGHTNESS_UP_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . 4 4 . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . 4 5 5 4 . . . . . . . . . . . . . .\n        . . . . . . . . 4 4 b . . . b b b b . . . b 4 4 . . . . . . . .\n        . . . . . . . 4 5 5 b . . . . . . . . . . b 5 5 4 . . . . . . .\n        . . . . . . . 4 5 b . . . . 4 4 4 4 . . . . b 5 4 . . . . . . .\n        . . . . . . . b b . . . 4 4 5 5 5 5 4 4 . . . b b . . . . . . .\n        . . . . . . . . . . . 4 d 5 5 5 5 5 5 d 4 . . . . . . . . . . .\n        . . . . . . . . . . 4 d 5 5 5 5 5 1 1 5 d 4 . . . . . . . . . .\n        . . . . . . . . . . 4 5 5 5 5 5 5 1 1 5 5 4 . . . . . . . . . .\n        . . . . . . 4 b . 4 d 5 5 5 5 5 5 5 5 5 5 d 4 . b 4 . . . . . .\n        . . . . . 4 5 b . 4 d 5 5 5 5 5 5 5 5 5 5 d 4 . b 5 4 . . . . .\n        . . . . . 4 5 b . b d 5 5 5 5 5 5 5 5 5 5 d b . b 5 4 . . . . .\n        . . . . . . 4 b . b d d 5 5 5 5 5 5 5 5 d d b . b 4 . . . . . .\n        . . . . . . . . . . b d d 5 5 5 5 5 5 d d b . . . . . . . . . .\n        . . . . . . . . . . b d d d d d d d d d d b . . . . . . . . . .\n        . . . . . . . . . . . b d d d d d d d d b . . . . . . . . . . .\n        . . . . . . . b b . . . b b d d d d b b . . . b b . . . . . . .\n        . . . . . . . 4 5 b . . . . b b b b . . . . b 5 4 . . . . . . .\n        . . . . . . . 4 5 5 b . . . . . . . . . . b 5 5 4 . . . . . . .\n        . . . . . . . . 4 4 b . . . b b b b . . . b 4 4 . . . . . . . .\n        . . . . . . . . . . . . . . 4 5 5 4 . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . 4 4 . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n    export const STATS_ICON = img`\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . b b b b . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . b 5 5 b b . b b b b b b . . . . . . . . . . . . . .\n        . . . . . . b 5 b d c c b d d d 5 5 b b . . . . . . . . . . . .\n        . . . . . . b b d b c d d b b b b d 5 5 b . . . . . . . . . . .\n        . . . . . . b b b c d d b 1 1 1 1 1 b d 5 b . . . . . . . . . .\n        . . . . . . . . c b d b 1 1 1 1 1 1 1 d b 5 b . . . . . . . . .\n        . . . . . . . . b 5 b d 1 1 b 1 1 1 1 1 d d 5 b . . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 d b 1 1 b 1 1 b 5 b . . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 1 b b 1 b 9 9 1 d 5 b . . . . . . .\n        . . . . . . . b b 5 b 1 1 1 1 1 b b b 9 9 9 b 5 b . . . . . . .\n        . . . . . . . b b 5 5 d 1 1 1 9 9 b b 9 9 9 b 5 b . . . . . . .\n        . . . . . . . b d b 5 b 1 1 9 9 9 9 9 9 9 9 c 5 b . . . . . . .\n        . . . . . . . b d b 5 5 b 1 9 9 9 9 9 9 9 d b 5 b . . . . . . .\n        . . . . . . . . b d b 5 5 b 9 9 9 9 9 9 9 c 5 d . . . . . . . .\n        . . . . . . . . c d d b 5 5 b b 9 9 9 d c b 5 b . . . . . . . .\n        . . . . . . . . . c d d b 5 5 5 b c c b 5 5 b . . . . . . . . .\n        . . . . . . . . . . c b b b d 5 5 5 5 5 d b . . . . . . . . . .\n        . . . . . . . . . . . c c b b b b b b b b . . . . . . . . . . .\n        . . . . . . . . . . . . . c c c c c c . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    `;\n}",
            "targetoverrides.cpp": "// Overriden in target\n",
            "targetoverrides.ts": "// Overriden in target\n",
            "textDialogs.ts": "enum DialogLayout {\n    //% block=bottom\n    Bottom,\n    //% block=left\n    Left,\n    //% block=right\n    Right,\n    //% block=top\n    Top,\n    //% block=center\n    Center,\n    //% block=\"full screen\"\n    Full\n}\n\nnamespace game {\n    let dialogFrame: Image;\n    let dialogCursor: Image;\n    let dialogTextColor: number;\n\n    export class BaseDialog {\n        image: Image;\n        frame: Image;\n        cursor: Image;\n\n        columns: number;\n        rows: number;\n        unit: number;\n\n        innerLeft: number;\n        innerTop: number;\n        cursorCount: number;\n\n        font: image.Font;\n        textColor: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            this.image = image.create(width, height);\n\n            this.frame = frame || dialogFrame || (dialogFrame = defaultFrame());\n\n            this.font = font || image.font8;\n\n            this.cursor = cursor || dialogCursor || (dialogCursor = defaultCursorImage());\n\n            this.textColor = dialogTextColor == undefined ? dialogTextColor = 15 : dialogTextColor;\n\n            this.unit = Math.floor(this.frame.width / 3);\n            this.columns = Math.floor(width / this.unit);\n            this.rows = Math.floor(height / this.unit);\n\n            this.innerLeft = (width - (this.columns * this.unit)) >> 1;\n            this.innerTop = (height - (this.rows * this.unit)) >> 1;\n\n            this.cursorCount = 0;\n\n            this.drawBorder();\n            this.clearInterior();\n        }\n\n        update() {\n            this.clearInterior();\n            this.drawTextCore();\n            this.drawCursorRow();\n        }\n\n        setText(rawString: string) {\n            // implemented by subclass\n        }\n\n        drawTextCore() {\n            // Implemented by subclass\n        }\n\n        drawCursorRow() {\n            let offset = 0;\n            if (this.cursorCount > 20) {\n                offset = 1;\n            }\n\n            this.cursorCount = (this.cursorCount + 1) % 40;\n\n            this.image.drawTransparentImage(\n                this.cursor,\n                this.innerLeft + this.textAreaWidth() + this.unit + offset - this.cursor.width,\n                this.innerTop + this.unit + this.textAreaHeight() + 1 - this.cursorRowHeight()\n            )\n        }\n\n        protected drawBorder() {\n            for (let c = 0; c < this.columns; c++) {\n                if (c == 0) {\n                    this.drawPartial(0, 0, 0);\n                    this.drawPartial(6, 0, this.rows - 1);\n                }\n                else if (c === this.columns - 1) {\n                    this.drawPartial(2, c, 0);\n                    this.drawPartial(8, c, this.rows - 1);\n                }\n                else {\n                    this.drawPartial(1, c, 0);\n                    this.drawPartial(7, c, this.rows - 1);\n                }\n            }\n\n            for (let r = 1; r < this.rows - 1; r++) {\n                this.drawPartial(3, 0, r);\n                this.drawPartial(5, this.columns - 1, r);\n            }\n        }\n\n        protected clearInterior() {\n            for (let d = 1; d < this.columns - 1; d++) {\n                for (let s = 1; s < this.rows - 1; s++) {\n                    this.drawPartial(4, d, s)\n                }\n            }\n        }\n\n        protected drawPartial(index: number, colTo: number, rowTo: number) {\n            const x0 = this.innerLeft + colTo * this.unit;\n            const y0 = this.innerTop + rowTo * this.unit;\n\n            const xf = (index % 3) * this.unit;\n            const yf = Math.floor(index / 3) * this.unit;\n\n            for (let e = 0; e < this.unit; e++) {\n                for (let t = 0; t < this.unit; t++) {\n                    this.image.setPixel(\n                        x0 + e,\n                        y0 + t,\n                        this.frame.getPixel(xf + e, yf + t));\n                }\n            }\n        }\n\n        protected cursorRowHeight() {\n            return this.cursor.height + 1;\n        }\n\n        protected rowHeight() {\n            return this.font.charHeight + 1;\n        }\n\n        protected textAreaWidth() {\n            return this.image.width - ((this.innerLeft + this.unit) << 1) - 2;\n        }\n\n        protected textAreaHeight() {\n            return this.image.height - ((this.innerTop + this.unit) << 1) - 1;\n        }\n\n        protected setFont(font: image.Font) {\n            this.font = font;\n        }\n    }\n\n    export class Dialog extends BaseDialog {\n        chunks: string[];\n        chunkIndex: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            super(width, height, frame, font, cursor);\n\n            this.chunkIndex = 0;\n        }\n\n        hasNext() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex < this.chunks.length - 1;\n        }\n\n        hasPrev() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex > 0;\n        }\n\n        nextPage() {\n            if (this.hasNext()) {\n                this.chunkIndex++;\n            }\n        }\n\n        prevPage() {\n            if (this.hasPrev()) {\n                this.chunkIndex--;\n            }\n        }\n\n        chunkText(str: string): string[] {\n            const charactersPerRow = Math.floor(this.textAreaWidth() / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(this.textAreaHeight() / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const screens: string[] = [];\n\n            let strIndex = 0;\n            let rowIndex = 0;\n            let current = \"\";\n\n            while (strIndex < str.length) {\n                const currRowCharacters = rowIndex < rowsOfCharacters - rowsWithCursor ?\n                    charactersPerRow : charactersPerCursorRow;\n                const lastIndex = strIndex + currRowCharacters - 1;\n\n                if (str.charAt(lastIndex) === \" \" || lastIndex >= str.length - 1) {\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters;\n                }\n                else if (str.charAt(lastIndex + 1) === \" \") {\n                    // No need to break, but consume the space\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters + 1;\n                }\n                else if (str.charAt(lastIndex - 1) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 1) + \" \";\n                    strIndex += currRowCharacters - 1;\n                }\n                else if (str.charAt(lastIndex - 2) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 2) + \"  \";\n                    strIndex += currRowCharacters - 2;\n                }\n                else {\n                    // Insert a break\n                    current += str.substr(strIndex, currRowCharacters - 1) + \"-\";\n                    strIndex += currRowCharacters - 1;\n                }\n\n                rowIndex++;\n                if (rowIndex >= rowsOfCharacters) {\n                    rowIndex = 0;\n                    screens.push(current);\n                    current = \"\";\n                }\n            }\n\n            // Only pushes the last part of the message to the screen when current isn't empty\n            if (current) {\n                screens.push(current);\n            }\n\n            return screens;\n        }\n\n        setText(rawString: string) {\n            this.chunks = this.chunkText(rawString);\n            this.chunkIndex = 0;\n            this.setFont(image.getFontForText(rawString));\n        }\n\n        drawTextCore() {\n            if (!this.chunks || this.chunks.length === 0) return;\n            const str = this.chunks[this.chunkIndex];\n            const availableWidth = this.textAreaWidth();\n            const availableHeight = this.textAreaHeight();\n\n            const charactersPerRow = Math.floor(availableWidth / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(availableHeight / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const textLeft = 1 + this.innerLeft + this.unit + ((availableWidth - charactersPerRow * this.font.charWidth) >> 1);\n            const textTop = 1 + this.innerTop + this.unit + ((availableHeight - rowsOfCharacters * this.rowHeight()) >> 1);\n\n            let current = 0;\n            for (let row = 0; row < rowsOfCharacters; row++) {\n                const currRowCharacters = row % rowsOfCharacters < rowsOfCharacters - rowsWithCursor ?\n                    charactersPerRow : charactersPerCursorRow;\n\n                this.image.print(\n                    str.substr(current, currRowCharacters),\n                    textLeft,\n                    textTop + row * this.rowHeight(),\n                    this.textColor, this.font\n                )\n                current += currRowCharacters;\n            }\n        }\n    }\n\n    export class SplashDialog extends game.BaseDialog {\n        text: string;\n        subtext: string;\n\n        timer: number;\n        offset: number;\n        maxOffset: number;\n        maxSubOffset: number;\n\n        constructor(width: number, height: number) {\n            super(width, height, defaultSplashFrame())\n            this.maxOffset = -1;\n            this.maxSubOffset = -1;\n            this.textColor = 1;\n        }\n\n        private updateFont() {\n            this.setFont(image.getFontForText((this.text || \"\") + (this.subtext || \"\")));\n        }\n\n        setText(text: string) {\n            this.text = text;\n            this.updateFont();\n            this.offset = 0;\n            this.maxOffset = text.length * this.font.charWidth - screen.width + (this.unit << 1);\n            this.timer = 2;\n        }\n\n        setSubtext(sub: string) {\n            this.subtext = sub;\n            this.updateFont();\n            this.maxSubOffset = sub.length * (this.font.charWidth) - screen.width + (this.unit << 1);\n        }\n\n        drawTextCore() {\n            const scrollMax = Math.max(this.maxOffset, this.maxSubOffset);\n            if (this.timer > 0) {\n                this.timer -= game.eventContext().deltaTime;\n                if (this.timer <= 0) {\n                    if (this.offset > 0) {\n                        this.offset = 0;\n                        this.timer = 2;\n                    }\n                }\n            }\n            else {\n                this.offset++;\n                if (this.offset >= scrollMax) {\n                    this.offset = scrollMax;\n                    this.timer = 2;\n                }\n            }\n            const ytitle = 10;\n            if (this.maxOffset < 0) {\n                const left = (this.image.width >> 1) - (this.text.length * this.font.charWidth >> 1)\n                this.image.print(this.text, left, ytitle, this.textColor, this.font)\n            }\n            else {\n                this.image.print(this.text, this.unit - this.offset, ytitle, this.textColor, this.font)\n            }\n\n            if (this.subtext) {\n                const ysub = ytitle + this.font.charHeight + 2;\n                if (this.maxSubOffset < 0) {\n                    const left = (this.image.width >> 1) - (this.subtext.length * this.font.charWidth >> 1)\n                    this.image.print(this.subtext, left, ysub, this.textColor, this.font);\n                }\n                else {\n                    this.image.print(this.subtext, this.unit - (Math.min(this.offset, this.maxSubOffset)), ysub, this.textColor, this.font);\n                }\n            }\n            this.drawBorder();\n        }\n    }\n\n    export class GameOverDialog extends game.BaseDialog {\n        protected cursorOn: boolean;\n        protected isNewHighScore: boolean;\n\n        constructor(\n            protected win: boolean,\n            protected score?: number,\n            protected highScore?: number\n        ) {\n            super(screen.width(), 46, defaultSplashFrame());\n            this.cursorOn = false;\n            this.isNewHighScore = this.score > this.highScore;\n        }\n\n        displayCursor() {\n            this.cursorOn = true;\n        }\n\n        update() {\n            this.clearInterior();\n            this.drawTextCore();\n\n            if (this.cursorOn) {\n                this.drawCursorRow();\n            }\n        }\n\n        drawTextCore() {\n            const titleHeight = 8;\n            this.image.printCenter(\n                this.win ? \"YOU WIN!\" : \"GAME OVER!\",\n                titleHeight,\n                screen.isMono ? 1 : 5,\n                image.font8\n            );\n\n            if (this.score !== undefined) {\n                const scoreHeight = 23;\n                const highScoreHeight = 34;\n                const scoreColor = screen.isMono ? 1 : 2;\n\n                this.image.printCenter(\n                    \"Score:\" + this.score,\n                    scoreHeight,\n                    scoreColor,\n                    image.font8\n                );\n\n                if (this.isNewHighScore) {\n                    this.image.printCenter(\n                        \"New High Score!\",\n                        highScoreHeight,\n                        scoreColor,\n                        image.font5\n                    );\n                } else {\n                    this.image.printCenter(\n                        \"HI\" + this.highScore,\n                        highScoreHeight,\n                        scoreColor,\n                        image.font8\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Show a long text string in a dialog box that will scroll\n     * using the \"A\" or \"down\" buttons. The previous section of the\n     * text is shown using the \"up\" button. This function\n     * halts execution until the last page of text is dismissed.\n     *\n     * @param str The text to display\n     * @param layout The layout to use for the dialog box\n     */\n    //% blockId=game_show_long_text group=\"Dialogs\"\n    //% block=\"show long text %str %layout\"\n    //% help=game/show-long-text\n    export function showLongText(str: string, layout: DialogLayout) {\n        // Pause to cede control from this fiber just in case the user code created\n        // sprites and they haven't had a chance to render yet.\n        pause(1);\n\n        // Clone the current screen so that it shows up behind the dialog\n        let temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n        temp = null;\n\n        let width: number;\n        let height: number;\n        let top: number;\n        let left: number;\n\n        switch (layout) {\n            case DialogLayout.Bottom:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = screen.height - height;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Top:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = 0;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Left:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n            case DialogLayout.Right:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = screen.width - width;\n                break;\n            case DialogLayout.Center:\n                width = Math.idiv(screen.width << 1, 3);\n                height = Math.idiv(screen.width << 1, 3);\n                top = (screen.height - height) >> 1;\n                left = (screen.width - width) >> 1;\n                break;\n            case DialogLayout.Full:\n                width = screen.width;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n        }\n\n        const dialog = new Dialog(width, height);\n        const s = sprites.create(dialog.image, -1);\n        s.top = top;\n        s.left = left;\n\n        dialog.setText(str)\n        let pressed = true;\n        let done = false;\n\n        let upPressed = true;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed() || controller.down.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                if (dialog.hasNext()) {\n                    dialog.nextPage();\n                }\n                else {\n                    scene.setBackgroundImage(null); // GC it\n                    game.popScene();\n                    done = true;\n                }\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n\n            const moveBack = controller.up.isPressed();\n            if (moveBack && !upPressed) {\n                upPressed = true;\n                if (dialog.hasPrev()) {\n                    dialog.prevPage();\n                }\n            }\n            else if (upPressed && !moveBack) {\n                upPressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n\n    function defaultFrame() {\n        return screen.isMono ?\n            img`\n        1 1 1\n        1 . 1\n        1 1 1\n        `\n            :\n            img`\n        . . . . . . . . . . . .\n        . b b b b b b b b b b .\n        . b b b b b b b b b b c\n        . b b d 1 1 1 1 d b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b d 1 1 1 1 d b b c\n        . b b b b b b b b b b c\n        . b b b b b b b b b b c\n        . . c c c c c c c c c c\n        `\n    }\n\n    function defaultSplashFrame() {\n        return screen.isMono ?\n            img`\n        1 1 1\n        . . .\n        1 1 1\n        `\n            :\n            img`\n        1 1 1\n        f f f\n        1 1 1\n        `\n    }\n\n    function defaultCursorImage() {\n        return screen.isMono ?\n            img`\n        1 1 1 1 1 1 1 . . .\n        1 . . 1 . . . 1 . .\n        1 . 1 . 1 . . . 1 .\n        1 . 1 1 1 . . . . 1\n        1 . 1 . 1 . . . 1 .\n        1 . . . . . . 1 . .\n        1 1 1 1 1 1 1 . . .\n        . . . . . . . . . .\n        `\n            :\n            img`\n        0 0 0 6 6 6 6 6 0 0 0\n        0 6 6 7 7 7 7 7 6 6 0\n        0 6 7 7 1 1 1 7 7 6 0\n        6 7 7 1 7 7 7 1 7 7 6\n        6 7 7 1 7 7 7 1 7 7 6\n        6 7 7 1 1 1 1 1 7 7 6\n        6 6 7 1 7 7 7 1 7 6 6\n        8 6 6 1 7 7 7 1 6 6 8\n        8 6 6 7 6 6 6 7 6 6 8\n        0 8 6 6 6 6 6 6 6 8 0\n        0 0 8 8 8 8 8 8 8 0 0\n        `\n    }\n\n    /**\n     * Change the default dialog frame to a new image. Dialog frames\n     * are divided into three rows and three columns and are used to define\n     * the outer frame of the dialog box.\n     *\n     * @param frame A square image with a width and height divisible by three\n     */\n    //% blockId=game_dialog_set_frame group=\"Dialogs\"\n    //% block=\"set dialog frame to %frame=dialog_image_picker\"\n    //% help=game/set-dialog-frame\n    export function setDialogFrame(frame: Image) {\n        dialogFrame = frame;\n    }\n\n    /**\n     * Change the default image used for the cursor that appears in the\n     * bottom left of the dialog box.\n     *\n     * @param cursor The image to use for the cursor\n     */\n    //% blockId=game_dialog_set_cursor group=\"Dialogs\"\n    //% block=\"set dialog cursor to %frame=screen_image_picker\"\n    //% help=game/set-dialog-cursor\n    export function setDialogCursor(cursor: Image) {\n        dialogCursor = cursor;\n    }\n\n    /**\n     * Change the color for the text in dialog boxes.\n     *\n     * @param color The index of the color 0-15\n     */\n    //% blockId=game_dialog_set_text_color group=\"Dialogs\"\n    //% block=\"set dialog text color to %color=colorindexpicker\"\n    //% help=game/set-dialog-text-color\n    export function setDialogTextColor(color: number) {\n        dialogTextColor = Math.floor(Math.min(15, Math.max(0, color)));\n    }\n\n    // this function is deprecated\n    //% deprecated blockHidden\n    export function setDialogFont(font: image.Font) {\n    }\n\n    /**\n     * Show a title and an optional subtitle menu\n     * @param title\n     * @param subtitle\n     */\n    //% weight=90 help=game/splash\n    //% blockId=gameSplash block=\"splash %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function splash(title: string, subtitle?: string) {\n        const temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n\n        const dialog = new SplashDialog(screen.width, subtitle ? 42 : 35);\n        dialog.setText(title);\n        if (subtitle) dialog.setSubtext(subtitle);\n\n        const s = sprites.create(dialog.image, -1);\n        let pressed = true;\n        let done = false;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                scene.setBackgroundImage(null); // GC it\n                game.popScene();\n                done = true;\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n}\n\n",
            "texteffects.ts": "namespace texteffects {\n    export enum TextEffectKind {\n        //% block=none\n        None,\n        //% block=shake\n        Shake,\n        //% block=wave\n        Wave\n    }\n\n    export function getTextEffect(e: TextEffectKind) {\n        switch (e) {\n            case texteffects.TextEffectKind.Wave:\n                return texteffects.wave;\n            case texteffects.TextEffectKind.Shake:\n                return texteffects.shake;\n            default:\n                return null;\n        }\n    }\n \n    //% fixedInstances\n    export class TextEffect {\n        public getState: (index?: number, state?: TextEffectState) => TextEffectState;\n    \n        constructor(getState: (index?: number, state?: TextEffectState) => TextEffectState) {\n            this.getState = getState;\n        }\n    }\n\n    //% fixedInstance\n    export const shake = new TextEffect(() => { \n        return { xOffset: (Math.random() * 2 - 1),\n                 yOffset: (Math.random() * 2 - 1) }\n    });\n\n\n    interface WaveEffectState extends TextEffectState {\n        up: boolean;\n    }\n\n    //% fixedInstance\n    export const wave = new TextEffect((index?: number, state?: WaveEffectState) => {  // TODO cast state type\n        if (!state) {\n            state = {\n                xOffset: 0,\n                yOffset: Math.sin(index) * 2,\n                up: Math.sign(Math.sin(index)) < 0\n            };\n        }\n\n        state.yOffset += (state.up ? 1 : -1) * 0.5;\n        state.up = Math.abs(state.yOffset) > 2 ? !state.up : state.up;\n\n        return state\n    });\n\n    /**\n     * A text sprite on the screen\n     **/\n    export class TextSprite {\n        _str: string\n        _font: image.Font\n        _color: number;\n        _effect: TextEffect\n        _state: TextEffectState[]; // per-character state initialized and used by the effect\n\n        get color(): number {\n            return this._color;\n        }\n\n        get state(): TextEffectState[] {\n            return this._state;\n        }\n\n        constructor(str: string, font: image.Font, color: number, effect?: TextEffect) {\n            this._str = str;\n            this._font = font;\n            this._color = color;\n            this._effect = effect;\n            this._state = [];\n        }\n\n        updateState() {\n            if (!this._effect) return;\n    \n            let i = 0;\n            while (i < this._str.length) {\n                this._state[i] = this._effect.getState(i, (i < this._state.length ? this._state[i] : null));\n                i++;\n            }\n        }\n\n        draw(image: Image, x: number, y: number, start?: number, length?: number): void {\n            this.updateState();\n\n            let s = this._str.substr(Math.max(start, 0), Math.min(length, this._str.length - start));\n            image.print(s, x, y, this._color, this._font, this._state);\n        }\n    }\n}",
            "tilemap.ts": "enum TileScale {\n    //% block=\"8x8\"\n    Eight = 3,\n    //% block=\"16x16\"\n    Sixteen = 4,\n    //% block=\"32x32\"\n    ThirtyTwo = 5\n}\nnamespace tiles {\n\n    class TileSet {\n        obstacle: boolean;\n        private map: TileMap;\n        private originalImage: Image;\n        private cachedImage: Image;\n\n        constructor(image: Image, collisions: boolean, map: TileMap) {\n            this.originalImage = image;\n            this.obstacle = collisions;\n            this.map = map;\n        }\n\n        get image(): Image {\n            const size = 1 << this.map.scale;\n            if (!this.cachedImage || this.cachedImage.width != size || this.cachedImage.height != size) {\n                if (this.originalImage.width == size && this.originalImage.height == size) {\n                    this.cachedImage = this.originalImage;\n                } else {\n                    this.cachedImage = image.create(size, size);\n                    this.cachedImage.drawImage(this.originalImage, 0, 0);\n                }\n            }\n            return this.cachedImage;\n        }\n    }\n\n    /**\n     * A tile in the tilemap\n     **/\n    //% blockNamespace=scene color=\"#401255\" blockGap=8\n    export class Tile {\n        private _row: number;\n        private _col: number;\n        private tileMap: TileMap;\n\n        constructor(col: number, row: number, map: TileMap) {\n            this._col = col;\n            this._row = row;\n            this.tileMap = map;\n        }\n\n        get x(): number {\n            const scale = this.tileMap.scale;\n            return (this._col << scale) + (1 << (scale - 1));\n        }\n\n        get y(): number {\n            const scale = this.tileMap.scale;\n            return (this._row << scale) + (1 << (scale - 1));\n        }\n\n        get tileSet(): number {\n            return this.tileMap.image.getPixel(this._col, this._row) | 0;\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tiles\"\n        //% weight=25\n        //% help=scene/place\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n\n            mySprite.x = this.x;\n            mySprite.y = this.y;\n        }\n    }\n\n    export class TileMap {\n        scale: number\n\n        private _layer: number;\n        private _map: Image;\n        private _tileSets: TileSet[];\n\n        constructor(scale: TileScale = TileScale.Sixteen) {\n            this._tileSets = [];\n            this._layer = 1;\n            this.scale = scale;\n\n            scene.createRenderable(\n                scene.TILE_MAP_Z,\n                (t, c) => this.draw(t, c)\n            );\n        }\n\n        get image(): Image {\n            return this._map;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << this.scale) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << this.scale) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setTile(index: number, img: Image, collisions?: boolean) {\n            if (this.isInvalidIndex(index)) return;\n            this._tileSets[index] = new TileSet(img, collisions, this);\n        }\n\n        setMap(map: Image) {\n            this._map = map;\n        }\n\n        public getTile(col: number, row: number): Tile {\n            return new Tile(col, row, this);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setPixel(col, row, index);\n        }\n\n        public getTilesByType(index: number): Tile[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return [];\n\n            let output: Tile[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getPixel(col, row);\n                    if (currTile === index) {\n                        output.push(new Tile(col, row, this));\n                    }\n                }\n            }\n            return output;\n        }\n\n        private generateTile(index: number): TileSet {\n            const size = 1 << this.scale\n\n            const i = image.create(size, size);\n            i.fill(index);\n            return this._tileSets[index] = new TileSet(i, false, this);\n        }\n\n        private isOutsideMap(col: number, row: number): boolean {\n            return !this.enabled || col < 0 || col >= this._map.width\n                || row < 0 || row >= this._map.height;\n        }\n\n        private isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xf;\n        }\n\n        protected draw(target: Image, camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            // render tile map\n            const bitmask = (0x1 << this.scale) - 1;\n            const offsetX = camera.drawOffsetX & bitmask;\n            const offsetY = camera.drawOffsetY & bitmask;\n\n            const x0 = Math.max(0, camera.drawOffsetX >> this.scale);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + target.width) >> this.scale) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> this.scale);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + target.height) >> this.scale) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getPixel(x, y);\n                    const tile = this._tileSets[index] || this.generateTile(index);\n                    if (tile) {\n                        target.drawTransparentImage(\n                            tile.image,\n                            ((x - x0) << this.scale) - offsetX,\n                            ((y - y0) << this.scale) - offsetY\n                        );\n                    }\n                }\n            }\n\n            if (game.debug) {\n                // render debug grid overlay\n                for (let x = x0; x <= xn; ++x) {\n                    const xLine = ((x - x0) << this.scale) - offsetX;\n                    if (xLine >= 0 && xLine <= screen.width) {\n                        target.drawLine(\n                            xLine,\n                            0,\n                            xLine,\n                            target.height,\n                            1\n                        );\n                    }\n                }\n\n                for (let y = y0; y <= yn; ++y) {\n                    const yLine = ((y - y0) << this.scale) - offsetY;\n                    if (yLine >= 0 && yLine <= screen.height) {\n                        target.drawLine(\n                            0,\n                            yLine,\n                            target.width,\n                            yLine,\n                            1\n                        );\n                    }\n                }\n            }\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this.isOutsideMap(col, row)) return true;\n\n            let t = this._tileSets[this._map.getPixel(col, row)];\n            return t && t.obstacle;\n        }\n\n        public getObstacle(col: number, row: number) {\n            const index = this.isOutsideMap(col, row) ? 0 : this._map.getPixel(col, row);\n            const tile = this._tileSets[index] || this.generateTile(index);\n            return new sprites.StaticObstacle(\n                tile.image,\n                row << this.scale,\n                col << this.scale,\n                this.layer,\n                index\n            );\n        }\n    }\n}\n"
        },
        "buttons": {
            "README.md": "# buttons\n\nA library to handle 2 buttons A and B.\n",
            "buttons.cpp": "#include \"pxt.h\"\n\n/*\n\nThese button events need CODAL work.\n\n    // % block=\"double click\"\n    DoubleClick = DEVICE_BUTTON_EVT_DOUBLE_CLICK,\n\n    // % block=\"hold\"\n    Hold = DEVICE_BUTTON_EVT_HOLD\n\n*/\n\n/**\n * User interaction on buttons\n */\nenum class ButtonEvent {\n    //% block=\"click\"\n    Click = DEVICE_BUTTON_EVT_CLICK,\n    //% block=\"long click\"\n    LongClick = DEVICE_BUTTON_EVT_LONG_CLICK,\n    //% block=\"up\"\n    Up = DEVICE_BUTTON_EVT_UP,\n    //% block=\"down\"\n    Down = DEVICE_BUTTON_EVT_DOWN\n};\n\n#ifdef PXT_74HC165\nstatic void waitABit() {\n    for (int i = 0; i < 10; ++i)\n        asm volatile(\"nop\");\n}\nclass MultiplexedButton;\nclass ButtonMultiplexer : public CodalComponent {\n  public:\n    Pin &latch;\n    Pin &clock;\n    Pin &data;\n    uint32_t state;\n    MultiplexedButton *createButton(uint16_t id, uint8_t shift);\n    ButtonMultiplexer(uint16_t id)\n        : latch(*LOOKUP_PIN(BTNMX_LATCH)), clock(*LOOKUP_PIN(BTNMX_CLOCK)),\n          data(*LOOKUP_PIN(BTNMX_DATA)) {\n        this->state = 0;\n        this->id = id;\n        this->status |= DEVICE_COMPONENT_STATUS_SYSTEM_TICK;\n    }\n\n    virtual void periodicCallback() {\n        latch.setDigitalValue(0);\n        waitABit();\n        latch.setDigitalValue(1);\n        waitABit();\n\n        state = 0;\n\n        for (int i = 0; i < 8; i++) {\n            state <<= 1;\n            if (data.getDigitalValue())\n                state |= 1;\n            clock.setDigitalValue(1);\n            waitABit();\n            clock.setDigitalValue(0);\n            waitABit();\n        }\n    }\n};\nclass MultiplexedButton : public Button {\n  public:\n    ButtonMultiplexer *parent;\n    uint8_t shift;\n    MultiplexedButton(uint16_t id, uint8_t shift, ButtonMultiplexer *parent)\n        : Button(parent->data, id), parent(parent), shift(shift) {}\n\n  protected:\n    virtual int buttonActive() { return (parent->state & (1 << shift)) != 0; }\n};\n\nMultiplexedButton *ButtonMultiplexer::createButton(uint16_t id, uint8_t shift) {\n    return new MultiplexedButton(id, shift, this);\n}\n\nstatic ButtonMultiplexer *buttonMultiplexer;\n#endif\n\nclass AnalogButton : public Button {\n  public:\n    int16_t threshold;\n    bool state;\n\n    AnalogButton(Pin &pin, uint16_t id, int threshold)\n        : Button(pin, id), threshold(threshold), state(false) {}\n\n  protected:\n    virtual int buttonActive() {\n        int v = _pin.getAnalogValue() - 512;\n        int thr = threshold;\n\n        if (thr < 0) {\n            v = -v;\n            thr = -thr;\n        }\n\n        if (v > thr)\n            state = true;\n        else if (state && v > thr * 3 / 4)\n            state = true;\n        else\n            state = false;\n\n        return state;\n    }\n};\n\nnamespace pxt {\n//%\nButton *getButtonByPin(int pin, int flags) {\n    pin &= 0xffff;\n\n    unsigned highflags = (unsigned)pin >> 16;\n    if (highflags & 0xff)\n        flags = highflags & 0xff;\n\n    auto cpid = DEVICE_ID_FIRST_BUTTON + pin;\n    auto btn = (Button *)lookupComponent(cpid);\n    if (btn == NULL) {\n#ifdef PXT_74HC165\n        if (1000 <= pin && pin < 1100) {\n            if (!buttonMultiplexer)\n                buttonMultiplexer = new ButtonMultiplexer(DEVICE_ID_FIRST_BUTTON);\n            return buttonMultiplexer->createButton(cpid, pin - 1000);\n        }\n#endif\n        if (1100 <= pin && pin < 1300) {\n            pin -= 1100;\n            int thr = getConfig(CFG_ANALOG_BUTTON_THRESHOLD, 300);\n            if (pin >= 100) {\n                thr = -thr;\n                pin -= 100;\n            }\n            return new AnalogButton(*lookupPin(pin), cpid, thr);\n        }\n\n        auto pull = PullMode::None;\n        if ((flags & 0xf0) == 0x10)\n            pull = PullMode::Down;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::Up;\n        else if ((flags & 0xf0) == 0x30)\n            pull = PullMode::None;\n        else\n            oops(3);\n        // GCTODO\n        btn = new Button(*lookupPin(pin), cpid, DEVICE_BUTTON_ALL_EVENTS,\n                         (ButtonPolarity)(flags & 0xf), pull);\n    }\n    return btn;\n}\n\n//%\nButton *getButtonByPinCfg(int key, int flags) {\n    int pin = getConfig(key);\n    if (pin == -1)\n        target_panic(PANIC_NO_SUCH_CONFIG);\n    return getButtonByPin(pin, flags);\n}\n\n// This is for A, B, and AB\n//%\nAbstractButton *getButton(int id) {\n    int pa = getConfig(CFG_PIN_BTN_A);\n    int pb = getConfig(CFG_PIN_BTN_B);\n    int flags = getConfig(CFG_DEFAULT_BUTTON_MODE, BUTTON_ACTIVE_LOW_PULL_UP);\n    if (id == 0)\n        return getButtonByPin(pa, flags);\n    else if (id == 1)\n        return getButtonByPin(pb, flags);\n    else if (id == 2)\n        return getMultiButton(DEVICE_ID_BUTTON_AB, pa, pb, flags);\n    else {\n        target_panic(PANIC_INVALID_ARGUMENT);\n        return NULL;\n    }\n}\n\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags) {\n    auto btn = (MultiButton *)lookupComponent(id);\n    if (btn == NULL) {\n        auto bA = getButtonByPin(pinA, flags);\n        auto bB = getButtonByPin(pinB, flags);\n        // GCTODO\n        btn = new codal::MultiButton(bA->id, bB->id, id);\n\n        // A user has registered to receive events from the buttonAB multibutton.\n        // Disable click events from being generated by ButtonA and ButtonB, and defer the\n        // control of this to the multibutton handler.\n        //\n        // This way, buttons look independent unless a buttonAB is requested, at which\n        // point button A+B clicks can be correclty handled without breaking\n        // causal ordering.\n        bA->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        bB->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        btn->setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);\n    }\n    return btn;\n}\n} // namespace pxt\n\nnamespace DigitalInOutPinMethods {\n\n/**\n * Get the push button (connected to GND) for given pin\n */\n//%\nButton_ pushButton(DigitalInOutPin pin) {\n    return pxt::getButtonByPin(pin->name, BUTTON_ACTIVE_LOW_PULL_UP);\n}\n\n} // namespace DigitalInOutPinMethods\n\n//% noRefCounting fixedInstances\nnamespace ButtonMethods {\n/**\n * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n * @param button the button that needs to be clicked or used\n * @param event the kind of button gesture that needs to be detected\n * @param body code to run when the event is raised\n */\n//% help=input/button/on-event\n//% blockId=buttonEvent block=\"on %button|%event\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=96 blockGap=12\n//% trackArgs=0\nvoid onEvent(Button_ button, ButtonEvent ev, Action body) {\n    registerWithDal(button->id, (int)ev, body);\n}\n\n/**\n * Check if a button is pressed or not.\n * @param button the button to query the request\n */\n//% help=input/button/is-pressed\n//% block=\"%button|is pressed\"\n//% blockId=buttonIsPressed\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=50 blockGap=8\n//% trackArgs=0\nbool isPressed(Button_ button) {\n    return button->isPressed();\n}\n\n/**\n * See if the button was pressed again since the last time you checked.\n * @param button the button to query the request\n */\n//% help=input/button/was-pressed\n//% block=\"%button|was pressed\"\n//% blockId=buttonWasPressed\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% group=\"More\" weight=46 blockGap=8\n//% trackArgs=0\nbool wasPressed(Button_ button) {\n    return button->wasPressed();\n}\n\n/**\n * Gets the component identifier for the buton\n */\n//%\nint id(Button_ button) {\n    return button->id;\n}\n\n} // namespace ButtonMethods\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    /**\n     * User interaction on buttons\n     */\n\n    declare const enum ButtonEvent {\n    //% block=\"click\"\n    Click = 3,  // DEVICE_BUTTON_EVT_CLICK\n    //% block=\"long click\"\n    LongClick = 4,  // DEVICE_BUTTON_EVT_LONG_CLICK\n    //% block=\"up\"\n    Up = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"down\"\n    Down = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "jacdac.ts": "namespace jacdac {\n    export class ButtonService extends SensorHost {\n        private button: Button;\n        constructor(name: string, button: Button) {\n            super(name, jacdac.BUTTON_DEVICE_CLASS);\n            this.button = button;\n            jacdac.BUTTON_EVENTS.forEach((ev, j) => {\n                control.onEvent(this.button.id(), ev, () => {\n                    this.raiseHostEvent(ev);\n                })\n            })\n        }\n\n        serializeState() {\n            const buf = control.createBuffer(1);\n            buf.setNumber(NumberFormat.UInt8LE, 0, this.button.isPressed() ? 0xff : 0);\n            return buf;\n        }\n    }\n\n    /**\n     * Connects the events of the button to the controller button\n     * @param controllerButton \n     * @param button \n     */\n    //% blockId=jdattachctrlbtn block=\"jacdac attach $button to controller $controllerButton\"\n    //% group=\"Controller\"\n    export function attachButtonToController(button: Button, controllerButton: JDControllerButton) {\n        button.onEvent(ButtonEvent.Up, () => jacdac.controllerClient.setIsPressed(controllerButton, false));\n        button.onEvent(ButtonEvent.Down, () => jacdac.controllerClient.setIsPressed(controllerButton, true));\n        jacdac.controllerClient.start();\n    }\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"buttons\",\n  \"description\": \"Button A and B drivers\",\n  \"files\": [\n    \"README.md\",\n    \"buttons.cpp\",\n    \"jacdac.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Get the push button (connected to GND) for given pin\n     */\n    //% shim=DigitalInOutPinMethods::pushButton\n    pushButton(): Button;\n}\n\n\n\n    //% noRefCounting fixedInstances\ndeclare interface Button {\n    /**\n     * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n     * @param button the button that needs to be clicked or used\n     * @param event the kind of button gesture that needs to be detected\n     * @param body code to run when the event is raised\n     */\n    //% help=input/button/on-event\n    //% blockId=buttonEvent block=\"on %button|%event\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=96 blockGap=12\n    //% trackArgs=0 shim=ButtonMethods::onEvent\n    onEvent(ev: ButtonEvent, body: () => void): void;\n\n    /**\n     * Check if a button is pressed or not.\n     * @param button the button to query the request\n     */\n    //% help=input/button/is-pressed\n    //% block=\"%button|is pressed\"\n    //% blockId=buttonIsPressed\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=50 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::isPressed\n    isPressed(): boolean;\n\n    /**\n     * See if the button was pressed again since the last time you checked.\n     * @param button the button to query the request\n     */\n    //% help=input/button/was-pressed\n    //% block=\"%button|was pressed\"\n    //% blockId=buttonWasPressed\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% group=\"More\" weight=46 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::wasPressed\n    wasPressed(): boolean;\n\n    /**\n     * Gets the component identifier for the buton\n     */\n    //% shim=ButtonMethods::id\n    id(): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": ""
        },
        "mixer": {
            "SoundOutput.h": "#include \"dmac.h\"\n#include \"SAMD21DAC.h\"\n#include \"Mixer.h\"\n\n// DAC always on PA02 on SAMD21\n#define DAC_PIN PA02\n\nclass SoundOutput {\n  public:\n    SAMD21DAC dac;\n\n    SoundOutput(DataSource &data) : dac(*lookupPin(DAC_PIN), pxt::getWDMAC()->dmac, data) {}\n\n    void setOutput(int output) { (void)output; }\n};\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;  // Hz\n    uint16_t duration;   // ms\n    int16_t startVolume; // 0-1023\n    int16_t endVolume;   // 0-1023\n    uint16_t endFrequency;  // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n        while (sz--) {\n            *dp++ += 1 << (OUTPUT_BITS - 1);\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "servo": {
            "README.md": "# Servo\n\nA small micro-servo library.",
            "jacdac.ts": "namespace jacdac {\n    export class ServoService extends ActuatorService {\n        servo: servos.Servo;\n        constructor(name: string, servo: servos.Servo) {\n            super(name, jacdac.SERVO_DEVICE_CLASS, 8, 2);\n            this.servo = servo;\n        }\n\n        addAdvertisementData() {\n            this.controlData.setNumber(NumberFormat.Int16LE, 0, this.servo.angle);\n            return super.addAdvertisementData();\n        }\n\n        protected handleStateChanged(): number {\n            const on = !!this.state[0];\n            if (!on)\n                this.servo.stop();\n            else {\n                const angle = this.state.getNumber(NumberFormat.Int16LE, 1);\n                const pulse = this.state.getNumber(NumberFormat.Int16LE, 3);\n                if (pulse)\n                    this.servo.setPulse(pulse);\n                this.servo.setAngle(angle);\n            }\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n    export class ServosService extends ActuatorService {\n        private servos: servos.Servo[];\n\n        constructor(name: string, servos: servos.Servo[]) {\n            super(name, jacdac.SERVOS_DEVICE_CLASS, servos.length * 4, servos.length * 2);\n            this.servos = servos;\n        }\n\n        addAdvertisementData() {\n            for (let i = 0; i < this.servos.length; ++i) {\n                this.controlData.setNumber(NumberFormat.Int16LE, i * 2, this.servos[i].angle);\n            }\n            return super.addAdvertisementData();\n        }\n\n        protected handleStateChanged(): number {\n            for (let i = 0; i < this.servos.length && (i + 1) * 4 <= this.state.length; ++i) {\n                const servo = this.servos[i];\n                const on = !!this.state.getNumber(NumberFormat.UInt8LE, i * 4);\n                const angle = this.state.getNumber(NumberFormat.Int16LE, i * 4 + 1);\n                if (!on)\n                    servo.stop();\n                else\n                    servo.setAngle(angle);\n            }\n            return jacdac.DEVICE_OK;\n        }\n    }\n}",
            "ns.ts": "/**\n * Control micro servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n}",
            "pxt.json": "{\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"edge-connector\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"name\": \"servo\",\n  \"description\": \"A micro-servo library\",\n  \"files\": [\n    \"README.md\",\n    \"servo.ts\",\n    \"jacdac.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\"\n  ],\n  \"public\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/3e3646f6a7aa8b4f4a4c79aefa1421ec9c830d5e/static/libs/servo.png\"\n}",
            "servo.ts": "/**\n * Control micro servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\" blockGap=8\n//% groups='[\"Positional\", \"Continuous\", \"Configuration\"]'\nnamespace servos {\n    //% fixedInstances\n    export class Servo {\n        private _minAngle: number;\n        private _maxAngle: number;\n        private _stopOnNeutral: boolean;\n        private _angle: number;\n\n        constructor() {\n            this._angle = undefined;\n            this._minAngle = 0;\n            this._maxAngle = 180;\n            this._stopOnNeutral = false;\n        }\n\n        private clampDegrees(degrees: number): number {\n            degrees = degrees | 0;\n            degrees = Math.clamp(this._minAngle, this._maxAngle, degrees);\n            return degrees;\n        }\n\n        /**\n         * Set the servo angle\n         */\n        //% weight=100 help=servos/set-angle\n        //% blockId=servoservosetangle block=\"set %servo angle to %degrees=protractorPicker °\"\n        //% degrees.defl=90\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% blockGap=8\n        //% parts=microservo trackArgs=0\n        //% group=\"Positional\"\n        setAngle(degrees: number) {\n            degrees = this.clampDegrees(degrees);\n            this._angle = this.internalSetAngle(degrees);\n        }\n\n        get angle() {\n            return this._angle || 90;\n        }\n\n        protected internalSetAngle(angle: number): number {\n            return 0;\n        }\n\n        /**\n         * Set the throttle on a continuous servo\n         * @param speed the throttle of the motor from -100% to 100%\n         */\n        //% weight=99 help=servos/run\n        //% blockId=servoservorun block=\"continuous %servo run at %speed=speedPicker \\\\%\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Continuous\"\n        //% blockGap=8\n        run(speed: number): void {\n            const degrees = this.clampDegrees(Math.map(speed, -100, 100, this._minAngle, this._maxAngle));\n            const neutral = (this.maxAngle - this.minAngle) >> 1;\n            if (this._stopOnNeutral && degrees == neutral)\n                this.stop();\n            else\n                this.setAngle(degrees);\n        }\n\n        /**\n         * Set the pulse width to the servo in microseconds\n         * @param micros the width of the pulse in microseconds\n         */\n\n        //% weight=10 help=servos/set-pulse\n        //% blockId=servoservosetpulse block=\"set %servo pulse to %micros μs\"\n        //% micros.min=500 micros.max=2500\n        //% micros.defl=1500\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Configuration\"\n        //% blockGap=8\n        setPulse(micros: number) {\n            micros = micros | 0;\n            micros = Math.clamp(500, 2500, micros);\n            this.internalSetPulse(micros);\n        }\n\n        protected internalSetPulse(micros: number): void {\n\n        }\n\n        /**\n         * Stop sending commands to the servo so that its rotation will stop at the current position.\n         */\n        // On a normal servo this will stop the servo where it is, rather than return it to neutral position.\n        // It will also not provide any holding force.\n        //% weight=10 help=servos/stop\n        //% blockId=servoservostop block=\"stop %servo\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Continuous\"\n        //% blockGap=8\n        stop() {\n            if (this._angle !== undefined)\n                this.internalStop();\n        }\n\n        /**\n         * Gets the minimum angle for the servo\n         */\n        public get minAngle() {\n            return this._minAngle;\n        }\n\n        /**\n         * Gets the maximum angle for the servo\n         */\n        public get maxAngle() {\n            return this._maxAngle;\n        }\n\n        /**\n         * Set the possible rotation range angles for the servo between 0 and 180\n         * @param minAngle the minimum angle from 0 to 90\n         * @param maxAngle the maximum angle from 90 to 180\n         */\n        //% help=servos/set-range\n        //% blockId=servosetrange block=\"set %servo range from %minAngle to %maxAngle\"\n        //% minAngle.min=0 minAngle.max=90\n        //% maxAngle.min=90 maxAngle.max=180 maxAngle.defl=180\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Configuration\"\n        //% blockGap=8\n        public setRange(minAngle: number, maxAngle: number) {\n            this._minAngle = Math.max(0, Math.min(90, minAngle | 0));\n            this._maxAngle = Math.max(90, Math.min(180, maxAngle | 0));\n        }\n\n        /**\n         * Set a servo stop mode so it will stop when the rotation angle is in the neutral position, 90 degrees.\n         * @param on true to enable this mode\n         */\n        //% help=servos/set-stop-on-neutral\n        //% blockId=servostoponneutral block=\"set %servo stop on neutral %enabled\"\n        //% enabled.shadow=toggleOnOff\n        //% group=\"Configuration\"\n        //% blockGap=8\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        public setStopOnNeutral(enabled: boolean) {\n            this._stopOnNeutral = enabled;\n        }\n\n        protected internalStop() { }\n    }\n\n    export class PinServo extends Servo {\n        private _pin: PwmOnlyPin;\n\n        constructor(pin: PwmOnlyPin) {\n            super();\n            this._pin = pin;\n        }\n\n        protected internalSetAngle(angle: number): number {\n            this._pin.servoWrite(angle);\n            return angle;\n        }\n\n        protected internalSetPulse(micros: number): void {\n            this._pin.servoSetPulse(micros);\n        }\n\n        protected internalStop() {\n            this._pin.digitalRead();\n            this._pin.setPull(PinPullMode.PullNone);\n        }\n    }\n}\n",
            "targetoverrides.ts": "namespace servos {\n    //% block=\"servo P0\" fixedInstance whenUsed\n    export const P0 = new servos.PinServo(pins.P0);\n    //% block=\"servo P1\" fixedInstance whenUsed\n    export const P1 = new servos.PinServo(pins.P1);\n    //% block=\"servo P2\" fixedInstance whenUsed\n    export const P2 = new servos.PinServo(pins.P2);\n}"
        },
        "light": {
            "README.md": "# neopixel\n\nThe neopixel library.\n\n",
            "animations.jres": "{\n  \"*\": {\n    \"namespace\": \"light\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"rainbowAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  },\n  \"colorWipeAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  },\n  \"runningLightsAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  },\n  \"sparkleAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  },\n  \"theaterChaseAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  },\n  \"cometAnimation\": {\n    \"icon\": \"data:image/png;base64,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\"\n  }\n}",
            "create.ts": "\nnamespace light {\n    /**\n     * Create a new programmable light strip.\n     * @param pin the pin where the strip is connected.\n     * @param numleds number of leds in the strip, eg: 30\n     * @param mode the light encoding mode for different LED strips, eg: NeoPixelMode.RGB_GRB\n     */\n    //% blockId=\"neopixel_create_strip\" block=\"create WS2812 strip on %pin with %numleds pixels\"\n    //% help=\"light/create-strip\"\n    //% weight=100\n    //% blockSetVariable=strip\n    //% trackArgs=0,2\n    //% parts=\"neopixel\"\n    //% advanced=true\n    export function createStrip(\n        pin: DigitalInOutPin = null,\n        numleds: number = 30,\n        mode: NeoPixelMode = NeoPixelMode.RGB\n    ): NeoPixelStrip {\n        return light.createNeoPixelStrip(pin, numleds, mode);\n    }\n\n    /**\n     * Creates a strip of colored LEDs (APA102)\n     */\n    //% blockId=\"light_create_dotstar\" block=\"create APA102 strip|data %data|clock %clk|with %numleds pixels\"\n    //% help=\"light/create-apa102-strip\"\n    //% trackArgs=0,1,2\n    //% parts=\"dotstar\"\n    //% weight=100 blockSetVariable=strip\n    //% advanced=true\n    export function createAPA102Strip(\n        dataPin: DigitalInOutPin,\n        clkPin: DigitalInOutPin,\n        numleds: number): NeoPixelStrip {\n        const strip = new NeoPixelStrip();\n        strip._mode = NeoPixelMode.APA102;\n        strip._length = Math.max(0, numleds | 0);\n        strip._dataPin = dataPin;\n        strip._clkPin = clkPin;\n        return strip;\n    }\n}",
            "defaultlights.ts": "namespace light {\n    /**\n     * Gets the default external light strip\n     */\n    //% whenUsed\n    export const pixels = light.defaultStrip();\n\n    /**\n     * Set all of the pixels on the strip to one RGB color.\n     * @param rgb RGB color of the LED\n     */\n    //% blockId=\"builtin_neopixel_set_strip_color\" block=\"set all pixels to %rgb=colorNumberPicker\"\n    //% help=\"light/set-all\"\n    //% weight=79 blockGap=8\n    export function setAll(rgb: number) {\n        light.pixels.setAll(rgb);\n    }\n\n    /**\n     * Sets a gradient between two colors\n     * @param startColor the start color\n     * @param endColor the end color\n     */\n    //% blockId=\"builtinlightsetgradient\" block=\"set gradient from %startRgb=colorNumberPicker to %endRgb=colorNumberPicker\"\n    //% weight=78 blockGap=8 blockHidden=true\n    export function setGradient(startRgb: number, endRgb: number) {\n        light.pixels.setGradient(startRgb, endRgb);\n    }\n\n    /**\n     * Turn off all pixel LEDs on the onboard strip.\n     */\n    //% blockId=\"builtin_neopixel_clear\" block=\"clear\"\n    //% parts=\"neopixel\"\n    //% help=\"light/clear\"\n    //% group=\"More\" weight=9 blockGap=8\n    export function clear() {\n        light.pixels.clear();\n    }\n\n    /**\n     * Display a vertical bar graph based on the `value` and `high` value.\n     * If `high` is 0, the chart gets adjusted automatically.\n     * @param value current value to plot\n     * @param high maximum value, 0 to autoscale\n     */\n    //% blockId=builtin_neopixel_show_bar_graph block=\"graph %value||up to %high\" icon=\"\\uf080\"\n    //% help=light/graph blockGap=8\n    //% weight=10\n    export function graph(value: number, high?: number): void {\n        light.pixels.graph(value, high);\n    }\n\n\n    /**\n     * Set the pixel to a given color.\n     * @param pixeloffset position of the NeoPixel in the strip\n     * @param color RGB color of the LED\n     */\n    //% blockId=\"builtin_neopixel_set_pixel_color\" block=\"set pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n    //% help=\"light/set-pixel-color\"\n    //% group=\"More\" weight=89 blockGap=8\n    export function setPixelColor(pixeloffset: number, color: number): void {\n        light.pixels.setPixelColor(pixeloffset, color);\n    }\n\n    /**\n     * Gets the pixel color at a given offset.\n     * @param pixeloffset position of the NeoPixel in the strip\n     */\n    //% blockId=\"builtin_neopixel_pixel_color\" block=\"pixel color at %pixeloffset\"\n    //% help=\"light/pixel-color\"\n    //% group=\"More\" weight=88\n    export function pixelColor(pixeloffset: number): number {\n        return light.pixels.pixelColor(pixeloffset);\n    }\n\n    /**\n     * Set the brightness of the strip. This flag only applies to future operation.\n     * @param brightness a measure of LED brightness in 0-255. eg: 20\n     */\n    //% blockId=\"builtin_neopixel_set_brightness\" block=\"set brightness %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/set-brightness\"\n    //% weight=2 blockGap=8\n    export function setBrightness(brightness: number): void {\n        light.pixels.setBrightness(brightness);\n    }\n\n    /**\n     * Move a photon effect along the pixel strip by a number of steps.\n     * @param steps number of steps (lights) to move, eg: 1\n     */\n    //% blockId=builtin_neophoton_fd block=\"photon forward by %steps\"\n    //% help=\"light/photon-forward\"\n    //% group=\"Photon\" weight=41 blockGap=8\n    export function photonForward(steps: number) {\n        light.pixels.photonForward(steps);\n    }\n    /**\n         * Switch the direction of the photon pulse.\n         */\n    //% blockId=builtin_neophoton_flip block=\"photon flip\"\n    //% help=\"light/photon-flip\"\n    //% parts=\"neopixel\"\n    //% group=\"Photon\" weight=40 blockGap=8\n    export function photonFlip() {\n        light.pixels.photonFlip();\n    }\n\n\n    /**\n     * Sets the photon position to a given light index\n     * @param index index of the light, if out of bound, the index is wrapped\n     */\n    //% blockId=builtin_light_photon_set_position block=\"photon set position %index\"\n    //% help=\"light/set-photon-position\"\n    //% parts=\"neopixel\"\n    //% group=\"Photon\" weight=39 blockGap=8\n    export function setPhotonPosition(index: number) {\n        light.pixels.setPhotonPosition(index);\n    }\n\n    /**\n     * Set the photon color hue.\n     * @param hue the color hue of the photon\n     */\n    //% blockId=builtin_neophoton_set_pen_hue block=\"photon set pen hue %hue=colorWheelHsvPicker\"\n    //% help=\"light/set-photon-pen-hue\"\n    //% group=\"Photon\" weight=39 blockGap=8\n    export function setPhotonPenHue(hue: number) {\n        light.pixels.setPhotonPenHue(hue);\n    }\n\n    /**\n     * Set the photon mode to pen up, pen down, or eraser.\n     * @param mode the desired mode\n     */\n    //% blockId=builtin_neophoton_set_photon block=\"photon %mode\"\n    //% help=\"light/set-photon-mode\"\n    //% group=\"Photon\" weight=38\n    export function setPhotonMode(mode: PhotonMode) {\n        light.pixels.setPhotonMode(mode);\n    }\n\n    /**\n     * Show an animation or queue an animation in the animation queue\n     * @param animation the animation to run, eg: light.rainbowAnimation\n     * @param duration the duration to run in milliseconds, eg: 500\n     */\n    //% blockId=builtin_neopixel_show_animation block=\"show animation %animation=light_animation_picker|for %duration=timePicker|ms\"\n    //% help=\"light/show-animation\" blockGap=8\n    //% weight=81\n    export function showAnimation(animation: NeoPixelAnimation, duration: number) {\n        light.pixels.showAnimation(animation, duration);\n    }\n\n    /**\n      * Show a single animation frame\n      * @param animation the animation to run, eg: light.rainbowAnimation\n      */\n    //% blockId=builtin_neopixel_show_animation_frame block=\"show frame of %animation=light_animation_picker|animation\"\n    //% help=\"light/show-animation-frame\"\n    //% group=\"More\" weight=24 blockGap=8\n    export function showAnimationFrame(animation: NeoPixelAnimation) {\n        light.pixels.showAnimationFrame(animation);\n    }\n\n    /**\n     * Stop the current animation and any other animations ready to show.\n     */\n    //% blockId=builtin_neopixel_stop_all_animations block=\"stop all animations\"\n    //% help=\"light/stop-all-animations\"\n    //% group=\"More\" weight=23\n    export function stopAllAnimations() {\n        light.pixels.stopAllAnimations();\n    }\n\n    /**\n     * Creates a builtin animation\n     * @param kind the type of animation\n     */\n    //% kind.fieldEditor=\"imagedropdown\"\n    //% kind.fieldOptions.columns=3 blockGap=8\n    //% blockId=light_animation block=\"%kind\"\n    //% group=\"More\" weight=25\n    //% help=\"light/animation\" blockHidden=true deprecated=1\n    export function animation(kind: LightAnimation): NeoPixelAnimation {\n        switch (kind) {\n            case LightAnimation.RunningLights: return runningLightsAnimation;\n            case LightAnimation.Comet: return cometAnimation;\n            case LightAnimation.ColorWipe: return colorWipeAnimation;\n            case LightAnimation.TheaterChase: return theaterChaseAnimation;\n            case LightAnimation.Sparkle: return sparkleAnimation;\n            default: return rainbowAnimation;\n        }\n    }\n}",
            "defaultlightsoverrides.ts": "namespace light {\n    /**\n     * Create a range of pixels.\n     * @param start offset in the NeoPixel strip to start the range\n     * @param length number of pixels in the range, eg: 4\n     */\n    //% blockId=\"lightstrip_range\" block=\"range from %start|with %length|pixels\"\n    //% weight=1\n    export function range(start: number, length: number): NeoPixelStrip {\n        return pixels.range(start, length);\n    }\n\n    /**\n     * Sets the number of LEDS on the default light strip\n     */\n    //% blockId=lightds_setlength block=\"set pixels length to %numleds pixels\"\n    //% numleds.defl=30\n    //% numleds.shadow=lightLengthPicker\n    //% weight=0\n    export function setLength(numleds: number) {\n        light.pixels.setLength(numleds);\n    }\n\n    /**\n     * Sets the type of RGB light on the default strip\n     */\n    //% blockId=lightds_setmode block=\"set default strip mode to %mode\"\n    //% weight=0\n    export function setMode(mode: NeoPixelMode) {\n        light.pixels.setMode(mode);\n    }\n}",
            "defaultstrip.ts": "namespace light {\n    let _defaultStrip: NeoPixelStrip;\n    /**\n     * Gets the default light strip\n     */\n    //% help=light/default-strip\n    //% blockId=\"neopixel_default_strip\" block=\"default strip\"\n    //% weight=110 blockGap=8\n    //% advanced=true\n    //% parts=pixels\n    export function defaultStrip(): NeoPixelStrip {\n        if (_defaultStrip) return _defaultStrip;\n\n        const data = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_DATA);\n        const clk = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_CLOCK);\n        const dsnum = control.getConfigValue(DAL.CFG_NUM_DOTSTARS, 0);\n        const neo = pins.pinByCfg(DAL.CFG_PIN_NEOPIXEL);\n        const neonum = control.getConfigValue(DAL.CFG_NUM_NEOPIXELS, 0);\n        const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n        const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n\n        _defaultStrip = new NeoPixelStrip();\n        if (data && clk && dsnum > 0) {\n            _defaultStrip._mode = NeoPixelMode.APA102;\n            _defaultStrip._dataPin = data;\n            _defaultStrip._clkPin = clk;\n            _defaultStrip._length = dsnum;\n        } else if(neo && neonum > 0) {\n            _defaultStrip._mode = NeoPixelMode.RGB;\n            _defaultStrip._dataPin = neo;\n            _defaultStrip._length = neonum;\n        } else { // mount strip on SPI\n            _defaultStrip._mode = NeoPixelMode.RGB;\n            _defaultStrip._dataPin = mosi;\n            _defaultStrip._clkPin = sck;\n            _defaultStrip._length = 30;\n        }\n\n        return _defaultStrip;\n    }\n}",
            "jacdac.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LightService extends ActuatorService {\n        strip: light.NeoPixelStrip;\n        constructor(name: string, strip: light.NeoPixelStrip) {\n            super(name, jacdac.LIGHT_DEVICE_CLASS, 5);\n            this.strip = strip;\n        }\n\n        protected handleStateChanged(): number {\n            const animation = this.state.getNumber(NumberFormat.UInt8LE, 0);\n            const value = this.state.getNumber(NumberFormat.UInt32LE, 1);\n            const range = this.strip;\n            switch (animation) {\n                case JDLightCommand.SetAll: range.setAll(value); break;\n                case JDLightCommand.SetBrightness: range.setBrightness(value);\n                case JDLightCommand.Rainbow: range.showAnimation(light.rainbowAnimation, value); break;\n                case JDLightCommand.RunningLights: range.showAnimation(light.runningLightsAnimation, value); break;\n                case JDLightCommand.ColorWipe: range.showAnimation(light.colorWipeAnimation, value); break;\n                case JDLightCommand.TheaterChase: range.showAnimation(light.theaterChaseAnimation, value); break;\n                case JDLightCommand.Comet: range.showAnimation(light.cometAnimation, value); break;\n                case JDLightCommand.Sparkle: range.showAnimation(light.sparkleAnimation, value); break;\n            }\n            return jacdac.DEVICE_OK;\n        }\n    }\n}",
            "neopixel.ts": "/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nconst enum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 3,\n    //% block=\"APA102\"\n    APA102 = 4\n}\n\nconst enum LightMove {\n    //% block=\"rotate\"\n    Rotate,\n    //% block=\"shift\"\n    Shift\n}\n\n/**\n * A determines the mode of the photon\n */\nconst enum PhotonMode {\n    //% block=\"pen up\"\n    PenUp,\n    //% block=\"pen down\"\n    PenDown,\n    //% block=\"eraser\"\n    Eraser,\n    //% block=\"off\"\n    Off\n}\n\nconst enum LightAnimation {\n    //% blockImage=1\n    //% block=\"rainbow\"\n    Rainbow,\n    //% blockImage=1\n    //% block=\"running lights\"\n    RunningLights,\n    //% blockImage=1\n    //% block=\"comet\"\n    Comet,\n    //% blockImage=1\n    //% block=\"sparkle\"\n    Sparkle,\n    //% blockImage=1\n    //% block=\"theater chase\"\n    TheaterChase,\n    //% blockImage=1\n    //% block=\"color wipe\"\n    ColorWipe\n}\n\n/**\n * Functions to operate colored LEDs.\n */\n//% weight=100 color=\"#0078d7\" icon=\"\\uf00a\"\n//% groups='[\"other\", \"Color\", \"Photon\", \"More\"]'\n//% blockGap=8\nnamespace light {\n    export type LightStrip = NeoPixelStrip;\n    /**\n     * A NeoPixel strip\n     */\n    export class NeoPixelStrip {\n        _parent: NeoPixelStrip;\n        _dataPin: DigitalInOutPin;\n        _clkPin: DigitalInOutPin;\n        _buf: Buffer; // unscaled color buffer\n        // per pixel scaling. This buffer is allocated on-demand when per-pixel brightness is needed.\n        // when rendering, if this buffer is null, use _brightness instead\n        _brightnessBuf: Buffer;\n        _sendBuf: Buffer; // scaled color buffer\n        _brightness: number; // global brightness for this strip\n        _start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _buffered: boolean;\n        _animationQueue: control.AnimationQueue;\n        // what's the current high value\n        _barGraphHigh: number;\n        // when was the current high value recorded\n        _barGraphHighLast: number;\n        // the current photon color, undefined = no photon\n        _photonMode: number;\n        _photonPos: number;\n        _photonDir: number;\n        _photonPenColor: number;\n        // last animation used by showAnimationFrame\n        _lastAnimation: NeoPixelAnimation;\n        _lastAnimationRenderer: () => boolean;\n        _transitionPlayer: BrightnessTransitionPlayer;\n\n        constructor() {\n            this._buffered = false;\n            this._mode = NeoPixelMode.RGB;\n            this._length = 0;\n            this._brightness = 16;\n            this._start = 0;\n            this._dataPin = undefined;\n            this._clkPin = undefined;\n            this._barGraphHigh = 0;\n            this._barGraphHighLast = 0;\n        }\n\n        /**\n         * Gets the underlying color buffer for the entire strip\n         */\n        get buf(): Buffer {\n            if (this._parent) return this._parent.buf;\n            if (!this._buf)\n                this.reallocateBuffer();\n            return this._buf;\n        }\n\n        get brightnessBuf(): Buffer {\n            if (this._parent) return this._parent.brightnessBuf;\n            if (!this._brightnessBuf) {\n                const b = this.buf; // force allocate buffer\n                this._brightnessBuf = control.createBuffer(this._length);\n                this._brightnessBuf.fill(this._brightness, 0, this._brightnessBuf.length);\n            }\n            return this._brightnessBuf;\n        }\n\n        /**\n         * Gets the LED data layout mode\n         */\n        get mode(): NeoPixelMode {\n            return this._mode;\n        }\n\n        /**\n         * Set all of the pixels on the strip to one RGB color.\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"light_set_strip_color\" block=\"set %strip all pixels to %rgb=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-all\"\n        //% weight=80 blockGap=8\n        //% advanced=true\n        setAll(rgb: number) {\n            rgb = rgb | 0;\n            const red = color.unpackR(rgb);\n            const green = color.unpackG(rgb);\n            const blue = color.unpackB(rgb);\n\n            const end = this._start + this._length;\n            const stride = this.stride();\n            for (let i = this._start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n            this.autoShow();\n        }\n\n        /**\n         * Sets a gradient between two colors\n         * @param startColor the start color\n         * @param endColor the end color\n         */\n        //% blockId=lightsetgradient block=\"set %strip gradient from %startColor=colorNumberPicker to %endColor=colorNumberPicker\"\n        //% weight=79 blockGap=8\n        //% group=\"More\" advanced=true\n        setGradient(startColor: number, endColor: number) {\n            const sr = color.unpackR(startColor);\n            const sg = color.unpackG(startColor);\n            const sb = color.unpackB(startColor);\n            const er = color.unpackR(endColor);\n            const eg = color.unpackG(endColor);\n            const eb = color.unpackB(endColor);\n\n            const end = this._start + this._length;\n            const n1 = this._length - 1;\n            const stride = this.stride();\n            for (let i = this._start; i < end; ++i) {\n                let x = (i - this._start) / n1;\n                const ox = 1 - x;\n                const r = (sr * ox + er * x) | 0;\n                const g = (sg * ox + eg * x) | 0;\n                const b = (sb * ox + eb * x) | 0;\n                this.setBufferRGB(i * stride, r, g, b);\n            }\n            this.autoShow();\n        }\n\n        /**\n         * Display a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, 0 to autoscale\n         */\n        //% blockId=light_show_bar_graph block=\"%strip|graph %value||up to %high\" icon=\"\\uf080\"\n        //% help=light/neopixelstrip/graph\n        //% weight=70 blockGap=8\n        //% advanced=true\n        graph(value: number, high?: number): void {\n            console.logValue(\"\", value);\n            value = Math.abs(value);\n\n            const now = control.millis();\n            if (high > 0) {\n                this._barGraphHigh = high;\n            }\n            else if (value > this._barGraphHigh || now - this._barGraphHighLast > 10000) {\n                this._barGraphHigh = value;\n                this._barGraphHighLast = now;\n            }\n\n            const bfr = this.buffered();\n            this.setBuffered(true);\n            const n = this._length;\n            const n1 = n - 1;\n            const nhalf = n / 2;\n            const v = Math.round((value * n) / this._barGraphHigh);\n            if (v == 0) {\n                this.setAll(0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i + 1 <= v) {\n                        if (i < nhalf) {\n                            const b = (i * 255 / nhalf) >> 0;\n                            this.setPixelColor(i, light.rgb(0, b, 255 - b));\n                        } else {\n                            const b = ((i - nhalf) * 255 / nhalf) >> 0;\n                            this.setPixelColor(i, light.rgb(b, 255 - b, 0));\n                        }\n                    }\n                    else {\n                        this.setPixelColor(i, 0);\n                    }\n                }\n            }\n            this.show();\n            this.setBuffered(bfr);\n        }\n\n        /**\n         * Set the pixel to a given color.\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param color RGB color of the LED\n         */\n        //% blockId=\"light_set_pixel_color\" block=\"set %strip pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-pixel-color\"\n        //% weight=79 blockGap=8\n        //% group=\"More\" advanced=true\n        setPixelColor(pixeloffset: number, c: number): void {\n            pixeloffset = pixeloffset | 0;\n            c = c | 0;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            const stride = this.stride();\n            pixeloffset = (pixeloffset + this._start) * stride;\n            const red = color.unpackR(c);\n            const green = color.unpackG(c);\n            const blue = color.unpackB(c);\n            this.setBufferRGB(pixeloffset, red, green, blue)\n            this.autoShow();\n        }\n\n        /**\n         * Gets the pixel color.\n         * @param pixeloffset position of the NeoPixel in the strip\n         */\n        //% blockId=\"light_get_pixel_color\" block=\"%strip|pixel color at %pixeloffset\"\n        //% help=\"light/neopixelstrip/pixel-color\"\n        //% weight=9 blockGap=8\n        //% group=\"More\" advanced=true\n        pixelColor(pixeloffset: number): number {\n            pixeloffset = pixeloffset | 0;\n            if (pixeloffset < 0\n                || pixeloffset >= this._length) {\n                return 0;\n            }\n\n            const stride = this.stride();\n            const offset = (pixeloffset + this._start) * stride;\n            const b = this.buf;\n            let red = 0, green = 0, blue = 0;\n            switch (this._mode) {\n                case NeoPixelMode.RGB_RGB:\n                    red = this.buf[offset + 0];\n                    green = this.buf[offset + 1];\n                    blue = this.buf[offset + 2];\n                    break;\n                case NeoPixelMode.APA102:\n                    blue = this.buf[offset + 1];\n                    green = this.buf[offset + 2];\n                    red = this.buf[offset + 3];\n                    break;\n                default:\n                    green = this.buf[offset + 0];\n                    red = this.buf[offset + 1];\n                    blue = this.buf[offset + 2];\n                    break;\n            }\n\n            return color.rgb(red, green, blue);\n        }\n\n        /**\n         * Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\n         * This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"light_set_pixel_white_led\" block=\"set %strip pixel white LED at %pixeloffset|to %white\"\n        //% help=\"light/neopixelstrip/set-pixel-white-led\"\n        //% weight=5 blockGap=8\n        //% group=\"More\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode != NeoPixelMode.RGBW) return;\n\n            pixeloffset = pixeloffset | 0;\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this._start) * 4;\n            white = white & 0xff;\n            const buf = this.buf;\n            buf[pixeloffset + 3] = white;\n            this.autoShow();\n        }\n\n        /**\n         * Make the strip show all the new changes for the pixels.\n         */\n        //% blockId=\"light_show\" block=\"%strip|show\"\n        //% help=\"light/neopixelstrip/show\"\n        //% weight=86 blockGap=8\n        //% group=\"More\" advanced=true\n        show(): void {\n            if (this._parent) this._parent.show();\n            else if (this._dataPin) {\n                const b = this.buf;\n\n                // fast path: no processing\n                if (this._brightness == 0xff && !this._brightnessBuf && !this._photonPenColor) {\n                    // no need to process buffer\n                    light.sendBuffer(this._dataPin, this._clkPin, this._mode, b);\n                    return;\n                }\n\n                // bb may be undefined if the brightness\n                // is uniform over the strip and has not been allocated\n                const _bb = this._brightnessBuf;\n                if (!this._sendBuf) this._sendBuf = control.createBuffer(b.length);\n                const sb = this._sendBuf;\n                const stride = this.stride();\n                const strideOffset = this._mode == NeoPixelMode.APA102 ? 1 : 0;\n                // apply brightness\n                for (let i = 0; i < this._length; ++i) {\n                    const offset = (this._start + i) * stride;\n                    for (let j = 0; j < strideOffset; ++j)\n                        sb[offset + j] = 0xff;\n                    for (let j = strideOffset; j < stride; ++j)\n                        sb[offset + j] = (b[offset + j] * (_bb ? _bb[i] : this._brightness)) >> 8;\n                }\n                // apply photon\n                this.drawPhoton(sb, stride);\n                //console.log(`${!!this._dataPin} ${!!this._clkPin} ${this.mode} hex${sb.toHex()}`)\n                light.sendBuffer(this._dataPin, this._clkPin, this._mode, sb);\n            }\n        }\n\n        protected drawPhoton(sb: Buffer, stride: number) {\n            // apply photon\n            if (this._photonPenColor) {\n                // draw head and trail\n                const tailn = Math.max(1, Math.min(8, this._length >> 4));\n                let pi = this._photonPos * stride;\n                let c = Math.max(128, this._brightness);\n                let dc = (c - 32) / tailn;\n                for (let bi = 0; bi < tailn && c > 0; ++bi) {\n                    if (this._mode == NeoPixelMode.RGBW)\n                        sb[pi + 3] = c;\n                    else if (this._mode == NeoPixelMode.APA102)\n                        sb[pi + 1] = sb[pi + 2] = sb[pi + 3] = c;\n                    else\n                        sb[pi] = sb[pi + 1] = sb[pi + 2] = c;\n\n                    c -= dc;\n                    pi += (-this._photonDir * stride) % sb.length;\n                    if (pi < 0) pi += sb.length;\n                }\n            }\n        }\n\n        /**\n         * Turn off all pixel LEDs.\n         */\n        //% blockId=\"light_clear\" block=\"%strip|clear\"\n        //% help=\"light/neopixelstrip/clear\"\n        //% weight=85 blockGap=8\n        //% group=\"More\" advanced=true\n        clear(): void {\n            const stride = this.stride();\n            this.buf.fill(0, this._start * stride, this._length * stride);\n            this.autoShow();\n        }\n\n        /**\n         * Get the number of pixels on the strip\n         */\n        //% blockId=\"light_length\" block=\"%strip|length\"\n        //% help=\"light/neopixelstrip/length\"\n        //% weight=8 blockGap=8\n        //% group=\"More\" advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"light_set_brightness\" block=\"set %strip brightness %brightness\"\n        //% brightness.min=0 brightness.max=255\n        //% help=\"light/neopixelstrip/set-brightness\"\n        //% weight=2 blockGap=8\n        //% advanced=true\n        setBrightness(brightness: number): void {\n            const b = Math.max(0, Math.min(0xff, brightness | 0));\n            if (b != this._brightness || this._brightnessBuf) {\n                this._brightness = b;\n                // if this is a top level strip clear any existing brightness buffer\n                if (!this._parent)\n                    this._brightnessBuf = undefined;\n                // if this is a NOT top-level strip or if brightness buff has been allocated,\n                else if (this._parent || this._brightnessBuf)\n                    this.brightnessBuf.fill(this._brightness, this._start, this._length);\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Sets an individual pixel brightness\n         * @param index \n         * @param brightness \n         */\n        setPixelBrightness(index: number, brightness: number): void {\n            const i = (index | 0);\n            if (i < 0 || i > this._length) return;\n\n            const b = Math.max(0, Math.min(0xff, brightness | 0));\n            const bb = this.brightnessBuf;\n            if (bb[this._start + i] != b) {\n                bb[this._start + i] = b;\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Get the brightness of the pixel strip.\n         */\n        //% blockId=\"light_get_brightness\" block=\"%strip|brightness\"\n        //% help=\"light/neopixelstrip/brightness\"\n        //% parts=neopixel\n        //% weight=7 blockGap=8\n        //% group=\"More\" advanced=true\n        brightness(): number {\n            return this._brightness;\n        }\n\n        /**\n         * Create a range of pixels.\n         * @param start offset in the NeoPixel strip to start the range\n         * @param length number of pixels in the range, eg: 4\n         */\n        //% blockId=\"light_range\" block=\"%strip|range from %start|with %length|pixels\"\n        //% help=\"light/neopixelstrip/range\"\n        //% weight=99 blockGap=30\n        //% blockSetVariable=strip\n        //% advanced=true\n        range(start: number, length: number): NeoPixelStrip {\n            start = start | 0;\n            length = length | 0;\n\n            let strip = new NeoPixelStrip();\n            strip._parent = this;\n            strip._dataPin = this._dataPin;\n            strip._clkPin = this._clkPin;\n            strip._brightness = this._brightness;\n            strip._start = this._start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip._start - this._start), length);\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"light_move_pixels\" block=\"%strip|%kind=MoveKind|by %offset\"\n        //% help=\"light/neopixelstrip/move\"\n        //% weight=87 blockGap=8\n        //% group=\"More\" advanced=true\n        move(kind: LightMove, offset: number = 1): void {\n            offset = offset | 0;\n\n            const stride = this.stride();\n            if (kind === LightMove.Shift) {\n                this.buf.shift(-offset * stride, this._start * stride, this._length * stride)\n            }\n            else {\n                this.buf.rotate(-offset * stride, this._start * stride, this._length * stride)\n            }\n            this.autoShow();\n        }\n\n        private stride(): number {\n            return this._mode === NeoPixelMode.RGBW || this._mode == NeoPixelMode.APA102 ? 4 : 3;\n        }\n\n        initPhoton() {\n            if (this._photonPos === undefined) {\n                this._photonMode = PhotonMode.PenDown;\n                this._photonPos = 0;\n                this._photonDir = 1;\n                this._photonPenColor = Colors.Red;\n            }\n        }\n\n        /**\n         * Move a photon effect along the pixel strip by a number of steps.\n         * @param steps number of steps (lights) to move, eg: 1\n         */\n        //% blockId=light_photon_fd block=\"%strip|photon forward by %steps\"\n        //% help=\"light/neopixelstrip/photon-forward\"\n        //% weight=41 blockGap=8\n        //% group=\"Photon\" advanced=true\n        photonForward(steps: number) {\n            steps = steps | 0;\n            this.setPhotonPosition(this._photonPos + this._photonDir * steps);\n        }\n\n        /**\n         * Switch the direction of the photon pulse.\n         */\n        //% blockId=light_photon_flip block=\"%strip|photon flip\"\n        //% help=\"light/neopixelstrip/photon-flip\"\n        //% weight=40 blockGap=8\n        //% group=\"Photon\" advanced=true\n        photonFlip() {\n            this.initPhoton();\n            this._photonDir *= -1;\n        }\n\n        /**\n         * Sets the photon position to a given light index\n         * @param index index of the light, if out of bound, the index is wrapped\n         */\n        //% blockId=light_photon_set_position block=\"%strip|photon set position %index\"\n        //% help=\"light/neopixelstrip/set-photon-position\"\n        //% weight=39 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPosition(index: number) {\n            index = index | 0;\n\n            this.initPhoton();\n\n            // disable buffering\n            const buffered = this.buffered();\n            this.setBuffered(false);\n\n            // move\n            this._photonPos = (index >> 0) % this._length;\n            if (this._photonPos < 0) this._photonPos += this._length;\n\n            // paint under photon\n            if (this._photonMode == PhotonMode.PenDown)\n                this.setPixelColor(this._photonPos, this._photonPenColor);\n            else if (this._photonMode == PhotonMode.Eraser)\n                this.setPixelColor(this._photonPos, 0); // erase led\n\n            // restoring buffer\n            this.setBuffered(buffered);\n\n            this.autoShow();\n        }\n\n        /**\n         * Set the photon color.\n         * @param color the color of the photon\n         */\n        //% blockId=light_photon_set_pen_color block=\"%strip=variables_get|photon set pen color %color=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-photon-pen-color\"\n        //% weight=38 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPenColor(color: number) {\n            color = color | 0;\n            this.initPhoton();\n            this._photonPenColor = color;\n            this.photonForward(0);\n        }\n\n        /**\n         * Sets the photon hue.\n         * @param hue the hue of the photon color\n         */\n        //% blockId=light_photon_set_pen_hue block=\"%strip=variables_get|photon set pen hue %hue=colorWheelHsvPicker\"\n        //% help=\"light/neopixelstrip/set-photon-pen-hue\"\n        //% weight=39 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPenHue(hue: number) {\n            hue = hue | 0;\n            this.setPhotonPenColor(color.hsv(hue, 0xff, 0xff));\n        }\n\n        //% deprecated=1 blockHidden=1\n        //% group=\"Photon\" advanced=true\n        setPhotonColor(hue: number) {\n            this.setPhotonPenHue(hue);\n        }\n\n        /**\n         * Set the photon mode to pen up, pen down, or eraser.\n         * @param mode the desired mode\n         */\n        //% blockId=light_photon_set_photon block=\"%strip|photon %mode\"\n        //% help=\"light/neopixelstrip/set-photon-mode\"\n        //% weight=38\n        //% group=\"Photon\" advanced=true\n        setPhotonMode(mode: PhotonMode) {\n            if (mode == PhotonMode.Off) {\n                this._photonPos = undefined;\n                this.show();\n            } else {\n                this.initPhoton();\n                if (this._photonMode != mode) {\n                    this._photonMode = mode;\n                    this.photonForward(0);\n                }\n            }\n        }\n\n        /**\n         * Starts a brightness transition on the strip (and cancels any other running transition)\n         * @param transition \n         * @param duration \n         */\n        startBrightnessTransition(\n            startBrightness: number,\n            endBrightness: number,\n            duration: number,\n            repeat?: number,\n            yoyo?: boolean,\n            transition?: BrightnessTransition\n        ) {\n            const player = this._transitionPlayer = new BrightnessTransitionPlayer(\n                transition || new EasingBrightnessTransition(undefined),\n                startBrightness,\n                endBrightness,\n                duration,\n                repeat,\n                yoyo);\n            control.runInBackground(() => {\n                while (player == this._transitionPlayer) {\n                    const buf = this.buffered();\n                    this.setBuffered(true);\n                    const keepRendering = player.update(this);\n                    this.setBuffered(buf);\n                    this.show();\n                    pause(20);\n                    if (!keepRendering) break;\n                }\n            });\n        }\n\n        /**\n         * Stops any running brightness transition\n         */\n        stopBrightnessTransition() {\n            this._transitionPlayer = undefined;\n        }\n\n        /**\n         * Show an animation or queue an animation in the animation queue\n         * @param animation the animation to run\n         * @param duration the duration to run in milliseconds, eg: 500\n         */\n        //% blockId=light_show_animation block=\"%strip|show animation %animation=light_animation_picker|for %duration=timePicker|ms\"\n        //% help=\"light/neopixelstrip/show-animation\"\n        //% weight=90 blockGap=8\n        //% advanced=true\n        showAnimation(animation: NeoPixelAnimation, duration: number) {\n            if (!animation) return;\n\n            // if a previous renderer for the same animation was used, keep using it\n            let animationRenderer = this._lastAnimationRenderer;\n            if (!animationRenderer || this._lastAnimation != animation) {\n                animationRenderer = animation.createRenderer(this);\n                if (!animationRenderer) return;\n            }\n\n            let start = -1;\n            const render: () => boolean = () => {\n                // keep track of whose running\n                this._lastAnimation = animation;\n                this._lastAnimationRenderer = animationRenderer;\n                // execute animation\n                if (start < 0) start = control.millis();\n                const now = control.millis() - start;\n                const buf = this.buffered();\n                this.setBuffered(true);\n                const keepRendering = animationRenderer();\n                this.setBuffered(buf);\n                this.show();\n                pause(1);\n                return duration > 0\n                    ? now <= duration\n                    : keepRendering;\n            };\n            this.queueAnimation(render);\n        }\n\n        /**\n         * Show a single animation frame.\n         * @param animation the animation to run\n         */\n        //% blockId=light_show_animation_frame block=\"%strip|show frame of %animation=light_animation_picker|animation\"\n        //% help=\"light/neopixelstrip/show-animation-frame\"\n        //% weight=87 blockGap=8\n        //% group=\"More\" advanced=true\n        showAnimationFrame(animation: NeoPixelAnimation) {\n            if (!animation) {\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n                return;\n            }\n            let renderer = this._lastAnimationRenderer;\n            if (!renderer || this._lastAnimation != animation) {\n                this._lastAnimation = animation;\n                renderer = this._lastAnimationRenderer = animation.createRenderer(this);\n            }\n            if (renderer) {\n                const buf = this.buffered();\n                this.setBuffered(true);\n                renderer();\n                this.setBuffered(buf);\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Renders a pattern of colors on the strip\n         */\n        showColors(leds: string, interval: number = 400) {\n            const n = this._length;\n            let tempColor = \"\";\n            let i = 0;\n            let pi = 0;\n\n            this.queueAnimation(() => {\n                const bf = this.buffered();\n                this.setBuffered(true);\n\n                while (i < leds.length) {\n                    const currChar = leds.charAt(i++);\n                    const isSpace = currChar == ' ' || currChar == '\\n' || currChar == '\\r';\n                    if (!isSpace)\n                        tempColor += currChar;\n\n                    if ((isSpace || i == leds.length) && tempColor) {\n                        this.setPixelColor(pi++, color.parseColor(tempColor))\n                        tempColor = \"\";\n                        if (pi == n) {\n                            this.show();\n                            pause(interval);\n                            pi = 0;\n                            break;\n                        }\n                    }\n                }\n\n                this.setBuffered(bf);\n                return i < leds.length;\n            });\n        }\n\n        //%\n        private queueAnimation(render: () => boolean) {\n            if (!this._animationQueue) {\n                this._animationQueue = new control.AnimationQueue();\n                this._animationQueue.interval = 50;\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n            }\n            this._animationQueue.runUntilDone(render);\n        }\n\n        /**\n         * Stop the current animation and any other animations ready to show.\n         */\n        //% blockId=light_stop_all_animations block=\"%strip|stop all animations\"\n        //% help=\"light/neopixelstrip/stop-all-animations\"\n        //% weight=85 blockGap=8\n        //% group=\"More\" advanced=true\n        stopAllAnimations() {\n            if (this._animationQueue) {\n                this._animationQueue.cancel();\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n            }\n        }\n\n        /**\n         * Enables or disables automatically calling show when a change is made\n         * @param on call show whenever a light is modified\n         */\n        //% blockId=light_set_buffered block=\"set %strip buffered  %on\"\n        //% help=\"light/neopixelstrip/set-buffered\"\n        //% weight=86 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        setBuffered(on: boolean): void {\n            if (this._parent) this._parent.setBuffered(on);\n            else this._buffered = on;\n        }\n\n        /**\n         * Gets a value indicated if the changes are buffered\n         */\n        //% weight=85 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        buffered(): boolean {\n            return this._parent ? this._parent.buffered() : this._buffered;\n        }\n\n        /**\n         * Sets the color mode and clears the colors.\n         * @param mode the kind of color encoding required by the programmable lights\n         */\n        //% blockId=light_set_mode block=\"set %strip mode to %mode\"\n        //% help=\"light/neopixelstrip/set-mode\"\n        //% weight=1 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        setMode(mode: NeoPixelMode): void {\n            if (this._parent)\n                this._parent.setMode(mode);\n            else if (this._mode != mode) {\n                this._mode = mode;\n                this.reallocateBuffer();\n            }\n        }\n\n        /**\n         * Sets the number of LEDs on a strip\n         * @param numleds \n         */\n        //% blockId=light_set_length block=\"set %strip length to %length pixels\"\n        //% weight=1 blockGap=8\n        //% length.shadow=lightLengthPicker\n        //% group=\"Configuration\" advanced=true\n        setLength(numleds: number): void {\n            const n = Math.max(0, numleds | 0);\n            // lazy update\n            if (n != this._length) {\n                if (this._parent)\n                    this._length = Math.min(n, this._parent.length() - this._start);\n                else {\n                    this._length = n;\n                    this.reallocateBuffer();\n                }\n            }\n        }\n\n        private autoShow() {\n            if (!this.buffered()) {\n                this.show();\n                pause(1);\n            }\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            const b = this.buf;\n            // https://cdn-shop.adafruit.com/datasheets/APA102.pdf\n            switch (this._mode) {\n                case NeoPixelMode.RGB_RGB:\n                    b[offset] = red;\n                    b[offset + 1] = green;\n                    b[offset + 2] = blue;\n                    break;\n                case NeoPixelMode.APA102:\n                    // https://cdn-shop.adafruit.com/datasheets/APA102.pdf\n                    b[offset] = 0xe0 | 0x1f; // full brightness\n                    b[offset + 1] = blue;\n                    b[offset + 2] = green;\n                    b[offset + 3] = red;\n                    break;\n                default:\n                    b[offset + 0] = green;\n                    b[offset + 1] = red;\n                    b[offset + 2] = blue;\n                    break;\n            }\n        }\n\n        private reallocateBuffer(): void {\n            if (this._parent) return; // not supported in ranges\n            const stride = this.stride();\n            this._buf = control.createBuffer(this._length * stride);\n            this._brightnessBuf = undefined;\n            this._sendBuf = undefined;\n        }\n\n        // From here onwards, these block definitions are there for compatibility with old blocks\n        // (that have the default instance logic)\n\n        /**\n         * Set all of the pixels on the strip to one RGB color.\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"set all pixels to %rgb=colorNumberPicker\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setAll(rgb: number) {\n            this.setAll(rgb);\n        }\n\n        /**\n         * Display a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, 0 to autoscale\n         */\n        //% blockId=neopixel_show_bar_graph block=\"graph %value |up to %high\" icon=\"\\uf080\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __graph(value: number, high: number): void {\n            this.graph(value, high);\n        }\n\n        /**\n         * Set the pixel to a given color.\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param color RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"set pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPixelColor(pixeloffset: number, color: number): void {\n            this.setPixelColor(pixeloffset, color);\n        }\n\n        /**\n         * Gets the pixel color.\n         * @param pixeloffset position of the NeoPixel in the strip\n         */\n        //% blockId=\"neopixel_get_pixel_color\" block=\"pixel color at %pixeloffset\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __pixelColor(pixeloffset: number): number {\n            return this.pixelColor(pixeloffset);\n        }\n\n        /**\n         * Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\n         * This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white_led\" block=\"set pixel white LED at %pixeloffset|to %white\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPixelWhiteLED(pixeloffset: number, white: number): void {\n            this.setPixelWhiteLED(pixeloffset, white);\n        }\n\n        /**\n         * Make the strip show all the new changes for the pixels.\n         */\n        //% blockId=\"neopixel_show\" block=\"show\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __show(): void {\n            this.show();\n        }\n\n        /**\n         * Turn off all pixel LEDs.\n         */\n        //% blockId=\"neopixel_clear\" block=\"clear\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __clear(): void {\n            this.clear();\n        }\n\n        /**\n         * Get the number of pixels on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"length\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __length() {\n            return this.length();\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"set brightness %brightness\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setBrightness(brightness: number): void {\n            this.setBrightness(brightness);\n        }\n\n        /**\n         * Get the brightness of the pixel strip.\n         */\n        //% blockId=\"neopixel_get_brightness\" block=\"brightness\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __brightness(): number {\n            return this.brightness();\n        }\n\n        /**\n         * Create a range of pixels.\n         * @param start offset in the NeoPixel strip to start the range\n         * @param length number of pixels in the range. eg: 4\n         */\n        //% blockId=\"neopixel_range\" block=\"range from %start|with %length|pixels\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __range(start: number, length: number): NeoPixelStrip {\n            return this.range(start, length);\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_move_pixels\" block=\"%kind=MoveKind|by %offset\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __move(kind: LightMove, offset: number = 1): void {\n            this.move(kind, offset);\n        }\n\n        /**\n         * Move a photon effect along the pixel strip by a number of steps.\n         * @param steps number of steps (lights) to move, eg: 1\n         */\n        //% blockId=neophoton_fd block=\"photon forward by %steps\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __photonForward(steps: number) {\n            this.photonForward(steps);\n        }\n\n        /**\n         * Switch the direction of the photon pulse.\n         */\n        //% blockId=neophoton_flip block=\"photon flip\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __photonFlip() {\n            this.photonFlip();\n        }\n\n        /**\n         * Set the photon color.\n         * @param color the color of the photon\n         */\n        //% blockId=neophoton_set_color block=\"photon set pen color %color\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPhotonColor(color: number) {\n            // The photon color has since changed, and we now use setPhotonPenHue to set the hue of the photon color\n            this.setPhotonPenHue(color);\n        }\n\n        /**\n         * Set the photon mode to pen up, pen down, or eraser.\n         * @param mode the desired mode\n         */\n        //% blockId=neophoton_set_photon block=\"photon %mode\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPhotonMode(mode: PhotonMode) {\n            this.setPhotonMode(mode);\n        }\n\n        /**\n         * Show an animation or queue an animation in the animation queue\n         * @param animation the animation to run\n         * @param duration the duration to run in milliseconds, eg: 500\n         */\n        //% blockId=neopixel_show_animation block=\"show %animation=light_animation|animation for %duration=timePicker|ms\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __showAnimation(animation: NeoPixelAnimation, duration: number) {\n            this.showAnimation(animation, duration);\n        }\n\n        /**\n         * Show a single animation frame\n         * @param animation the animation to run\n         */\n        //% blockId=neopixel_show_animation_frame block=\"show animation frame %animation=light_animation\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __showAnimationFrame(animation: NeoPixelAnimation) {\n            this.showAnimationFrame(animation);\n        }\n\n        /**\n         * Stop the current animation and any other animations ready to show.\n         */\n        //% blockId=neopixel_stop_all_animations block=\"stop all animations\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __stopAllAnimations() {\n            this.stopAllAnimations();\n        }\n\n        /**\n         * Enables or disables automatically calling show when a change is made\n         * @param on call show whenever a light is modified\n         */\n        //% blockId=neopixel_set_buffered block=\"set buffered  %on\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setBuffered(on: boolean): void {\n            this.setBuffered(on);\n        }\n\n        /**\n         * Sets the color mode and clears the colors.\n         * @param mode the kind of color encoding required by the programmable lights\n         */\n        //% blockId=neopixel_set_mode block=\"set mode %mode\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setMode(mode: NeoPixelMode): void {\n            this.setMode(mode);\n        }\n    }\n\n    /**\n     * Creates a strip of colored LEDs (WS2812b)\n     */\n    //% blockId=\"neopixel_create\" block=\"create WS2812 strip|pin %pin|with %numleds pixels\"\n    //% help=\"light/create-neo-pixel-strip\"\n    //% trackArgs=0,2\n    //% parts=\"neopixel\"\n    //% weight=100 blockSetVariable=strip\n    //% advanced=true blockHidden=1\n    export function createNeoPixelStrip(\n        pin: DigitalInOutPin,\n        numleds: number = 10,\n        mode?: NeoPixelMode\n    ): NeoPixelStrip {\n        if (!mode)\n            mode = NeoPixelMode.RGB;\n\n        const strip = new NeoPixelStrip();\n        strip._mode = mode;\n        strip._length = Math.max(0, numleds | 0);\n        strip._dataPin = pin;\n        if (strip._dataPin) // board with no-board LEDs won't have a default pin\n            strip._dataPin.digitalWrite(false);\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% red.min=0 red.max=255 green.min=0 green.max=255 blue.min=0 blue.max=255\n    //% help=\"light/rgb\"\n    //% group=\"Color\" weight=19 blockGap=8\n    export function rgb(red: number, green: number, blue: number): number {\n        return color.rgb(red, green, blue);\n    }\n\n    /**\n     * Get the RGB value of a known color\n    */\n    //% blockId=neopixel_colors block=\"%color\"\n    //% help=\"light/colors\"\n    //% shim=TD_ID\n    //% group=\"Color\" weight=20 blockGap=8\n    export function colors(color: Colors): number {\n        return color;\n    }\n\n    /**\n     * Convert an HSV (hue, saturation, value) color to RGB\n     * @param hue value of the hue channel between 0 and 255. eg: 255\n     * @param sat value of the saturation channel between 0 and 255. eg: 255\n     * @param val value of the value channel between 0 and 255. eg: 255\n     */\n\n    //% blockId=\"neopixel_hsv\" block=\"hue %hue|sat %sat|val %val\"\n    //% hue.min=0 hue.max=255 sat.min=0 sat.max=255 val.min=0 val.max=255\n    //% help=\"light/hsv\"\n    //% group=\"Color\" weight=17\n    export function hsv(hue: number, sat: number = 255, val: number = 255): number {\n        return color.hsv(hue, sat, val);\n    }\n\n    /**\n     * Use color.fade instead\n     * @param color color to fade\n     * @param brightness the amount of brightness to apply to the color, eg: 128\n     */\n    //% blockId=\"neopixel_fade\" block=\"fade %color=neopixel_colors|by %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/fade\"\n    //% group=\"Color\" weight=18 blockGap=8\n    //% blockHidden=true deprecated\n    export function fade(c: number, brightness: number): number {\n        return color.fade(c, brightness);\n    }\n\n    /**\n     * An animation of a NeoPixel\n     */\n    //% fixedInstances\n    export class NeoPixelAnimation {\n        constructor() { }\n\n        /**\n         * Creates an animator instance\n         * @param strip the strip to execute on\n         */\n        createRenderer(strip: NeoPixelStrip): () => boolean {\n            return undefined;\n        }\n    }\n\n    export class RainbowCycleAnimation extends NeoPixelAnimation {\n        public delay: number;\n        constructor(delay: number) {\n            super();\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const n = strip.length();\n            let hueOffset = 0;\n            return () => {\n                for (let i = 0; i < n; i++) {\n                    strip.setPixelColor(i, color.hsv(((i * 256) / (n - 1) + hueOffset) % 0xff, 0xff, 0xff));\n                }\n                hueOffset += Math.ceil(128 / n);\n                if (hueOffset >= 0xff) {\n                    hueOffset = 0;\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"rainbow\" whenUsed jres blockIdentity=\"light._animationPicker\"\n    export const rainbowAnimation: NeoPixelAnimation = new RainbowCycleAnimation(50);\n\n    export class RunningLightsAnimation extends NeoPixelAnimation {\n        public red: number;\n        public green: number;\n        public blue: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let iteration = 0;\n            let step = 0;\n            return () => {\n                if (iteration < l * 2) {\n                    step++;\n                    for (let i = 0; i < l; i++) {\n                        const level = (Math.isin(i + step) * 127) + 128;\n                        strip.setPixelColor(i, color.rgb(level * this.red / 255, level * this.green / 255, level * this.blue / 255));\n                    }\n                    iteration++;\n                    return true;\n                } else {\n                    step = 0;\n                    iteration = 0;\n                    return false;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"running lights\" jres blockIdentity=\"light._animationPicker\"\n    export const runningLightsAnimation: NeoPixelAnimation = new RunningLightsAnimation(0xff, 0, 0, 50);\n\n    class CometAnimation extends NeoPixelAnimation {\n        public red: number;\n        public green: number;\n        public blue: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            const spacing = (255 / l) >> 0;\n            let start = -1;\n            let step = 0;\n            const offsets: number[] = [];\n            for (let i = 0; i < l; i++) {\n                offsets[i] = spacing * i;\n            }\n            return () => {\n                for (let i = 0; i < l; i++) {\n                    offsets[i] = (offsets[i] + (step * 2)) % 255\n                    strip.setPixelColor(i, color.rgb(255 - offsets[i], this.green, this.blue));\n                }\n                step++;\n                if (step * 2 > 0xff) {\n                    step = 0;\n                    return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"comet\" jres blockIdentity=\"light._animationPicker\"\n    export const cometAnimation: NeoPixelAnimation = new CometAnimation(0xff, 0, 0xff, 50);\n\n    export class SparkleAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.rgb = color.rgb(red, green, blue);\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let count = 0;\n            let pixel = -1;\n            let pixelColor = 0;\n            return () => {\n                if (count == 0)\n                    strip.clear();\n                if (pixel < 0) {\n                    pixel = Math.randomRange(0, l - 1);\n                    pixelColor = strip.pixelColor(pixel);\n                    strip.setPixelColor(pixel, this.rgb);\n\n                } else {\n                    strip.setPixelColor(pixel, pixelColor);\n                    pixel = -1;\n                }\n                count++;\n                if (count > 50) {\n                    count = 0;\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"sparkle\" jres blockIdentity=\"light._animationPicker\"\n    export const sparkleAnimation: NeoPixelAnimation = new SparkleAnimation(0xff, 0xff, 0xff, 50);\n\n    class ColorWipeAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(rgb: number, delay: number) {\n            super();\n            this.rgb = rgb;\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let i = 0;\n            let reveal = true;\n            return () => {\n                if (i < l) {\n                    if (reveal) {\n                        strip.setPixelColor(i, this.rgb);\n                    } else {\n                        strip.setPixelColor(i, 0);\n                    }\n                    i++;\n                } else {\n                    reveal = !reveal;\n                    i = 0;\n                    if (reveal)\n                        return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"color wipe\" jres blockIdentity=\"light._animationPicker\"\n    export const colorWipeAnimation: NeoPixelAnimation = new ColorWipeAnimation(0x0000ff, 50);\n\n    class TheatreChaseAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.rgb = color.rgb(red, green, blue);\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let j = 0;\n            let q = 0;\n            let on = false;\n            return () => {\n                if (j < 10) { // 10 cycles of chasing\n                    if (q < 3) {\n                        if (on) {\n                            for (let i = 0; i < l; i = i + 3) {\n                                strip.setPixelColor(i + q, this.rgb); // every third pixel on\n                            }\n                        }\n                        else {\n                            for (let i = 0; i < l; i = i + 3) {\n                                strip.setPixelColor(i + q, 0); // every third pixel off\n                            }\n                        }\n                        on = !on;\n                        q++;\n                    } else {\n                        q = 0;\n                    }\n                    j++;\n                } else {\n                    j = 0;\n                    return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"theater chase\" jres blockIdentity=\"light._animationPicker\"\n    export const theaterChaseAnimation: NeoPixelAnimation = new TheatreChaseAnimation(0xff, 0, 0, 50);\n\n    /**\n     * An animation that can be shown on a light strip\n     * @param animation The animation type\n     */\n    //% blockId=light_animation_picker block=\"%animation\" shim=TD_ID\n    //% animation.fieldEditor=\"imagedropdown\"\n    //% animation.fieldOptions.columns=3\n    //% weight=0\n    //% group=\"More\"\n    export function _animationPicker(animation: NeoPixelAnimation): NeoPixelAnimation {\n        return animation;\n    }\n\n    /**\n  * Get the light length picker\n  * @param pixels number of LEDs\n  */\n    //% blockId=lightLengthPicker block=\"%pixels\"\n    //% blockHidden=true shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% pixels.fieldEditor=\"numberdropdown\" pixels.fieldOptions.decompileLiterals=true\n    //% pixels.fieldOptions.data='[[\"7\", 7], [\"8\", 8], [\"12\", 12], [\"16\", 16], [\"24\", 24], [\"30\", 30], [\"60\", 60], [\"64\", 64], [\"90\", 90], [\"120\", 120], [\"144\", 144]]'\n    export function __lengthPicker(pixels: number): number {\n        return pixels;\n    }\n}\n",
            "neopixeloverrides.ts": "//% weight=97\nnamespace light {\n\n}",
            "ns.ts": "\n/**\n * Functions to operate colored LEDs.\n */\n//% weight=100 color=\"#0078d7\" icon=\"\\uf00a\"\nnamespace light {\n\n}",
            "onboardstrip.ts": "namespace light {\n    let _onboardStrip: light.LightStrip;\n    /**\n     * Get the default light strip.\n     */\n    //% help=light/onboard-strip\n    //% blockId=\"neopixel_onboard_strip\" block=\"onboard strip\"\n    //% weight=111 blockGap=8\n    //% advanced=true\n    export function onboardStrip(): NeoPixelStrip {\n        if (_onboardStrip) return _onboardStrip;\n\n        const data = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_DATA);\n        const clk = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_CLOCK);\n        const dsnum = control.getConfigValue(DAL.CFG_NUM_DOTSTARS, 0);\n        const neo = pins.pinByCfg(DAL.CFG_PIN_NEOPIXEL);\n        const neonum = control.getConfigValue(DAL.CFG_NUM_NEOPIXELS, 0);\n        if (data && clk && dsnum > 0) {\n            _onboardStrip = light.createAPA102Strip(data, clk, dsnum);\n            _onboardStrip.setBrightness(96);\n        } else if (neo && neonum > 0) {\n            _onboardStrip = light.createNeoPixelStrip(neo, neonum, NeoPixelMode.RGB);\n        } else {\n            _onboardStrip = light.createNeoPixelStrip(undefined, 0);\n        }\n        return _onboardStrip;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"light\",\n  \"description\": \"The programmable LED (WS2812b,APA102) driver.\",\n  \"files\": [\n    \"README.md\",\n    \"neopixel.ts\",\n    \"transitions.ts\",\n    \"create.ts\",\n    \"defaultstrip.ts\",\n    \"onboardstrip.ts\",\n    \"defaultlights.ts\",\n    \"defaultlightsoverrides.ts\",\n    \"ns.ts\",\n    \"jacdac.ts\",\n    \"neopixeloverrides.ts\",\n    \"animations.jres\",\n    \"targetoverrides.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"color\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/646f17c79d0d65e2702ce2cd881ccb2f6679c984/static/libs/light.png\"\n}",
            "targetoverrides.ts": "// define built-in strips here",
            "test.ts": "\nlet strip = light.createStrip()\nstrip.setBrightness(20)\n\nfunction flash(n: number) {\n    control.runInParallel(() => {\n        strip.setPixelColor(n, 0x0000ff)\n        pause(1000)\n        strip.setPixelColor(n, 0x000000)\n    })\n}\n\nflash(0)\n\n",
            "transitions.ts": "namespace easing {\n    export function linear(t: number): number { return t; }\n    export function inQuad(t: number): number { return t * t; }\n    export function outQuad(t: number): number { return t * (2 - t); }\n    export function inOutQuad(t: number): number { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }\n    export function inCubic(t: number): number { return t * t * t; }\n    export function outCubic(t: number): number { return (--t) * t * t + 1; }\n    export function inOutCubic(t: number): number { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }\n}\n\nnamespace light {\n    export class BrightnessTransition {\n        constructor() { }\n        apply(strip: LightStrip, t: number, start: number, end: number): void {\n\n        }\n    }\n\n    export class EasingBrightnessTransition extends BrightnessTransition {\n        private timeEasing: (t: number) => number;\n        private spatialEasing: (t: number) => number;\n\n        constructor(\n            timeEasing: (t: number) => number, \n            spatialEasing?: (t: number) => number) {\n            super();\n            this.timeEasing = timeEasing || easing.inOutQuad;\n            this.spatialEasing = spatialEasing;\n        }\n\n        apply(strip: LightStrip, t: number, start: number, end: number): void {\n            // t in [0..1]\n            const db = end - start;\n            const b = this.timeEasing(t); // [0..1]\n            if (!this.spatialEasing) {\n                strip.setBrightness(start + db * b);\n            }\n            else {\n                // convolve desired brightness with spacial easing function\n                const n = strip.length();\n                for (let i = 0; i < n; ++i) {\n                    const x = this.spatialEasing(i / (n - 1)); // [0..1]\n                    strip.setPixelBrightness(i, end - db * (1 - b) * x);\n                }\n            }\n        }\n    }\n\n    export class BrightnessTransitionPlayer {\n        private transition: BrightnessTransition;\n        private startBrightness: number;\n        private endBrightness: number;\n        private duration: number;\n        private startTime: number;\n        private repeat: number;\n        private yoyo: number;\n\n        constructor(\n            transition: BrightnessTransition,\n            startBrightness: number,\n            endBrightness: number,\n            duration: number,\n            repeat: number,\n            yoyo: boolean) {\n            this.transition = transition;\n            this.startBrightness = startBrightness;\n            this.endBrightness = endBrightness;\n            this.duration = duration;\n            this.startTime = control.millis();\n            this.repeat = repeat || 1;\n            this.yoyo = yoyo ? 1 : 0;\n        }\n\n        update(strip: LightStrip): boolean {\n            let elapsed = control.millis() - this.startTime;\n            if (elapsed > this.duration) {\n                this.yoyo = -this.yoyo;\n                if (this.repeat > 0)\n                    this.repeat--;\n                this.startTime = control.millis();\n                elapsed = 0;\n                return this.repeat != 0;\n            }\n\n            let t = elapsed / this.duration;\n            if (this.yoyo < 0)\n                t = 1 - t;\n            this.transition.apply(strip, t, this.startBrightness, this.endBrightness);\n            return true;\n        }\n    }\n}"
        },
        "mixer---samd": {
            "SoundOutput.h": "#include \"SAMDDAC.h\"\n#include \"Synthesizer.h\"\n#include \"Mixer.h\"\n\nnamespace jacdac {\nvoid setJackRouterOutput(int output);\n}\n\nclass SoundOutput {\n  public:\n    SAMDDAC dac;\n\n    SoundOutput(DataSource &data) : dac(*pxt::lookupPin(PIN_PA02), data) {\n        jacdac::setJackRouterOutput(-1);\n    }\n\n    void setOutput(int output) { jacdac::setJackRouterOutput(output); }\n};\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;  // Hz\n    uint16_t duration;   // ms\n    int16_t startVolume; // 0-1023\n    int16_t endVolume;   // 0-1023\n    uint16_t endFrequency;  // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n        while (sz--) {\n            *dp++ += 1 << (OUTPUT_BITS - 1);\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer---samd\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer---stm32": {
            "SoundOutput.h": "#include \"ZPWM.h\"\n#include \"Synthesizer.h\"\n#include \"Mixer.h\"\n\nnamespace jacdac {\nvoid setJackRouterOutput(int output);\n}\n\nclass SoundOutput {\n  public:\n    ZPWM dac;\n\n    SoundOutput(DataSource &data) : dac(*LOOKUP_PIN(JACK_SND), data) {\n        jacdac::setJackRouterOutput(-1);\n    }\n\n    void setOutput(int output) { jacdac::setJackRouterOutput(output); }\n};\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;  // Hz\n    uint16_t duration;   // ms\n    int16_t startVolume; // 0-1023\n    int16_t endVolume;   // 0-1023\n    uint16_t endFrequency;  // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n        while (sz--) {\n            *dp++ += 1 << (OUTPUT_BITS - 1);\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer---stm32\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer---none": {
            "SoundOutput.h": "\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"melody.h\"\n\nnamespace music {\n//%\nvoid forceOutput(int outp) {}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n}\n\n//%\nvoid enableAmp(int enabled) {\n\n}\n\n} // namespace music\n",
            "melody.h": "\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer---none\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer---linux": {
            "SoundOutput.h": "#define SAMPLE_RATE 44100\n\nnamespace music {\nclass WSynthesizer;\n\nclass LinuxDAC {\n  public:\n    int16_t data[256];\n    WSynthesizer &src;\n    LinuxDAC(WSynthesizer &data);\n    static void *play(void *);\n    int getSampleRate() { return SAMPLE_RATE; }\n};\n\nclass SoundOutput {\n  public:\n    LinuxDAC dac;\n\n    SoundOutput(WSynthesizer &data) : dac(data) {}\n\n    void setOutput(int) {}\n};\n\n} // namespace music",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;  // Hz\n    uint16_t duration;   // ms\n    int16_t startVolume; // 0-1023\n    int16_t endVolume;   // 0-1023\n    uint16_t endFrequency;  // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n        while (sz--) {\n            *dp++ += 1 << (OUTPUT_BITS - 1);\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer---linux\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n#include <alsa/asoundlib.h>\n#include <pthread.h>\n\nnamespace music {\n\nstatic void alsa_check(int pos, int fn) {\n    if (fn < 0) {\n        DMESG(\"alsa fail! pos=%d err=%d: %s\", pos, fn, snd_strerror(fn));\n        target_panic(950);\n    }\n}\n\nvoid *LinuxDAC::play(void *self) {\n    auto dac = (LinuxDAC *)self;\n\n    snd_pcm_t *pcm_handle;\n\n    sleep_core_us(1000 * 1000);\n\n    alsa_check(0, snd_pcm_open(&pcm_handle, \"default\", SND_PCM_STREAM_PLAYBACK, 0));\n\n    alsa_check(1, snd_pcm_set_params(pcm_handle, SND_PCM_FORMAT_S16_LE,\n                                     SND_PCM_ACCESS_RW_INTERLEAVED, 1, SAMPLE_RATE, 1, 30 * 1000));\n\n    DMESG(\"PCM name: '%s'\", snd_pcm_name(pcm_handle));\n    DMESG(\"PCM state: %s\", snd_pcm_state_name(snd_pcm_state(pcm_handle)));\n\n    for (;;) {\n        target_disable_irq();\n        auto hasData = dac->src.fillSamples(dac->data, sizeof(dac->data) / 2);\n        target_enable_irq();\n        auto len = (int)sizeof(dac->data) / 2;\n        if (!hasData) {\n            sleep_core_us(5000);\n            continue;\n        }\n        for (int i = 0; i < len; ++i) {\n            // playing at half-volume\n            dac->data[i] = dac->data[i] << 3;\n        }\n        int frames = snd_pcm_writei(pcm_handle, dac->data, len);\n        if (frames < 0)\n            frames = snd_pcm_recover(pcm_handle, frames, 0);\n        if (frames < 0) {\n            DMESG(\"alsa write faield: %s\", snd_strerror(frames));\n            target_panic(951);\n        }\n    }\n\n    return NULL;\n}\n\nLinuxDAC::LinuxDAC(WSynthesizer &data) : src(data) {\n    pthread_t upd;\n    pthread_create(&upd, NULL, LinuxDAC::play, this);\n    pthread_detach(upd);\n}\n\n}",
            "targetoverrides.ts": "// make sure sound starts\nnew music.Melody(\"!440,100\").playUntilDone(1)\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer---ext": {
            "SoundOutput.h": "#define SAMPLE_RATE 44100\n\nnamespace music {\nclass WSynthesizer;\n\nclass ExtDAC {\n  public:\n    WSynthesizer &src;\n    ExtDAC(WSynthesizer &data);\n    int getSampleRate() { return SAMPLE_RATE; }\n};\n\nclass SoundOutput {\n  public:\n    ExtDAC dac;\n\n    SoundOutput(WSynthesizer &data) : dac(data) {}\n\n    void setOutput(int) {}\n};\n\n} // namespace music",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;  // Hz\n    uint16_t duration;   // ms\n    int16_t startVolume; // 0-1023\n    int16_t endVolume;   // 0-1023\n    uint16_t endFrequency;  // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n        while (sz--) {\n            *dp++ += 1 << (OUTPUT_BITS - 1);\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music { \n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n  \"name\": \"mixer---ext\",\n  \"description\": \"The music library with a mixer\",\n  \"files\": [\n    \"SoundOutput.h\",\n    \"sound.cpp\",\n    \"melody.h\",\n    \"melody.cpp\",\n    \"melody.ts\",\n    \"piano.ts\",\n    \"legacy.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"music.ts\",\n    \"pxtparts.json\",\n    \"headphone.svg\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\nnamespace music {\n\nstatic ExtDAC *dac;\n\nDLLEXPORT void pxt_get_audio_samples(int16_t *buf, unsigned numSamples) {\n    if (!dac) {\n        memset(buf, 0, numSamples * 2);\n        return;\n    }\n\n    target_disable_irq();\n    dac->src.fillSamples(buf, numSamples);\n    target_enable_irq();\n\n    for (unsigned i = 0; i < numSamples; ++i) {\n        // playing at half-volume\n        buf[i] = buf[i] << 3;\n    }\n\n    //DMESG(\"samples %d %d %d %d\", numSamples, buf[0], buf[20], buf[100]);\n}\n\nExtDAC::ExtDAC(WSynthesizer &data) : src(data) {\n    dac = this;\n}\n\n} // namespace music",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "device": {
            "README.md": "# device\n\nThe core library for fantasy game console target.\n\n",
            "bigFood.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.food\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"bigBurger\": \"hwQgACAAAAAAAAAAAO7/AID4//8PAAAAAAAAAO67y+94h75rxg8AAAAAAO5mZrb7dmf/vmb8AAAAAOBrtmZmuy9i+P9t9gAAAAC+tru7ZrbsYob/3WsPAADAu7tEtGtm+yJ2/t+0DwAAvERbS0S0Zvsidu7fvfsAAExEtERERGbGInf/T037AMBERERERERrtixn/+9N6wDARERERLRLZLYsh+//TbsPwERLRERbS7S2LPbu/k20D0y0tUREu0S0tiyG7/5NtA9MtEtERERERLssZu/+TbQPTERERERERES7LHbn/020D0xEREREREREuyx35/9NtA9MRERERERERLQsd+buTUQPRkREu0RERES0LHfm701EDEa7RFtLREREtCx35u9NRAxGW0u0RERERLQsd+juTUQMRrRERERERES0LGfo7k1EDEZEREREtEtEtCxm7v5NRAxgRERLRLS1RLQsZu/+TUQOYES0tUREu0S0LHb//k1EDmBEREtEREREtCx37v9N5AAARkRERERERMQiZ+5PTeQAAEZEtEtERET0Ivfu3kvkAACwRLS1REREy3L37t5EDgAAAEtEu0RERCxi/++9RA4AAABgRERERLQsZv++S+QAAAAAAOZERLT7dob/u2TuAAAAAAAA7rvL73hnvmbmDgAAAAAAAADu/wCI+P/vDgAAAA==\",\n  \"bigDrumstick\": \"hwQgACAAAAAAAAAAIiIiAgAAAAAAAAAAAAAAIru7uyICAAAAAAAAAAAAILu7u7u74gAAAAAAAAAAAEJEu0S0u+sOAAAAAAAAACBERERLRLvrDgAAAAAAAABCRERERES0u+4AAAAAAAAAQkREREREtLvuAAAAAAAAsEREREREtES77g4AAAAAALBERERERLRLu+sOAAAAAACwRERERES0u7vrDgAAAAAAS0RERERERLS76w4AAAAAAEtERERERES7tCsOAAAAAABLTUREREREu0Qr4gAAAAAAS91ERERERERLKyIAAAAAAEvdREREREREu7siDgAAAABL1E1ERERERLu7Kw4AAAAAsNRNRERERES0RLsCAAAAALBE3URERERERES06wAAAAAAS0RNRERERES7tOsAAAAAAOBLREREREREtLvrAAAAAAAAvru7RERERLS76wAAAAAAAOC+u0tEtEREu+4AAAAAAAAA4O67RLtLtLvOAAAAAAAAAAAA7u7uu7vu2wwAAAAAAAAAAAAAAO7uzt3NAAAAAAAAAAAAAAAAAADb0cvMAAAAAAAAAAAAAAAAsBERvQwAAAAAAAAAAAAAAAAbEREMAAAAAAAAAAAAAAAAG9EdDAAAAAAAAAAAAAAAANvRywAAAAAAAAAAAAAAAAC7EQwAAAAAAAAAAAAAAAAAsMwAAA==\",\n  \"bigHam\": \"hwQgACAAAAAAAAAAACAiIiLu7u4AAAAAAAAAACAy3RERERE97gAAAAAAACAyHTEzMzMz3T0OAAAAAAAyER0zMzMzMzPd4wAAAAAgEz3T0TMzMzMz0z0OAAAAMjEzM93dPTMzMzMdDgAAINMxMzMzMz0zMzMzE+0AADIdMzMzMzPdHTEzMxPhAADSMTMzMzMz3dEdMzMTvQ4g0zMzMzMzMxM93TEzHTMOINMzMzMzMzMTM9PR09EzDjIdMzMzMzMz3TETPd3TPQ4yET0zMzMz090d0Tsz09EPMhHRPTMzMz0zM7szMzPRDzLRHT3T3d0zMzMzMzMzEQ8y0dPd3TMzMzMzMzMzMzEPshMz0z0zMzMzMzMzM9OxD77TPdM9MzMzMzMzMzPd4w7uMzEzMzMzMzMzMzMz3fsO4DsTMzMzMzMzMzMz3bP+AODuO90zMzMzMzMzHT37/wAA7u473d3d3d0dET3r//4AAODu7rvTERER0bNm/+8PAAAA4E5Eu7tmZmtmu+7vDwAAAABORLRGtES0u+vu/wAAAAAA4E5ERmRGtGvm6w8AAAAAAADuRERGtERmu+sAAAAAAAAA4E5ERmRGu7sOAAAAAAAAAADgTmRGtLvuAAAAAAAAAAAAAOBOS2TmAAAAAAAAAAAAAAAAvmbmDgAAAAAAAAAAAAAAAODuDgAAAAAAAA==\",\n  \"bigPizza\": \"hwQgACAAAAAAAAAAAAAAAAAAAAAAu0REAAAAAAAAAAAAAAAAu10VQQAAAAAAAAAAAAAAS11V0eUAAAAAAAAAAAAARtRdXUHlAAAAAAAAAAAAa4dV1R1dBAAAAAAAAAAAu22HJS4dVA4AAAAAAAAAu11VViLiUlQOAAAAAAAAS+Qu1SUiIt7UTQAAAAAAuz0i4tIlIyLeTe4AAAAAQF0lIiJeJTMi3uUAAAAAsFRVJSMiXlUi4tPlAAAAAEtd1SUzIl5V5T5dBADg7k5dVdVVIuJTVVVVVAQA60vrVFXVVu0+VdVVFdQOAL5DtN5VbYfdVVXVXRVUDgC+NENLVWWHXVVV1V1BRQAAuzQzRN1VVlVVVdVWQUUAALtLM0PUVVVV7lJlh9XlAABLu0QzRF1VJSIuZYcR7QQAu7REM7RUVSIi4lUW0d1NALBLSzNDu1UyIuJV0VTkTgAAu0QzQ7vUMiPiVUFdDgAAALBLRENETi0iPlVN5QAAAAAAvkQ0tOvU7lMV1OQAAAAAAOBLRETrvt1VUdTtAAAAAAAAu0REtE7d1UXU5AAAAAAAALBLRETr1NVFTQ4AAAAAAAAAu0REu0tE1O0OAAAAAAAAAOBOtLvr1E3uAAAAAAAAAAAA7kS0u+7k7gAAAAAAAAAAAODuu+vu7g4AAAAAAAAAAAAA6+7u7u4AAAAAAA==\",\n  \"bigTaco\": \"hwQgACAAAAAAAAAAAAAAAO7u7u7uAAAAAAAAAAAA4O5UVVVVRO4AAAAAAAAA4E5V5e7/5O5UDgAAAAAAQE5VVUTu/+7+TuUAAAAAAERmVuTu5P7v7u/lAAAAAEBVdkbu7u7//v/vVA4AAABUZXdITv7+/v//714OAABAJXJ35k7+//7v/+5ODgAATjJzRIf+/+/uVFVVRQ4A4EQickV35u5UVdXd3d0OAE6GLn5FduZU1U3dVVXdDgBud3dXZGZe1V1VVdVF3Q7gdER3VnTm1V1VVVVVVe0A4HVFZ0Z3Xl1V1VVdVdXtAE5lRWdn59XVVVVUVV3VDgBeZUV3Il5dVVVVVVVVRQ4AXnZEJzNUXVVVVVVFVe0AAG53dybi1VVVVdVVVd0OAABuInfnQtVVXVVV1dVNDgAALjNyZ15dVVVVVVXd7QAAAO4ucmdUXUVV1VXV3Q4AAAAg4mJn1V1V1VVVRe0AAAAA4HZn5tVdVVVV1d3tAAAAAAB4d+bVVVXVVVXdDgAAAAAAeHfm3dVVXV3d7QAAAAAAAGB2591VVd3d3eQAAAAAAABgZ+bdVVXd1N0OAAAAAAAAgHeG3dRV3d3tAAAAAAAAAACIhtTdVdXdDgAAAAAAAAAAAIjY3V3U7QAAAAAAAAAAAAAAQNTd3Q4AAAAAAAAAAAAAAABE7u4AAAAAAAAAAA==\",\n  \"bigCake\": \"hwQgACAAAAAAAAAAALC7u7u7u7u7AAAAAAAAAACws1vVO1NVvQAAAAAAAAAA2zNbVbVT3bUAAAAAAAAAsNM9W1W1U1VdCwAAAAAAALDdPVtVNVNVVQsAAAAAAACwPT07VVXTVdULAAAAAAAAOz09u1VVO13VCwAAAAAAsNszPbNVVTtdVb0AAAAAALDTMz2zVVU7VVW9AAAAAACwPTPTs1VVM1VVtQAAAAAA2zMz071VVTVVXbUAAAAAANszM9O9VVU1U1VVCwAAALA9MzPTM1NVvVNVXQsAAACwMzMz0zNbVb1TVV0LAAAAuzMzMzM9W1W1U1VdCwAAADszMzMzPVvVNdtVVbUAALAzMzMzM91bVVXbXVW1AAC7MzMzMzPd21XVO13VtQAAOzMzMzMzPdtV1TtVVbUAADsj7jszMz3bXd07Vd3VC7AzMiK+MzM9u93VM1Xd1QuwM+4i4jMzPaNd1b1d3dULOzPuIuIzMz2jXdW93V1VCzs97iLiMzPdo91dvdvd1b070y4ivjMz06PdXb3b3VW9sDPt7jszM9Oj3d29291VvQCrO90zMzMzvdvdvdvd3a0AAKrT3d0zMz3b3T3b3V2rAAAAqjPd3d3ds93du921owAAAACqOtPdPbO7u7u7M6sAAAAAAKCqO7O7uzMzM7MKAAAAAAAAAKqqqqqqqqqqAA==\",\n  \"bigDonut\": \"hwQgACAAAAAAAAAAAAAAu6qqqgAAAAAAAAAAAACwu9Pd3bPuAAAAAAAAAACwO93dbd09uu4AAAAAAAAAO91jNnY4PavrDgAAAAAAsNMzmzh2ONO7uu4AAAAAADs9Y4kzdjjTs7q+DgAAALAzM2M4M2Y70z2r6w4AAAA7NDMzMzMzMzPdo+vrAACwQyUzMzMzMzMjM73q6wAAO0MlMzMzMzMzVDI9uusAADtDNDMzs7szM1QyPbu7DrAzMzPTs6q7MzNE06O0tA6wMzMzPTujOiMzMzNKtLQOYDYz070zqjNCPjMzSrREDmuHM9OzozozQj4zs0q7RA5rhzPTO6ozMyMzM6NEs0QOa4cz0zu6MzMzM9OrRLPkADs2MzO7OzMzM2bdSjRD5AA7MzMzuzMzM2OJPUo0S+QAOzMzMzMzMzOWOD1KNEQOADszMzMzYzgzhjOtRLNEDgCwhjNEM2OHMzPTo0RD5AAAoJY4VDIzdjjTPUo0S+QAAKBjiVQyM2M2M6NEtEQOAAAAOmYjMyMzM6tKREvkAAAAADozMzNCPqtKRLREDgAAAACgMzMzQr5KRERL5AAAAAAAoLrT3SOzRES7RA4AAAAAAACqqqq6S7S7ROQAAAAAAAAA4O5LRLTuS+QOAAAAAAAAAADg7u7uu+sOAAAAAAAAAAAAAADu7u4OAAAAAAAAAA==\",\n  \"bigIceCream\": \"hwQgACAAAAAAAAAAAAAAAAAAAABERAAAAAAAAAAAAABARERE1V0EAAAAAAAwszMA1N1EVVXdRQAAAACwE9ERS93dVVRV1V0EAAAAOx3REd27XVVFVVXdRQAAANsd0R3R3VtVVVRV1U0AADMzHREdEd2xVVVFVVVNALPd3RMR3RHdEVtVVVRVRTDbEdHREdER3R2xVVVF1UWw3RERHR0RHdEd0VtVRd0EsN0REdHREdER3RFbVdXUBDDRHRHR0R0RHRHdsVXV1AQTER0R0dHdEdERMT1b1U0AExHREREd3RMR3REzW91NABMR0R0RHd09Ed0dMdvdTQATERHdEdHR3RMR3dGz3U0A273b0R3REd3TEd0Rs90EADvbERPdER3RPRHdHb1NAACwHRE90R3dET0d0R0xBAAAMBHd3RMd0R3dE9Ed0QMAABvREdET0RHd3dPRHREDAAAbHRER3REd0d0z0R0RAwAA0xEREd0RHdHdPdEd0QMAABMR3d3dEd0R3T3RHT0AAAAT0R0R3R3REd093REzAAAAE9ET3d0d0RHdvd0xAwAAANMR093dE9HR3bM7AwAAAAAwET3TPRPRMd27AAAAAAAAMBExuzsR3T09CwAAAAAAAAATEbMAM90zuwAAAAAAAAAAMB3RCwC7uwAAAAAAAAAAAAAzuwAAAAAAAAAAAAAAAA==\",\n  \"plate\": \"hwQxABgAAAAAAAAAsLu7CwAAAAAAAACw2xERvQsAAAAAAADbEREREb0AAAAAALAdEREREdELAAAAANsRERERERG9AAAAABsRERERERGxAAAAsB0REd0dERHRCwAAsBER3dHdERERCwAA2xHREd3dHRERvQAAGxHd0d3d3RERvQAAGxEd0d3d3R0RsQCwHdEd3RER3RsR0QuwEdERHRER0dsR0QuwEdHRHREREb0REQuwER3REREREb0dEQvbER3dEREREdEbEQvbER3dEREREdEbEb0b0REdEREREREbEb0b0REdERERERHbEb0b0REdERERERG7EbEb0REdERERERG7EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERG9EbEb0REdERERERHdEbEb0REdERERERHdEbEb0REdERERERHdEb0bER0dEREREREdEb3bER3dEREREdEdEb3bER3dEREREdEdEQuwER3REREREd0dEQuwEdHRHREREb0REQuwEdERHRER0b0R0QuwHdEd3RER3dsR0QsAGxEd0d3d3RsRsQAAGxHd0d3dvR0RvQAA2xHREd3d2xERvQAAsBERHdG7HRERCwAAsB0REd0dERHRCwAAABsRERERERGxAAAAANsRERERERG9AAAAALAdEREREdELAAAAAADbEREREb0AAAAAAACw2xERvQsAAAAAAAAAsLu7CwAAAAA=\"\n}",
            "bigFood.ts": "namespace sprites.food {\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigBurger = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigDrumstick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigHam = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigPizza = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigTaco = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigCake = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigDonut = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigIceCream = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const plate = image.ofBuffer(hex``);\n}\n",
            "ns.ts": "//% color=#8854d0\nnamespace game {\n    /**\n     * Reset the current game. This is usually equivalent to pressing\n     * the reset button to restart the current program\n     */\n    //% blockId=arcade_game_reset block=\"reset game\"\n    //% group=\"Gameplay\" weight=10\n    //% help=game/reset\n    export function reset() {\n        control.reset();\n    }\n}\n\n//% color=\"#4b6584\"\nnamespace scene {\n\n}\n\n//% color=\"#cf6a87\"\nnamespace info {\n\n}\n\n//% color=#E30FC0\nnamespace music {\n\n}\n\n//% color=#B09EFF\nnamespace player {\n\n}\n\n//% color=#FF5722 weight=90 advanced=true\nnamespace control {\n\n}\n",
            "pxt.json": "{\n  \"name\": \"device\",\n  \"description\": \"The fantasy game console library\",\n  \"files\": [\n    \"README.md\",\n    \"ns.ts\",\n    \"smallFood.jres\",\n    \"smallFood.ts\",\n    \"bigFood.jres\",\n    \"bigFood.ts\",\n    \"sprites.duck.jres\",\n    \"sprites.duck.ts\",\n    \"sprites.castle.jres\",\n    \"sprites.castle.ts\",\n    \"sprites.builtin.jres\",\n    \"sprites.builtin.ts\",\n    \"sprites.dialog.jres\",\n    \"sprites.dialog.ts\",\n    \"sprites.dungeon.jres\",\n    \"sprites.dungeon.ts\",\n    \"sprites.space.jres\",\n    \"sprites.space.ts\",\n    \"sprites.vehicle.ts\",\n    \"sprites.vehicle.jres\",\n    \"startup.ts\",\n    \"pxtsnippets.json\"\n  ],\n  \"core\": true,\n  \"dependencies\": {\n    \"hw\": \"*\"\n  },\n  \"palette\": [\n    \"#000000\",\n    \"#ffffff\",\n    \"#ff2121\",\n    \"#ff93c4\",\n    \"#ff8135\",\n    \"#fff609\",\n    \"#249ca3\",\n    \"#78dc52\",\n    \"#003fad\",\n    \"#87f2ff\",\n    \"#8e2ec4\",\n    \"#a4839f\",\n    \"#5c406c\",\n    \"#e5cdc4\",\n    \"#91463d\",\n    \"#000000\"\n  ],\n  \"screenSize\": {\n    \"width\": 160,\n    \"height\": 120\n  },\n  \"public\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "pxtsnippets.json": "[{\n    \"name\": \"Sprite Builder\",\n    \"namespace\": \"sprites\",\n    \"group\": \"Create\",\n    \"label\": \"Create a sprite...\",\n    \"outputType\": \"blocks\",\n    \"initialOutput\": \"let $spriteName = sprites.create($spriteImage, $spriteKind)\",\n    \"questions\": [\n        {\n            \"title\": \"What should your sprite be called?\",\n            \"inputs\": [{\n                    \"answerToken\": \"spriteName\",\n                    \"defaultAnswer\": \"mySprite\",\n                    \"type\": \"text\"\n            }],\n            \"output\": \"\",\n            \"goto\": {\n                \"question\": 2\n            },\n            \"hint\": \"This answer will be used to set a name for your sprite. This name will be used whenever your game needs to change, destroy, or build your sprite. Read more at makecode.com/docs/setsprite\"\n        },\n        {\n            \"title\": \"Where should your sprite be placed?\",\n            \"inputs\": [\n                {\n                    \"label\": \"x:\",\n                    \"defaultAnswer\": 80,\n                    \"answerToken\": \"xLocation\",\n                    \"type\": \"number\",\n                    \"min\": 0,\n                    \"max\": 160\n                },\n                {\n                    \"label\": \"y:\",\n                    \"defaultAnswer\": 60,\n                    \"answerToken\": \"yLocation\",\n                    \"type\": \"number\",\n                    \"min\": 0,\n                    \"max\": 120\n                }\n            ],\n            \"output\": \"$spriteName.setPosition($xLocation,$yLocation)\",\n            \"goto\": {\n                \"question\": 3\n            }\n        },\n        {\n            \"title\": \"What should your sprite look like?\",\n            \"inputs\": [\n                {\n                    \"answerToken\": \"spriteImage\",\n                    \"type\": \"spriteEditor\",\n                    \"defaultAnswer\": \"img`\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n. . . . . . . . . . . . . . . .\\n`\"\n                }\n            ],\n            \"goto\": {\n                \"question\": 1\n            }\n        },\n        {\n            \"title\": \"What kind of sprite should this be?\",\n            \"inputs\": [\n                {\n                    \"answerToken\": \"spriteKind\",\n                    \"defaultAnswer\": \"SpriteKind.Player\",\n                    \"type\": \"dropdown\",\n                    \"options\": {\n                        \"SpriteKind.Player\": \"Player\",\n                         \"SpriteKind.Enemy\": \"Enemy\",\n                        \"SpriteKind.Food\": \"Food\",\n                        \"SpriteKind.Projectile\": \"Projectile\"\n                    } \n                }\n            ],\n            \"goto\": {\n                \"question\": 4,\n                \"parameters\": {\n                    \"spriteKind\": 0\n                }\n            }\n        },\n        {\n            \"title\": \"How many lives should your player have?\",\n            \"inputs\": [\n                {\n                    \"answerToken\": \"gameLives\",\n                    \"defaultAnswer\": 3,\n                    \"max\": 20,\n                    \"type\": \"number\"\n                }\n            ],\n            \"output\": \"info.setLife($gameLives)\",\n            \"goto\": {\n                \"question\": 5\n            }\n        },\n        {\n            \"title\": \"How should your sprite move?\",\n            \"inputs\": [\n                {\n                    \"answerToken\": \"moveX\",\n                    \"type\": \"number\",\n                    \"label\": \"vx\",\n                    \"defaultAnswer\": 100,\n                    \"max\": 500\n                },\n                {\n                    \"answerToken\": \"moveY\",\n                    \"type\": \"number\",\n                    \"label\": \"vy\",\n                    \"defaultAnswer\": 100,\n                    \"max\": 500\n                }\n            ],\n            \"output\": \"controller.moveSprite($spriteName, $moveX, $moveY)\"\n        }\n    ]\n}]",
            "smallFood.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.food\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"smallBurger\": \"hwQQABAAAAAAAO4OiO7uAADsu+t3xusOwExEuy5mvg7AREVE7nLoy7xERETrYsjLTERERORizMRMREVE5HLsxEtERETkcujES0VEVORy6ORLRERE5GLs5EtERETkYuzku1REROtyzOSwRFRE7mLo5LBLRLQuxr4OAOxL63bM6w4AAOwOiO7uAA==\",\n  \"smallApple\": \"hwQQABAAAAAAAMDMzAwAAADA7O7u7gIAAOzu7u7uLgAA7u4iIuLuAuDuLiIiIuIC4O4iIiIiIi7g7i4iIiIiLs7MLCIiIiLkfGcsIiIiIuR37iIiIiIi5ODiRCIiIkLi4CJVJCIiQg4ALlQkIiIkDgAuIiIiROIAAOAuIiLiDgAAAODu7g4AAA==\",\n  \"smallLemon\": \"hwQQABAAAABEC7DMzAAAAFS0S91EzAAAVFVdRdVEDABAVVVVVdXEAEBRVVVFVUQMVFVVVV1FTQxUEVVV1VVEy1QRVVVV3UTEVFFVVVVNRMRUVVVVVU1ExEAVVVVV1UTLQBVRVVVVTcsAVBFVVVVdtABAVRVVVVW1AABEVVVFXUQAAABERMtMBA==\",\n  \"smallDrumstick\": \"hwQQABAAAAAAIiIiAAAAACCyuysCAAAAskREtOsAAABCREREuw4AAEtERES7DgAAS0RERLTrAABLTUREtOQAAEtNRES05AAAS9RERLvrAACwRE1Eu+4AAAC7RLTr7gAAAAC77u6+ywwAAAAAANsRwQAAAAAAsNHLAAAAAACw0QwAAAAAAAC7AA==\",\n  \"smallHam\": \"hwQQABAAAAAAAAAiIu4OAAAAItPd3eMAACATMTPTPQ4AMtE9MzMT4yATM9MzMxPjIN0zExEz0eMyMTMxE93d4zIxMxExMx3jMj3TMzMzE+My3T0zMzMd6yDTMTMzHbHu4DITERE9u+4A7jszu7vr7gAAvkRERO4OAACwS0S07gAAAAC77u4AAA==\",\n  \"smallPizza\": \"hwQQABAAAAAAAAAAAAC7RAAAAAAAu11NAAAAALsjU00AAAC7XSJSTQAAu11XI10EALA9MlVV1QS7SyUiVVfVBEu7NTJVVUUAS7RVVSNTTQBLtFRXIlJNALBES1UjU00AAEvkVFXVBAAAsETuVd0EAAAAS+Te7QAAAACw5O5OAAAAAADu7gQAAA==\",\n  \"smallDonut\": \"hwQQABAAAAAAAAC7q6oAAAAAuzMzow4AALAzMzMz6gAA2z0zMzPqDrDdMzMzM7oOsD0zszPTug7bPTOqM9NKDtszozoz00oO2zOjMzOtRA47MzszM61EDjozMzPTSrQOOjMzM61E5ACgMzPdSkTuAKA6M6pE5A4AAKqqRETuAAAAALu77gAAAA==\",\n  \"smallCake\": \"hwQQABAAAAAAALC7u7sLAAAAsLM9MwsAAAA7s9XTCwAAADuz1VOzAACwM71VU70AALAzvVVTtQAAOzO9XTM1CwA7Mz1bPdULsO4z01s1VQvgIz7TWzVVC+siPtNaNVWzO+4z09o9Vb07MzPT2r3dvbA6M93avd2tAKA6Pdq9O6sAAKCqqqqqCg==\",\n  \"smallIceCream\": \"hwQQABAAAAAAAAAAAEREAAAAM0tEXVUEADARvdTdVUUA0xERvVVdRTDdHRHRW9VFExHRERG91QQTEREdEbHdBNsREdER0dsEM90R0RERSwDT0R0RERFLAB0RHREdEb0AHRHRER0RPQATHRERHdEDABMzG9E7MwAAMDEwMwsAAAAAMwAAAAAAAA==\",\n  \"smallStrawberry\": \"hwQQABAAAAAAAADu7u7uDgAA7iIiIu7OAOAiREQk4s4ALkJFIiLuwgAuRCIiIiLOAC4kIkIi4s6AKGJmJiIkzGbod3cmIiLOYIZ3ZyJC4gwAZncmQuLuDABgZyIiIu4MAHZ3Zy7izgBgZ2h35+4MAIAIhnZ3zAAAAACAYGYGAAAAAAAAAAAAAA==\",\n  \"smallCherries\": \"hwQQABAAAAAAAODuDAAAAAAALiLCAAAAAOBC4i4MAAAA4CXi7uIAAADgJCLiwgAAAOAiIuLCAAAAyC4iIu4AAABoLCLizswAAGjI7C4i4gxghwDgQiLuzmCHAOAlIu7CdggA4CQi4sJ2iGbIIiLiwnZ2d2YsIu7CdoiIiMgiIgyGCAAAAO7MAA==\",\n  \"smallTaco\": \"hwQQABAAAAAAAADg7u5OAAAA4E5VVVUEAABeVczsTkUA4GWGzszuRABeImfoVVXl4GQiZ1VFVeXgZYdYRVVV5E52hlVVRVUOXiJWVFRV5QBeIlRVVVXkAF5nVVRFVQ4A4EZVVVXlAADgRlVFVeQAAABORVVVDgAAAOBUVeUAAAAAAEBEBAAAAA==\"\n}",
            "smallFood.ts": "namespace sprites.food {\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallBurger = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallApple = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallLemon = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallDrumstick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallHam = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallPizza = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallDonut = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallCake = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallIceCream = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallStrawberry = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallCherries = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallTaco = image.ofBuffer(hex``);\n}\n",
            "sprites.builtin.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.builtin\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"bed0\": \"hwQQABgAAAAAAADw///////MDAAAy/xvxrvb3d29zQ+w3btrtrvd3d3bzfvbvczMvDMRERHbzfvbG83dPNMRERHdzQ/cGxvROxMREdHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxvROxMREdHdzQsbG83dPNMRERHdzQ/bvczMvDMRERHbzfuw3btrtrvd3d3bzfsAy/xvxrvb3d29zQ8AAADw///////PDAA=\",\n  \"bed1\": \"hwQQABgAAAAAAADw///////MDAAAy/xvxrvb3d29zQ+w3bvMtrvd3d3bzfvbvbzdvDMRERHbzfvbG9vRO9MRERHdzQ/cGxsROxMREdHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxsROxMREbHdzQvcGxsROxMREdHdzQsbG9vRO9MRERHdzQ/bvbzdvDMRERHbzfuw3bvMvLvd3d3bzfsAy/xvxrvb3d29zQ8AAADw///////PDAA=\",\n  \"bed2\": \"hwQQABgAAAAAAADw///////MDAAAy8xvxrvb3d3LzA+w3btrvLvd3b3dy/vbvbvMvDMREdu9zPvbu8vdPNMREdu7zA/cuxzROxMREdy7zAvcuxwROxMREdy7zAvcuxwROxMREdy7zAvcuxwROxMREdy7zAvcuxwROxMREdy7zAvcuxzROxMREdy7zAsbu8vdPNMRERu7zA/bvbvMvDMREdu9zPuw3btrvLvd3b3dy/sAy8xvxrvb3d3LzA8AAADw///////PDAA=\",\n  \"brick\": \"hwQQABAAAADdHd0d3R3dHRER3R0REd0d3R3dHd0d3R3dHd0d3R3dHd0d3R3dHd0d3R0REd0dERHdHd0d3R3dHd0d3R3dHd0d3R3dHd0d3R0REd0dERHdHd0d3R3dHd0d3R3dHd0d3R3dHd0d3R3dHd0dERHdHRER3R3dHd0d3R3dHd0d3R3dHQ==\",\n  \"cat0\": \"hwQOAA4AAADOzO/+DwAAAN472937//8A3r3T3y3b/QDA3d39Ld0PAADf3d0r3Q8AAL/d3Svd/wDA3d39Ld39AN69098tvQ8A3jvb3bLdDwDOzO/+v9v9AAAAAADw+/8AAAAA+//9AAAAAADf3fsAAAAAAPv/DwAA\",\n  \"cat1\": \"hwQOAA4AAADgzPzu/wAAAOC9s929/w8A4N07/d3S/QAA3N3d39L7AADw3d290v0AAPDb3b3S/wAA3N3d39IPAODdO/3d0g8A4L2z3S3d/QDgzPzuv/v/AAAAALD//QAAAAAA8N37AAAAAACw/w8AAAAAAAAAAAAA\",\n  \"cat2\": \"hwQOAA4AAADgzPzu/wAAAOC9s929/wAA4N07/d3SDwAA3N3d39L9AADw3d290vsAAPDb3b3S/QAA3N3d39L/AODdO/3d0v0A4L2z3S3d/wDgzPzuv/sAAAAAAADw+wAAAAAAsP/9AAAAAADw3fsAAAAAALD/DwAA\",\n  \"computer0\": \"hwQQABAAAAAAwMzMzMzMzAAc3d3dERHLABzNu7sb3csAHM29u9sdywAczbu7Gx3LABzNu7sb3csAHM27u9sdywAczbu7Gx3LABzNu7sb3csAHM27u9sdywAczbu7Gx3LABzNu7sb3csAHN3d3RERywDAzMzMzMzMAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"computer1\": \"hwQQABAAAAAAAAAAAMDMzAC7u7u7vBHLsNHd3d3L3csbsczMzMsdy9vBZmbGyx3L28HWZsbL3cvbwWZmxssdy9vBZmbGyx3L28FmZsbL3cvbwWZmxssdy9vBZmbGyx3LG7HMzMzL3cuw0d3d3csdywC7u7u7vBHLAAAAAADAzMwAAAAAAAAAAA==\",\n  \"console\": \"hwQKAAgAAACwy8wMGxERyxsREcsbERHLu93dzbvd3c0bERHLGxERyxsREcuwu8sM\",\n  \"couchFront0\": \"hwQYABAAAAAAAADMzMzMDADMzNvdvcwMwN3d293du8y83bvLzMy7vNy9u7zd3bu83L273N3du8zcvbvc3d27DNy9u9zd3bsM3L273N3duwzcvbvc3d27DNy9u9zd3bsM3L273N3duwzcvbvc3d27DNy9u9zd3bsM3L273N3duwzcvbvc3d27DNy9u9zd3bsM3L273N3duwzcvbvc3d27zNy9u7zd3bu8vN27y8zMu7zA3d3b3d27zADMzNvdvcwMAAAAzMzMzAw=\",\n  \"couchFront1\": \"hwQYABAAAAAAAADMzMzMDADMzFNVNcwMwFVVU1VVM8zcVTPDzMwzvFw1MzxVVTO8XDUzXFVVM8xcNTNcVVUzDFw1M1xVVTMMXDUzXFVVMwxcNTNcVVUzDFw1M1xVVTMMXDUzXFVVMwxcNTNcVVUzDFw1M1xVVTMMXDUzXFVVMwxcNTNcVVUzDFw1M1xVVTMMXDUzXFVVMwxcNTNcVVUzzFw1MzxVVTO83FUzw8zMM7zAVVVTVVUzzADMzFNVNcwMAAAAzMzMzAw=\",\n  \"couchSide0\": \"hwQPABgAAAAAzMzMzMzMzMzMzADAu7u7u7u7u7u7u8zc3d3d3d3d3bu7u7zc3d3d3d3d3bu7u7zc3d3d3d3dvbu7u8y8u7u7u7u7u7u7uwzAzMzMzMzMzMzMzAwAvL3c3d3d3by9uwwA3L3c3d3d3dy9uwwA3L3c3d3d3dy9uwwA3L3c3d3d3dy9u8wA3L283d3d3dy9u7wA3LvLu7u7u9y7u7wAwLvLzMzMzMy7u8wAAMzMAAAAAADMzAw=\",\n  \"couchSide1\": \"hwQPABgAAAAAzMzMzMzMzMzMzADAMzMzMzMzMzMzM8xcVVVVVVVVVTMzM7xcVVVVVVVVVTMzM7xcVVVVVVVVNTMzM8w8MzMzMzMzMzMzMwzAzMzMzMzMzMzMzAwAPDVcVVVVVTw1MwwAXDVcVVVVVVw1MwwAXDVcVVVVVVw1MwwAXDVcVVVVVVw1M8wAXDU8VVVVVVw1M7wAXDPDMzMzM1wzM7wAwDPDzMzMzMwzM8wAAMzMAAAAAADMzAw=\",\n  \"couchSide2\": \"hwQPABgAAAAAzMzMzMzMzMzMzADAZmZmZmZmZmZmZsx8d3d3d3d3d2ZmZrx8d3d3d3d3d2ZmZrx8d3d3d3d3Z2ZmZsxsZmZmZmZmZmZmZgzAzMzMzMzMzMzMzAwAbGd8d3d3d2xnZgwAfGd8d3d3d3xnZgwAfGd8d3d3d3xnZgwAfGd8d3d3d3xnZswAfGdsd3d3d3xnZrwAfGbGZmZmZnxmZrwAwGbGzMzMzMxmZswAAMzMAAAAAADMzAw=\",\n  \"dog0\": \"hwQQAA4AAAAARA4AAAAAAEBV5QAAAAAAVFXk/g8AAABURVRV9P//AFRFVV9lVPUA4FVVVWVVDwAAXlVFb1UPAABeVUVvVf8A4FVVVWVV9QBURVVfZUUPAFRFVFVGVQ8AVFXk/k9U9QBAVeUA8PT/AABEDgBf9QAAAAAA8FUPAAAAAADw/wAAAA==\",\n  \"dog1\": \"hwQQAA4AAAAAQOQAAAAAAABUVQ4AAAAAQFVF7g8AAABAVURVRf//AEBVVPVVVvUAAF5VVVVW9AAA4FVV9Fb1AADgVVX0Vv8AAF5VVVVWDwBAVVT1VVYPAEBVRFVlVPUAQFVF7v/0/wAAVFUO8PQAAABA5ABf9QAAAAAAAP8PAAAAAAAAAAAAAA==\",\n  \"dog2\": \"hwQQAA4AAAAAQOQAAAAAAABUVQ4AAAAAQFVF7g8AAABAVURVRf8AAEBVVPVVVg8AAF5VVVVW9QAA4FVV9Fb0AADgVVX0VvUAAF5VVVVW/wBAVVT1VVb1AEBVRFVlVP8AQFVF7v9P/wAAVFUO8FUPAABA5ABf9QAAAAAAAP8PAAAAAAAAAAAAAA==\",\n  \"furnitureRug\": \"hwQgABgAAAAAu7u7u7u7u7u7uwAwOzs7Ozs7Ozs7OwvTPTs7Ozs7Ozs73QvbPd3d3d3d3d093bsz0z0zMzMzMzPdM7O73TMzMzMzMzPTvbszPTMzMzMzMzMzPbO7PdMzMzPTMzMzvbszPTMzMzMzMzMzPbO7PTMzMzMzMzMzvbszPTMzMzMzMzMzPbO7PTMz0zMzM9MzvbszPTMzMzMzMzMzPbO7PTMzMzMzMzMzvbszPTMzMzMzMzMzPbO7PdMzMzPTMzMzvbszPTMzMzMzMzMzPbO7PTMzMzMzMzMzvbszPTMzMzMzMzMzPbO7PTMz0zMzMzMzvbszPTMzMzMzM9MzPbO7PTMzMzMzMzMzvbszPTMzMzMzMzMzPbO7PdMzMzPTMzMzvbszPTMzMzMzMzMzPbO7PTMzMzMzMzMzvbsz3TMzMzMzMzPTPbO70z0zMzMzMzPds7vTPd3d3d3d3d093bPbPTs7Ozs7Ozs73QswOzs7Ozs7Ozs7OwsAu7u7u7u7u7u7uwA=\",\n  \"furnitureTable1\": \"hwQgABgAAAAAzMzMzMzMzMzMAACwvd293b3dvb27DADcvd293T3dvd27zAzcvd093T3dvd27vMPcPd093T3dvd27vMPc3d3d3d3dvd27zAzc3d3d3d3dvd27DADc3d3d3d3dPd27DADcPd3d3d3dPd27DADcPd093T3dPd27DADc3d293d3dPd27DADcPd293b3dPd27DADc3d093T3dPd27DADc3d093d3dPd27DADc3d3d3d3d3d27DADc3d093d3d3d27DADcPd093d3d3d27DADcPd3d3d3d3d27DADcPd3d3d3dPd27DADcPd093d3dPd27DADc3d093d3dPd27DADc3d3d3T3d3d27DADc3d3d3T3dPd27DADc3d3d3T3d3d27DADcPd093T3d3d27DADc3d093T3d3d27DADcPd093d3d3d27zAzcPd093d3dPd27vMPcPd093d3dPd27vMPcvd293T3dvd27zAywvd293b3dvb27DAAAzMzMzMzMzMzMAAA=\",\n  \"furnitureTable2\": \"hwQgABgAAAAAzMzMzMzMzMwMAACwMzMzMzMzuzvDAAA8MzMzMzMzs7vLzAw8ExERERExM7u7vMM8ETMzMzMRM7vDvMM8MTMzMzMTM7vDzAw8MTMzMzMTM7vDDAA8MTMzMzMTM7u7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7u7DAA8MTMzMzMTM7vDDAA8MTMzMzMTM7vDDAA8MTMzMzMTM7vDDAA8MTMzMzMTM7u7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7u7DAA8MTMzMzMTM7vDDAA8MTMzMzMTM7vDDAA8MTMzMzMTM7vDDAA8MTMzMzMTM7u7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7s7DAA8MTMzMzMTM7u7DAA8MTMzMzMTM7vDDAA8MTMzMzMTM7vDzAw8ETMzMzMRM7vDvMM8ExERERExM7u7vMM8MzMzMzMzs7vLzAwAMzMzMzMzuzvDAAAAzMzMzMzMzMwMAAA=\",\n  \"largeShelf\": \"hwQYABgAAADAzMzMzMz///////+83d29zLvb3d3d3f3c3d3d+8zM/MzMzP/c3d3d+8zM+8zMu//c3d3d+zPD+8zMu//c3d3d+zPD/WbG3f/c3d3d+8zM/czM3f/c3d3d+2bG/TPD3f/c3d3d+8zM/TPD3f/c3d3d+0TE/czM3f/c3d3d+0TE/UTM3f/c3d3d+8zM/czM3f/c3d3d+zPM/WbG3f/c3d3d+8zM/czM3f/c3d3d+3fH/UTE3f/c3d3d+8zM/UTE3f/c3d3d+2bG/czM3f/c3d3d+2bG/TPM3f/c3d3d+8zM/czM3f/c3d3d+zPD+3fHu//c3d3d+8zM+8zMu//c3d3d+8zM/MzMzP+83d29zLvb3d3d3f3AzMzMzMz///////8=\",\n  \"smallShelf0\": \"hwQQABgAAADAzMzMzMz///////+83d3dvbu7u7u7u/vc3d3du83MvM3MvP/c3d3du727vL27vP/c3d3du727vL27vP/c3d3du727vL27vP/c3d3du828vM28vP/c3d3du73NvL3NvP/c3d3du73NvL3NvP/c3d3du828vM28vP/c3d3du727vL27vP/c3d3du727vL27vP/c3d3du727vL27vP/c3d3du83MvM3MvP+83d3dvbu7u7u7u/vAzMzMzMz///////8=\",\n  \"smallShelf1\": \"hwQQABgAAADAzMzMzMz///////+8d3d3Z2ZmZmZmZvZ8d3d3ZsfMbMfMbP98d3d3ZmdmbGdmbP98d3d3ZmdmbGdmbP98d3d3ZmdmbGdmbP98d3d3ZsdsbMdsbP98d3d3ZmfNbGfNbP98d3d3ZmfNbGfNbP98d3d3ZsdsbMdsbP98d3d3ZmdmbGdmbP98d3d3ZmdmbGdmbP98d3d3ZmdmbGdmbP98d3d3ZsfMbMfMbP+8d3d3Z2ZmZmZmZvbAzMzMzMz///////8=\",\n  \"smallShelf2\": \"hwQQABgAAADAzMzMzMz///////+83d29zLvb3d3d3f3c3d3d+8zM/MzMzP/c3d3d+0TE+8zMu//c3d3d+0TE+0TMu//c3d3d+8zM/czM3f/c3d3d+3fH/UTE3f/c3d3d+8zM/UTE3f/c3d3d+2bG/czM3f/c3d3d+2bG/TPM3f/c3d3d+8zM/czM3f/c3d3d+zPD+3fHu//c3d3d+8zM+8zMu//c3d3d+8zM/MzMzP+83d29zLvb3d3d3f3AzMzMzMz///////8=\",\n  \"tv\": \"hwQQABYAAAAAAAAAAADw/////wAAu7u7u7vMu7u7+wCwEd3d3d3Ly8y8/wAbEc3MzNzL27u8/wAbEWxmZsbL27u8/wAbEWzRZsbL27u8/wAbEWxtZsbL27u8/wAbEWxmZsbL27u8/wAbEWxmZsbL27u8/wAbEWxmZsbL27u8/wAbEWxmZsbL27u8/wAbEWxmZsbL27u8/wAbEc3MzNzL27u8/wCwEd3d3d3L28y8/wAAu7u7u7vMu7u7+wAAAAAAAADw/////wA=\",\n  \"villager1WalkFront1\": \"hwQOABAAAADw/wAAAAAAAP////8P4EQA///D//9OTQD/z8P89P//APA7zLzRvmP/z8zM9N80Y//PzExE3TRjD8/MTETdNGMPz8zM9N80Y//wO8y80b5j///Pw/z0//wA///D//9OTQD/////D+BEAPD/AAAAAAAA\",\n  \"villager1WalkFront2\": \"hwQOABAAAAAA/w8AAAAAAPD/////8A4A8P8//P/vBADw/zzMT////wC/w8wb/Wv/8MzMTP+9Y//wzMxE1L1jD/DMzETUvWMP8MzMTP/t/g8Av8PMG9TtD/D/PMxP3u0A8P8//P9PDgDw/////+4AAAD/DwAAAAAA\",\n  \"villager1WalkFront3\": \"hwQOABAAAAAA/w8AAAAAAPD/////7gAA8P8//P9PDgDw/zzMT97tAAC/w8wb1O0P8MzMTP/t/g/wzMxE1L1jD/DMzETUvWMP8MzMTP+9a/8Av8PMG/1u//D/PMxP////8P8//P/vBADw//////AOAAD/DwAAAAAA\",\n  \"villager1WalkBack1\": \"hwQOABAAAADw/wAAAAAAAP////8P4EQA///D//9OTQD/z8P8////APA7zMz//2P/z8zMzP//Y//PzMzM//9jD8/MzMz//2MPz8zMzP//Y//wO8zM//9j///Pw/z///wA///D//9OTQD/////D+BEAPD/AAAAAAAA\",\n  \"villager1WalkBack2\": \"hwQOABAAAAAA/w8AAAAAAPD/////AAAA8P8//P/vTg7w/zzM/P///wC/w8z8/z//8MzMzPz/P//wzMzM/P8/D/DMzMz8/z8P8MzMzPz/Pw8Av8PM///vDvD/PMz//98O8P8////v1ATw/////wBOAAD/DwAAAAAA\",\n  \"villager1WalkBack3\": \"hwQOABAAAAAA/w8AAAAAAPD/////AE4A8P8////v1ATw/zzM///fDgC/w8z//+8O8MzMzPz/Pw/wzMzM/P8/D/DMzMz8/z8P8MzMzPz/P/8Av8PM/P8///D/PMz8////8P8//P/vTg7w/////wAAAAD/DwAAAAAA\",\n  \"villager1WalkLeft1\": \"hwQOABAAAAAAAAAAAAAAAAAA//8AAAAAAP/M/w8AAADwzMzu////AP/MTETdPmMPz8zMRN00Yw/PzMz83zRj/8/MzLzR5P7/z8zM/ETe7f/wO8xP/d7tD//P80/0T/4A///z//8AAAD/////AAAAAPD/AAAAAAAA\",\n  \"villager1WalkLeft2\": \"hwQOABAAAAAAAAAAAAAAAAAA8P8PAAAAAPDP/P8A8A8Az8zM//////DPzETU7WP/8MzMTNRNY//wzMzM/+3+D/DMzMwb3u0P8MzMzE/e7Q8Av8P81E/+//D/PP9E////8P8///8P8A/w////DwAAAAD/DwAAAAAA\",\n  \"villager1WalkLeft3\": \"hwQOABAAAAAAAAAAAAAAAAAA8P8PAAAAAPDP/P8A8A8Az8zMz/////DPzETU7WP/8MzMTNRNY//wzMzM/01jD/DMzMwbTWMP8MzMzE/k/g8Av8P81N/t//D/PP9E3+3/8P8///9P/g/w/////wAAAAD/DwAAAAAA\",\n  \"villager1WalkRight1\": \"hwQOABAAAAAA/w8AAAAAAPD/////AAAA8P8///9P/g/w/zz/RN/t/wC/w/zU3+3/8MzMzE/k/g/wzMzMG01jD/DMzMz/TWMP8MzMTNRNY//wz8xE1O1j/wDPzMzP////APDP/P8A8A8AAPD/DwAAAAAAAAAAAAAA\",\n  \"villager1WalkRight2\": \"hwQOABAAAAAA/w8AAAAAAPD///8PAAAA8P8///8P8A/w/zz/RP///wC/w/zUT/7/8MzMzE/e7Q/wzMzMG97tD/DMzMz/7f4P8MzMTNRNY//wz8xE1O1j/wDPzMz/////APDP/P8A8A8AAPD/DwAAAAAAAAAAAAAA\",\n  \"villager1WalkRight3\": \"hwQOABAAAADw/wAAAAAAAP////8AAAAA///z//8AAAD/z/NP9E/+APA7zE/93u0Pz8zM/ETe7f/PzMy80eT+/8/MzPzfNGP/z8zMRN00Yw//zExE3T5jD/DMzO7///8AAP/M/w8AAAAAAP//AAAAAAAAAAAAAAAA\",\n  \"villager2WalkFront1\": \"hwQNABAAAAAA8M//APDuAAD/z///7+QA8P/P/+T//wDw//y/Qb9n//////9Pfmf/////7kR+Zw//z+/uRH5nD//M7/9Pfmf/8P//v0G/Z//w///85P//AAD/z/z/7+QAAMDM/wDw7gAAAAAAAAAAAA==\",\n  \"villager2WalkFront2\": \"hwQNABAAAAAAAP8AAAAAAAAA//z/8A4AAPD//P/vBAAA///8T/7//wD/z/8btGf/8P////90Z//w///vTnRnD/D//O5OdGcP8M/8/v/kbg8A////G07kDwD//89PTuQAAPD/zP9PDgAAAMz8/+4AAA==\",\n  \"villager2WalkFront3\": \"hwQNABAAAAAAAMz8/+4AAADw/8z/Tw4AAP//z09O5AAA////G07kD/DP/P7/5G4P8P/87k50Zw/w///vTnRnD/D/////dGf/AP/P/xu0Z/8A///8T/7//wDw//z/7wQAAAD//P/wDgAAAP8AAAAAAA==\",\n  \"villager2WalkBack1\": \"hwQNABAAAAAA8P//D/DuAAD/////7+QA8M/8/////wDwzPz///9n/8/M//z//2f/z8zM/P//Zw/PzMz8//9nD8/MzP///2f/8Mz8/P//Z//wz8z8///8AAD/zP//7+QAAPD//w/w7gAAAAAAAAAAAA==\",\n  \"villager2WalkBack2\": \"hwQNABAAAAAAAP8AAAAAAADwz///AAAAAPDM///vTg4A/8z////P/wDPzP///3//8Mz8zP//f//wzMzM//9/D/DMzPz//38P8MzMzP//fw8Az8zP///vDwD/zMz//08OAPDP/P//Tg4AAP///wDvAA==\",\n  \"villager2WalkBack3\": \"hwQNABAAAAAAAPAPAAAAAAAA//8PAO8AAPD//P//Tg4A/8/8//9PDgDPzPz//+8P8MzM//z/fw/wzMzM/P9/D/DMzMz//38P8MzMzP//f/8Az8z8/P9//wD/zMz//8//APDP/P/vTg4AAP///wAAAA==\",\n  \"villager2WalkLeft1\": \"hwQNABAAAAAAAP8AAAAAAAAA/w8AAAAAAP/8/wAAAADw//z/////APDP/+5Ef2cP//zv7kR+Zw//////T35n/////L9B7v7//8/8/+5O5P/////v9E7kD/D/z+/+7/4A8P/M//8AAAAA8P//AAAAAA==\",\n  \"villager2WalkLeft2\": \"hwQNABAAAAAAAPAPAAAAAAAA//8AAAAAAPDP//8A8A8A/8////////D//O9O9Gf/8M//7k7kZ//w/////+T+D/D/z/8bTuQP8P/M/+9O5A/w////Tu/+/wD///zu////AP/P/P8P8A8AAP//DwAAAA==\",\n  \"villager2WalkLeft3\": \"hwQNABAAAAAAAPAPAAAAAAAA//8PAAAAAPDP//8A8A8A/8////////D//O9O9Gf/8M//7k7kZ//w/////+RnD/D/z/8b5GcP8P/M/+/u/g/w////Tk/k/wD///zuT+T/AP/P/P9P/g8AAP///wAAAA==\",\n  \"villager2WalkRight1\": \"hwQNABAAAAAAAP///wAAAAD/z/z/T/4PAP///O5P5P/w////Tk/k//D/zP/v7v4P8P/P/xvkZw/w/////+RnD/DP/+5O5Gf/8P/87070Z/8A/8///////wDwz///APAPAAD//w8AAAAAAPAPAAAAAA==\",\n  \"villager2WalkRight2\": \"hwQNABAAAAAAAP//DwAAAAD/z/z/D/APAP///O7////w////Tu/+//D/zP/vTuQP8P/P/xtO5A/w/////+T+D/DP/+5O5Gf/8P/87070Z/8A/8///////wDwz///APAPAAD//wAAAAAAAPAPAAAAAA==\",\n  \"villager2WalkRight3\": \"hwQNABAAAAAA8P//AAAAAPD/zP//AAAA8P/P7/7v/gD////v9E7kD//P/P/uTuT////8v0Hu/v//////T35n///87+5EfmcP8M//7kR/Zw/w//z/////AAD//P8AAAAAAAD/DwAAAAAAAP8AAAAAAA==\",\n  \"villager3WalkFront1\": \"hwQMABAAAAAA8P//D+BEAAD//0T+T00A8P//TuT//wDw/kT03b5h/+9ORPTdFGH/7+5ERL0UYQ/v7k5EvRRhD+/u7vTdFGH/8P7v9N2+Yf/w//9O5P//AAD//0T+T00AAPD//w/gRAA=\",\n  \"villager3WalkFront2\": \"hwQMABAAAAAA8P////AOAAD//0/k/wQAAP//70T+///web.archive.org/web/20191229135125/https://w709e3+1r//DuRETfTWH/8O5ORNRLYQ/w7u5E1EthD/Du7k7fTf4P8O//Tt/U7Q8A///vRN7tAAD//0/kTw4AAPD////uAAA=\",\n  \"villager3WalkFront3\": \"hwQMABAAAAAA8P///+4AAAD//0/kTw4AAP//70Te7QDw709E39TtD/DuRETfTf4P8O5ORNRLYQ/w7u5E1EthD/Du7k7fTWH/8O//Tt/ta/8A///vRP7//wD//0/k/wQAAPD////wDgA=\",\n  \"villager3WalkBack1\": \"hwQMABAAAAAA8P//D+BEAAD/////Tk0A8O7//////wDw/u7//79t/+/u7v7/v23/7+7u/v+/bQ/v7u7+/79tD+/u7v7/v23/8O7u//+/bf/w7/7////8AAD/7v//Tk0AAPD//w/gRAA=\",\n  \"villager3WalkBack2\": \"hwQMABAAAAAAAP///wAAAADw/v//70QOAO/+/v////8A7+/u///b//Du7u7//9v/8O7u7v//2w/w7u7u///bD/Du7v7//9sPAO/u/v//7w4A/+7////eDgDw7/7/79QEAAD///8ATgA=\",\n  \"villager3WalkBack3\": \"hwQMABAAAAAAAP///wBOAADw////79QEAO/+////3g4A7+/////vDvDu7v7//9sP8O7u7v//2w/w7u7u///bD/Du7u7//9v/AO/u7v//2/8A/+7//////wDw7/7/70QOAAD///8AAAA=\",\n  \"villager3WalkLeft1\": \"hwQMABAAAAAA8P//AAAAAADv7v8PAAAA8O7u7v///wDv7kREvR5hD+/uTkS9FGEP7+7u9N0UYf/v7u703eT+/+/u70RE3u3/8P7/7/3e7Q/w//9P9E/+AAD/////AAAAAPD//wAAAAA=\",\n  \"villager3WalkLeft2\": \"hwQMABAAAAAAAP//AAAAAADw7v4PAPAPAO/u7v7////w7k5E1Oth//Du7kTUS2H/8O7uTt/t/g/w7u5O397tD/Du/k5E3u0P8O///95P/v8A////RP///wD/////D/APAPD//w8AAAA=\",\n  \"villager3WalkLeft3\": \"hwQMABAAAAAAAP//AAAAAADw7v4PAPAPAO/u7v7////w7k5E1Oth//Du7kTUS2H/8O7uTt9NYQ/w7u5O301hD/Du/k5E5P4P8O///97f7f8A////RN/t/wD/////T/4PAPD///8AAAA=\",\n  \"villager3WalkRight1\": \"hwQMABAAAAAA8P///wAAAAD/////T/4PAP///0Tf7f/w7///3t/t//Du/k5E5P4P8O7uTt9NYQ/w7u5O301hD/Du7kTUS2H/8O5ORNTrYf8A7+7u/v///wDw7v4PAPAPAAD//wAAAAA=\",\n  \"villager3WalkRight2\": \"hwQMABAAAAAA8P//DwAAAAD/////D/APAP///0T////w7///3k/+//Du/k5E3u0P8O7uTt/e7Q/w7u5O3+3+D/Du7kTUS2H/8O5ORNTrYf8A7+7u/v///wDw7v4PAPAPAAD//wAAAAA=\",\n  \"villager3WalkRight3\": \"hwQMABAAAAAA8P//AAAAAAD/////AAAA8P//T/RP/gDw/v/v/d7tD+/u70RE3u3/7+7u9N3k/v/v7u703RRh/+/uTkS9FGEP7+5ERL0eYQ/w7u7u////AADv7v8PAAAAAPD//wAAAAA=\",\n  \"villager4WalkFront1\": \"hwQOABAAAAAAAPD/DwAAAADwX7X770QAAF9VtbtO/Q/wVVX89P+8D/BVtbzRbjnzX1VN9N+UuftfVUtE3ZQ5s19VS0TdlLm7X1VN9N+UOfPwVbW80W658/BVVfz0/7wPAF9VtbtO/Q8A8F+1++9EAAAA8P8PAAAA\",\n  \"villager4WalkFront2\": \"hwQOABAAAAAAAMD//wwAAAAAv1W7z+4AAPBVVbvrxAwAX1XF78+8DABfVcsbbbnD8FXVRP+dObPwVbVE1J25u/BVtUTUnbnD8FXVRP9NtMsAX1XLG9TtwwBfVcXv1O0MAPBVVbvbxAwAAL9Vu88MAAAAwP//DAAA\",\n  \"villager4WalkFront3\": \"hwQOABAAAAAAAMD//wwAAAAAv1W7zwwAAPBVVbvbxAwAX1XF79TtDABfVcsb1O3D8FXVRP9NtMvwVbVE1J25w/BVtUTUnbm78FXVRP+dObMAX1XLG225wwBfVcXvz7wMAPBVVbvrxAwAAL9Vu8/uAAAAwP//DAAA\",\n  \"villager4WalkBack1\": \"hwQOABAAAAAAAPD//w8AAADwv7u7z0QAAN9VtbvL/Q/wXVVVu7u8D/BVVVW9uz/zX1VVVbW7v/tfVVVVtbs/s19VVVW1u7+7X1VVVbW7P/PwVVVVvbu/+/BdVVW7u7wPAN9VtbvL/Q8A8L+7u89EAAAA8P//AAAA\",\n  \"villager4WalkBack2\": \"hwQOABAAAAAAAPD///8EAAAA3727y00AAPBVVbu7xAwAX1VVtbu/DABfVVW1u7/D8FVVVbW7P7PwVVVVtbu/u/BVVVW1uz/D8FVVVb27v8sAX1VVu7tPywC/Vb27u9wEAPC7u7vL1A4AAP+7u89MAAAAAP//DAAA\",\n  \"villager4WalkBack3\": \"hwQOABAAAAAAAAD//wwAAAAA/7u7z0wAAPC7u7vL1A4Av1W9u7vcBABfVVW7u0/L8FVVVb27v8vwVVVVtbs/w/BVVVW1u7+78FVVVbW7P7MAX1VVtbu/wwBfVVW1u78MAPBVVbu7xAwAAN+9u8tNAAAA8P///wQA\",\n  \"villager4WalkLeft1\": \"hwQOABAAAAAA8P//AAAAAPBfVfUPAPAP8FXV+///web.archive.org/web/20191229135125/https://pw9fvute3zq5819vtutdlln7x1w1xnyuobncvvw80e6+u1xVVcxO3u3zXFVVtfve7fvwVVVVu0S+D/BVVVW7+/8PAF9VVbv7AAAAwFy1uwwAAAAA8P/MAAAA\",\n  \"villager4WalkLeft2\": \"hwQOABAAAAAAAP//AAAAAAD/VVUPAMAMAF9Vvf/MvMPwVbVE1E25y/BV1UTUTbnD8FVVS8xNubvAVVXFG+2+s8BVVcXs3u3DwFVVVbve7cMAX1VVtUu+ywBfVVW1u7wMAPBVVbW7zAAAAFxVu8sAAAAAwP/PDAAA\",\n  \"villager4WalkRight1\": \"hwQOABAAAAAAAPD/zAAAAADAXLW7DAAAAF9VVbv7AADwVVVVu/v/D/BVVVW7RL4PXFVVtfve7ftcVVXMTt7t81xVVbzR7r67X1W1xNyUObNfVU1E3ZS5+19VS0TdlDnz8FXV+///web.archive.org/web/20191229135125/https://pw/wX1X1DwDwDwDw//8AAAAA\",\n  \"villager4WalkRight2\": \"hwQOABAAAAAAAMD/zwwAAAAAXFW7ywAAAPBVVbW7zAAAX1VVtbu8DABfVVW1S77LwFVVVbve7cPAVVXF7N7tw8BVVcUb7b6z8FVVS8xNubvwVdVE1E25w/BVtUTUTbnLAF9Vvf/MvMMA/1VVDwDADAAA//8AAAAA\"\n}",
            "sprites.builtin.ts": "namespace sprites.builtin {\n    //% fixedInstance jres blockIdentity=images._image\n    export const bed0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bed1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bed2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const brick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const cat0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const cat1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const cat2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const computer0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const computer1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const console = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const couchFront0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const couchFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const couchSide0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const couchSide1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const couchSide2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const dog0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const dog1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const dog2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const furnitureRug = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const furnitureTable1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const furnitureTable2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const largeShelf = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallShelf0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallShelf1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallShelf2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tv = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager1WalkRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager2WalkRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager3WalkRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const villager4WalkRight2 = image.ofBuffer(hex``);\n}\n",
            "sprites.castle.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.castle\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"heroFrontAttack1\": \"hwQYABgAAAAAAAAA//D/AAAAAAAAAP//79+7DwAAAAAA8P/+7t+7/AAAAAAA/+/yT9+7/AAAAAAA/y7/G9+7/w8AAADwLy7v//3/9A8AAADwIi7v1E0i9QAAAADwIi7v1E0i9QAAAADwLy7v/00i9A8AAAAA/y7/G+0i9A8AAAAA/+/yT+7/DwAAAAAA8O/+7v7UBAAAAAAAAP//7w9OBAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroFrontAttack2\": \"hwQYABgAAAAAAAAAAP//AAAAAAAAAAAA/73LDwAAAAAAAP//7///DwAAAAAA8P/+7v4EAAAAAAAA/+/yT+7//8DMAAAA/y7/G+0i9N/NAADwLy7v/00i9N0MAADwIi7v1E3C3M0AAADwIi7v1E3C3QwAAADwLy7v/+3OzA8AAAAA/y7/G9Tt9A8AAAAA/+/yT97t/wAAAAAA8O/+7k8OAAAAAAAAAP//7+8AAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroFrontAttack3\": \"hwQYABgAAAAAAAAAAP//AAAAAAAAAAAA/73LDwAAAAAAAPD/////DwAAAAAAAP/v/u7vBAAAAAAAAP/v8k/+/wAAAAAA8C/i8hsk9A8AAAAA8CLi4v8t9A8AAAAALyLi4tQt9Q8AAAAALyLi4tQt9Q/AAAAA8CLi4v8t9A7MzMwA8C/i8hv03+0cEREAAP/v8k9O1O3MzMwAAP/v/u7v7g7AAAAAAPD///8OAAAAAAAAAADw/w8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroFrontAttack4\": \"hwQYABgAAAAAAAAAAP//AAAAAAAAAADw/73LDwAAAAAA8P//7///DwAAAAAA/+/v7v4EAAAAAADw/y7/T+7//wAAAADw7/K/2+0i9A8AAAD/4vL+300i9A8AAAAv4vJO1E0i9QAAAAAv4vJO1E0i9QAAAAD/4vL+300i9A8AAADw7/K/2+Qi9A8AAADw/y7/T+7//wAAAAAA/+7v7k5BAAAAAAAA8P//7/9OAAAAAAAAAADw/9/tAAAAAAAAAAAAAN7tAAAAAAAAAAAAwMwOAAAAAAAAAAAAwM0AAAAAAAAAAAAA3M0AAAAAAAAAAADA3QwAAAAAAAAAAADczQAAAAAAAAAAAADcDAAAAAAAAAAAAADMAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroSideAttackLeft1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMwAAAAAAAAAAAAAwN0MAAAAAAAAAAAAANzNAAAAAAAAAAAAAMDdzAAAAAAAAAAAAP/czQ4AAAAAAAAA/y7PzO0AAAAAAADw4uLv3u3/AAAAAAAv4vJO7URSDwAAAAD/4vJO3U5eDwAAAADv7/L+3yRC/wAAAADv/v6/0SRC/wAAAADv/i7vRC5C/wAAAADv7i9P7S5CDwAAAADw7i9P5P//AAAAAADw7+/v7g8AAAAAAAAA/////gAAAAAAAAAAAAD/DwAAAAAAAAA=\",\n  \"heroSideAttackLeft2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzAwAAAAAAAAAAAAA3AwAAAAAAAAAAAAAwM0AAAAAAAAAAAAAwN0MAAAAAAAAAAAAANzMAAAAAAAAAAAAANzNAAAAAAAAAAAAAMDMAAAAAAAAAAD//+DdDgAAAAAAAP8u7+/dDgAAAAAA8O/i7/5ODgAAAAAA8OLyTt1ODgAAAAAAL+LyTt3i/wAAAADwIuLy/t9S/wAAAADw7/7+v9tCDwAAAADw7/7+v9tCDwAAAAAA7/4u70RCDwAAAAAA7+4vT+1C/wAAAAAA7+4vT+RC/wAAAAAA8O7v7+7//wAAAAAA8O////4AAAAAAAAAAP//7w8AAAAAAAAAAADw/wAAAAAAAAA=\",\n  \"heroSideAttackLeft3\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMANAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAPD/D8zMDAAAAAAA8O/y/uAOAAAAAAAA/y7+7t7tAAAAAADwLy7v1N7tAAAAAADwIi7v1O3kDwAAAAAv/y7v/+3k/wAAAAD/7u//uy3+/wAAAADw7u/yTiT0DwAAAADw7v7y1C70DwAAAADw7v7yRC70/wAAAAAA7/7+7v7//wAAAAAA//7/7w8A/wAAAAAA8P///gAAAAAAAAAAAAD/DwAAAAAAAAA=\",\n  \"heroSideAttackLeft4\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMwAAAAAAP//AAAA3M0AAAAA/y7vDwDA3QwAAADw4uLv/s/czQAAAAAv4vJO3c7dDAAAAAD/4vJO3cTMDwAAAADv7/L+3yRC/wAAAADv/v6/0SRC/wAAAADv/i7vRO5P/wAAAADv7i9P7d1ODwAAAADw7i9P5N3+AAAAAADw7+/v7v8AAAAAAAAA/////gAAAAAAAAAAAAD/DwAAAAAAAAA=\",\n  \"heroSideAttackRight4\": \"hwQYABgAAAAAAAD/DwAAAAAAAAAA/////gAAAAAAAADw7+/v7v8AAAAAAADw7i9P5N3+AAAAAADv7i9P7d1ODwAAAADv/i7vRO5P/wAAAADv/v6/0SRC/wAAAADv7/L+3yRC/wAAAAD/4vJO3cTMDwAAAAAv4vJO3c7dDAAAAADw4uLv/s/czQAAAAAA/y7vDwDA3QwAAAAAAP//AAAA3M0AAAAAAAAAAAAAwMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroSideAttackRight3\": \"hwQYABgAAAAAAAD/DwAAAAAAAAAA8P///gAAAAAAAAAA//7/7w8A/wAAAAAA7/7+7v7//wAAAADw7v7yRC70/wAAAADw7v7y1C70DwAAAADw7u/yTiT0DwAAAAD/7u//uy3+/wAAAAAv/y7v/+3k/wAAAADwIi7v1O3kDwAAAADwLy7v1N7tAAAAAAAA/y7+7t7tAAAAAAAA8O/y/uAOAAAAAAAAAPD/D8zMDAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMDNAAAAAAAAAAAAAMANAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroSideAttackRight2\": \"hwQYABgAAAAAAADw/wAAAAAAAAAAAP//7w8AAAAAAAAA8O////4AAAAAAAAA8O7v7+7//wAAAAAA7+4vT+RC/wAAAAAA7+4vT+1C/wAAAAAA7/4u70RCDwAAAADw7/7+v9tCDwAAAADw7/7+v9tCDwAAAADwIuLy/t9S/wAAAAAAL+LyTt3i/wAAAAAA8OLyTt1ODgAAAAAA8O/i7/5ODgAAAAAAAP8u7+/dDgAAAAAAAAD//+DdDgAAAAAAAAAAAMDMAAAAAAAAAAAAANzNAAAAAAAAAAAAANzMAAAAAAAAAAAAwN0MAAAAAAAAAAAAwM0AAAAAAAAAAAAA3AwAAAAAAAAAAAAAzAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroSideAttackRight1\": \"hwQYABgAAAAAAADw/wAAAAAAAAAA8P//7w8AAAAAAAAA//7+7v4AAAAAAAAA7/7yRP7/DwAAAADw7v7y1O4i9AAAAADw7u/yTuQi9A8AAADw7u//G00i9A8AAADw/i7v/00i9A8AAADwLy7v1O3k9QAAAADwIi7v1E4k9QAAAAAALy7+7t3+DwAAAAAA8O/yzNwOAAAAAAAAAPDP3ewAAAAAAAAAAADczQwAAAAAAAAAAMDdDAAAAAAAAAAAANzNAAAAAAAAAAAAAMwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"heroWalkFront1\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD/Lv/k/v8A8O/yv9EuQv//4vL+3yRC/y/i8k7dJFIPL+LyTt0kUg//4vL+3yRC//Dv8r/RLkL/8P8u/+T+/wAA/+7v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkFront2\": \"hwQQABAAAAAAAAAAAAAAAAAAAP8AAAAAAAD////wDgAA8P/+7u8EAAD/7/JP/v//AP8u/xskQv/wLy7v/y1C//AiLu/ULVIP8CIu79QtUg/wLy7v/+3+DwD/Lv8b1O0PAP/v8k/e7QAA8O/+7k8OAAAA////7gAAAAAA/wAAAAAAAAAAAAAAAA==\",\n  \"heroWalkFront3\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD/Lv/k/v8A8O/yv9EuQv//4vL+3yRC/y/i8k7dJFIPL+LyTt0kUg//4vL+3yRC//Dv8r/RLkL/8P8u/+T+/wAA/+7v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkFront4\": \"hwQQABAAAAAAAAAAAAAAAAAAAP8AAAAAAAD////uAAAA8O/+7k8OAAD/7/JP3u0AAP8u/xvU7Q/wLy7v/+3+D/AiLu/ULVIP8CIu79QtUg/wLy7v/y1C/wD/Lv8bJEL/AP/v8k/+//8A8P/+7u8EAAAA////8A4AAAAA/wAAAAAAAAAAAAAAAA==\",\n  \"heroWalkBack1\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD+Lv/v/v8A8P7yIu/+Qv/v/i7y7v5C/+8v8u7u/kIP7y/y7u7+Qg/v/i7y7v5C//D+8iLv/kL/8P4u/+7+/wAA/+/v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkBack2\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwDwAAAADw//8PAAAA8P/+7v5ODgDv7/Ly7v//AO8vL//uL//w7u/y7+4v//D+Iu/u7i8P8P4i7+7uLw/w7u8v8u4vDwDvLyLv7u8OAO/v/+7u3w4A8P/+7v7UBAAA8P//D04AAAAAAPAPAAAAAAAAAAAAAA==\",\n  \"heroWalkBack3\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD+Lv/v/v8A8P7yIu/+Qv/v/i7y7v5C/+8v8u7u/kIP7y/y7u7+Qg/v/i7y7v5C//D+8iLv/kL/8P4u/+7+/wAA/+/v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkBack4\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwDwAAAADw//8PTgAA8P/+7v7UBADv7//u7t8OAO8vIu/u7w7w7u8v8u4vD/D+Iu/u7i8P8P4i7+7uLw/w7u/y7+4v/wDvLy//7i//AO/v8vLu//8A8P/+7v5ODgAA8P//DwAAAAAAAPAPAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldFront1\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAP/w8AAPD///69+wAA/+/v/r3LD/D/Lv/0vcsP8O/yv/G9+///web.archive.org/web/20191229135125/https://4vl+3/9P/y/i8k7dJFIPL+LyTt0kUg//4vL+3yRC//Dv8r/RLkL/8P8u/+T+/wAA/+7v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldFront2\": \"hwQQABAAAAAAAAAAAP//AAAAAP/wvcsPAAD//////w8A8P/+7u8EAAD/7/JP/v//AP8u/xskQv/wLy7v/y1C//AiLu/ULVIP8CIu79QtUg/wLy7v/+3+DwD/Lv8b1O0PAP/v8k/e7QAA8O/+7k8OAAAA////7gAAAAAA/wAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldFront3\": \"hwQQABAAAAAAAAAAAAAAAAAAAP8AAAAAAAD////+/wAA8O/+7t+7DwD/7/JP37v8AP8u/xvfu/zwLy7v/9+7D/AiLu/U/f8P8CIu79QtUg/wLy7v/y1C/wD/Lv8bJEL/AP/v8k/+//8A8P/+7u8EAAAA////8A4AAAAA/wAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldFront4\": \"hwQQABAAAAAAAAAAAAAAAAAAAP8AAAAAAAD////uAAAA8O/+7k8OAAD/7/JP3u0AAP8u/xvU7Q/wLy7v/+3+D/AiLu/ULVIP8CIu79QtUg/wLy7v/y1C/wD/Lv8bJEL/AP/v8k/+//8A8P/+7u8EAAAA//////8PAAAA//C9yw8AAAAAAP//AA==\",\n  \"heroWalkShieldBack1\": \"hwQQABAAAAAAAAAAAAAAAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD+Lv/v/v8A8P7yIu/+Qv/v/i7y7v5C/+8v8u7u/kIP7y/y7u7+Qg/v/i7y7v5C//D+8iLv/kL/8P4u/+7+/wAA/+/v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldBack2\": \"hwQQABAAAAAAAAAA8A8AAAAA8P//DwAAAPD//u7+Tg4A7+/y8u7//wDvLy//7i//8O7v8u/uL//w/iLv7u4vD/D+Iu/u7i8P8O7vL/LuLw8A7y8i7+7vDgDv7//u7t8OAPD//u7+1AQAAPD/////DwAAAADwvcsPAAAAAAD//wAAAAAAAAAAAA==\",\n  \"heroWalkShieldBack3\": \"hwQQABAAAAAAAADwDwAAAADw///+4EQAAP/v7+5PTQDw/i7/7/7/APD+8iLv/kL/7/4u8u7+Qv/vL/Lu7v5CD+8v8u7u/kIP7/4u8u7+Qv/w/vIi7/5C//D+Lv/u/v8AAP/v7+5PTQAA8P///uBEAAAAAPAPAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldBack4\": \"hwQQABAAAAAAAAAAAAAAAAAA8P////8PAPD//u7+1AQA7+//7u7fDgDvLyLv7u8O8O7vL/LuLw/w/iLv7u4vD/D+Iu/u7i8P8O7v8u/uL/8A7y8v/+4v/wDv7/Ly7v//APD//u7+Tg4AAPD//w8AAAAAAADwDwAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideLeft1\": \"hwQQABAAAAAAAAAAAAAAAAAA8P8PAAAAAPDv8v4A8A8ALy7+7v////AiLu/U7VL/8C8u79RNUv/w/i7v/+3+D/Du7/8b3u0P8O7v8k7e7Q/w7v7y1E7+/wDv/vJE/v//AP/+/u4O8A8A8P//7w8AAAAAAPD/AAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideLeft2\": \"hwQQABAAAAAAAAAAAAAAAAAAAADw/wAAAAD//9+7DwAA/y7v37v7APDi4u/+7/4AL+LyTt3e7Q//4vJO3d7tD+/v8v7fTv7/7/7+v9EkQv/v/i7vRC5C/+/uL0/tLkIP8O4vT+T//gDw7+/v7g8AAAD////+AAAAAAAA/w8AAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideLeft3\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/w8AAAAA8O/y/gDwDwAvLv7u////8CIu79TtUv/wLy7v1E1S//D+Lu//7f4P8O7v/xve7Q/w7u/yTt7tD/Du/vLUTv7/AO/+8kT+//8A//7+7g7wDwDw///vDwAAAAAA8P8AAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideLeft4\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAA/w8AAADw//+9+wAA8O/y/r27DwAvLv7u/+7/8CIu79Tt3f7wLy7v1O3d/vD+Lu//7eQP8O7v/xtNQg/w7u/yTuRCD/Du/vLU7kL/AO/+8kT+//8A//7+7g7wDwDw///vDwAAAAAA8P8AAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideRight4\": \"hwQQABAAAAAAAAAAAAAAAAAAAPD/AAAAAPD//+8PAAAA//7+7g7wDwDv/vJE/v//8O7+8tTuQv/w7u/yTuRCD/Du7/8bTUIP8P4u7//t5A/wLy7v1O3d/vAiLu/U7d3+AC8u/u7/7v8A8O/y/r27DwAA8P//vfsAAAAAAAD/DwAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideRight3\": \"hwQQABAAAAAAAAAAAAAAAAAAAPD/AAAAAPD//+8PAAAA//7+7g7wDwDv/vJE/v//8O7+8tRO/v/w7u/yTt7tD/Du7/8b3u0P8P4u7//t/g/wLy7v1E1S//AiLu/U7VL/AC8u/u7///8A8O/y/gDwDwAA8P8PAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideRight2\": \"hwQQABAAAAAAAAAAAAAAAAAAAP8PAAAAAP////4AAADw7+/v7g8AAPDuL0/k//4A7+4vT+0uQg/v/i7vRC5C/+/+/r/RJEL/7+/y/t9O/v//4vJO3d7tDy/i8k7d3u0P8OLi7/7v/gAA/y7v37v7AAAA///fuw8AAAAAAPD/AAAAAAAAAAAAAA==\",\n  \"heroWalkShieldSideRight1\": \"hwQQABAAAAAAAAAAAAAAAAAAAPD/AAAAAPD//+8PAAAA//7+7g7wDwDv/vJE/v//8O7+8tRO/v/w7u/yTt7tD/Du7/8b3u0P8P4u7//t/g/wLy7v1E1S//AiLu/U7VL/AC8u/u7///8A8O/y/gDwDwAA8P8PAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideLeft1\": \"hwQQABAAAAAAAAAAAAAAAAAA//8AAAAAAP8u7w8AAADw4uLv/v//AC/i8k7dLlIP/+LyTt0kUg/v7/L+3yRC/+/+/r/R5P7/7/4u70Te7f/v7i9P7d7tD/DuL0/kT/4A8O/v7+4PAAAA/////gAAAAAAAP8PAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideLeft2\": \"hwQQABAAAAAAAAAAAAAAAAAA8P8PAAAAAPDv8v4A8A8ALy7+7v////AiLu/U7VL/8C8u79RNUv/w/i7v/+3+D/Du7/8b3u0P8O7v8k7e7Q/w7v7y1E7+/wDv/vJE/v//AP/+/u4O8A8A8P//7w8AAAAAAPD/AAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideLeft3\": \"hwQQABAAAAAAAAAAAAAAAAAA//8AAAAAAP8u7w8AAADw4uLv/v//AC/i8k7dLlIP/+LyTt0kUg/v7/L+3yRC/+/+/r/R5P7/7/4u70Te7f/v7i9P7d7tD/DuL0/kT/4A8O/v7+4PAAAA/////gAAAAAAAP8PAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideLeft4\": \"hwQQABAAAAAAAAAAAAAAAAAA8P8PAAAAAPDv8v4A8A8ALy7+7v////AiLu/U7VL/8C8u79RNUv/w/i7v/01CD/Du7/8bTUIP8O7v8k7k/g/w7v7y1N7t/wDv/vJE3u3/AP/+/u5O/g8A8P//7w8AAAAAAPD/AAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideRight4\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAA8P//7w8AAAD//v7uTv4PAO/+8kTe7f/w7v7y1N7t//Du7/JO5P4P8O7v/xtNQg/w/i7v/01CD/AvLu/UTVL/8CIu79TtUv8ALy7+7v///wDw7/L+APAPAADw/w8AAAAAAAAAAAAAAA==\",\n  \"heroWalkSideRight3\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/w8AAAAA/////gAAAPDv7+/uDwAA8O4vT+RP/gDv7i9P7d7tD+/+Lu9E3u3/7/7+v9Hk/v/v7/L+3yRC///i8k7dJFIPL+LyTt0uUg/w4uLv/v//AAD/Lu8PAAAAAAD//wAAAAAAAAAAAAAAAA==\",\n  \"heroWalkSideRight2\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAA8P//7w8AAAD//v7uDvAPAO/+8kT+///web.archive.org/web/20191229135125/https://w7v7y1e7+//Du7/JO3u0P8O7v/xve7Q/w/i7v/+3+D/AvLu/UTVL/8CIu79TtUv8ALy7+7v///wDw7/L+APAPAADw/w8AAAAAAAAAAAAAAA==\",\n  \"heroWalkSideRight1\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/w8AAAAA/////gAAAPDv7+/uDwAA8O4vT+RP/gDv7i9P7d7tD+/+Lu9E3u3/7/7+v9Hk/v/v7/L+3yRC///i8k7dJFIPL+LyTt0uUg/w4uLv/v//AAD/Lu8PAAAAAAD//wAAAAAAAAAAAAAAAA==\",\n  \"houseRed\": \"hwQwADAAAAAAAABARkRGREZERkRGRGxmZmZmxswAAAAAAADAbMZsxmzGbMZsxkxmZmZmZsYMAAAAAADAZsZmxmbGZsZmxkxsZmZmZmbGAAAAAAAiLiLiIiIuIuIiwkzL5u7u7m5mDAAAAAAiLiLiIiIuIuIiYkzEJN7d3W1EZAAAACDu7u7u7u7u7u7ubEzEJN7P/WzkTgYAACAuIuIiIi4i4iIibEzEJN7P/WzkTmQAACAuIuIiIi4i4iIiZkzEJN7d3W3kTs4AAO7u7u7u7u7u7u7OxkbEJN7P/WxERM4AAC4i4iIiLiLiIiLOxkbEJN7P/WzkTs4AAC4i4iIiLiLiIiJuxkbEJN7d3W3kTmQA4O7u7u7u7u7u7u5sbEbE5O7u7m7kTmQAICLiIiIuIuIiIuJsTEbERERERERERGQAICLiIiIuIuIiIuJmTGbMzMzMzMzMzMwA4u7u7u7u7u7u7s5mRsbbEWFmZmZmZmYAIuIiIi4iIi4iIs7GtEwUYWZmZmZmZmYAIuIiIi4iIi4iIm7GxEth5v7/7+7+/+8g7u7u7u7u7u7u7mxmxERhTkREREREREQg4iIi4iIi4iIi4mxMZERh7u7u7u7u7u4g4iIi4iIi4iIi4mZMZERhTkT/TkRERETu7u7u7u7u7u7uzmZGZERhTuT/TkRERETiIiIuIuIiIi4izsZEZERh7v7/7u7u7u7u7u7u7u7u7u7ubsZEZERhTvT/TkREREQiIiIiIiIiIiIiYsZEZERhTvT/TkREREQiIiIiIiIiIiIiYsZEZERh7v7/7u7u7u7u7u7u7u7u7u7ubsZEZERhTvT/TkREREQiLiIuIuIiIi4izsZEZERhTvT/TkRERETu7u7u7u7u7u7uzmZGZERh7u7/7v7/7u4g4iIi4iIi4iIi4mZMZERhTkT/TuRPT0Qg4iIi4iIi4iIi4mxMZERhTkTkTuRPT0Qg7u7u7u7u7u7u7mxmxERh7u7u7u7/7u4AIuIiIi4iIi4iIm7GxEth5u7u7u7u7u4AIuIiIi4iIi4iIs7GtEwUYWZmZmZmZmYA4u7u7u7u7u7u7s5mRsbbEWFmZmZmZmYAICLiIiIuIuIiIuJmTGbMzMzMzMzMzMwAICLiIiIuIuIiIuJsTEbERERERERERGQA4O7u7u7u7u7u7u5sbEbE5O7u7m7kTmQAAC4i4iIiLiLiIiJuxkbEJN7d3W3kTmQAAC4i4iIiLiLiIiLOxkbEJN7P/WzkTs4AAO7u7u7u7u7u7u7OxkbEJN7P/WxERM4AACAuIuIiIi4i4iIiZkzEJN7d3W3kTs4AACAuIuIiIi4i4iIibEzEJN7P/WzkTmQAACDu7u7u7u7u7u7ubEzEJN7P/WzkTgYAAAAiLiLiIiIuIuIiYkzEJN7d3W1EZAAAAAAiLiLiIiIuIuIiwkzL5u7u7m5mDAAAAADAZsZmxmbGZsZmxkxsZmZmZmbGAAAAAADAbMZsxmzGbMZsxkxmZmZmZsYMAAAAAABARkRGREZERkRGRGxmZmZmxswAAAA=\",\n  \"houseBlue\": \"hwQwADAAAAAAAADQ293b3dvd293b3by7u7u7y8wAAAAAAADAvMu8y7zLvMu8y9y7u7u7u8sMAAAAAADAu8u7y7vLu8u7y9y8u7u7u7vLAAAAAACqqKqKqqqoqoqqytzLi4iIiLi7DAAAAACqqKqKqqqoqoqqutzNrTgzM7PdvQAAAKCIiIiIiIiIiIiIvNzNrTjP87y92wsAAKCoqoqqqqiqiqqqvNzNrTjP87y9270AAKCoqoqqqqiqiqqqu9zNrTgzM7O928sAAIiIiIiIiIiIiIjIy9vNrTjP87zd3csAAKiqiqqqqKqKqqrIy9vNrTjP87y928sAAKiqiqqqqKqKqqq4y9vNrTgzM7O9270AgIiIiIiIiIiIiIi8vNvNjYiIiLi9270AoKqKqqqoqoqqqoq83NvN3d3d3d3d3b0AoKqKqqqoqoqqqoq73LvMzMzMzMzMzMwAioiIiIiIiIiIiMi728vbEbG7u7u7u7sAqoqqqqiqqqiqqsjLvdwdsbu7u7u7u7sAqoqqqqiqqqiqqrjLzdux6/7/7+7+/++giIiIiIiIiIiIiLy7zd2xPjMzMzMzMzOgiqqqiqqqiqqqirzcvd2xvrvrvru7u7ugiqqqiqqqiqqqirvcvd2xPjP/PjMzMzOIiIiIiIiIiIiIyLvbvd2xPuP/PjMzMzOKqqqoqoqqqqiqyMvdvd2xvvv/vru7u7uIiIiIiIiIiIiIuMvdvd2xPvP/PjMzMzOqqqqqqqqqqqqqusvdvd2xPvP/PjMzMzOqqqqqqqqqqqqqusvdvd2xvvv/vru7u7uIiIiIiIiIiIiIuMvdvd2xPvP/PjMzMzOqqKqoqoqqqqiqyMvdvd2xPvP/PjMzMzOIiIiIiIiIiIiIyLvbvd2xvuv/vvv/u7ugiqqqiqqqiqqqirvcvd2xPjP/PuM/PzOgiqqqiqqqiqqqirzcvd2xPjPjPuM/PzOgiIiIiIiIiIiIiLy7zd2xvru7u+v/vrsAqoqqqqiqqqiqqrjLzdux6+7u7u7u7u4AqoqqqqiqqqiqqsjLvdwdsbu7u7u7u7sAioiIiIiIiIiIiMi728vbEbG7u7u7u7sAoKqKqqqoqoqqqoq73LvMzMzMzMzMzMwAoKqKqqqoqoqqqoq83NvN3d3d3d3d3b0AgIiIiIiIiIiIiIi8vNvNjYiIiLi9270AAKiqiqqqqKqKqqq4y9vNrTgzM7O9270AAKiqiqqqqKqKqqrIy9vNrTjP87y928sAAIiIiIiIiIiIiIjIy9vNrTjP87zd3csAAKCoqoqqqqiqiqqqu9zNrTgzM7O928sAAKCoqoqqqqiqiqqqvNzNrTjP87y9270AAKCIiIiIiIiIiIiIvNzNrTjP87y92wsAAACqqKqKqqqoqoqqutzNrTgzM7PdvQAAAACqqKqKqqqoqoqqytzLi4iIiLi7DAAAAADAu8u7y7vLu8u7y9y8u7u7u7vLAAAAAADAvMu8y7zLvMu8y9y7u7u7u8sMAAAAAADQ293b3dvd293b3by7u7u7y8wAAAA=\",\n  \"princessFront0\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwAAAAAAAA/2//AAAA8P9mZt//DwAfZv/23T8P8GH23T/zM/9VZf8//TVT/1Bi3939UzMPVWXf3f1TMw/wYf8//TVT//AW9t0/8zP/AG9h//bdPw8A8P9mZt//DwAAAP9v/wAAAAAAAPAAAAAAAAAAAAAAAA==\",\n  \"princessFront1\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwAAAAAAAA/28PAAAA8P9mZv//AAAfZv/20/0P8GH23T/zPw9VZf8//TVTD1Bi3939UzMPVWXf3f1TMw/wYf8//TVT//AW9t0/8zP/AG9h//b9Pw8A8P9mZt//DwAAAP9v/wAAAAAAAPAAAAAAAAAAAAAAAA==\",\n  \"princessFront2\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwAAAAAAAA/2//AAAA8P9mZt//DwAfZv/2/T8P8GH23T/zM/9VZf8//TVT/1Bi3939UzMPVWXf3f1TMw/wYf8//TVTD/AW9t0/8z8PAG9h//bT/Q8A8P9mZv//AAAAAP9vDwAAAAAAAPAAAAAAAAAAAAAAAA==\",\n  \"princessLeft0\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P//AAAAAABv1t0P//AP8Gb2P/01Pw9VYtbd/TNT81BlZtZd8z/zVRVmZj/f/f/wZmFm///fDwBvFmZmD/AAAPD//28PAAAAAABvbw8AAAAAAPDwAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"princessLeft1\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8PAAAAAPBm3f3wD/8Ab2b/09/9/1AlZt3d3/3/AFVmZt3T/fNQVWFm9tPf8wBvFmb2/1P/APBmYWb/P/8AAP////bwAAAAAPD29gAAAAAAAA8PAAAAAAAAAAAAAA==\",\n  \"princessLeft2\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8PAAAAAPBm3f3wDw8Ab2b/01/z81AlZt3dPzPzAFVmZt0zU/NQVWFm9tP/8wBvFmb23/3/APBmYWb//QAAAP////YPAAAAAPD29gAAAAAAAA8PAAAAAAAAAAAAAA==\",\n  \"princessBack0\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAPAAAAAAAA8PbwAAAA8P//9t8PAABvZmb23f8P8BZmZj/1P/NQFmZm9jM181UWZmb2M1PzVWZmZvYzU/NQFmZm9jM18/BmZmY/9T/zAG9mZvbd/w8A8P//9t8PAAAAAPD28AAAAAAAAA8AAAAAAAAAAAAAAA==\",\n  \"princessBack1\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAG8PAAAAAP//b/8AAADwZmZm3/8PAG9hZvbzMw8AZWFmZj8181BlYWZmP1PzUGVmZmY/Uw8AZWFmZj8/DwBvZmb21f0AAPBmZmbf/QAAAP//b/8PAAAAAABvDwAAAAAAAPAAAAAAAAAAAAAAAA==\",\n  \"princessBack2\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAG8PAAAAAP//b/8PAADwZmZm3/0AAG9hZvbV/QAAZWFmZj8/D1BlYWZmP1MPUGVmZmY/U/MAZWFmZj818wBvZmb28zMPAPBmZmbf/w8AAP//b/8AAAAAAABvDwAAAAAAAPAAAAAAAAAAAAAAAA==\",\n  \"princess2Front\": \"hwQQABAAAAAAAAAA8A8AAAAA8P//+wAAAPA/s7vr7gAAvzOzu+/0D/A+4//+/7wPX+Szv0G/3fFPRTP+T969/VRF4+5E3t2xVEXj7kTevb1PRTP+T97d8V/ks79Bv7398D7j//7/vA8AvzOzu+/0DwDwP7O76+4AAADw///7AAAAAAAA8A8AAA==\",\n  \"princess2WalkFront1\": \"hwQQABAAAAAAAAAA/wAAAAAA8P+/DwAAAADvs7v7DwAA8Dszu0v+DwDvM/7vTuQP8EU++xtO5PHwVDTj/+Te/U9VNO5O1N3xT1U07k7Uvb3wVDTj/9TdsfBFPvsbtL3xAO8z/u//vA8A8Dszu+v0DwAA77O7++4AAADw/78PAAAAAAAA/wAAAA==\",\n  \"princess2WalkFront2\": \"hwQQABAAAAAAAAAA8A8AAAAA8P//+wAAAPA/s7vr7gAAvzOzu+/0D/A+4//+/7wPX+Szv0G/3fFPRTP+T969/VRF4+5E3t2xVEXj7kTevb1PRTP+T97d8V/ks79Bv7398D7j//7/vA8AvzOzu+/0DwDwP7O76+4AAADw///7AAAAAAAA8A8AAA==\",\n  \"princess2WalkFront3\": \"hwQQABAAAAAAAAAA/wAAAAAA8P+/DwAAAADvs7v77gAA8Dszu+v0DwDvM/7v/7wP8EU++xu0vfHwVDTj/9TdsU9VNO5O1L29T1U07k7U3fHwVDTj/+Te/fBFPvsbTuTxAO8z/u9O5A8A8Dszu0v+DwAA77O7+w8AAADw/78PAAAAAAAA/wAAAA==\",\n  \"princess2Back\": \"hwQQABAAAAAAAAAA8A8AAAAA8P/P+wAAAPA/u7vL7gAAvzOzu8v0D/A+MzO7u7wPXzMzM7u73/FPMzMzu7u//VQzMzO7u9+xVDMzM7u7v71PMzMzu7vf8V8zMzO7u7/98D4zM7u7vA8AvzOzu8v0DwDwP7u7y+4AAADw/8/7AAAAAAAA8A8AAA==\",\n  \"princess2WalkBack1\": \"hwQQABAAAAAAAAAA8P8AAAAAAP/P+w8AAAD/u7u7DAAA8Duzu7v8DwDvMzO7u7wP8DUzM7u7v/HwNDMzu7vfsUA1MzO7u7+9QDUzM7u73/HwNDMzu7vf/fA1MzO7u+/+AO8zM7u7Tw4A8Duzu8tODwAA/7u7/OwAAAAA//8PAAAAAAAAAAAAAA==\",\n  \"princess2WalkBack2\": \"hwQQABAAAAAAAAAA8A8AAAAA8P/P+wAAAPA/u7vL7gAAvzOzu8v0D/A+MzO7u7wPXzMzM7u73/FPMzMzu7u//VQzMzO7u9+xVDMzM7u7v71PMzMzu7vf8V8zMzO7u7/98D4zM7u7vA8AvzOzu8v0DwDwP7u7y+4AAADw/8/7AAAAAAAA8A8AAA==\",\n  \"princess2WalkBack3\": \"hwQQABAAAAAAAAAAAAAAAAAAAP//DwAAAAD/u7v87AAA8Duzu8tODwDvMzO7u08O8DUzM7u77/7wNDMzu7vf/UA1MzO7u9/xQDUzM7u7v73wNDMzu7vfsfA1MzO7u7/xAO8zM7u7vA8A8Duzu7v8DwAA/7u7uwwAAAAA/8/7DwAAAAAA8P8AAA==\",\n  \"princess2Left1\": \"hwQQABAAAAAAAAAAAAAAAAAA8P8AAAAA8P8/Mw8A8A9P5TPj/v+/D1RF4+5E3t3xVEXj7kTevf1PRTP+T97dsV/ks79B7769/z7j//5P5PG/MzOzu0/k/fAzM7O7+74P8Dszs7u7/w8AvzOzu7sPAADw////+wAAAAAAAPAPAAAAAAAAAAAAAA==\",\n  \"princess2Left2\": \"hwQQABAAAAAAAAAAAAAAAAAA8P8AAAAAAP8/Mw8A8A/wVD4z7v/f+0BVNO5O1N39QFU07k7U3fHwVDTj/9S9vfBFPvsb5L6x8O8z/u9P5P3wOzMzu0vk/QA/MzO7u7/7AL8zM7u7vw8A8Dszu7v/AAAA//+/+wAAAAAAAP8PAAAAAAAAAAAAAA==\",\n  \"princess2Right1\": \"hwQQABAAAAAAAAAAAAAAAAAAAADwDwAAAPD////7AAAAvzOzu7sPAPA7M7O7u/8P8DMzs7v7vg+/MzOzu0/k/f8+4//+T+TxX+Szv0Hvvr1PRTP+T97dsVRF4+5E3r39VEXj7kTe3fFP5TPj/v+/D/D/PzMPAPAPAADw/wAAAAAAAAAAAAAAAA==\",\n  \"princess2Right2\": \"hwQQABAAAAAAAAAAAAAAAAAAAAD/DwAAAAD//7/7AAAA8Dszu7v/AAC/MzO7u78PAD8zM7u7v/vwOzMzu0vk/fDvM/7vT+T98EU++xvkvrHwVDTj/9S9vUBVNO5O1N3xQFU07k7U3f3wVD4z7v/f+wD/PzMPAPAPAADw/wAAAAAAAAAAAAAAAA==\",\n  \"rock0\": \"hwQQABAAAAAAAAAAzMwAAAAAAMzLywwAAAAA3Lu8zAAAAMzcvbzMAMDMu7zdzMwAvN27y93LzADc3d2728vMDNvd3bvby7wM293du9u7vMvb3d2929u8y7Dd3b3b27zLANvdvb3bvMsA2927vb27DACwu7u7zbsMAAAA293MywAAAACwy7wLAA==\",\n  \"rock1\": \"hwQQABAAAAAAAAAAAMDMAAAAAADLvMwMAAAAsNvLywwAAAC73c3LDACwy8zdzcvMALDdzN3Nzcuw293L27vNy7Dd3bvb28vLsN3d27vdzMvb3d3b27u8y9vdvb27vLvL2727zcu8u8vbvdvLzLy7DLDbvczMu8sMAADLzLzLzAAAAAAAzMwMAA==\",\n  \"rock2\": \"hwQQABAAAAAAAADADLALAMALALvM27sAuwyw3cvbzQDdDLDdy7DNANsLsN27sMsAsADL27sAvAAAsN3MDAAAuwCw3csMALC9AMu7y7wL272wzLzMwAzbzbu9zAC7zNvL293LsL3Lu8zbvcuw3cu7vNu9y7Ddu8sLsLsMALsLuwAAAAAAsAAAAA==\",\n  \"saplingOak\": \"hwQQABAAAAAAAADMDAAAAAAAzMbMDAAAAMBmZszMAAAAwGZnbMYAAABsdmdm9gwAAGx3dmf8TwDAZndnZ2b8DsBnV3fGZvzuwHd3Z2fM/O7AVWdmZ/bPAGBVd2dn/AzgAHZ1Z2bG7wQAxnZWZ8YPAADAbHbG/AAAAADMZsYMAAAAAMDMzAAAAA==\",\n  \"saplingPine\": \"hwQQABAAAAAAAADMAAAAAAAAYMfMDAAAAABsx3wMAAAAYGxndwwAAMDMx2ZmzAAOwMZnbGZ35g7AfHfHdsfvAGxVd2xm9u7uXFV3Zmb/7u7AfHVnd8fuAGDHZ2Z3d+wOYGbHd2fMAA4AYMx3dwwAAAAAZmd8DAAAAABgZ8YMAAAAAABmAAAAAA==\",\n  \"shrub\": \"hwQQABAAAAAAAGZgZgwAAAAAZsx2xmwAAGB2bHfMZgYAYHVsd1x3ZgDMdWZnVnVmwMZVZmx3ZcZmZ3ZnzGZmDHZVZ8bMfFdmdld1xsx8V2dmZ1ZlzGZmZsDGVWdsd2UMAMx1ZmdWdcYAYHdsd1x3ZgBgdmx3zGYGAAB2xnbGbAAAAGZgZgwAAA==\",\n  \"skellyFront\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAAAAAAAAAAwLEAAAAAAAAA//8PH/sAAAAAAAD/3b38H7EAAAAAAPAbEd29H/sAAAAAAPAREb0czPEPAAAAAB8REfEfvf8PAAAAAB8REdER+///web.archive.org/web/20191229135125/https://aaaaab8redersf//AAAAAB8REfEf+///web.archive.org/web/20191229135125/https://aaaaapareb0czbepaaaaapabed29h/sAAAAAAAD/3b38H7EAAAAAAAAA//8PH/sAAAAAAAAAAAAAz7EAAAAAAAAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkFront1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAAAAAAAAAAwLEAAAAAAAAA//8PH/sAAAAAAAD/3b38H7EAAAAAAPAbEd29H/sAAAAAAPAREb0czPEPAAAAAB8REfEfvf//AAAAAB8REdER+///web.archive.org/web/20191229135125/https://aaaaab8redersf//AAAAAB8REfEf+/8PAAAAAPAREb0cHPsAAAAAAPAbEd39sQ8AAAAAAAD/3b38EQsAAAAAAAAA////sQ8AAAAAAAAAAADwHAsAAAAAAAAAAAAA/w8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkFront2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAAAAAAAAAAwLEAAAAAAAAA//8PH/sAAAAAAAD/3b38H7EAAAAAAPAbEd29H/sAAAAAAPAREb0czPEPAAAAAB8REfEfvf8PAAAAAB8REdER+///web.archive.org/web/20191229135125/https://aaaaab8redersf//AAAAAB8REfEf+///web.archive.org/web/20191229135125/https://aaaaapareb0czbepaaaaapabed29h/sAAAAAAAD/3b38H7EAAAAAAAAA//8PH/sAAAAAAAAAAAAAz7EAAAAAAAAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkFront3\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/w8AAAAAAAAAAADwHAsAAAAAAAAA////sQ8AAAAAAAD/3b38EQsAAAAAAPAbEd39sQ8AAAAAAPAREb0czPsAAAAAAB8REfEfvf8PAAAAAB8REdER+///web.archive.org/web/20191229135125/https://aaaaab8redersf//AAAAAB8REfEf+///web.archive.org/web/20191229135125/https://aaaaapareb0czfepaaaaapabed29h/sAAAAAAAD/3b38H7EAAAAAAAAA//8PH/sAAAAAAAAAAAAAwLEAAAAAAAAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackFront1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAAAAAAAAAAwLEAAAAAAAAAAAAAH/sAAAAAAAAAAAAAH7EPAAAAAAAAAADwH/vMDwAAAAAAAAC/zPHP/w8AAAAAAAAf0cux//8PAAAAAPAREfHR+///web.archive.org/web/20191229135125/https://aaaaaparergx////DwAAAPARERER+///web.archive.org/web/20191229135125/https://dwaaaparefgx////DwAAAAAfEc0R/c+xDwAAAAC/Ed37/x/7AAAAAADwH93LDx+xAAAAAAAA8P//AB/7AAAAAAAAAAAAAM+xAAAAAAAAAAAAAPD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackFront2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHB3dwAAAAAAAAAAAAcAd/f/AAAAAAAAAAAAcMfRDwAAAAAA8P///7/8AAAAAADw393dyx/RDwAAAAC/ERHR3b/8AAAAAAAfERHRy8vRDwAAAPARERER//3/AAAAAPARERERHfv/AAAAAPARERERHfH/AAAAAPARERER//v/AAAAAAAfERHRy/3/AAAAAAC/ERHR3f8PAAAAAADw393dyw8AAAAAAAAA8P///wwAAAAAAAAAAADwvA8AAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackFront3\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAA//8AAM8PAAAAAAD/3c3/AL8PAAAAAPAbEdH7/x8LAAAAAPAREdG8/L8PAAAAAB8RERHf+88PAAAAAB8RERGx//8AAAAAAB8RERER+/8AAAAAAB8RERG///8AAAAAAPAREdHc/f8AAAAAAPAbEdH7/w8AAAAAAAD/0c3/AAAAAAAAAAAA///7AAAAAAAAAAAAAPD7AAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackFront4\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAAAAAAA//8AABwPAAAAAAD/3cv/8LsPAAAAAPAb0d37/xELAAAAAPAREb28/LsPAAAAAB8REfEf/RwPAAAAAB8REdER+/8AAAAAAB8REdER8f8AAAAAAB8REfEf+/8AAAAAAPAREb28/f8AAAAAAPAb0d3L/w8AAAAAAAD/3b3/+wAAAAAAAAAA//+/ywAAAAAAAAAAAADP+wAAAAAAAAAAAADwDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkLeft1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8PAAAAAAAAAAD/3d37/wAAAAAAAPAbEREdsQ8AAAAAAPAREdEd+/8AAAAAAB8REfEfwbEPAAAAAB8REb0cH/sPAAAAAB8REd0dH7H/AAAAAB8REd27H/v/AAAAAPAR0d27v///AAAAAPDb3d3L////AAAAAAD/3b38AAD/AAAAAAAA//8PAPAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackLeft1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////DwAAAAAAAAD/3RuxDwAAAAAAAPAbERH7DwAAAAAAAPARERGx//8AAAAAAB8RER/7//8PAAAAAB8R0RzN////AAAAAB8R0b3/////AAAAAB8REf/M////AAAAAL8RwbHP////AAAAAPARH/vPD/D/AAAAAPAbH7H/AAD/AAAAAAD/H/sPAAD/AAAAAAAAv/8AAPAPAAAAAAAA8A8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackLeft2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8P8AAAAAAAAAAAAAz9EPAAAAAADw////v/sAAAAAAPDf3d29H9EPAAAAAL8RERHRv/0AAAAAAB8REdHdvAwAAAAA8BEREdH/vA8AAAAA8BER0d3L/f8AAAAA8BER0d3dzf8AAAAA8BER0d29+/8PAAAAAB8R3d27//8PAAAAAL/d3d3L//8PAAAAAPDb3b3///8PAAAAAAD///8PAP8PAAAAAAAAAAAAAPAPAAAAAAAAAAAAAPAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkLeft2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAA//+/sQ8AAAAAAAD/3R0R+w8AAAAAAPAbERERsQ//AAAAAB8REREf+w+xAAAAAB8REd0c/Q/7AAAAAB8REd29//+xAAAAAB8REd3d/P/7AAAAAB8R0d3d////AAAAAPAR3d3d////AAAAAPDb3d29////AAAAAAC/3d398P//AAAAAADw//8PAPD/AAAAAAAAAAAAAP8PAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkRight1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAP8PAAAAAADw//8PAPD/AAAAAAC/3d398P//AAAAAPDb3d29////AAAAAPAR3d3d////AAAAAB8R0d3d////AAAAAB8REd3d/P/7AAAAAB8REd29//+xAAAAAB8REd0c/Q/7AAAAAB8REREf+w+xAAAAAPAbERERsQ//AAAAAAD/3R0R+w8AAAAAAAAA//+/sQ8AAAAAAAAAAADw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackRight1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAPAPAAAAAAD///8PAP8PAAAAAPDb3b3///8PAAAAAL/d3d3L//8PAAAAAB8R3d27//8PAAAA8BER0d29+/8PAAAA8BER0d3dzf8AAAAA8BER0d3L/f8AAAAA8BEREdH/vA8AAAAAAB8REdHdvAwAAAAAAL8RERHRv/0AAAAAAPDf3d29H9EPAAAAAADw////v/sAAAAAAAAAAAAAz9EPAAAAAAAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyAttackRight2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8A8AAAAAAAAAAAAAv/8AAPAPAAAAAAD/H/sPAAD/AAAAAPAbH7H/AAD/AAAAAPARH/vPD/D/AAAAAL8RwbHP////AAAAAB8REf/M////AAAAAB8R0b3/////AAAAAB8R0RzN////AAAAAB8RER/7//8PAAAAAPARERGx//8AAAAAAPAbERH7DwAAAAAAAAD/3RuxDwAAAAAAAAAA////DwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"skellyWalkRight2\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8PAPAPAAAAAAD/3b38AAD/AAAAAPDb3d3L////AAAAAPAR0d27v///AAAAAB8REd27H/v/AAAAAB8REd0dH7H/AAAAAB8REb0cH/sPAAAAAB8REfEfwbEPAAAAAPAREdEd+/8AAAAAAPAbEREdsQ8AAAAAAAD/3d37/wAAAAAAAAAA//8PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"tileGrass1\": \"hwQQABAAAAB1d3d3d3d3d3d3d3d3d3d3dXdnd1d3d1d3d1V2d3d3d3d3V2V3d3d3d1d1d3d3d3d3d1V3d3d3d3d3d1V3d3d3d3dXZXd3dXd3d1d2d3dVd3d3d3d3V1d3d3d3d3dVdnd3d3V3d2V3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3VQ==\",\n  \"tileGrass2\": \"hwQQABAAAAB1d3d3d3d3d3d30XZ3F3Z3dTcRY3dxcVd3EXbRdxd2d3cRdtF3d3d3dzcRY3d3d3d3d9F2F3Z3d3d3d3dxcXd3d3d3dxd2d3d3V2V3d3d3d3d3d1d1F213d3d3VXYTMXZ3YXdnF2EXfRcXd3cXYRd9d2F3d3cTMXZ3d3d3dxdtdw==\",\n  \"tilePath1\": \"hwQQABAAAAB3d3d3d3d3d3dndmd21nZmd3dm3W3dbd131t3d3d3d3Wfd3d3d3d3bd9bd3d3d3d131t29293d3WfW3b3b3d3dZ93d3d3d3d1n3d3d3d3d3XfW3d3dHdHdZ93d3dEd0d131t3d3d3d3Xfd293d3d3dZ9fd3d3R3d131t3d3d3d2w==\",\n  \"tilePath2\": \"hwQQABAAAABn3d3d3d3d3WfdHdHd3d3dd9Yd0d293d1n193d3d3d3XfXHd3d3d3dZ9bd3d3d3d13Z93dvd3d3Wfd3d3d3d3RZ93d3d3d3d3X3d3d3d3d3WfXHd3d3d3dd9bd3d2929133d3d3b3b3WfW3d3d3d3dd2fd3R3d3R131t3d3d3d3Q==\",\n  \"tilePath3\": \"hwQQABAAAADX3d3R3d3d3Wfd3d3d3d3dd9bd3d3d3d1n1t3dvdvd3Wfd2929293dd93d3d3d3dt31t3d3d3d3XfW3d3d3d3dZ9bd0d3d3d3X3d3d293d3WfdEd3d3dHdd9YR3d3d3d1n3d3d1t3d3XfWbd1n3Wbdd2d2ZndmZ213d3d3d3d3dw==\",\n  \"tileDarkGrass1\": \"hwQQABAAAABnZmZmZmZmZmZmZmZmZmZmZ2aGZnZmZnZmZndoZmZmZmZmdodmZmZmZnZnZmZmZmZmZndmZmZmZmZmZndmZmZmZmZ2h2ZmZ2ZmZnZoZmZ3ZmZmZmZmdnZmZmZmZmZ3aGZmZmdmZodmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmdw==\",\n  \"tileDarkGrass2\": \"hwQQABAAAABnZmZmZmZmZmZm0WhmFmhmZzYRg2ZhYXZmEWjRZhZoZmYRaNFmZmZmZjYRg2ZmZmZmZtFoFmhmZmZmZmZhYWZmZmZmZhZoZmZmdodmZmZmZmZmZnZnFo1mZmZmd2gTMWhmgWaGFoEWbRYWZmYWgRZtZoFmZmYTMWhmZmZmZhaNZg==\",\n  \"tilePath4\": \"hwQQABAAAAB3d3d3d3d3d2dnd2d21nZ2Zmdm3W3dbdbd1tbd3b3d1t3d3d3d3d3d3d3d3d3d3d0R3d3d3d3d3RHdvd3d3d3d3d3d3d0d3dvd3d3d3RHR3d3R3d3dHd3d3d3d3d3d3d3d3d3du93d3d3d3d273d3d3d3d3d3d3d3d3d3R3d3dHQ==\",\n  \"tilePath5\": \"hwQQABAAAADd3d3d3R3R3d3d3d3dHdHd3d3b3d3d3d0d0d3d3d3d3R3R3d3d3d3d3d3d3dvd3d3d3d3d3d0d3d3d3d3d3d3d3d3d3d3d3d3d3bvd3d3d3d3du93d3d3d3d3d3d3d3d3d3d3d3d3b3b3d3d3d3d3d3d3d3d3d3b3d3d3d3d3d3Q==\",\n  \"tilePath6\": \"hwQQABAAAADd3d3d0d3d3d0d3d3d3d3d3RHR3d3d3dHdHd3d3d3d3d3d3d29293d3d3d3b3b3d3d3d3d3d3d3d3d3d3d3d3d3b3d3d3d3d3d3d3d3d3d3d3d3d3d3dvd3d3d0d3d3d3d3d3dbd3d3d3W3WZ91m3WZmdtZ3Z2bWd3d3d3d3d3dw==\",\n  \"tileGrass3\": \"hwQQABAAAAB3d3d3d3d3d3d2d3d3d3d3V2V3d3d3d3d3VXZ3d1V2d1V3d3d3d3d3V3V3d3d3d3d3V3V3d3d3d3dVdnd3d3d3d2V3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d1dld3d3d3d3d3d3d1d3d3d3d3d3d3d3d3d3d3d3dw==\",\n  \"tileDarkGrass3\": \"hwQQABAAAABmZmZmZmZmZmZoZmZmZmZmdodmZmZmZmZmd2hmZndoZndmZmZmZmZmdmdmZmZmZmZmdmdmZmZmZmZ3aGZmZmZmZodmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZnaHZmZmZmZmZmZmZnZmZmZmZmZmZmZmZmZmZmZmZg==\",\n  \"tilePath7\": \"hwQQABAAAAB3d3d3d3d3d9Z2ZndmZ3Z33Wbddt3WbXfd3d1t3d3ddt3d3d2922133d3d3b3b3XbdHd3d3d3dfd3d3d3d3W123d3d3d3dbXfd3d3d3d1td90R3d3d3d133RHd3dvd3Xbd3d3d3d1tdt3d3d3dEW133d3d3d0R3Xbd3d3b3d3dfQ==\",\n  \"tilePath8\": \"hwQQABAAAADd3d3d3d1td9Hd3dHd3XZ33d3d3d3dbXbd3d3d3dvdd93d3d3d3W133d3du93dfXbd29273d3dfd3d3d3d3d123d3d3d3d3Xbd3d3d3d12d93d3d3d3W123d3d3d3RfXfdEd3d3d19dt0R3d3d3W133d3dvd3d3Xbd3d3d3d3ddg==\",\n  \"tilePath9\": \"hwQQABAAAAC93d3d3d1td93d3R3R3X123d3dHdG93Xfd3d3d3d1td93d3d3d3d123dHd3d3dbXfd3d3d3d3ddt3d3d3R3d123d3d3d3dbXbd3bvd3d1td93du93d3W133d3d3d0d3Xbd3d3d3d1td93W3dbdZnd3ZmdtZ3Zndnd3d3d3d3d3dw==\",\n  \"treePine\": \"hwQgACAAAAAAAAAAAAAAwAwAAAAAAAAAAAAAAAAAYMbGDAAAAAAAAAAAAAAAAGBnZgwAAAAAAAAAAAAAAABsZ3ZmbAAAAAAAAAAAAADAzGd3ZswAAAAAAAAAAADAbMdmd3bHAAAAAAAAAAAAfHxnxmd2xgYAAAAAAAAAAHZmZ8dmZ8wMAAAAAAAAAMx2ZnbHZsZmzAAAAAAAAGDHzGx2bMdmdswAAAAAAABsx3xsZnbHZnfHAPAAAABgbGd3bGZ3xmZmbAzwAADAzMdmZsxmZmZmZnYM7wAAwMZnbGZ3ZnZnbGZ3Z+8PAMB8d8d2x2Z3d2xmd8fu/g9sVXdsZmx3d8ZmZsZs7u7+XFV3ZmZ2d2dsZmZnZu7+D8B8dWd3Z3d3d2Z2d2fuDwBgx2dmd3d2d2dmd3dn7w8AYGbHVWdsd3fGdmZ2BuAOAABgzFd3fHd3x3Z3bAbwAAAAAGZlfHZ3dmdmd8cAAAAAAABgZ2Z2d2ZnZnbHAAAAAAAAAGZ3dnbHbHfGZgAAAAAAAAAAdnZmx2Z3dwwAAAAAAAAAAHZ2Z3ZnZncMAAAAAAAAAABgZnx3d2xnAAAAAAAAAAAAAGB2Z3fMZgAAAAAAAAAAAAAAZnd2xmwAAAAAAAAAAAAAAGBnbMYAAAAAAAAAAAAAAABgZsbGAAAAAAAAAAAAAAAAAGAGAAAAAAAAAA==\",\n  \"treeOak\": \"hwQgACAAAAAAAAAABsDMxgwAAAAAAAAAAAAAYGbMbMZsDAAAAAAAAAAAAGBmdmfGZwwAAAAAAAAAAABmZndmdmfMDAAAAAAAAAAAZndmZmfGxswMAAAAAAAAZnZ3ZnZnZsZmDAAAAAAAYHd2Z2d2dnd2x8wAAAAAAGB3ZnZnZnZnd8bMDAAAAABgZnd3Z3dmZsZszAwAAAAAZnZ3d3Z3dmdmd8YAAA4AYHd2d3d3d3d3dmfMDAAOAGB3dnd3d3d3Z2bGZswADgBgd3d3dXd3d3Z3ZmbG8P4AZld1V3V3d2Z3Z2bGzO/+AGZXVVd3d3dnd2Z3Zsbu/wB2d1V3d3d3d2ZmdmfM7v4PdndXVVV3d3dnZmbGzO7u7mB3VXdVdXd3Z3Z3Zszu7g5gV1VXd3d3ZmZmd2fG7v8AAHZ3V3V3d2d3Z8bMzP4PAGB3d1d1d3d3dndmzMzgDgBgd3d3dXdnZmZmZsYMAO4AYHd2d3d3Z3dmZ8bMDADgAGBmd3d3d2d3Z3dmzAAAAAAAYHd2d3Z3dmd2ZswMAAAAAGBndndnd2ZmZmzGDAAAAAAAZmZ2Z2Z3Z2bGzAAAAAAAAHZ2Z2dmdmdsxgwAAAAAAAB2dndmZ2ZmzMYMAAAAAAAAYGBmZnfGxswMAAAAAAAAAAAAZmB2xszMDAAAAAAAAAAAAGDAbMYMAAAAAAAAAA==\",\n  \"treeSmallPine\": \"hwQQABgAAAAAAAAAAADAzAAAAAAAAAAAwMxsxwwAAAAAAGDMbGd8d8YAAAAAAMxnfHdnd8cMAAAAzGx2xnfHd2YMAADAxmZ2x3bGdmfMAA5sZ2x2d3ZndnfG4A5cd3Z2Z3Z3dmfM7u52dXZ3Z3ZndmbG7u5mZ3Z2d3ZmdmfG4A7AZsd2Z3dndnfMAA4AbMx3Zndnd2cMAAAAAGxnfHdmd2YMAAAAAMDGbGd2d8cAAAAAAAAAwGx2ZwwAAAAAAAAAAABmxgAAAAA=\"\n}",
            "sprites.castle.ts": "namespace sprites.castle {\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const houseRed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const houseBlue = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Front = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Back = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Left1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Left2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Right1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Right2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const rock0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const rock1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const rock2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const saplingOak = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const saplingPine = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const shrub = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileGrass1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileGrass2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileDarkGrass1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileDarkGrass2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileGrass3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tileDarkGrass3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath7 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath8 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const tilePath9 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treePine = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treeOak = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treeSmallPine = image.ofBuffer(hex``);\n}\n",
            "sprites.dialog.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.dialog\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"hugeLeaf\": \"hwQwADAAAACIiAAAiAAAiAgAgAiIAACICACACAAAiIhod4iAZwiAdoYAaIdnCIB2hgBohwCId4Z4dmeId4doZ2eId4d3h2hnZ4h3h4h2Z4d4Z3eGZ3d4Z3d4Z2dnd3hnd3hnZ2h3doeAd3hmd3Z4Z3d4dmd3dnhnd3h2Z2aHdwiAdodmdmZoZ2dodoZ2ZmhnZ2h2hmZ4ZwgAaGZoaGeIhoaIZ4hoZ4iGhmhniIZmhgAAgGaGiIiIiIiIiIiIiIiIiIiIiGiGiIiAaIaIZmZmZmZmZmZmZmZmZmZmZoh2d4d4d2eIZmZmZmZmZmZmZmZmZmZmZmh3doZoZ3eGZmZmZmZmZmZmZmZmZmZmZnhmdwiAd2aHZmZmZmZmZmZmZmZmZmZmZmh2hwAAeGeGZmZmZmZmZmZmZmZmZmZmZoiIiAAAiIiIZmZmZmZmZmZmZmZmZmZmZoh2ZwiAdmeIZmZmZmZmZmZmZmZmZmZmZmh3d4Zod3eGZmZmZmZmZmZmZmZmZmZmZohmZod4ZmaIZmZmZmZmZmZmZmZmZmZmZmh3d4Zod3eGZmZmZmZmZmZmZmZmZmZmZoh2ZwiAdmeIZmZmZmZmZmZmZmZmZmZmZoiIiAAAiIiIZmZmZmZmZmZmZmZmZmZmZmh2hwAAeGeGZmZmZmZmZmZmZmZmZmZmZnhmdwiAd2aHZmZmZmZmZmZmZmZmZmZmZmh3doZoZ3eGZmZmZmZmZmZmZmZmZmZmZoh2d4d4d2eIZmZmZmZmZmZmZmZmZmZmZohohgiAaIaIZmZmZmZmZmZmZmZmZmZmZoh2d4d4d2eIZmZmZmZmZmZmZmZmZmZmZmh3doZoZ3eGZmZmZmZmZmZmZmZmZmZmZnhmdwiAd2aHZmZmZmZmZmZmZmZmZmZmZmh2hwAAeGeGZmZmZmZmZmZmZmZmZmZmZoiIiAAAiIiIZmZmZmZmZmZmZmZmZmZmZoh2ZwiAdmeIZmZmZmZmZmZmZmZmZmZmZmh3d4Zod3eGZmZmZmZmZmZmZmZmZmZmZohmZod4ZmaIZmZmZmZmZmZmZmZmZmZmZmh3d4Zod3eGZmZmZmZmZmZmZmZmZmZmZoh2ZwiAdmeIZmZmZmZmZmZmZmZmZmZmZoiIiAAAiIiIZmZmZmZmZmZmZmZmZmZmZmh2hwAAeGeGZmZmZmZmZmZmZmZmZmZmZnhmdwiAd2aHZmZmZmZmZmZmZmZmZmZmZmh3doZoZ3eGZmZmZmZmZmZmZmZmZmZmZoh2d4d4d2eIZmZmZmZmZmZmZmZmZmZmZohohgiIiGiGiIiIiIiIiIiIiIiIiIiIiGhmCAAAaGZoiHaGaGiIdoaIdoZoaIh2hoZmhgCAdodmaGeGdnaGZmdoZ4Z2doZmZ2Z4ZwiAd3hmdmeHd3aHZ3d2Z4d3dodnd2aHdwh4Z3eGdnaHd3aHd3Z2dod3dod3dmh3dod4dmeIeHeIdnaGeHd4d4h2doZ4d4h2Z4dod4gAeIYAaGcIgHZ4hgBoZwiAdgiId4aIiAAAgAgAgIgAAIiACACAiAAAiAAAiIg=\",\n  \"largeShell\": \"hwQqACoAAAAAzMwMADMDAAAzAwAAMwMAwMzMAAAAAADAMzvDMJk5ADCZOQAwmTkAPLMzDAAAAAA8O7M7nJmZM5OZmTOTmZnGszuzwwAAAAA8szM7nBGRmZkRkZmZEZHJszM7wwAAAAC8MzuzHJkZmRmZGZkZmRnJO7MzywAAAAA8O7O7vJmZEZGZmRGRmZnLuzuzwwAAAAA8u7PbsRERmRkREZkZEREbvTu7wwAAAADAM7sdGxERERERERERERGx0bszDAAAAAAAzMyxERERERERERERERERG8zMAAAAAAAAk7kbERERERERERERERERsRuZAwAAAAAwmZEREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkRERERERERERERERERERmZAwAAAAAwmZERERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERERmZAwAAAAAwmZEREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkRERERERERERERERERERmZAwAAAAAwmZERERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERkZE5AAAAAAAAkxkZERERERERERERERERERmZAwAAAAAwmZEREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkREREREREREREREREREZmROQAAAACTGZkRERERERERERERERERERmZAwAAAAAwmbEbERERERERERERERERsZs5AAAAAAAAzMyxERERERERERERERERG8zMAAAAAADAM7sdGxERERERERERERGx0bszDAAAAAA8u7PbsRERkZkREZGZEREbvTu7wwAAAAA8O7O7vJmZGRGZmRkRmZnLuzuzwwAAAAC8MzuznJGZkZmRmZGZkZnBO7MzywAAAAA8szM7nBkRmZkZEZmZGRHJszM7wwAAAAA8O7M7PJmZOTOZmTkzmZnJszuzwwAAAADAMzvDAJOZAwCTmQMAk5kDPLMzDAAAAAAAzMwMADAzAAAwMwAAMDMAwMzMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"largeStar\": \"hwQqACoAAAAAsMsAAAAAAAAAAAAAAAAAALDLAAAAAAAAXLvMALC7uwCwu7sAsLu7AFy7zAAAAADAW1W1u7vdvbu73b27u929y1tVtQAAAABcVVW7EdvdGxHb3RsR2927XFVVuwAAAABcVVW7EbG9ERGxvRERsb3bXFVVuwAAAADAW1W1ERHdHRER3R0REd0RwVtVtQAAAAAAXLvMEdER0RHREdER0REREVy7zAAAAAAAu8sREREREREREREREREREb3LAAAAAACwvdsREREREREREREREREREd29AAAAAACw3dsRERERERERERERERERERG9AAAAAACw3d0RERERERERERERERERERGxAAAAAACw2xsdERERERERERERERERERGxAAAAAAAAuxERERERERERERERERERERG7AAAAAAAAGxERERERERERERERERER0bG9CwAAAAAAGxEREREREREREREREREREd3dCwAAAACwGxEdEREREREREREREREREb3dCwAAAACwvdERERERERERERERERERER3bCwAAAACw3dsRERERERERERERERER0RGxCwAAAACw3d0RERERERERERERERERERGxAAAAAACw2xsdERERERERERERERERERGxAAAAAAAAuxERERERERERERERERERERG7AAAAAAAAGxERERERERERERERERER0bG9CwAAAAAAGxEREREREREREREREREREd3dCwAAAACwGxEdEREREREREREREREREb3dCwAAAACwvdERERERERERERERERERER3bCwAAAACw3dsRERERERERERERERER0RGxCwAAAACw3d0RERERERERERERERERERGxAAAAAACw2xsdERERERERERERERERERGxAAAAAAAAuxERERERERERERERERERERG7AAAAAAAAGxERERERERERERERERER0bG9CwAAAAAAGxEREREREREREREREREREd3dCwAAAAAA2xEdEREREREREREREREREb3dCwAAAAAAu8sdEREREREREREREREREb3LCwAAAAAAXLvMEREREREREREREREREVy7zAAAAADAW1W1HREdER0RHREdER0RzVtVtQAAAABcVVW73d0REdHdERHR3RERXFVVuwAAAABcVVW7vdsbERHbGxER2xsRXFVVuwAAAADAW1W1u929EbHdvRGx3b0RzVtVtQAAAAAAXLvM2927u9vdu7vb3bu7u1y7zAAAAAAAsMsAsLsLALu7CwC7uwsAALDLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"mediumStar\": \"hwQhACEAAAAAsMsAAAAAAAAAAAAAsMsAAAAAAABcu8wAsLu7ALC7uwBcu8wAAAAAwFtVtbu73b27u929y1tVtQAAAABcVVW7EdvdGxHb3btcVVW7AAAAAFxVVbsRsb0REbG921xVVbsAAAAAwFtVtRER3R0REd0RwVtVtQAAAAAAXLvMEdER0RHRERERXLvMAAAAAAC7yxERERERERERERG9ywAAAAAAsL3dERERERERERERER3bCwAAAACw3dsRERERERERERHREbELAAAAALDd3RERERERERERERERsQAAAAAAsNsbHRERERERERERERGxAAAAAAAAuxEREREREREREREREbsAAAAAAAAbEREREREREREREdGxvQsAAAAAABsREREREREREREREd3dCwAAAACwGxEdERERERERERERvd0LAAAAALC90REREREREREREREd2wsAAAAAsN3bERERERERERER0RGxCwAAAACw3d0REREREREREREREbEAAAAAALDbGx0RERERERERERERsQAAAAAAALsRERERERERERERERG7AAAAAAAAGxERERERERERERHRsb0LAAAAAAAbERERERERERERERHd3QsAAAAAANsRHREREREREREREb3dCwAAAAAAu8sdERERERERERERvcsLAAAAAABcu8wRERERERERERFcu8wAAAAAwFtVtR0RHREdER0RzVtVtQAAAABcVVW70d0REdHdERFcVVW7AAAAAFxVVbsR2xsREdsbEVxVVbsAAAAAwFtVtbHdvRGx3b0RzVtVtQAAAAAAXLvM2927u9vdu7u7XLvMAAAAAACwywC7uwsAu7sLAACwywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"mediumShell\": \"hwQhACEAAAAAzMwMADMDAAAzAwDAzMwAAAAAAMAzO8MwmTkAMJk5ADyzMwwAAAAAPDuzO5yZmTOTmZnGszuzwwAAAAA8szM7nBGRmZkRkcmzMzvDAAAAALwzO7McmRmZGZkZyTuzM8sAAAAAPDuzu7yZmRGRmZnLuzuzwwAAAAA8u7PbsRERmRkRERu9O7vDAAAAAMAzux0bERERERERsdG7MwwAAAAAAMzMsRERERERERERG8zMAAAAAAAAk7kbERERERERERGxG5kDAAAAADCZkRERERERERERERGZkTkAAAAAkxmZEREREREREREREZmROQAAAACTGZkRERERERERERERmZE5AAAAAJMZmREREREREREREREZmQMAAAAAMJmRERERERERERERkZE5AAAAAAAAkxkZERERERERERGRkTkAAAAAAACTGRkREREREREREZGROQAAAAAAAJMZGRERERERERERERmZAwAAAAAwmZERERERERERERERmZE5AAAAAJMZmRERERERERERERGZkTkAAAAAkxmZEREREREREREREZmROQAAAACTGZkRERERERERERERGZkDAAAAADCZsRsREREREREREbGbOQAAAAAAAMzMsRERERERERERG8zMAAAAAADAM7sdGxEREREREbHRuzMMAAAAADy7s9uxERGRmRERG707u8MAAAAAPDuzu7yZmRkRmZnLuzuzwwAAAAC8MzuznJGZkZmRmcE7szPLAAAAADyzMzucGRGZmRkRybMzO8MAAAAAPDuzOzyZmTkzmZnJszuzwwAAAADAMzvDAJOZAwCTmQM8szMMAAAAAADMzAwAMDMAADAzAMDMzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"mediumLeaf0\": \"hwQhACEAAACIiAAAiAAAiAgAgAgAAIiIAAAAAGh3iIBnCIB2hgBohwCId4YAAAAAeHZniHeHaGdniHeHiHZnhwAAAAB4Z3eGZ3d4Z3d4Z2dod3aHAAAAAIB3eGZ3dnhnd3h2Z2aHdwgAAAAAgHaHZnZmaGdnaHaGZnhnCAAAAAAAaGZoaGeIhoZoZ4iGZoYAAAAAAACAZoaIiIiIiIiIiGiGiIgAAAAAgGiGiGZmZmZmZmZmiHZ3hwAAAAB4d2eIZmZmZmZmZmZod3aGAAAAAGhnd4ZmZmZmZmZmZnhmdwgAAAAAgHdmh2ZmZmZmZmZmaHaHAAAAAAAAeGeGZmZmZmZmZmaIiIgAAAAAAACIiIhmZmZmZmZmZoh2ZwgAAAAAgHZniGZmZmZmZmZmaHd3hgAAAABod3eGZmZmZmZmZmaIZmaHAAAAAHhmZohmZmZmZmZmZmh3d4YAAAAAaHd3hmZmZmZmZmZmiHZnCAAAAACAdmeIZmZmZmZmZmaIiIgAAAAAAACIiIhmZmZmZmZmZmh2hwAAAAAAAHhnhmZmZmZmZmZmeGZ3CAAAAACAd2aHZmZmZmZmZmZod3aGAAAAAGhnd4ZmZmZmZmZmZoh2d4cAAAAAeHdniGZmZmZmZmZmiGiGCAAAAACIiGiGiIiIiIiIiIhoZggAAAAAAABoZmiIdoZoaIh2hoZmhgAAAAAAgHaHZmhnhnZ2hmZnZnhnCAAAAACAd3hmdmeHd3aHZ3dmh3cIAAAAAHhnd4Z2dod3dod3dmh3docAAAAAeHZniHh3iHZ2hnh3iHZnhwAAAABod4gAeIYAaGcIgHYIiHeGAAAAAIiIAACACACAiAAAiAAAiIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"mediumLeaf1\": \"hwQhACEAAACIiAgAiIiIiIiIiIgAAIiIAAAAAHh3hoh4d3h3eHd4d4iIdocAAAAAeHd3iHZ2eHZ2dnh2hnZ3hwAAAABoZ3eGZ3Z2Zmd2dmZnd3aHAAAAAIh3doZnd3ZnZ3d2Z2dnd4YAAAAAgHZnhmdnaHdnZ2h3h3Z3CAAAAACAaIaIiIiIiIiIiIiIZoYIAAAAAIh2d4hmZmZmZmZmZoiIiIgAAAAAeGd2aGZmZmZmZmZmhndniAAAAAB4ZndoZmZmZmZmZmaGZnaHAAAAAHh3Z2hmZmZmZmZmZoZ3ZocAAAAAiGiGaGZmZmZmZmZmhnZ3hwAAAAB4d2doZmZmZmZmZmaGaIaIAAAAAHhmd2hmZmZmZmZmZoZ2d4cAAAAAeGdmaGZmZmZmZmZmhndmhwAAAACIdndoZmZmZmZmZmaGZ3aHAAAAAHhndmhmZmZmZmZmZoZ3Z4gAAAAAeGZ3aGZmZmZmZmZmhmZ2hwAAAAB4d2doZmZmZmZmZmaGd2aHAAAAAIhohmhmZmZmZmZmZoZ2d4cAAAAAeHdnaGZmZmZmZmZmhmiGiAAAAAB4ZndoZmZmZmZmZmaGdneHAAAAAHhnZmhmZmZmZmZmZoZ3ZocAAAAAgHZ3aGZmZmZmZmZmhmd2hwAAAACAiIiIZmZmZmZmZmaId2cIAAAAAIBoZoiIiIiIiIiIiIhohggAAAAAgHdneHeGdnZ3hnZ2aHZnCAAAAABod3Z2dmd3dnZnd3ZoZ3cIAAAAAHhnd3ZmZ2d2Zmdndmh3doYAAAAAeHdnaGeHZ2dnh2dniHd3hwAAAAB4Z4iId4d3h3eHd4eIaHeHAAAAAIiIAACIiIiIiIiIiACAiIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"smallIndustrial0\": \"hwQYABgAAAAzu7u7u7u7u7u7u8vTMzMzMzMzMzMzs8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTPTMzMzMzMzMzM8zTMzMzMzMzMzMzs8wzu7u7u7u7u7u7u8s=\",\n  \"smallIndustrial1\": \"hwQYABgAAAAzM7u7u7u7u7u7u7vTPTMzMzMzMzMzs7vTM7s7MzMzMzO7O7vTMz07MzMzMzM9O7vTMz07MzMzMzM9O7vTM7s7MzMzMzO7O7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTMzMzMzMzMzMzM7vTM7s7MzMzMzO7O7vTMz07MzMzMzM9O7vTMz07MzMzMzM9O7vTM7s7MzMzMzO7O7vTPTMzMzMzMzMzs7szM7u7u7u7u7u7u7s=\",\n  \"smallBlue0\": \"hwQYABgAAAAAmZmZmZmZmZmZmQCQaWZmZmZmZmZmlgmZZmZmZmZmZmZmZplpZmZmZmZmZmZmZpZpFhERERERERERYZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpEREREREREREREZZpFhERERERERERYZZpZmZmZmZmZmZmZpaZZmZmZmZmZmZmZpmQaWZmZmZmZmZmlgkAmZmZmZmZmZmZmQA=\",\n  \"smallBlue1\": \"hwQYABgAAAAAZmZmZmZmZmZmZgBglpmZmZmZmZmZaQZmmZmZmZmZmZmZmWaWmZmZmZmZmZmZmWmWGRERERERERERkWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWEREREREREREREWmWGRERERERERERkWmWmZmZmZmZmZmZmWlmmZmZmZmZmZmZmWZglpmZmZmZmZmZaQYAZmZmZmZmZmZmZgA=\",\n  \"smallDefault\": \"hwQYABgAAAAAu7u7u7u7u7u7uwCwHRERERERERERvQvb0bu7u7u7u7u70bsbvR0RERERERHRG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbuxERERERERERG7sbvR0RERERERHRG7vb0bu7u7u7u7u70buwHRERERERERERvQsAu7u7u7u7u7u7uwA=\",\n  \"smallSwirlyWhite\": \"hwQYABgAAAAAu7u7u7u7u7u7uwCwuxG7EbsRuxG7EQsbG7EbsRuxG7Ebsbsbsbu7u7u7u7u7G7u7sRsRERERERGxG7G7uxERERERERERu7EbuxERERERERERu7sbsRERERERERERG7u7sRERERERERERG7G7uxERERERERERu7EbuxERERERERERu7sbsRERERERERERG7u7sRERERERERERG7G7uxERERERERERu7EbuxERERERERERu7sbsRERERERERERG7u7sRERERERERERG7G7uxERERERERERu7EbuxERERERERERu7sbsRsRERERERGxG7u7sbu7u7u7u7u7G7G7G7EbsRuxG7EbsbGwEbsRuxG7EbsRuwsAu7u7u7u7u7u7uwA=\",\n  \"smallSwirlyPurple\": \"hwQYABgAAAAAqrqruqu6q7qrqgCw3bu63brdut263Qrb3a3brdut263b3a3b3b2ruqu6q7rb3a263RsRERERERGx3auruxERERERERERq7vbuhERERERERERu7rarRERERERERER2qu6rRERERERERER2q2ruxERERERERERq73buhERERERERERu7rarRERERERERER2qu6rRERERERERER2q2ruxERERERERERq73buhERERERERERu7rarRERERERERER2qu6rRERERERERER2q2ruxERERERERERq727uhERERERERERu7q73RsRERERERGx3avb3b2ruqu6q7rb3a3b3b3avdq92r3a3a2w3avdq92r3au73QoAqrqruqu6q7qrqgA=\",\n  \"smallDialogLeftThin\": \"hwQYABgAAAAAAMDMzMzMzMwAAMAAwNsREREREdHLAMsA3BERERERERHRvMHAHRERERERERERHcGwEREREREREREREcvcERERERERERER0QwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQwcEREREREREREREQzcERERERERERER0QywERERERERERERsQDAHRERERERERERzQAA3BERERERERHRDAAAwNsREREREdHLAAAAAMDMzMzMzMwAAAA=\",\n  \"smallDialogLeftThick\": \"hwQYABgAAAAAAMDMzMzMzMwMAMwAwNsREREREb3MsM0A3BERERERERHNHM3AHRERERERERHREcywERERERERERER0czcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQzcERERERERERERzQywERERERERERERywDAHRERERERERHRzAAA3BERERERERHNDAAAwNsREREREb3MAAAAAMDMzMzMzMwAAAA=\",\n  \"smallDialogCenterThin\": \"hwQYABgAAAAAAMDMzMzMzAwAAAAAwNsREREREb0MAAAA3BERERERERHNAADAHRERERERERHRDACwERERERERERERCwDcERERERERERERzQAcERERERERERERwQAcERERERERERERwQAcERERERERERERwQAcERERERERERERzQAcERERERERERERsQwcEREREREREREREcEcERERERERERERsQwcERERERERERERzQAcERERERERERERwQAcERERERERERERwQAcERERERERERERwQAcERERERERERERwQDcERERERERERERzQCwERERERERERERCwDAHRERERERERHRDAAA3BERERERERHNAAAAwNsREREREb0MAAAAAMDMzMzMzAwAAAA=\",\n  \"smallDialogcenterThick\": \"hwQYABgAAAAAAMDMzMzMzMwAAAAAwNsREREREb3MAAAA3BERERERERHNDADAHRERERERERHRzACwERERERERERERywDcERERERERERERzQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERzQwcERERERERERERsQwcEREREREREREREcEcERERERERERERsQwcERERERERERERzQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQwcERERERERERERwQzcERERERERERERzQywERERERERERERywDAHRERERERERHRzAAA3BERERERERHNDAAAwNsREREREb3MAAAAAMDMzMzMzMwAAAA=\"\n}",
            "sprites.dialog.ts": "namespace sprites.dialog {\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const hugeLeaf = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const largeShell = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const largeStar = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const mediumStar = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const mediumShell = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const mediumLeaf0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const mediumLeaf1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallIndustrial0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallIndustrial1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallBlue0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallBlue1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallDefault = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallSwirlyWhite = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallSwirlyPurple = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallDialogLeftThin = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallDialogLeftThick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallDialogCenterThin = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"dialog\"\n    export const smallDialogcenterThick = image.ofBuffer(hex``);\n}\n",
            "sprites.duck.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.duck\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"duck1\": \"hwQQABAAAAAAAAAAsMsMAAAAsAuw3csAAACwvdvd3QwAALBVvdzdywAAsFtVzd3NAAC7tVXF3c0AsFtVW7XdzQCwVdXRW9XNALBVFf9VVc0Au1X1v1RVxQC1VVVFVFXFALVV1URUVbUAC1tFRFRVuwAAsPtMVNULAAAAALC0uwAAAAAAAAsAAA==\",\n  \"duck2\": \"hwQQABAAAAAAAAAAsMsMAAAAsAuw3csAAACwvdvd3QwAALBVvdzdywAAsFtVzd3NAAC7tVXF3c0AsFtVW7XdzQCwVdXRW9XNALBVFf9VVc0Au1X1v1RVxbC1VVVFVFXFULtV1URUVbWwAFtFRFRVuwAAsPtMVNULAAAAAEC7uwAAAAAAsAAAAA==\",\n  \"duck3\": \"hwQQABAAAAAAAAAAu8sMAAAAAAC93csAAAAAAN3c3QwAAAAAXcXdywAAsLtb1dzNAAC7VVtV3M0AsFtVvVXbzQCw1dFVvdXNALAV/1VVVc2wu/W/RVVVxVu8VdVEVVXFtbBV3URVVbULANtERFVVuwAA8ExEW9ULAAAAALSwuwAAAAAACwAAAA==\",\n  \"duck4\": \"hwQQABAAAAAAAAAAAMsMCwAAAACw3bsLAAAAANvdWwwAAACw3b1dzAAAu9vdW7XMALBbVdVbzc0Au1VVVdvczQBbHV1Vxd3NAFvxX1VVVc2wW/9LVVVVxVtb1URVVVXFtVvdRFVVVbULsEREVVVVuwAATLRbVdULAABAC7C7uwAAALAAAAAAAA==\",\n  \"duck5\": \"hwQQABAAAAAAAAAAsMy8AAAAAADbvbsAAAAAANu9xQAAAACw3dvFAAAAu9u9VcsMALBbVb3V3AwAu1VVtc3dzQBbHV1V3N3NAFvxX1VVVc2wW/9LVVVVxVtb1URVVVXFtVvdRFVVVbULsEREVVVVuwAATLRbVdULAABAC7C7uwAAALAAAAAAAA==\",\n  \"duck6\": \"hwQQABAAAAAAAAAAu8wAAAAAALC9vQwAAAAAsN3czQAAAACwXcW9DAAAu9tb1dwMALBbVVtV3AwAu1VVvVXbDABbHV1Vvd0MAFvxX1VV1QywW/9bVFVVDFtbVU1UVVUMtVvVTVRVVQsLsE1EVFW1CwAAz0S0Vb0AAAAAQAu7CwAAAACwAAAAAA==\",\n  \"duckHurt\": \"hwQQABAAAAAAAAAAAMsMAAAAsAuw3csAAACwvdvd3QwAALBVvdzdywAAu1tVzd3NALBbtVXF3c0Au1VVW7XdzQBbW1vVW9XNAFu8XFVVVc27W/VLVVVVxVVb1URVVVXFu1vdRFVVVbUAsEREVVVVuwAATLRbVdULAABAC7C7uwAAALAAAAAAAA==\",\n  \"log1\": \"hwQYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAABgZwAAAAAAAAAAAAB2ZwAAALDL7O7Mz2B3hgAAANvd++7uzv936O4AsL27ve/u7s5m7u4A27u92+/u7u5udmcA29vb2/vu7u5ud+ewvb29vf3u7u7uZ+6wvb29vc3u7u7uhu6wvb29vc3u7u7uhu6wvb29vc3u7u7uZ+4A29vb28vu7u5ud+cA27u92+zu7u5ud2cAsL27vezu7u5uhu4AANvdy+7u7u5mhuwAALDL7A4AAGB3Z/4AAAAAAAAAAAB2Zw4AAAAAAAAAAABgZwAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log2\": \"hwQYACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAABgAAAAAAAAAAAAAAAHYGAAAAAGBnAAAAAAAAAAAAAABgdwYAAAAAdmcAAAAAALvM7s78DHZnCAAAAGB3hgAAAACw3b3v7u78f4fu7u7M/3fu7gAAANu72/vu7u5s5u7u7u7uZu7uAACwvdu7/e7u7u5md+bu7u5udmcAALC9vb297+7u7nZ37u7u7m535wAA29vb29vv7u7ufubu7u7u7mfuAADb29vb2+zu7u5u6O7u7u7uh+4AANvb29vb7O7u7m7o7u7u7u6H7gAA29vb29vs7u7ufubu7u7u7mfuAACwvb29vezu7u52d+7u7u5ud+YAALC927vN7u7u7nZ35u7u7m53ZwAAANu728vu7u7uZuju7u7ubobOAAAAsN297O7u7m5myO7O/P92hu4AAAAAu8zuAAAAdnfm////bndnAAAAAAAAAAAAAABgd+YAAAAAdmcAAAAAAAAAAAAAAAB2BgAAAABgZwAAAAAAAAAAAAAAAGAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log3\": \"hwQYADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAABgAAAAAAAABgAAAAAAAAAAAAAAAABgZwAAAAAAdgYAAAAAYGcAAAAAAAAAAAAAAAAAdmcAAAAAYHcGAAAAAHZnAAAAAAAAsMvs7szPYHeGAAAAAHZnCAAAAGB3hgAAAAAAANvd++7uzv936O7uzvx/5+7u7u7uZ87MAAAAALC9u73v7u7OZu7u7u7ububu7u7u7mbu7gAAAADbu73b7+7u7m52Z+7u7u5md/bM7O5ud2cAAAAA29vb2/vu7u5ud+fu7u7udnfu7u7ubnfnAAAAsL29vb397u7u7mfu7u7u7n7m7u7u7u5n7gAAALC9vb29ze7u7u6G7u7u7u5+6O7u7u7uh+4AAACwvb29vc3u7u7uhu7u7u7ufuju7u7u7ofuAAAAsL29vb3N7u7u7mfu7u7u7n7m7u7u7u5n7gAAAADb29vby+7u7m535+7u7u52Z+7u7u5ud+YAAAAA27u92+zu7u5ud2fu7u7udnfm7u7ufndnAAAAALC9u73s7u7ubobu7u7u7mbozPz/zG6G7gAAAAAA293L7u7u7maG7O7M/29n6O7u7u5mhu4AAAAAALDL7A4AAGB3Z/7//+92dwYAAABgd2cAAAAAAAAAAAAAAAAAdmcOAAAAYHcGAAAAAHZnAAAAAAAAAAAAAAAAAGBnAAAAAAB2BgAAAABgZwAAAAAAAAAAAAAAAAAABgAAAAAAYAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log4\": \"hwQYAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAGAAAAAABgAAAAAAAABgAAAAAAAAAAAAAAdgYAAAAAYGcAAAAAAHYGAAAAAGBnAAAAAAAAAAAAAGB3BgAAAAB2ZwAAAABgdwYAAAAAdmcAAAAAu8zuzvwMdmcIAAAAYHeGAAAAAHZnCAAAAGB3hgAAALDdve/u7vx/h+7u7sz/d+7u7u7ufubMzP///2fMzAAA27vb++7u7mzm7u7u7u5m7u7u7u5u5u7uzMzMZszMALC927v97u7u7mZ35u7u7m52Z8/M7u52d+bMzMx8d2cAsL29vb3v7u7udnfu7u7ubnfn7u7u7nZ37s7OzGx3xwDb29vb2+/u7u5+5u7u7u7uZ+7u7u7ufubu7u7MzGfMANvb29vb7O7u7m7o7u7u7u6H7u7u7u5+6O7u7szMh8wA29vb29vs7u7ubuju7u7u7ofu7u7u7n7o7u7MzsyHzADb29vb2+zu7u5+5u7u7u7uZ+7u7u7ufubuzszMzGfMALC9vb297O7u7nZ37u7u7m535u7u7u52Z+7u7s5sd8YAsL3bu83u7u7udnfm7u7ubndn7u7u7nd35szMznx3ZwAA27vby+7u7u5m6O7u7u5uhs7M/8/sZujuzszMbIbMAACw3b3s7u7ubmbI7s78/3aG7u7u7m5m6O7uzPxmhv8AAAC7zO4AAAB2d+b///9ud2cAAAAAdncGAAAAYHdnAAAAAAAAAAAAAGB35gAAAAB2ZwAAAABgdwYAAAAAdmcAAAAAAAAAAAAAAHYGAAAAAGBnAAAAAAB2BgAAAABgZwAAAAAAAAAAAAAAYAAAAAAAAAYAAAAAAGAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log5\": \"hwQYABAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAdgYAAAAAAGB3BgAAAAAAdmcIAAAAAAB+5szu7u6+AG7m7u7u7u4L7nZ37u7u7r7udnfu7u7u7u5+5u7u7u7u7n7o7u7u7u7ufuju7u7u7u5+5u7u7u7u7nZn7u7u7u7ud3fu7u7uvuxm6O7u7u4Lbmbo7u7uvgB2dwYAAAAAAGB3BgAAAAAAAHYGAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log6\": \"hwQYACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAABgAAAAAAAAAAdgYAAAAAYGcAAAAAAAAAYHcGAAAAAHZnAAAAAAAAAHZnCAAAAGB3hgAAAAAAAAB/5+7u7u7uZ87s7u7uCwAAbubu7u7u7mbu7u7u7r4AAO5md/bM7O5ud+fu7u7uCwDudnfu7u7ubnfn7u7u7g4A7n7m7u7u7u5n7u7u7u4OAO5+6O7u7u7uh+7u7u7uDgDufuju7u7u7ofu7u7u7g4A7n7m7u7u7u5n7u7u7u4OAO52Z+7u7u5ud+bu7u7uDgDudnfm7u7ufnfn7u7u7gsA7mbozPz/zG6G7u7u7r4AAG9n6O7u7u5mhu7u7u4LAAB2dwYAAABgd2cAAAAAAAAAYHcGAAAAAHZnAAAAAAAAAAB2BgAAAABgZwAAAAAAAAAAYAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log7\": \"hwQYADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAYAAAAAAGAAAAAAAAAAAAAAdgYAAAAAYGcAAAAAAHYGAAAAAAAAAABgdwYAAAAAdmcAAAAAYHcGAAAAAAAAAAB2ZwgAAABgd4YAAAAAdmcIAAAAAAAAAAB/5+7u7u7/d+7u7u7ufubM7u7uvgAAAABu5u7u7u7uZu7u7u7ububu7u7u7gsAAADuZnfm7u7ubnZnz8zu7nZ37u7u7r4AAADudnfu7u7ubnfn7u7u7nZ37u7u7u4AAADufubu7u7u7mfu7u7u7n7m7u7u7u4AAADufuju7u7u7ofu7u7u7n7o7u7u7u4AAADufuju7u7u7ofu7u7u7n7o7u7u7u4AAADufubu7u7u7mfu7u7u7n7m7u7u7u4AAADudmfu7u7ubnfm7u7u7nZn7u7u7u4AAADudnfm7u7ubndn7u7u7nd37u7u7r4AAADuZujs7u7ubobOzP/P7Gbo7u7u7gsAAABvZ+juzvz/dobu7u7ubmbo7u7uvgAAAAB2d+b///9ud2cAAAAAdncGAAAAAAAAAABgd+YAAAAAdmcAAAAAYHcGAAAAAAAAAAAAdgYAAAAAYGcAAAAAAHYGAAAAAAAAAAAAYAAAAAAAAAYAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n  \"log8\": \"hwQYADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAABgAAAAAAYAAAAAAAAAYAAAAAAAAAdgYAAAAAYGcAAAAAAHYGAAAAAGBnAAAAAAAAYHcGAAAAAHZnAAAAAGB3BgAAAAB2ZwAAAAAAAHZnCAAAAGB3hgAAAAB2ZwgAAABgd4YAAAAAAAB/h+7u7sz/d+7u7u7+f+fu7u7u7mfO7O7u7gsAbObu7u7u7mbu7u7u7m7m7u7u7u5m7u7u7u6+AO5md+bu7u5udmfu7u7uZnf2zOzubnfn7u7u7gvudnfu7u7ubnfn7u7u7nZ37u7u7m535+7u7u4O7n7m7u7u7u5n7u7u7u5+5u7u7u7uZ+7u7u7uDu5u6O7u7u7uh+7u7u7ufuju7u7u7ofu7u7u7g7ubuju7u7u7ofu7u7u7n7o7u7u7u6H7u7u7u4O7n7m7u7u7u5n7u7u7u5+5u7u7u7uZ+7u7u7uDu52d+7u7u5ud+bu7u7udmfu7u7ubnfm7u7u7g7udnfm7u7ubndn7u7u7nZ35u7u7n535+7u7u4L7mbo7u7u7m6Gzu7u7u5m6Mz8/8xuhu7u7u6+AG5myO7O/P92hu7uzP9vZ+ju7u7uZobu7u7uCwB2d+b///9ud2f+///web.archive.org/web/20191229135125/https://vdncgaaaayhdnaaaaaaaayhfmaaaaahzndgaaagb3bgaaaab2zwaaaaaaaab2bgaaaabgzwaaaaaadgyaaaaaygcaaaaaaaaayaaaaaaaaayaaaaaagaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=\",\n  \"tree\": \"hwQkACkAAAAAAAAAAAAAAAAAgIYAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgIaIBgAAAAAAAAAAAAAAAAAAAAAAAICGaIZmhgAAAAAAAAAAAAAAAAAAAAAAAICGZmhmiIgAAAAAAAAAAAAAAAAAAABgAGZmZ2aGaGYIAAAAAAAAAAAAAAAAAAB2CGh2Z2aIZoYIAAAAAAAAAAAAAAAAAIB3hmh2ZmZoZoiICAAAAAAAAAAAAAAAAIZndmdmdmZmhmhmCAAAAAAAAAAAAGAAYGdmd2dmd2dmZmaGiAAAAAAAAAAAAHYGaGdmd2Znd2ZmZmaIhgAAAAAAAAAAAHiHdmZnZ3ZnZmZmZoZohgAAAAAAAABgCGhndnZnZndnZnZmZmZmhgAAAAAAAABghnZmZnZnZndmZndnZmZmiAAAAAAAAACAZnZmZnZmZmZ2ZndmZmaIiAAAAAAAAACAhndmZmd2Z3Z3dmZmZmZmhg4AAAAAAACAeHd3ZmZ3Z3d3ZnZ3ZmZmZujM/w8AAABod3dnZnZ3ZndmZnd3ZmZmiOjuzg8AAAB2d3dmZmZmZnZ3ZmZmZmaGiO7u7gwAAACAdnd3Zndndnd3ZndnZmZmhuj/7w4AAACAaHdmZnd3d3dnZndndndmhgjA7A4AAABgeHZ2ZnZ3dnd3ZmZmdmdmhgDszgwAAAAAeIZ2Z2Z3Znd3dmdmZmZmyO7OAAAAAAAAZmhoZ2Zmd3dmdndmZmaG6AwAAAAAAAAAiGiGZ2dmd3dmZmZ2d2dmiAAAAAAAAAAAAGCIeGdmd3dmZ2Zmd2dmZggAAAAAAAAAAAAAYIdnd2dmd2ZmdmdmhgAAAAAAAAAAAAAAAIZ2dmdmd2d3ZmaGCAAAAAAAAAAAAAAAAAB4Z2d3dmd3ZmZmCAAAAAAAAAAAAAAAAABgZ2Z3ZmZ2ZmaGCAAAAAAAAAAAAAAAAAAAhmd2ZnZmZoYIAAAAAAAAAAAAAAAAAAAAgHdmZnZmZoYAAAAAAAAAAAAAAAAAAAAAAHZmZmZmZoYAAAAAAAAAAAAAAAAAAAAAAIBohmZmiAgAAAAAAAAAAAAAAAAAAAAAAACACGhmCAAAAAAAAAAAAAAAAAAAAAAAAAAAAICGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIAAAAAAAAAAAAAAA=\"\n}",
            "sprites.duck.ts": "namespace sprites.duck {\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duckHurt = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log7 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log8 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tree = image.ofBuffer(hex``);\n}\n",
            "sprites.dungeon.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.dungeon\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"buttonOrange\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8u05ERN1EvLvrRERERE3Eu0tERERE1MS7S0RERETUxLtLRERERNTEu0tERERE1MS7S0RERETUxLtLRERERNTEu0tERERE1MS7S0RERETUxLvrRERERE3Eu7tORETdRLy7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"buttonOrangeDepressed\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8u+tERNRNvLu7TkRERNTEu7tERERERM27u0REREREzbu7RERERETNu7tERERERM27u0REREREzbu7RERERETNu7tERERERM27u0REREREzbu7TkRERNTEu7vrRETUTby7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"buttonTeal\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8u2xmZplmvLvLZmZmZmnGu2tmZmZmlsa7a2ZmZmaWxrtrZmZmZpbGu2tmZmZmlsa7a2ZmZmaWxrtrZmZmZpbGu2tmZmZmlsa7a2ZmZmaWxrvLZmZmZmnGu7tsZmaZZry7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"buttonTealDepressed\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8u8tmZpZpvLu7bGZmZpbGu7tmZmZmZsm7u2ZmZmZmybu7ZmZmZmbJu7tmZmZmZsm7u2ZmZmZmybu7ZmZmZmbJu7tmZmZmZsm7u2ZmZmZmybu7bGZmZpbGu7vLZmaWaby7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"buttonPink\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8uzozMxEzvLurMzMzMzHDuzszMzMzE8O7OzMzMzMTw7s7MzMzMxPDuzszMzMzE8O7OzMzMzMTw7s7MzMzMxPDuzszMzMzE8O7OzMzMzMTw7urMzMzMzHDu7s6MzMRM7y7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"buttonPinkDepressed\": \"hwQQABAAAAC7u7u7u7u7u8u7u7u7u7u8u6szMxMxvLu7OjMzMxPDu7szMzMzM8G7uzMzMzMzwbu7MzMzMzPBu7szMzMzM8G7uzMzMzMzwbu7MzMzMzPBu7szMzMzM8G7uzMzMzMzwbu7OjMzMxPDu7urMzMTMby7y7u7u7u7u7y7u7u7u7u7uw==\",\n  \"chestClosed\": \"hwQQABAAAAAAu7u7y7y7C7Du7u677M6760Tk7rvs7rtLRETuu+zuC0tERO677O4LS0RE7rvs7gtLRETuu8vuC0tERO7NvO4LS0RE7s287gtLRETuu8vuC0tERO677O4LS0RE7rvs7gtLRETuu+zuC+tE5O677O67sO7u7rvszrsAu7u7y7y7Cw==\",\n  \"chestOpen\": \"hwQQABAAAACwuwu7u7u7C+vuu8zM6867S+S7zMzr7rtLRLvMzOvuC0tEu8zM6+4LS0S7zMzr7gtLRLvLzOvuC0tEzbzM6+4LS0TNvMzr7gtLRLvLzOvuC0tEu8zM6+4LS0S7zMzr7gtLRLvMzOvuC0vku8zM6+67S+67zMzrzruwuwu7u7u7Cw==\",\n  \"collectibleInsignia\": \"hwQQABAAAABmZmZmZmZmZpaZZpmZZplplmmWyZxplmmWZplpzJlmaWaWmWacmWlmZpmZZpmZmWaWyZmWZmaZaZbMnJaZZsZplmxmmWnJzGmWmWZmaZmcaWaZmZlmmZlmZpaZyWaZaWaWZpnMlplmaZZplsmcaZZplplmmZlmmWlmZmZmZmZmZg==\",\n  \"collectibleRedCrystal\": \"hwQQABAAAAAAAAAAAAAAAAAAAEREAAAAAAA0MyREAAAAMDMzMyIEAAA0MzMzI0IAADQzIyIzQgBANDMiIiIiBEBFIiJEJCIEQEUiQkREIgRARCJCREQiBABEEUJEREIAAEQRRUQkQgAAQFRVREIEAAAARERERAAAAAAAREQAAAAAAAAAAAAAAA==\",\n  \"collectibleBlueCrystal\": \"hwQQABAAAAAAAAAAAAAAAAAAAGZmAAAAAAB2d4ZmAAAAcHd3d4gGAAB2d3d3h2gAAHZ3h4h3aABgdneIiIiIBmBliIhmhogGYGWIaGZmiAZgZohoZmaIBgBmEWhmZmgAAGYRZWaGaAAAYFZVZmgGAAAAZmZmZgAAAAAAZmYAAAAAAAAAAAAAAA==\",\n  \"darkGroundNorthWest0\": \"hwQQABAAAADMzMzMzMzMzLy7u7u7u7u7vMzMzMzMzMy8zMzMzMy8zLzMzMzMzMzMvMzMzLzMzMy8zLzMzMzMzLzMzMzMzMzLvMzMzMzMzMy8zMzMzMzMzLzMzMzMzMzMvMy8zLzMzMy8zMzMzMzMzLzMzMzMzLzMvMzMzMzMzMy8zMzMzMzMzA==\",\n  \"darkGroundNorth\": \"hwQQABAAAAC8zMzMzMzMzLzMzLzMzMzMvLzMzMzMvMy8zMzMzMzMzLzMzMzMzMzMvMzMzLzMzMy8zLzMzMzMzLzMzMzMzMzLvMzMzMzMzMy8zMzMzMzMzLzMzMzMzMzMvMy8zLzMzMy8zMzMzMzMzLzMzMzMzLzMvMzMzMzMzMy8zMzMzMzMzA==\",\n  \"darkGroundNorthEast0\": \"hwQQABAAAAC8zMzMzMzMzLzMzLzMzMzMvLzMzMzMvMy8zMzMzMzMzLzMzMzMzMzMvMzMzLzMzMy8zLzMzMzMzLzMzMzMzMzLvMzMzMzMzMy8zMzMzMzMzLzMzMzMzMzMvMy8zLzMzMy8zMzMzMzMzLzMzMzMzMzMvLu7u7u7u7vMzMzMzMzMzA==\",\n  \"darkGroundEast\": \"hwQQABAAAADMzMzMzMzMzMzMzLzMzMzMzMvMzMzMvMzMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzMzMu7u7u7u7u7vMzMzMzMzMzA==\",\n  \"darkGroundSouthEast0\": \"hwQQABAAAADMzMzMzMzMy8zMzLzMzMzLzMvMzMzMzMvMzMzMzMzMy8zMzMzMzMzLzMzMzLzMzMvMzLzMzMzMy8zMzMzMzMzLzMzMzMzMy8u8zMzMzMzMy8zMzMzMzMzLzMy8zLzMzMvMzMzMzMzMy8zMzMzMzMzLu7u7u7u7u8vMzMzMzMzMzA==\",\n  \"darkGroundSouth\": \"hwQQABAAAADMzMzMzMzMzLu7u7u7u7vLzMzMzMzMzMvMy8zMzMzMy8zMzMzMzMzLzMzMzLzMzMvMzLzMzMzMy8zMzMzMzMzLzMzMzMzMy8u8zMzMzMzMy8zMzMzMzMzLzMy8zLzMzMvMzMzMzMzMy8zMzMzMzMzLvMzMzMzMzMvMzMzMzMzMyw==\",\n  \"darkGroundSouthWest0\": \"hwQQABAAAADMzMzMzMzMy8zMzLzMzMzLzMvMzMzMzMvMzMzMzMzMy8zMzMzMzMzLzMzMzLzMzMvMzLzMzMzMy8zMzMzMzMzLzMzMzMzMy8u8zMzMzMzMy8zMzMzMzMzLzMy8zLzMzMvMzMzMzMzMy8zMzMzMzMzLvMzMzMzMy8vMzMzMzMzMyw==\",\n  \"darkGroundWest\": \"hwQQABAAAADMzMzMzMzMzLu7u7u7u7u7zMzMzMzMzMzMvMzMzMy8zMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzLzMvMzMzMzMzMzMzMzMzMzMzA==\",\n  \"darkGroundCenter\": \"hwQQABAAAADMzMzMzMzMzMzMzLzMzMzMzMvMzMzMvMzMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzLzMvMzMzMzMzMzMzMzMzMzMzA==\",\n  \"darkGroundNorthWest1\": \"hwQQABAAAADMzMzMzMzMzMzMzLzMzMzMzMvMzMzMvMzMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzMzMvMzMzMzMzLvMzMzMzMzMyw==\",\n  \"darkGroundNorthEast1\": \"hwQQABAAAADMzMzMzMzMy8zMzLzMzMy7zMvMzMzMy8zMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzLzMvMzMzMzMzMzMzMzMzMzMzA==\",\n  \"darkGroundSouthEast1\": \"hwQQABAAAAC8zMzMzMzMzLvMzLzMzMzMzMzMzMzMvMzMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzLzMvMzMzMzMzMzMzMzMzMzMzA==\",\n  \"darkGroundSouthWest1\": \"hwQQABAAAADMzMzMzMzMzMzMzLzMzMzMzMvMzMzMvMzMzMzMzMzMzMzMzMzMzMzMzMzMzLzMzMzMzLzMzMzMzMzMzMzMzMzLzMzMzMzMzMy8zMzMzMzMzMzMzMzMzMzMzMy8zLzMzMzMzMzMzMzMzMzMzMzMzLzMu8zMzMzMzMy8zMzMzMzMzA==\",\n  \"doorClosedWest\": \"hwQQABAAAAC8u7u7u7u7y7y7u7u7u7vL3N3d3d3d3c3c3d3d3d3dzczMzMzMzMzMvLvP//z8u8vcvc///Pzbzdy9z//8/NvN3L3P//z8283cvc///PzbzbzLz//8/LzL3L3Pz//8283cvc/P//zbzdy9z8///NvN3L3Pz//8283KrM/P//zKrA==\",\n  \"doorClosedSouth\": \"hwQQABAAAADKzMzMzMzMzNzdvd3dy9273N293d3L3bu6u8u7u8vdu///////z927zMzMzMzM3bv//////8/du8zM/P//z927///PzMzM3bv//////8/du8zMzMzMzN27///////P3bu6u8u7u8vdu9zdvd3dy9273N293d3L3bvKzMzMzMzMzA==\",\n  \"doorClosedNorth\": \"hwQQABAAAADMzMzMzMzMrLvdvN3d293Nu9283d3b3c273by7u7y7q7vd/P//////u93MzMzMzMy73fz//////7vdzMzM/P//u938///PzMy73fz//////7vdzMzMzMzMu938//////+73by7u7y7q7vdvN3d293Nu9283d3b3c3MzMzMzMzMrA==\",\n  \"doorClosedEast\": \"hwQQABAAAADKrM///PzKrNy9z//8/NvN3L3P//z8283cvc///Pzbzdy9z//8/NvNvMvPz//8vMvcvc/P//zbzdy9z8///NvN3L3Pz//8283cvc/P//zbzby7z8///LvLzMzMzMzMzMzc3d3d3d3dzdzd3d3d3d3NvLu7u7u7u8u8u7u7u7u7yw==\",\n  \"doorOpenWest\": \"hwQQABAAAAC8u7u7u7u7y7y7u7u7u7vL3N3d3d3d3c3c3d3d3d3dzczMzMzMzMzMvLv/////u8vcvf/////bzdy9/////9vN3L3/////283cvf/////bzbzL/////7zL3L3/////283cvc/8///bzdy9///M/NvN3L3M/M/M283KrMzMzMzKrA==\",\n  \"doorOpenSouth\": \"hwQQABAAAADKzMzMzMzMzNzdvd3dy9273N293d3L3bu6u8u7u8vdu8z/////z927zM/////P3bvMz////8/du/z/////z927/Pz////P3bvM/P///8/du8z8////z927zP/////P3bu6u8u7u8vdu9zdvd3dy9273N293d3L3bvKzMzMzMzMzA==\",\n  \"doorOpenNorth\": \"hwQQABAAAADMzMzMzMzMrLvdvN3d293Nu9283d3b3c273by7u7y7q7vd/P/////Mu938////z8y73fz////PzLvd/P///8/Pu938/////8+73fz////8zLvd/P////zMu938/////8y73by7u7y7q7vdvN3d293Nu9283d3b3c3MzMzMzMzMrA==\",\n  \"doorOpenEast\": \"hwQQABAAAADKrMzMzMzKrNy9zPzPzNvN3L3PzP//283cvf//z/zbzdy9/////9vNvMv/////vMvcvf/////bzdy9/////9vN3L3/////283cvf/////bzby7/////7vLzMzMzMzMzMzc3d3d3d3dzdzd3d3d3d3NvLu7u7u7u8u8u7u7u7u7yw==\",\n  \"doorLockedWest\": \"hwQQABAAAAC8u7u7u7u7y7y7u7u7u7vL3N3d3d3d3c3c3d3d3d3dzczMzMzMzMzMvMu7u7u7vMvczbu7u7vczdzNtFu1S9zN3M3rtVu+3M3czetURb7czbzLtPVUS7zL3M275ES73M3czbtO5LvczdzNu+u+u9zN3M27u7u73M3KzMzMzMzMrA==\",\n  \"doorLockedSouth\": \"hwQQABAAAADKzMzMzMzMzNzdvd3dy9273N293d3L3bvMzMzMzMzdu7y7S7u0y927vLu77rvL3bu861RUu8vdu7xO/rW1y927vE5EtbXL3bu861RUu8vdu7y7u+67y927vLtLu7TL3bvMzMzMzMzdu9zdvd3dy9273N293d3L3bvKzMzMzMzMzA==\",\n  \"doorLockedNorth\": \"hwQQABAAAADMzMzMzMzMrLvdvN3d293Nu9283d3b3c273czMzMzMzLvdvEu7tLvLu928u+67u8u73by7RUW+y7vdvFtbROTLu928W1vv5Mu73by7RUW+y7vdvLvuu7vLu928S7u0u8u73czMzMzMzLvdvN3d293Nu9283d3b3c3MzMzMzMzMrA==\",\n  \"doorLockedEast\": \"hwQQABAAAADKzMzMzMzMrNzNu7u7u9zN3M2767673M3czbtO5LvczdzNu0ROu9zNvMu0RV9LvMvczetURb7czdzN67VbvtzN3M20W7VL3M3czbu7u7vczbzLu7u7u7zLzMzMzMzMzMzc3d3d3d3dzdzd3d3d3d3NvLu7u7u7u8u8u7u7u7u7yw==\",\n  \"floorLight0\": \"hwQQABAAAAAdERGxHRERsdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d3d0d3d3bu7u+27u7vtHRERsR0REdHR3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3d3dHd3b27u7vtu7u77Q==\",\n  \"floorLight1\": \"hwQQABAAAAAdERGxHRERsdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHdvbvR3d3d0d27u7u7u+27u7vtHRERsR0REbHR3d290d3dvdHdvbvR3d290d27u9Hd3b3RHd290d3dvdEb3b3R3d29sd3d3dHd3b27u7vtu7u77Q==\",\n  \"floorLight2\": \"hwQQABAAAAAdERERERERsdHd3d3d3d290d3d3d3d3b3R3d3d3d3dvdHd3d3d3d290d3d3d3d3b3R3d3d3d3dvdHd3d3d3d290d3d3d3d3b3R3d3d3d3dvdHd3d3d3d290d3d3d3d3b3R3d3d3d3dvdHd3d3d3d290d3d3d3d3b27u7u7u7u7uw==\",\n  \"floorLight3\": \"hwQQABAAAAAdERGxzMzMzNHd3b3MzMzM0d3dvcwcEczR3d29EdHdy9Hd3b0c3d3L0d3dvczd3cvR3d3tzMzdvbu7287MzNy9HRGxy8zMzL3R3b0cwczMy9HdvdEdwczM0d3L3N3dvczR3cvM3N29zNHdy8zM3MvM0b3MzMzMzMy7u8zMzMzMzA==\",\n  \"floorLight4\": \"hwQQABAAAAAdERGxu7u7u9Hd3b0dERGx0d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d3d0d3dvbu7u+3R3bvbHRERsbu7Ee3R3d29HdHd3dHd3b3R3d290d3dvdHd3b3R3d290d3dvdHd3b3R3d290d3d3dHd3b27u7vtu7u77Q==\",\n  \"floorLight5\": \"hwQQABAAAAAdERERERERsdHd3d3d3d290d3d3d3d3b3R3d3d3d3dvdHd3d3d3d29293d3d3d3bux293d3d27u9G9u93dvRux0d3d270b0b3R3d29G9HdvdHd3d293d290d3d3b3d3b3R3d3d3dvdvdHd3d3d29290d3d3d293b27u7u7u7u7uw==\",\n  \"floorDark0\": \"hwQQABAAAADb3d3N293dzb27u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7u7vbu7u8zMzKvMzMyr293dzdvd3b29u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7u727u8vMzMyrzMzMqw==\",\n  \"floorDark1\": \"hwQQABAAAADb3d3N293dzb27u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7y727y8y9u7u7vbvMzMzMzKvMzMyr293dzdvd3c29u7vLvbu7y727y8y9u7vLvbvMzL27u8u927vLvbu7y73cu8u9u7vLzbu7u727u8vMzMyrzMzMqw==\",\n  \"floorDark2\": \"hwQQABAAAADb3d3d3d3dzb27u7u7u7vLvbu7u7u7u8u9u7u7u7u7y727u7u7u7vLvbu7u7u7u8u9u7u7u7u7y727u7u7u7vLvbu7u7u7u8u9u7u7u7u7y727u7u7u7vLvbu7u7u7u8u9u7u7u7u7y727u7u7u7vLvbu7u7u7u8vMzMzMzMzMrA==\",\n  \"floorDark3\": \"hwQQABAAAADb3d3NzMzMzL27u8vMzMzMvbu7y8zc3cy9u7vL3b27zL27u8vcu7vMvbu7y8y7u8y9u7urzMy7y8zMvMrMzLzL293NzMzMzMu9u8vczczMzL27y73bzczMvbvMvLu7y8y9u8zMvLvLzL27zMzMvMzMvcvMzMzMzMzMzMzMzMzMzA==\",\n  \"floorDark4\": \"hwQQABAAAADb3d3NzMzMzL27u8vb3d3Nvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7u7vbu7y8zMzKu9u8y8293dzczM3au9u7vL2727u727u8u9u7vLvbu7y727u8u9u7vLvbu7y727u8u9u7vLvbu7u727u8vMzMyrzMzMqw==\",\n  \"floorDark5\": \"hwQQABAAAADb3d3d3d3dzb27u7u7u7vLvbu7u7u7u8u9u7u7u7u7y727u7u7u7vLvLu7u7u7u8zNvLu7u7vMzL3LzLu7y9zNvbu7vMvcvcu9u7vL3L27y727u7vLu7vLvbu7u8u7u8u9u7u7u7y7y727u7u7vLvLvbu7u7vLu8vMzMzMzMzMrA==\",\n  \"floorDarkDiamond\": \"hwQQABAAAADb3d3N3N3dzb27u9zNu7vLvbvLvbu8u8u9u9y7u8u7y73Lvbu7u7zLvdy7u7u7y8vNvbu7u7u7vNy7u7u7u7vL3Lu7u7u7u9zNu7u7u7vLzb28u7u7u9zLvcu7u7vLvcu9u7y7u9y7y727y7vLvbvLvbu7vNy7u8vMzMzLzczMrA==\",\n  \"floorLightMoss\": \"hwQQABAAAAAdERGxHRERsdHd3bbR3d290d3dZtHd3b3R3W290d3dvdHd3b3R3d290d3dvd3d3b3R1t1t293d3btrtr3m7rvtHRERYWa+EdHR3d29Ft3dvdHd3W3R3d290d3dvdHd3bvR3d290d27vdHd3b3R3d290d3d3dG93b27u7vtu7u77Q==\",\n  \"floorMixed\": \"hwQQABAAAADb3d3NHRERwb27u8vR3d3Nvbu7y9Hd3c29u7vL0d3dzb27u8vR3d3Nvbu7y9Hd3c29u7u70d3d3czMzKvMzMytHRERwdvd3b3R3d3Nvbu7y9Hd3c29u7vL0d3dzb27u8vR3d3Nvbu7y9Hd3c29u7vL0d3d3b27u8vMzMytzMzMqw==\",\n  \"greenOuterNorthWest\": \"hwQQABAAAADPZmZmxmxmZvx8d3d3fHd3xsx3d3fMd3d2zGxmZsZmZnbHzMzMzMzMdmfMfHd3d8Z2Z8zMZmZmzHZnbMzMzMzMdmd8xsxmZmZ8Z3zGzGxmZnxnfMbGzMzMzGd8xmbMbGbMbHzGZszMzHbMfMZmbMxmdmdsxmZszM92Z8zGZmxs/A==\",\n  \"greenOuterNorth0\": \"hwQQABAAAAB2Z8zMZsxszHZnbMxmbGzMdmd8xmZszMx8ZnzGzGzMzMzMfMbGbGzMdmd8xmZsbMx2Z3zGZmxszHZnbMZmzGzMdmfMzGbMbMx2Z2zMZmxszHZnfMZmbMzMfGd8xmZszMzMzHzGzGxszHbHfMZmbGzMdmd8xmZsbMx2Z2zGZsxszA==\",\n  \"greenOuterNorth1\": \"hwQQABAAAAB2Z8zMZsxszHZnbMZmzGzMdmd8xmbMzMx8ZnzGxszMzMzMfMbMzGzMdmZ8xmzMbMx2Z2zGbMZszHZnbMxsxmzMdmfMzGbGbMx2Z2zMZsxszHZnfMZmbMzMfGd8xmZszMzMzHzGzGxszHbHfMZmbGzMdmd8xmZsbMx2Z2zGZsxszA==\",\n  \"greenOuterNorth2\": \"hwQQABAAAAB2Z8zMZsxszHZndsxmbGzMdnd2x2dszMx8d3Znd2zMzMxmdnd3Z2zMdnd2Z3dmbMx2d3dEbGZszHZ3RBXkbGzMdndHFeRsbMx2d3dEZGZszHZ3dnd3ZszMfHd2d3dnzMzMZnZnd2ZszHbHdmdnbGzMdmd8Z2ZsbMx2Z2zGZsxszA==\",\n  \"greenOuterNorthEast\": \"hwQQABAAAAB2Z8zMZmxs/HZnbMxmbGzPdmd8xmZszGx2Z3zGZszMzHbMfMZmzGxmzGx8xsbMzMx8Z3zGzGxmZnZnfMbMZmZmdmd8zMzMzMx2Z8zMZmZmZnZnzGx3d3fGdsfMzMzMzMx2zGxmZmbGZsbMd3d3d8x3/Hx3d3fHfHfPZmZmxsxsZg==\",\n  \"greenOuterEast0\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMZsxmZmbMZmbMzMzMzMzMzGxmZsZsZmbGzMzMzMzMzMxmxmxmZmZsZmbGZmZmZmxmzMzMzMzMzMzMZmZmzGZmZmx3d2dsd3dnzMzMzMzMzMxmZmxmZmbMZndnfHd3d3x3d3d8d3d3fHdmxmxmZsZsZg==\",\n  \"greenOuterEast1\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMZsxmZmbMZmbMzMzMzMzMzMzMzMzMZmbGzMzMZsbMzMxmxmxmZmZsZmZmzMxmZmxmzMzMzMzMzMxsZmbGzGZmZmx3d2Zsd3dnzMzMzMzMzMxmZmxmZmbMZndnbHd3d3x3d3d8d3d3fHdmxmxmZsZsZg==\",\n  \"greenOuterEast2\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMZsxmZmbMZmbMzMzMzMzMzGxmZmZmZmbGzMxnxmx2xsxmdnfmbndnZmZ3d0xEd3dmzGxnFEF3ZsbMd3dURXd3Z3x3d0d0d3dnbGZmR3dmZsxmd3Z3d3fGZnd3dnd3d3Z3d3d8d3d3fHdmxmxmZsZsZg==\",\n  \"greenOuterSouthEast\": \"hwQQABAAAADPxsZmbMx2Z/zMxmZsxnZnZszGZmzHzGfMzMxmbMfGzGbGzGZsx3bMzMzMbGzHdsdmZsbMbMd2x2ZmZsxsx3ZnzMzMzMzGdmfMZmZmzMx2Z2x3d3fHzHZnzMzMzMzMfGdmZmxmZsbMZ3d3zHd3d8xsd3fHd3d3x89mZsZsZmZm/A==\",\n  \"greenOuterSouth0\": \"hwQQABAAAADMxsxmbMZ2Z8zGxmZsx3ZnzMbGZmzHfGfMxsbMbMfMzMzMxmZsx3bHzMzGZmzHdmfMxsZmzMZ2Z8zGzGbMzHZnzMbMZmzGdmfMxsZmbMd2Z8zGxmZsx3ZnzMbGbGzHzMzMzMbMbMdmx8zMxmZsx3ZnzMbGZszGdmfMxsxmzMx2Zw==\",\n  \"greenOuterSouth1\": \"hwQQABAAAADMxsxmbMZ2Z8zGxmZsx3ZnzMbGZmzHfGfMxsbMbMfMzMzMxmZsx3bHzMzGZmzHdmfMxsxmzMZ2Z8zGbGbMzHZnzMZsxszGdmfMxmzGbMZ2Z8zGzMZsx2ZnzMbMzGzHzMzMzMxsbMdmx8zMzGZsx3ZnzMbMZmzGdmfMxsxmzMx2Zw==\",\n  \"greenOuterSouth2\": \"hwQQABAAAADMxsxmbMZ2Z8zGxmZ2x3ZnzMbGdnZnfGfMxmZ3dmdmzMzMdnd3Z3fHzMxmd3dnd2fMxmZGRHd3Z8zGxk5RdHdnzMbGTlFEd2fMxmbGRHd3Z8zGZnd2Z3dnzMZ2d3dnZszMzMZ3dmd3x8zMxnZ8Z3dnzMbGZsxndmfMxsxmzMx2Zw==\",\n  \"greenOuterSouthWest\": \"hwQQABAAAABmxsxsZmZm/HfHfHd3d8fPd8x3d3d3zGxmbGZmZsbMZ8zMzMzMzHxnbHd3d8bMdmdmZmZmzMx2Z8zMzMzMx3ZnZmZmzGzHdmdmZsbMbMd2x8zMzGxsx8bMZsbMZmzHzGfMzMxmbMd2Z8bMxmZsx3Zn/MbGZszGdmfPxsZmzMx2Zw==\",\n  \"greenOuterWest0\": \"hwQQABAAAABmxmxmZsZsZnfHd3d3x3d3d8d3d3fHdndmzGZmZsZmZszMzMzMzMzMdnd3xnZ3d8ZmZmbMZmZmzMzMzMzMzMzMZsZmZmZmbGZmxmZmZsZsZszMzMzMzMzMbGZmxmxmZsbMzMzMzMzMzGZmzGZmZsxmzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"greenOuterWest1\": \"hwQQABAAAABmxmxmZsZsZnfHd3d3x3d3d8d3d3fGdndmzGZmZsZmZszMzMzMzMzMdnd3xmZ3d8ZmZmbMbGZmxszMzMzMzMzMZsZmZszMZmZmxmZmZsZsZszMzGxmzMzMbGZmzMzMzMzMzMzMzMzMzGZmzGZmZsxmzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"greenOuterWest2\": \"hwQQABAAAABmxmxmZsZsZnfHd3d3x3d3d2d3d3dnd3dmbHd3d2d3ZsxmZnd0ZmbGdnd3R3R3d8d2d3dURXd3zGxmdxRBdsbMZnd3RMR3d2ZmdnfmbndnZsxsZ8ZsdszMbGZmZmZmZsbMzMzMzMzMzGZmzGZmZsxmzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"greenSwitchUp\": \"hwQQABAAAAB2Z8zMZsxszHZnbMxmbGzMdmd8xmZszMx8ZnzGzGzMzMzMzMzMzGzMdmfdvbu7y8x2Z828u7vLzHZnTcTMzMvMdmdN1M3My8x2Z929u7vLzHZn3b27u8vMfGfMzMzMzMzMzHzGzGxszHbHfMZmbGzMdmd8xmZsbMx2Z2zGZsxszA==\",\n  \"greenSwitchDown\": \"hwQQABAAAAB2Z8zMZsxszHZnbMxmbGzMdmd8xmZszMx8ZnzGzGzMzMzMzMzMzGzMdmfdvbu7y8x2Z929u7vMzHZn3b3M3UTMdmfdvczMRMx2Z929u7vLzHZn3b27u8vMfGfMzMzMzMzMzHzGzGxszHbHfMZmbGzMdmd8xmZsbMx2Z2zGZsxszA==\",\n  \"greenInnerNorthWest\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMzMxmZmbMZmbMzMzMzMzMzMzGZmZmZmbGzMbGzMzMzMzMxsZmZmZsZszGzHZmZmxmzMbMZsfMzMzMxsZmzGZmZszGxmZsd3dnzMbGbGx3zMzMzMbMbMfMZszMxmZsx2Z3zMbGZszGdnfMxsxmzMx2Zw==\",\n  \"greenInnerNorthEast\": \"hwQQABAAAADMxsxmbMZ2Z8zGxmZsx3Z3zMbGZmzHbHfMxsbMbMdsZszMxmZsd8zMzMzGZmx3d8bMxsZmzGZmzMzGxmbHzMzMzMbGdmZmbGbMxsZmZsZsZszGxszMzMzMzMZmxmxmZsbMzMzMzMzMzMzMZmZmZsxmzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"greenInnerSouthEast\": \"hwQQABAAAAB2Z8zMZsxszHdnbMxmbGzMd2Z8xmZszMxmzHzGzGzMzMzMd8bGbGzMdnd3xmZsbMxmZmbMZmxszMzMzHxmzGzMZsZmZmfMbMxmxmZmZmxszMzMzMzMbGzMbGZmZmZmbMzMzMzMzMzMzGZmzGZmZszMzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"greenInnerSouthWest\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMZsxmZmZmzMzMzMzMzMzMzGxmZsZsZmzMzMzMzMxsbMxmxmxmZmxszGbGZmZnbGzMzMzMfGZsbMzMZmbMZmxszGx3d8ZmbMzMzMx3xmZszMxmxnzGzGxszHfGfMZmbGzMd2d8xmZsbMx2Z2zGZsxszA==\",\n  \"hazardWater\": \"hwQQABAAAACMaJaWmZmZmYxolpaZmZmZjIhmlpmZmZmMhmaWmZmZmYyGZpmZmZmZjGZmmZmZmZmMaGaZmZmZmYxolpaZmZmZjGiWlpmZmZmMZpaWmZmZmYxmlpmZmZmZjIZmmZmZmZmMhmaZmZmZmYyIZpmZmZmZjIiWmZmZmZmMaJaZmZmZmQ==\",\n  \"hazardLava0\": \"hwQQABAAAABVJERCRVREREUiREJVVVVVJCIiVEVFVVUiJERVRCJURCJCVEQiQiJFIkRFJCIkJEUiVEUiJEIiRUJUJCIiIkJFREUkIiIiQkVCRSJEIiRCRUJFIkQiIlJFQlVEIiJCVCRCRVVFRFRVJERVRFVVVUQiVEREVEVVJEJVRCJCRVQkQg==\",\n  \"hazardLava1\": \"hwQQABAAAABFJEJCRVRFREQiIiJEQlVVREIiIkRCRFVFIiJEJCJCVUVERFQkQkJFVERUVSQiQkVUVVVVRCJURURERFVFQlREJCJCRFVEVCQiIkIkVFVVJCJERCJCVUUiIlREQkJVJCREVUUiQkVCQkRVRSJERSIkRFVEIlRFIkJURSRCVFVERA==\",\n  \"hazardHole\": \"hwQQABAAAAC8z////////7zP////////vPz////////M/Pz//////8z8/P//////zPz8//////+8/////////7zP////////vM////////+8z////////8z/////////zPz////////M/Pz//////8z8/P//////zP/////////cz////////w==\",\n  \"hazardSpike\": \"hwQQABAAAADMzMzMzMzM3My7u7u7u7sRzLu7u7u7HRHMvLu7uxsREcy8u7vbERERzMy7uxERERHMzLsdEREREczMGxERERERzMwbERERERHMzLsdEREREczMu7sRERERzLy7u9sRERHMvLu7uxsREcy7u7u7ux0RzLu7u7u7uxG8u7u7u7u72w==\",\n  \"purpleOuterNorthWest\": \"hwQQABAAAADPqqqqyqyqqvw8MzMzPDMzyswzMzPMMzM6zKyqqsqqqjrDzMzMzMzMOqPMPDMzM8o6o8zMqqqqzDqjrMzMzMzMOqM8ysyqqqo8ozzKzKyqqjyjPMrKzMzMzKM8yqrMrKrMrDzKqszMzDrMPMqqrMyqOqOsyqqszM86o8zKqqys/A==\",\n  \"purpleOuterNorth0\": \"hwQQABAAAAA6o8zMqsyszDqjrMyqrKzMOqM8yqqszMw8qjzKzKzMzMzMPMrKrKzMOqM8yqqsrMw6ozzKqqyszDqjrMqqzKzMOqPMzKrMrMw6o6zMqqyszDqjPMqqrMzMPKM8yqqszMzMzDzKzKyszDrDPMqqrKzMOqM8yqqsrMw6o6zKqsyszA==\",\n  \"purpleOuterNorth1\": \"hwQQABAAAAA6o8zMqsyszDqjrMqqzKzMOqM8yqrMzMw8qjzKyszMzMzMPMrMzKzMOqo8yqzMrMw6o6zKrMqszDqjrMysyqzMOqPMzKrKrMw6o6zMqsyszDqjPMqqrMzMPKM8yqqszMzMzDzKzKyszDrDPMqqrKzMOqM8yqqsrMw6o6zKqsyszA==\",\n  \"purpleOuterNorth2\": \"hwQQABAAAAA6o8zMqsyszDqjOsyqrKzMOjM6w6OszMw8MzqjM6zMzMyqOjMzo6zMOjM6ozOqrMw6MzNErKqszDozRBXkrKzMOjNDFeSsrMw6MzNEpKqszDozOjMzqszMPDM6MzOjzMzMqjqjM6qszDrDOqOjrKzMOqM8o6qsrMw6o6zKqsyszA==\",\n  \"purpleOuterNorthEast\": \"hwQQABAAAAA6o8zMqqys/DqjrMyqrKzPOqM8yqqszKw6ozzKqszMzDrMPMqqzKyqzKw8ysrMzMw8ozzKzKyqqjqjPMrMqqqqOqM8zMzMzMw6o8zMqqqqqjqjzKwzMzPKOsPMzMzMzMw6zKyqqqrKqsrMMzMzM8wz/DwzMzPDPDPPqqqqysysqg==\",\n  \"purpleOuterEast0\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMqsyqqqrMqqrMzMzMzMzMzKyqqsqsqqrKzMzMzMzMzMyqyqyqqqqsqqrKqqqqqqyqzMzMzMzMzMzMqqqqzKqqqqwzM6OsMzOjzMzMzMzMzMyqqqyqqqrMqjOjPDMzMzwzMzM8MzMzPDOqyqyqqsqsqg==\",\n  \"purpleOuterEast1\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMqsyqqqrMqqrMzMzMzMzMzMzMzMzMqqrKzMzMqsrMzMyqyqyqqqqsqqqqzMyqqqyqzMzMzMzMzMysqqrKzKqqqqwzM6qsMzOjzMzMzMzMzMyqqqyqqqrMqjOjrDMzMzwzMzM8MzMzPDOqyqyqqsqsqg==\",\n  \"purpleOuterEast2\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMqsyqqqrMqqrMzMzMzMzMzKyqqqqqqqrKzMyjyqw6ysyqOjPqrjOjqqozM0xEMzOqzKyjFEEzqsrMMzNURTMzozwzM0M0MzOjrKqqQzOqqsyqMzozMzPKqjMzOjMzMzozMzM8MzMzPDOqyqyqqsqsqg==\",\n  \"purpleOuterSouthEast\": \"hwQQABAAAADPysqqrMw6o/zMyqqsyjqjqszKqqzDzKPMzMyqrMPKzKrKzKqswzrMzMzMrKzDOsOqqsrMrMM6w6qqqsyswzqjzMzMzMzKOqPMqqqqzMw6o6wzMzPDzDqjzMzMzMzMPKOqqqyqqsrMozMzzDMzM8ysMzPDMzMzw8+qqsqsqqqq/A==\",\n  \"purpleOuterSouth0\": \"hwQQABAAAADMysyqrMo6o8zKyqqswzqjzMrKqqzDPKPMysrMrMPMzMzMyqqswzrDzMzKqqzDOqPMysqqzMo6o8zKzKrMzDqjzMrMqqzKOqPMysqqrMM6o8zKyqqswzqjzMrKrKzDzMzMzMrMrMOqw8zMyqqswzqjzMrKqszKOqPMysyqzMw6ow==\",\n  \"purpleOuterSouth1\": \"hwQQABAAAADMysyqrMo6o8zKyqqswzqjzMrKqqzDPKPMysrMrMPMzMzMyqqswzrDzMzKqqzDOqPMysyqzMo6o8zKrKrMzDqjzMqsyszKOqPMyqzKrMo6o8zKzMqsw6qjzMrMzKzDzMzMzMysrMOqw8zMzKqswzqjzMrMqqzKOqPMysyqzMw6ow==\",\n  \"purpleOuterSouth2\": \"hwQQABAAAADMysyqrMo6o8zKyqo6wzqjzMrKOjqjPKPMyqozOqOqzMzMOjMzozPDzMyqMzOjM6PMyqpKRDMzo8zKyk5RNDOjzMrKTlFEM6PMyqrKRDMzo8zKqjM6ozOjzMo6MzOjqszMzMozOqMzw8zMyjo8ozOjzMrKqsyjOqPMysyqzMw6ow==\",\n  \"purpleOuterSouthWest\": \"hwQQABAAAACqysysqqqq/DPDPDMzM8PPM8wzMzMzzKyqrKqqqsrMo8zMzMzMzDyjrDMzM8rMOqOqqqqqzMw6o8zMzMzMwzqjqqqqzKzDOqOqqsrMrMM6w8zMzKysw8rMqsrMqqzDzKPMzMyqrMM6o8rMyqqswzqj/MrKqszKOqPPysqqzMw6ow==\",\n  \"purpleOuterWest0\": \"hwQQABAAAACqyqyqqsqsqjPDMzMzwzMzM8MzMzPDOjOqzKqqqsqqqszMzMzMzMzMOjMzyjozM8qqqqrMqqqqzMzMzMzMzMzMqsqqqqqqrKqqyqqqqsqsqszMzMzMzMzMrKqqyqyqqsrMzMzMzMzMzKqqzKqqqsyqzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"purpleOuterWest1\": \"hwQQABAAAACqyqyqqsqsqjPDMzMzwzMzM8MzMzPKOjOqzKqqqsqqqszMzMzMzMzMOjMzyqozM8qqqqrMrKqqyszMzMzMzMzMqsqqqszMqqqqyqqqqsqsqszMzKyqzMzMrKqqzMzMzMzMzMzMzMzMzKqqzKqqqsyqzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"purpleOuterWest2\": \"hwQQABAAAACqyqyqqsqsqjPDMzMzwzMzM6MzMzOjMzOqrDMzM6MzqsyqqjM0qqrKOjMzQzQzM8M6MzNURTMzzKyqMxRBOsrMqjMzRMQzM6qqOjPqrjOjqsyso8qsOszMrKqqqqqqqsrMzMzMzMzMzKqqzKqqqsyqzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"purpleSwitchUp\": \"hwQQABAAAAA6o8zMqsyszDqjrMyqrKzMOqM8yqqszMw8qjzKzKzMzMzMzMzMzKzMOqPdvbu7y8w6o828u7vLzDqjTcTMzMvMOqNN1M3My8w6o929u7vLzDqj3b27u8vMPKPMzMzMzMzMzDzKzKyszDrDPMqqrKzMOqM8yqqsrMw6o6zKqsyszA==\",\n  \"purpleSwitchDown\": \"hwQQABAAAAA6o8zMqsyszDqjrMyqrKzMOqM8yqqszMw8qjzKzKzMzMzMzMzMzKzMOqPdvbu7y8w6o929u7vMzDqj3b3M3UTMOqPdvczMRMw6o929u7vLzDqj3b27u8vMPKPMzMzMzMzMzDzKzKyszDrDPMqqrKzMOqM8yqqsrMw6o6zKqsyszA==\",\n  \"purpleInnerNorthWest\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMzMyqqqrMqqrMzMzMzMzMzMzKqqqqqqrKzMrKzMzMzMzMysqqqqqsqszKzDqqqqyqzMrMqsPMzMzMysqqzKqqqszKyqqsMzOjzMrKrKwzzMzMzMrMrMPMqszMyqqsw6ozzMrKqszKOjPMysyqzMw6ow==\",\n  \"purpleInnerNorthEast\": \"hwQQABAAAADMysyqrMo6o8zKyqqswzozzMrKqqzDrDPMysrMrMOsqszMyqqsM8zMzMzKqqwzM8rMysqqzKqqzMzKyqrDzMzMzMrKOqqqrKrMysqqqsqsqszKyszMzMzMzMqqyqyqqsrMzMzMzMzMzMzMqqqqqsyqzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"purpleInnerSouthEast\": \"hwQQABAAAAA6o8zMqsyszDOjrMyqrKzMM6o8yqqszMyqzDzKzKzMzMzMM8rKrKzMOjMzyqqsrMyqqqrMqqyszMzMzDyqzKzMqsqqqqPMrMyqyqqqqqyszMzMzMzMrKzMrKqqqqqqrMzMzMzMzMzMzKqqzKqqqszMzMzMzMzMzMzMzMzMzMzMzA==\",\n  \"purpleInnerSouthWest\": \"hwQQABAAAADMzMzMzMzMzMzMzMzMzMzMqsyqqqqqzMzMzMzMzMzMzKyqqsqsqqzMzMzMzMysrMyqyqyqqqyszKrKqqqjrKzMzMzMPKqsrMzMqqrMqqyszKwzM8qqrMzMzMwzyqqszMyqyjzKzKyszDPKPMqqrKzMM6M8yqqsrMw6o6zKqsyszA==\",\n  \"stairWest\": \"hwQQABAAAADdzMzMzMzM3d28u7u7u8vd3dvd3d3dvd3dzMzMzMzM3d28u7u7u8vd3dvd3d3dvd3dzMzMzMzM3d28u7u7u8vd3dvd3d3dvd3dzMzMzMzM3d28u7u7u8vd3dvd3d3dvd3dzMzMzMzM3d28u7u7u8vdu9vd3d3dvbvMzMzMzMzMzA==\",\n  \"stairSouth\": \"hwQQABAAAAC83d3d3d3d3bzd3d3d3d3dvMzLvMzLvMzcy73cy73cy9zLvdzLvdzL3Mu93Mu93Mvcy73cy73cy9zLvdzLvdzL3Mu93Mu93Mvcy73cy73cy9zLvdzLvdzL3Mu93Mu93Mvcy73cy73cy7zMy7zMy7zMvN3d3d3d3d283d3d3d3d3Q==\",\n  \"stairNorth\": \"hwQQABAAAADd3d3d3d3dy93d3d3d3d3LzMu8zMu8zMu8zdu8zdu8zbzN27zN27zNvM3bvM3bvM28zdu8zdu8zbzN27zN27zNvM3bvM3bvM28zdu8zdu8zbzN27zN27zNvM3bvM3bvM28zdu8zdu8zczLvMzLvMzL3d3d3d3d3cvd3d3d3d3dyw==\",\n  \"stairEast\": \"hwQQABAAAADMzMzMzMzMzLvb3d3d3b273by7u7u7y93dzMzMzMzM3d3b3d3d3b3d3by7u7u7y93dzMzMzMzM3d3b3d3d3b3d3by7u7u7y93dzMzMzMzM3d3b3d3d3b3d3by7u7u7y93dzMzMzMzM3d3b3d3d3b3d3by7u7u7y93dzMzMzMzM3Q==\",\n  \"stairLarge\": \"hwQQABAAAADMzMzMzMzMzMzMzMy7u7u9zMzMzLu7u73MzMzMu7u7vczMzMy7u7u9zMzMzMzMvLvMzLu7u9u7u8zMu7u727u7zMy7u7vbu7vMzLu7u9u7u8zMzMzMu7u7vLu7u9u7u7u8u7u727u7u7y7u7vbu7u7vLu7u9u7u7vMzMzMzMzMzA==\",\n  \"stairLadder\": \"hwQQABAAAADu7u7u7u7u7kNOREREQ+7uQ+7u7u5DzuxDTj7kQ0PO7ENOPuRDQ87sQ04+5ENDzuxDTj7kQ0PO7ENOPuRDQ87sQ04+5ENDzuxDTj7kQ0PO7ENOPuRDQ87sQ04+5ENDzuxDTj7kQ0PO7EPu7u7uQ87sQ05ERERD7u7u7u7u7u7u7g==\",\n  \"statueLight\": \"hwQQACAAAAAAAAAAAAAAAAAAOzMzOxHLAAAAAAAAAAAAsBEREbEzswAAAAAAAAAAALARERGxM7MAAAAAAAAAEwCwMRMRETOzAAAAAAAwM7MAsBMxEREzswAAAAC7u8s8MzMzERMRs7MAETM7M8w8EREREREzEbOzEDOxEzEzERERETMzMxGzsxATETszERERMTMzMzMRs7MQEzETERMREREREREzEbOzAAAQMRsxERERERERMxGzswAAABExEQATERExMxMRM7MAAAAAAAAAAAATETMTETOzAAAAAAAAAAAAsDMTEbEzswAAAAAAAAAAALARERGxM7MAAAAAAAAAAAAAOzMzOxHL\",\n  \"statueDark\": \"hwQQACAAAAAAAAAAAAAAAAAAvLu7vN38AAAAAAAAAAAAwN3d3c27ywAAAAAAAAAAAMDd3d3Nu8sAAAAAAAAA2wDAvdvd3bvLAAAAAACwu8sAwNu93d27ywAAAADMzPy/u7u73dvdy8sA3bu8u/+/3d3d3d273cvL0LvN27273d3d3bu7u93Ly9Db3by73d3dvbu7u7vdy8vQ273b3dvd3d3d3d273cvLAADQvdy93d3d3d3du93LywAAAN293QDb3d29u9vdu8sAAAAAAAAAAADb3bvb3bvLAAAAAAAAAAAAwLvb3c27ywAAAAAAAAAAAMDd3d3Nu8sAAAAAAAAAAAAAvLu7vN38\"\n}",
            "sprites.dungeon.ts": "namespace sprites.dungeon {\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonOrange = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonOrangeDepressed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonTeal = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonTealDepressed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonPink = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const buttonPinkDepressed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const chestClosed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const chestOpen = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const collectibleInsignia = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const collectibleRedCrystal = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"?tile\"\n    export const collectibleBlueCrystal = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundNorthWest0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundNorth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundNorthEast0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundSouthEast0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundSouth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundSouthWest0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundCenter = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundNorthWest1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundNorthEast1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundSouthEast1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const darkGroundSouthWest1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorClosedWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorClosedSouth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorClosedNorth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorClosedEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorOpenWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorOpenSouth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorOpenNorth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorOpenEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorLockedWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorLockedSouth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorLockedNorth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const doorLockedEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLight5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDark5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorDarkDiamond = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorLightMoss = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const floorMixed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterNorthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterNorth0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterNorth1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterNorth2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterNorthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterEast0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterEast1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterEast2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterSouthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterSouth0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterSouth1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterSouth2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterSouthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterWest0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterWest1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenOuterWest2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenSwitchUp = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenSwitchDown = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenInnerNorthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenInnerNorthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenInnerSouthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const greenInnerSouthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const hazardWater = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const hazardLava0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const hazardLava1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const hazardHole = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const hazardSpike = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterNorthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterNorth0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterNorth1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterNorth2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterNorthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterEast0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterEast1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterEast2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterSouthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterSouth0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterSouth1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterSouth2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterSouthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterWest0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterWest1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleOuterWest2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleSwitchUp = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleSwitchDown = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleInnerNorthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleInnerNorthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleInnerSouthEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const purpleInnerSouthWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairWest = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairSouth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairNorth = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairEast = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairLarge = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const stairLadder = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const statueLight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const statueDark = image.ofBuffer(hex``);\n}\n",
            "sprites.space.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.space\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"spaceSmallAsteroid0\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8DAAAAAAAwLvLAAAAAAC6+68MAAAAwKurr8wAAADA+r/LDAAAAMDKv7oMAAAAAKCqvwAAAAAAwKysAAAAAAAAzAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceSmallAsteroid1\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAzAAAAAAAwKq7CwAAAACguqurAAAAAKD/y68AAAAArP+qvwAAAACsy7+6AAAAAAC6vMoAAAAAAAC7DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceSmallAsteroid2\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMwAAAAAAMCquwsAAAAAoLqrqwAAAACg/8uvAAAAAKz/qr8AAAAArMu/ugAAAAAAurzKAAAAAAAAuwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceSmallAsteroid3\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvMsAAAAAAMD8uwsAAAAAoP/6ugAAAACguru/AAAAAKz7v8wAAAAAwKuvDAAAAAAArMoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceAsteroid0\": \"hwQQABAAAAAAAMisygAAAAAAzPqoCgAAAMDMyo/MAAAAzLyrrMrMAADM/6uqussMAPj/uMqsu8yA+P+6zP+6ysD/j6vM/7/LwMyszMr6b8vMqszMrKpmzPyvysyqu6bMiP+qzPy4ygzA/6zM/8/LAMDMqPz/z8YAAMzM/I9szAAAwMzMrMoAAA==\",\n  \"spaceAsteroid1\": \"hwQQABAAAAAAwMzMAAAAAADMqrsMAAAAAKyPvAsAAAAAzPqvCwAAAADMqqqqvMsAAMysyqu7uwwAwMz6vMy6CgDMqoq/yrvGAIzPqrqqasYA/M/Mqrxmy8D8zMyqvMoMwMyqzIirAADA/6qMqAAAAMD8r8zMAAAAAMyvzAwAAAAAwMzMAAAAAA==\",\n  \"spaceSmallAsteroid4\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwKoMAAAAAADA/7sAAAAAALz7uwwAAAAAy7uqCwAAAAD6q/8LAAAAAKz6rwAAAAAAwMwMAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceSmallAsteroid5\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADKAAAAAAAAvKqrAAAAAAD6z/8KAAAAwP+7/wsAAADAu7q7CwAAAADM+78MAAAAAMD6ugwAAAAAALyrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n  \"spaceRedShip\": \"hwQQABAAAAAAAAAAAAAAzAAAAAAAAMDMAAAAAAAAzMwAAAAAAADPzAAAAAAA4M/MAAAAAADs78wAAAAA7izs7szMz+8uLCzu3b0vL0QuLiIAAAAA7k4uIgAAAAAA7i8iAAAAAADgTyQAAAAAAAAuQgAAAAAAAO4iAAAAAAAA4O4AAAAAAAAA7g==\",\n  \"spaceAsteroid2\": \"hwQQABAAAAAAAADAzAwAAAAAAKyqzAAAAMDM/K/LDAAAzMz8z7oMAMD/qsz/uswMwPyvyv+6uwvA/K/MzLqsu8D6rKysu8xqzKq6u2y2zGrMqsq6Zru7xsyq/2+7q7rLzMz/vLvKugzAqv+6u8vLAACsqrqquwwAAMCqzKqqAAAAAMzMzAAAAA==\",\n  \"spaceAsteroid3\": \"hwQQABAAAAAAAADMzMwAAADMzMysqgwAwKyqrLqMqwDAuoyqy/+8DLDL/6yGz7wMsPr/zGrKvAyw/I/MzLy8DKz7yMzMrLsLzLqqqqr6v8usqrvLr/+8u6q6u/yvyrq7rLu7/7y8u8vAvLvKvMy7DACsu7vLzLoMAACqvLvLzAAAAACsygAAAA==\",\n  \"spaceAsteroid4\": \"hwQQABAAAAAAAAAAzLq7CgAArArArLqrAMC8q6rKrKYArKq7qrvMuwDKrLuqu6rLoPzMpsy6uwqs/2/6zGqrDKz6qvuvtqoAzKqqu6zKDADA+sy6qwsAAMD6z6q6ywAAAKz/rLrGAAAAwKrKrKsAAAAAzP/PywAAAADA/6oMAAAAAMDMzAAAAA==\",\n  \"spaceOrangeShip\": \"hwQQABAAAAAAAAAAAAAA7gAAAAAAAODuAAAAAAAA7u4AAAAAAADv7gAAAAAA4O/uAAAAAADsL+4AAAAA7kwsIszMz+9OTEwi3b1PT1VCQkQAAAAAIlJCRAAAAAAAIk9EAAAAAAAgX0UAAAAAAABCVAAAAAAAACJEAAAAAAAAICIAAAAAAAAAIg==\",\n  \"spacePinkShip\": \"hwQQABAAAAAAAAAAAAAAiAAAAAAAAICIAAAAAAAAiIgAAAAAAACPiAAAAAAAgI+IAAAAAACMr4gAAAAAiDysqszMz484PDyq3b0/PxE6OjMAAAAAqho6MwAAAAAAqj8zAAAAAACgHzEAAAAAAAA6EwAAAAAAAKozAAAAAAAAoKoAAAAAAAAAqg==\",\n  \"spaceBlueShip\": \"hwQQABAAAAAAAAAAAAAAiAAAAAAAAICIAAAAAAAAiIgAAAAAAACPiAAAAAAAgI+IAAAAAACMj4gAAAAAiGyMiMzMz49obGyI3b1vb5lobmYAAAAAiJhuZgAAAAAAiG9mAAAAAACAn2kAAAAAAABolgAAAAAAAIhmAAAAAAAAgIgAAAAAAAAAiA==\",\n  \"spaceGreenShip\": \"hwQQABAAAAAAAAAAAAAAiAAAAAAAAICIAAAAAAAAiIgAAAAAAACPiAAAAAAAgI+IAAAAAACMb4gAAAAAiHxsZszMz494fHxm3b1/f1V2dncAAAAAZlZ2dwAAAAAAZn93AAAAAABgX3UAAAAAAAB2VwAAAAAAAGZ3AAAAAAAAYGYAAAAAAAAAZg==\"\n}",
            "sprites.space.ts": "namespace sprites.space {\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceRedShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceOrangeShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spacePinkShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceBlueShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceGreenShip = image.ofBuffer(hex``);\n}\n",
            "sprites.vehicle.jres": "{\n  \"*\": {\n    \"namespace\": \"sprites.vehicle\",\n    \"mimeType\": \"image/x-mkcd-f4\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"carRedLeft\": \"hwQQABAAAAAAAAAAAAAAAAAA0CIi7Q4AAAAtItLtDgAAACIi0uLuAAAgRCQi7v4PAMLMK+7u/w8gzLzu8u7/DyAi4r7i7/8PICLku+L+/gAgIuS74v7uACAi5Lvy/+4AICLk7u7u/gAgIuS74u7/DyBE5Lvi7v8PAMIsvuLu/w8AIMzi7u7/AA==\",\n  \"carRedRight\": \"hwQQABAAAAAAAAAAAAAAAAAAIiLu7g4AACDM4u7u/wAAwiy+4u7/DyBE5Lvi7v8PICLku+Lu/w8gIuTu7u7+ACAi5Lvy/+4AICLku+L+7gAgIuS74v7+ACAi4r7i7/8PIMy87vLu/w8Awswr7u7/DwAgRCQi7v4PAAAiItLi7gAAAC0i0u0OAA==\",\n  \"carRedBack\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4P//7u7/DwAiIiIi4u7/4MwiwuzuLf4uQkQkzuveDi4iIkK86+4OLCIiQrzr7g4sIiIivOvuDi4iIiK86+4OLiIiIs7r3g7gzCzC7O4t/gAiIiIi4u7/AOD//+7u/w8AAAAAAAAAAA==\",\n  \"carRedFront\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOD/7/4PAAAAIuIi7i4PAMLMzCxL3eIgQkQkskzSLSAkIiLLTCIiICQiIstMIiIgIiIiy0wiIiAiIiLLTCIiICIiIrJM0i0AwszMLEvd4gAAIuIi7i4PAADg/+/+/wAAAAAAAAAAAA==\",\n  \"carBlueLeft\": \"hwQQABAAAAAAAAAAAAAAAAAA0GZmjQgAAABtZtaNCAAAAGZm1oaIAABgmWlmiPgPAMbMa4iI/w9gzLyI9oj/D2BmhriGj/8PYGaJu4b4+ABgZom7hviIAGBmibv2/4gAYGaJiIiI+ABgZom7hoj/D2CZibuGiP8PAMZsuIaI/w8AYMyGiIj/AA==\",\n  \"carBlueRight\": \"hwQQABAAAAAAAAAAAAAAAAAAZmaIiAgAAGDMhoiI/wAAxmy4hoj/D2CZibuGiP8PYGaJu4aI/w9gZomIiIj4AGBmibv2/4gAYGaJu4b4iABgZom7hvj4AGBmhriGj/8PYMy8iPaI/w8AxsxriIj/DwBgmWlmiPgPAABmZtaGiAAAAG1m1o0IAA==\",\n  \"carBlueBack\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP//iIj/DwBmZmZmhoj/gMxmxoyIbfholplpyIvYCGhmZpa8i4gIbGZmlryLiAhsZmZmvIuICGhmZma8i4gIaGZmZsiL2AiAzGzGjIht+ABmZmZmhoj/AID//4iI/w8AAAAAAAAAAA==\",\n  \"carBlueFront\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAID/j/gPAAAAZoZmiGgPAMbMzGyb3YZglplptpzWbWBpZmbLnGZmYGlmZsucZmZgZmZmy5xmZmBmZmbLnGZmYGZmZrac1m0AxszMbJvdhgAAZoZmiGgPAACA/4/4/wAAAAAAAAAAAA==\",\n  \"carPinkLeft\": \"hwQQABAAAAAAAAAAAAAAAAAA0DMzrQoAAAA9M9OtCgAAADMz06OqAAAw3T0zqvoPAMPMO6qq/w8wzLyq86r/DzAzo7qjr/8PMDOtu6P6+gAwM627o/qqADAzrbvz/6oAMDOtqqqq+gAwM627o6r/DzDdrbujqv8PAMM8uqOq/w8AMMyjqqr/AA==\",\n  \"carPinkRight\": \"hwQQABAAAAAAAAAAAAAAAAAAMzOqqgoAADDMo6qq/wAAwzy6o6r/DzDdrbujqv8PMDOtu6Oq/w8wM62qqqr6ADAzrbvz/6oAMDOtu6P6qgAwM627o/r6ADAzo7qjr/8PMMy8qvOq/w8Aw8w7qqr/DwAw3T0zqvoPAAAzM9OjqgAAAD0z060KAA==\",\n  \"carPinkBack\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoP//qqr/DwAzMzMzo6r/oMwzw6yqPfo60909yqvaCjozM9O8q6oKPDMz07yrqgo8MzMzvKuqCjozMzO8q6oKOjMzM8qr2gqgzDzDrKo9+gAzMzMzo6r/AKD//6qq/w8AAAAAAAAAAA==\",\n  \"carPinkFront\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKD/r/oPAAAAM6MzqjoPAMPMzDzb3aMw0909s9zTPTA9MzPL3DMzMD0zM8vcMzMwMzMzy9wzMzAzMzPL3DMzMDMzM7Pc0z0Aw8zMPNvdowAAM6MzqjoPAACg/6/6/wAAAAAAAAAAAA==\",\n  \"roadTurn1\": \"hwQQABAAAAAAwMzMzMzMzAC8u7u7u7u7wLvd3d3d3d2827u7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7vbu7vL27uxvRu7u8vbu7EbG7u7y9u9sRu7u7vL27u727u7u8vbu7u7u7u7y9u7u7u7vdvL27u7u727u8vbu7u7vbyw==\",\n  \"roadTurn2\": \"hwQQABAAAAC8vbu7u7vby7y9u7u7u9u7vL27u7u7u928vbu7u7u7u7y9u7u9u7u7vL272xG7u7u8vbu7EbG7u7y9u7sb0bu7vL27u7u9u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u827u7u7u7u8C73d3d3d3dALy7u7u7u7sAwMzMzMzMzA==\",\n  \"roadTurn4\": \"hwQQABAAAADMzMzMzMwMALu7u7u7u8sA3d3d3d3duwy7u7u7u7u9y7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u727u7u9vLu7sdsbu728u7uxsRu7vby7u7uxG9u9vLu7u727u728u7u7u7u7vby927u7u7u9vLu727u7u728u8vbu7u7vbyw==\",\n  \"roadIntersection1\": \"hwQQABAAAAC7vbu7u7vby9u7u7u7u9vLvbu7u7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby727u7u7u9vL27u7u7u728u7vbu7u7vbyw==\",\n  \"roadIntersection2\": \"hwQQABAAAADMzMzMzMzMzLu7u7u7u7u73d3d3d3d3d27u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u727u7u7u7vb27u7u7u7u727vbu7u7vbuw==\",\n  \"roadVertical\": \"hwQQABAAAADMzMzMzMzMzLu7u7u7u7u73d3d3d3d3d27u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u9sREbvbERG7GxHRuxsR0bu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u93d3d3d3d3du7u7u7u7u7vMzMzMzMzMzA==\",\n  \"roadTurn3\": \"hwQQABAAAAC8vbu7u7vby7u9u7u7u9vL3bu7u7u728u7u7u7u7vby7u7u9u7u9vLu7u7Eb2728u7uxsRu7vby7u7HbG7u9vLu7vbu7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7u9y93d3d3d3bsMu7u7u7u7ywDMzMzMzMwMAA==\",\n  \"roadHorizontal\": \"hwQQABAAAAC8vbu7u7vby7y9uxu9u9vLvL27G7G728u8vbsbsbvby7y9uxuxu9vLvL2727G728u8vbu7u7vby7y9u7u7u9vLvL27u7u728u8vbsbvbvby7y9uxuxu9vLvL27G7G728u8vbsbsbvby7y9u9uxu9vLvL27u7u728u8vbu7u7vbyw==\",\n  \"roadIntersection3\": \"hwQQABAAAAC7vbu7u7vbu9u7u7u7u7u9vbu7u7u7u9u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u93d3d3d3d3du7u7u7u7u7vMzMzMzMzMzA==\",\n  \"roadIntersection4\": \"hwQQABAAAAC8vbu7u7vbu7y9u7u7u7u9vL27u7u7u9u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7vbvL27u7u7u728vbu7u7vbuw==\"\n}",
            "sprites.vehicle.ts": "namespace sprites.vehicle {\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadTurn1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadTurn2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadTurn4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadIntersection1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadIntersection2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadVertical = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadTurn3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadHorizontal = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadIntersection3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    //% tags=\"tile\"\n    export const roadIntersection4 = image.ofBuffer(hex``);\n}\n",
            "startup.ts": "// This is the last thing executed before user code\n\ngame.setWaitAnyButton(controller.pauseUntilAnyButtonIsPressed)\n// force first game engine\ngame.eventContext()"
        },
        "jacdac": {
            "README.md": "# JACDAC\n\n## ~ hint\n\n**JACDAC is still in early prototyping phase.** The protocol and all hardware design are MOST LIKELY to change during this phase. You are welcome to join us in prototyping but we strongly recommend avoiding going to production with JACDAC at the current stage.\n\nTo join the discussion, join us on [Discord](https://discord.gg/9WMc5Es).\n\n## ~\n",
            "actuator.ts": "namespace jacdac {\n    export class ActuatorService extends Host {\n        stateLength: number;\n        state: Buffer;\n\n        constructor(name: string, deviceClass: number, stateLength: number, controlDataLength?: number) {\n            super(name, deviceClass, controlDataLength);\n            this.stateLength = stateLength;\n            this.state = control.createBuffer(this.stateLength);\n        }\n\n        public handlePacket(packet: JDPacket): number {\n            this.state = packet.data;\n            return this.handleStateChanged();\n        }\n\n        protected handleStateChanged(): number {\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n    export class ActuatorClient extends Client {\n        protected state: Buffer;\n\n        constructor(name: string, deviceClass: number, stateLength: number, controlDataLength?: number) {\n            super(name, deviceClass, controlDataLength);\n            this.state = control.createBuffer(stateLength);\n            // TODO\n            // this.onDriverEvent(JDDriverEvent.Connected, () => this.notifyChange());\n        }\n\n        protected ensureState(length: number) {\n            if (length > this.state.length) {\n                const b = control.createBuffer(length);\n                b.write(0, this.state);\n                this.state = b;\n            }\n        }\n\n        protected notifyChange() {\n            this.sendPacket(this.state)\n        }\n    }\n}",
            "config.ts": "namespace jacdac {\n    // common logging level for jacdac services\n    export let consolePriority = ConsolePriority.Debug;\n\n    export function toHex(n: number): string {\n        const hexBuf = control.createBuffer(4);\n        hexBuf.setNumber(NumberFormat.UInt32LE, 0, n);\n        return hexBuf.toHex();\n    }\n    export function toHex16(n: number): string {\n        const hexBuf = control.createBuffer(2);\n        hexBuf.setNumber(NumberFormat.UInt16LE, 0, n);\n        return hexBuf.toHex();\n    }\n    export function toHex8(n: number): string {\n        const hexBuf = control.createBuffer(1);\n        hexBuf.setNumber(NumberFormat.UInt8LE, 0, n);\n        return hexBuf.toHex();\n    }\n\n    // drivers\n    export const JD_DEVICE_CLASS_MAKECODE_START = 2000;\n    export const LOGGER_DEVICE_CLASS = 2001;\n    export const BATTERY_DEVICE_CLASS = 2002;\n    export const ACCELEROMETER_DEVICE_CLASS = 2003;\n    export const BUTTON_DEVICE_CLASS = 2004;\n    export const TOUCHBUTTON_DEVICE_CLASS = 2005;\n    export const LIGHT_SENSOR_DEVICE_CLASS = 2006;\n    export const MICROPHONE_DEVICE_CLASS = 2007;\n    export const THERMOMETER_DEVICE_CLASS = 2008;\n    export const SWITCH_DEVICE_CLASS = 2009;\n    export const PIXEL_DEVICE_CLASS = 2010;\n    export const HAPTIC_DEVICE_CLASS = 2011;\n    export const LIGHT_DEVICE_CLASS = 2012;\n    export const KEYBOARD_DEVICE_CLASS = 2013;\n    export const MOUSE_DEVICE_CLASS = 2014;\n    export const GAMEPAD_DEVICE_CLASS = 2015;\n    export const MUSIC_DEVICE_CLASS = 2016;\n    export const SERVO_DEVICE_CLASS = 2017;\n    export const CONTROLLER_DEVICE_CLASS = 2018;\n    export const LCD_DEVICE_CLASS = 2019;\n    export const MESSAGE_BUS_DEVICE_CLASS = 2020;\n    export const COLOR_SENSOR_DEVICE_CLASS = 2021;\n    export const LIGHT_SPECTRUM_SENSOR_DEVICE_CLASS = 2022;\n    export const PROXIMITY_DEVICE_CLASS = 2023;\n    export const TOUCH_BUTTONS_DEVICE_CLASS = 2024;\n    export const SERVOS_DEVICE_CLASS = 2025;\n    export const ROTARY_ENCODER_DEVICE_CLASS = 2026;\n\n    // events\n    export const JD_MESSAGE_BUS_ID = JD_DEVICE_CLASS_MAKECODE_START;\n\n    export const BUTTON_EVENTS: number[] = [\n        DAL.DEVICE_BUTTON_EVT_CLICK,\n        DAL.DEVICE_BUTTON_EVT_LONG_CLICK,\n        DAL.DEVICE_BUTTON_EVT_DOWN,\n        DAL.DEVICE_BUTTON_EVT_UP\n    ];\n}\n\nconst enum JDLightCommand {\n    None,\n    SetAll,\n    SetBrightness,\n    Rainbow,\n    RunningLights,\n    ColorWipe,\n    Comet,\n    TheaterChase,\n    Sparkle\n}\n\nenum JDLightAnimation {\n    //% block=\"rainbow\"\n    Rainbow = JDLightCommand.Rainbow,\n    //% block=\"running lights\"\n    RunningLights = JDLightCommand.RunningLights,\n    //% block=\"color wipe\"\n    ColorWipe = JDLightCommand.ColorWipe,\n    //% block=\"comet\"\n    Comet = JDLightCommand.Comet,\n    //% block=\"theater chase\"\n    TheaterChase = JDLightCommand.TheaterChase,\n    //% block=\"sparkle\"\n    Sparkle = JDLightCommand.Sparkle\n}\n\nconst enum JDKeyboardCommand {\n    None,\n    Type,\n    Key,\n    MediaKey,\n    FunctionKey\n}\n\nconst enum JDMouseCommand {\n    None,\n    Button,\n    Move,\n    TurnWheel\n}\n\nconst enum JDGamepadCommand {\n    None,\n    Button,\n    Move,\n    Throttle\n}\n\nconst enum JDMusicCommand {\n    None,\n    PlayTone\n}\n\nconst enum JDGesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = DAL.ACCELEROMETER_EVT_SHAKE,\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = DAL.ACCELEROMETER_EVT_TILT_UP,\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = DAL.ACCELEROMETER_EVT_TILT_DOWN,\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = DAL.ACCELEROMETER_EVT_TILT_LEFT,\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = DAL.ACCELEROMETER_EVT_TILT_RIGHT,\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = DAL.ACCELEROMETER_EVT_FACE_UP,\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = DAL.ACCELEROMETER_EVT_FACE_DOWN,\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = DAL.ACCELEROMETER_EVT_FREEFALL,\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = DAL.ACCELEROMETER_EVT_3G,\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = DAL.ACCELEROMETER_EVT_6G,\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = DAL.ACCELEROMETER_EVT_8G,\n    /**\n     * Raised when a 2g move (or step) is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = DAL.ACCELEROMETER_EVT_2G,\n}\n\nconst enum JDDimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3\n}\n\nconst enum JDButtonEvent {\n    //% block=\"click\"\n    Click = DAL.DEVICE_BUTTON_EVT_CLICK,\n    //% block=\"long click\"\n    LongClick = DAL.DEVICE_BUTTON_EVT_LONG_CLICK,\n    //% block=\"up\"\n    Up = DAL.DEVICE_BUTTON_EVT_UP,\n    //% block=\"down\"\n    Down = DAL.DEVICE_BUTTON_EVT_DOWN\n}\n\nconst enum JDSwitchDirection {\n    //% block=\"left\"\n    Left = DAL.DEVICE_BUTTON_EVT_UP,\n    //% block=\"right\"\n    Right = DAL.DEVICE_BUTTON_EVT_DOWN,\n}\n\nconst enum JDControllerCommand {\n    ClientButtons = 1,\n    ControlServer = 2,\n    ControlClient = 3\n}\n\nconst enum JDControllerButton {\n    A = 5,\n    B = 6,\n    Left = 1,\n    Up = 2,\n    Right = 3,\n    Down = 4,\n    Menu = 7\n}\n\nconst enum JDLCDFlags {\n    None,\n    Display = 1 << 0,\n    Blink = 1 << 1,\n    Cursor = 1 << 2\n}\n\nconst enum JDLightSpectrumRange {\n    Full = 10,\n    Infrared = 20,\n    Visible = 40\n}\n\nconst enum JDLightCondition {\n    //% block=\"dark\"\n    Dark = DAL.SENSOR_THRESHOLD_LOW,\n    //% block=\"bright\"\n    Bright = DAL.SENSOR_THRESHOLD_HIGH\n}\n\nconst enum JDLightSpectrumEvent {\n    FullBright = JDLightSpectrumRange.Full | DAL.LEVEL_THRESHOLD_HIGH,\n    FullDark = JDLightSpectrumRange.Full | DAL.LEVEL_THRESHOLD_LOW,\n    InfraredBright = JDLightSpectrumRange.Infrared | DAL.LEVEL_THRESHOLD_HIGH,\n    InfraredDark = JDLightSpectrumRange.Infrared | DAL.LEVEL_THRESHOLD_LOW,\n    VisibleBright = JDLightSpectrumRange.Visible | DAL.LEVEL_THRESHOLD_HIGH,\n    VisibleDark = JDLightSpectrumRange.Visible | DAL.LEVEL_THRESHOLD_LOW\n}\n\nconst enum JDPromixityEvent {\n    Close = DAL.LEVEL_THRESHOLD_LOW,\n    Far = DAL.LEVEL_THRESHOLD_HIGH\n}\n\nconst enum JDRotaryEncoderEvent {\n    Changed = 0x2233 /* ROT_EV_CHANGED */\n}",
            "configurationservice.ts": "/// <reference path=\"service.ts\"/>\n\nnamespace jacdac{\n\n    const JD_CONTROL_CONFIGURATION_SERVICE_NUMBER = 1;\n\n    const JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_NAME = 1;\n    const JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_IDENTIFY= 2;\n\n    export const JD_CONTROL_CONFIGURATION_SERVICE_PACKET_HEADER_SIZE = 2;\n\n    export class JDConfigurationService extends JDService {\n\n        name: string\n\n        send(buffer: Buffer): void {\n            if (JACDAC.instance.bus.isConnected())\n                JACDAC.instance.write(buffer, this.service_number, 0, null);\n        }\n\n        constructor() {\n            super(JDServiceClass.CONTROL_CONFIGURATION, JDServiceMode.ControlLayerService);\n            this.service_number = JD_CONTROL_CONFIGURATION_SERVICE_NUMBER;\n        }\n\n        handlePacket(pkt: JDPacket)\n        {\n            let cfg = new JDConfigurationPacket(pkt);\n\n            if (this.device)\n            {\n                if (cfg.device_address == this.device.device_address)\n                {\n                    if (cfg.request_type == JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_NAME && cfg.new_name.length)\n                    {\n                        JACDAC.instance.setDeviceName(cfg.new_name);\n                        if (JACDAC.instance.onNameRemotelyChanged)\n                            JACDAC.instance.onNameRemotelyChanged(cfg.new_name);\n                    }\n\n                    if (cfg.request_type == JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_IDENTIFY && JACDAC.instance.onIdentificationRequest)\n                        JACDAC.instance.onIdentificationRequest()\n                }\n            }\n\n            return DEVICE_OK;\n        }\n\n        triggerRemoteIdentification(device_address: number) : void\n        {\n            if (device_address == 0)\n                return;\n\n            let cfg = new JDConfigurationPacket;\n\n            cfg.device_address = device_address;\n            cfg.request_type = JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_IDENTIFY;\n\n            this.send(cfg.getBuffer());\n        }\n\n        setRemoteDeviceName(device_address: number, name: string) : void\n        {\n            let cfg = new JDConfigurationPacket;\n            cfg.device_address = device_address;\n            cfg.request_type = JD_CONTROL_CONFIGURATION_SERVICE_REQUEST_TYPE_NAME;\n            cfg.new_name = name;\n            this.send(cfg.getBuffer());\n        }\n    }\n}",
            "consoleservice.ts": "/// <reference path=\"service.ts\"/>\n\nnamespace jacdac {\n    const JD_CONSOLE_LOG_PRIORITY_DEBUG = 0;\n    const JD_CONSOLE_LOG_PRIORITY_LOG = 1;\n    const JD_CONSOLE_LOG_PRIORITY_WARNING = 2;\n    const JD_CONSOLE_LOG_PRIORITY_ERROR = 3;\n    const JD_CONSOLE_LOG_PRIORITY_SILENT = 4;\n\n    export enum JDConsolePriority {\n        Debug = JD_CONSOLE_LOG_PRIORITY_DEBUG,\n        Log = JD_CONSOLE_LOG_PRIORITY_LOG,\n        Warning = JD_CONSOLE_LOG_PRIORITY_WARNING,\n        Error = JD_CONSOLE_LOG_PRIORITY_ERROR,\n        Silent = JD_CONSOLE_LOG_PRIORITY_SILENT\n    };\n\n    export const enum JDConsolePacketType {\n        Unknown,\n        Message\n    }\n\n    export const JD_CONSOLE_SERVICE_MODE_OFF = 0;\n    export const JD_CONSOLE_SERVICE_MODE_LISTEN = 1;\n    export const JD_CONSOLE_SERVICE_MODE_LOGGER = 2;\n    export const JD_CONSOLE_SERVIE_LOGGER_TIMEOUT = 2000;\n\n    export enum JDConsoleMode {\n        Off = JD_CONSOLE_SERVICE_MODE_OFF,\n        Listen = JD_CONSOLE_SERVICE_MODE_LISTEN,\n        Logger = JD_CONSOLE_SERVICE_MODE_LOGGER\n    }\n\n    export const JD_CONSOLE_SERVICE_PACKET_HEADER_SIZE = 1;\n\n    export class JDConsoleService extends JDService {\n        private _consoleMode: JDConsoleMode;\n        private _lastListenerTime: number;\n\n        onMessageReceived: (priority: number, device_address: number, device_name: string, message: string) => void;\n\n        constructor() {\n            super(JDServiceClass.CONSOLE, JDServiceMode.BroadcastHostService);\n            this._consoleMode = JD_CONSOLE_SERVICE_MODE_OFF;\n            this.minPriority = JDConsolePriority.Silent; // drop all packets by default\n            this._lastListenerTime = 0;\n        }\n\n        get consoleMode() {\n            return this._consoleMode;\n        }\n\n        set consoleMode(consoleMode: JDConsoleMode) {\n            if (this._consoleMode != consoleMode) {\n                this._consoleMode = consoleMode;\n            }\n        }\n\n        addAdvertisementData(): Buffer {\n\n            const buf = jacdac.options.createBuffer(2);\n            buf.setUint8(0,this.consoleMode);\n            buf.setUint8(1,this.minPriority);\n            return buf;\n        }\n\n        handleServiceInformation(device: JDDevice, serviceInfo: JDServiceInformation): number {\n            const data = serviceInfo.data;\n            if (data.length < 2)\n                return -1; // TODO fix\n            const consoleMode = data.getUint8(0);\n            const priority = data.getUint8(1);\n\n            if (consoleMode == JDConsoleMode.Listen) {\n                // if a listener enters the bus, automatically start broadcasting\n                if (this.consoleMode != JDConsoleMode.Listen)\n                    this.consoleMode = JDConsoleMode.Logger;\n                // update priority if needed\n                if (priority < this.minPriority) // update priority\n                    this.minPriority = priority;\n                this._lastListenerTime = jacdac.options.getTimeMs();\n            }\n            return jacdac.DEVICE_OK;\n        }\n\n        handlePacket(packet: JDPacket): number {\n            // received packet, ignore unless in listening mode\n            if (this.consoleMode != JD_CONSOLE_SERVICE_MODE_LISTEN)\n                return jacdac.DEVICE_OK;\n\n            const cpacket = new JDConsolePacket(packet);\n            switch (cpacket.packetType) {\n                case JDConsolePacketType.Message:\n                    // check priority\n                    if (cpacket.priority < this.minPriority)\n                        return DEVICE_OK;\n\n                    // send message to console\n                    const device = jacdac.JACDAC.instance.getRemoteDevice(packet.device_address);\n                    const deviceName = device && device.device_name ? device.device_name : `${packet.device_address}`;\n                    const msg = `:${deviceName}> ${cpacket.message}`;\n                    switch(cpacket.priority) {\n                        case JD_CONSOLE_LOG_PRIORITY_DEBUG: console.debug(msg); break;\n                        case JD_CONSOLE_LOG_PRIORITY_LOG: console.log(msg); break;\n                        case JD_CONSOLE_LOG_PRIORITY_WARNING: console.warn(msg); break;\n                        case JD_CONSOLE_LOG_PRIORITY_ERROR: console.error(msg); break;\n                    }\n                    if (this.onMessageReceived)\n                        this.onMessageReceived(cpacket.priority, packet.device_address, deviceName, cpacket.message);\n                    break;\n                default:\n                    break;\n            }\n\n            return DEVICE_OK;\n        }\n\n        get minPriority() {\n            return <JDConsolePriority>((this.status & 0xF0) >> 4);\n        }\n\n        set minPriority(priority: JDConsolePriority) {\n            this.status = priority << 4 | (this.status & 0x0F);\n        }\n\n        debug(message: string): void {\n            this.add(JDConsolePriority.Debug, message);\n        }\n        log(message: string): void {\n            this.add(JDConsolePriority.Log, message);\n        }\n        warn(message: string): void {\n            this.add(JDConsolePriority.Warning, message);\n        }\n        error(message: string): void {\n            this.add(JDConsolePriority.Error, message);\n        }\n\n        add(priority: JDConsolePriority, message: string): void {\n            if (this.consoleMode != JDConsoleMode.Logger\n                || !message || !message.length)\n                return;\n\n            // no one listening -- or disconnected?\n            if (!jacdac.JACDAC.instance.bus.isConnected()\n                || jacdac.options.getTimeMs() - this._lastListenerTime > JD_CONSOLE_SERVIE_LOGGER_TIMEOUT) {\n                this.consoleMode = JDConsoleMode.Off;\n                return;\n            }\n\n            // chunk message\n            let cursor = 0;\n            while (cursor < message.length) {\n                const txLength = Math.min(message.length - cursor, jacdac.JD_SERIAL_MAX_PAYLOAD_SIZE - 2);\n\n                const pkt = new JDConsolePacket();\n                pkt.priority = priority;\n                pkt.packetType = JDConsolePacketType.Message;\n                pkt.message = message.substr(cursor, txLength);\n                this.send(pkt.getBuffer());\n\n                cursor += txLength;\n            }\n        }\n    }\n}",
            "consts.ts": "namespace jacdac{\n    export const DEVICE_OK = 0;\n\n\n    export const JD_CONTROL_PACKET_HEADER_SIZE = 10\n    export const JD_CONTROL_ROLLING_TIMEOUT_VAL = 3\n\n    export const JD_SERVICE_STATUS_FLAGS_INITIALISED = 0x02\n\n    export const JD_SERVICE_INFO_HEADER_SIZE = 6\n\n    export const JD_DEVICE_FLAGS_NACK = 0x08\n    export const JD_DEVICE_FLAGS_HAS_NAME = 0x04\n    export const JD_DEVICE_FLAGS_PROPOSING = 0x02\n    export const JD_DEVICE_FLAGS_REJECT = 0x01\n\n    export const JD_DEVICE_MAX_HOST_SERVICES = 16\n\n    export const JD_SERIAL_HEADER_SIZE = 4;\n    export const JD_SERIAL_UDID_SIZE = 8;\n    export const JD_SERIAL_CRC_HEADER_SIZE = 2;\n    export const JD_SERIAL_MAX_PAYLOAD_SIZE = 255;\n\n    export const JD_SERVICE_NUMBER_UNITIALISED_VAL = 65535;\n\n    const JD_SERIAL_BAUD_1M = 1;\n    const JD_SERIAL_BAUD_500K = 2;\n    const JD_SERIAL_BAUD_250K = 4;\n    const JD_SERIAL_BAUD_125K = 8;\n\n    export const JD_DEVICE_DEFAULT_COMMUNICATION_RATE = JD_SERIAL_BAUD_1M;\n\n    export enum JDBaudRate\n    {\n        Baud1M = JD_SERIAL_BAUD_1M,\n        Baud500k = JD_SERIAL_BAUD_500K,\n        Baud250k = JD_SERIAL_BAUD_250K,\n        Baud125k = JD_SERIAL_BAUD_125K\n    }\n}",
            "control.ts": "/// <reference path=\"service.ts\"/>\n\nnamespace jacdac{\n    const JD_CONTROL_SERVICE_STATUS_ENUMERATE = 0x02\n    const JD_CONTROL_SERVICE_STATUS_ENUMERATING = 0x04\n    const JD_CONTROL_SERVICE_STATUS_ENUMERATED = 0x08\n    const JD_CONTROL_SERVICE_STATUS_BUS_LO = 0x10\n    const JD_CONTROL_SERVICE_STATUS_INITIALISED = 0x20\n    const JD_CONTROL_MAX_ALLOC_ADDRESS = 0xFE;\n    const JD_CONTROL_MIN_ALLOC_ADDRESS = 1;\n    export const JD_CONTROL_TRANSMIT_ONLY_ADDRESS = 0xFF\n\n    export class JDControlService extends JDService {\n        name: string\n        deviceManager: JDDeviceManager;\n        rngService: JDRNGService;\n        configurationService: JDConfigurationService;\n        _intervalId: any;\n        nextAddress: number;\n\n        onChange: () => void;\n\n        send(buffer: Buffer): void {\n            if (JACDAC.instance.bus.isConnected())\n                JACDAC.instance.write(buffer, 0, 0, null);\n        }\n\n        deviceDisconnected(device: JDDevice): void {\n            if (this.nextAddress == device.device_address)\n                this.nextAddress = JD_CONTROL_MAX_ALLOC_ADDRESS;\n\n            // iterate over services on the device and provide connect / disconnect events.\n            for (let current of JACDAC.instance.services) {\n                if (!current.device || current.mode == JDServiceMode.ControlLayerService || device.device_address != current.device.device_address)\n                    continue;\n\n                current.device = undefined;\n                current.service_number = JD_SERVICE_NUMBER_UNITIALISED_VAL;\n                current._hostDisconnected();\n            }\n        }\n\n        deviceEnumerated(): void {\n            // iterate over services on the device and provide connect / disconnect events.\n            for (let current of JACDAC.instance.services) {\n                if (current == this || current.mode == JDServiceMode.ClientService)\n                    continue;\n\n                current.device = this.device;\n                current._hostConnected();\n            }\n        }\n\n        formControlPacket(): JDControlPacket {\n            const controlPacket = new JDControlPacket();\n\n            controlPacket.unique_device_identifier = this.device.unique_device_identifier;\n            controlPacket.device_address = this.device.device_address;\n            controlPacket.device_flags = this.device.device_flags;\n            controlPacket.device_name = this.name;\n\n            let service_number = 0;\n\n            for (let current of JACDAC.instance.services) {\n                if (current.mode == JDServiceMode.ControlLayerService || current.mode == JDServiceMode.ClientService)\n                    continue;\n\n                if (current.service_number != JD_SERVICE_NUMBER_UNITIALISED_VAL && current.service_number != service_number)\n                    jacdac.options.error(\"Device service order changed whilst enumerated\");\n\n                current.service_number = service_number;\n\n                let info = new JDServiceInformation();\n\n                info.service_flags = current.service_flags;\n                info.service_class = current.service_class;\n                const data = current.addAdvertisementData();\n                info.advertisement_size = data.length;\n                info.data = data;\n\n                controlPacket.append(info.getBuffer());\n\n                service_number++;\n            }\n\n            if (controlPacket.getBuffer().length > JD_SERIAL_MAX_PAYLOAD_SIZE)\n                jacdac.options.error(\"Packet too big\");\n\n            return controlPacket;\n        }\n\n        /**\n         * Timer callback every 500 ms\n         **/\n        startDeviceTimer() {\n\n            if (this._intervalId !== undefined)\n                jacdac.options.error(\"Device Timer called twice.\");\n\n            jacdac.options.log(\"start device timer\")\n            this._intervalId = setInterval(() => {\n                jacdac.options.log(\"control tick\")\n                // handle enumeration\n                if (this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATE) {\n                    if (this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATING) {\n                        this.device.rolling_counter++;\n\n                        if (this.device.rolling_counter > 3) {\n                            this.status &= ~JD_CONTROL_SERVICE_STATUS_ENUMERATING;\n                            this.status |= JD_CONTROL_SERVICE_STATUS_ENUMERATED;\n                            this.device.device_flags &= ~JD_DEVICE_FLAGS_PROPOSING;\n                            this.deviceEnumerated();\n                        }\n                    }\n                    else {\n                        if (!JACDAC.instance.bus.isConnected()) {\n                            this.device.rolling_counter++;\n\n                            if (this.device.rolling_counter >= JD_CONTROL_ROLLING_TIMEOUT_VAL) {\n                                this.status |= JD_CONTROL_SERVICE_STATUS_BUS_LO;\n                                jacdac.options.log(\"This disconnected\");\n                                this.deviceDisconnected(this.device);\n                                return;\n                            }\n                        }\n                        else {\n                            if (this.status & JD_CONTROL_SERVICE_STATUS_BUS_LO) {\n                                this.deviceEnumerated();\n                                this.status &= ~JD_CONTROL_SERVICE_STATUS_BUS_LO;\n                            }\n\n                            this.device.rolling_counter = 0;\n                        }\n                    }\n\n                    // queue a control packet if we have host services.\n                    this.send(this.formControlPacket().getBuffer());\n                }\n\n                // now check to see if remote devices have timed out.\n                for (let dev of this.deviceManager.getDeviceList()) {\n                    dev.rolling_counter++;\n\n                    if (dev.rolling_counter >= JD_CONTROL_ROLLING_TIMEOUT_VAL) {\n                        this.deviceManager.removeDevice(dev);\n                        this.deviceDisconnected(dev);\n                    }\n                }\n            }, 500);\n        }\n\n        private initialise(device_address?: number): void{\n            if (!(this.status & JD_CONTROL_SERVICE_STATUS_INITIALISED))\n            {\n                this.status |= JD_CONTROL_SERVICE_STATUS_INITIALISED;\n                JACDAC.instance.add(this.configurationService);\n                JACDAC.instance.add(this.rngService);\n                this.device = new JDDevice();\n                this.device.unique_device_identifier = generate_eui64(jacdac.options.getSerialNumber());\n            }\n\n            // naiive implementation for now... we can sniff the bus for a little before enumerating to\n            // get a good first address in the future.\n            if (device_address)\n                this.device.device_address = device_address;\n            else\n                this.device.device_address = random(JD_CONTROL_MIN_ALLOC_ADDRESS, JD_CONTROL_MAX_ALLOC_ADDRESS);\n\n            jacdac.options.log(`device address: ${this.device.device_address}`)\n\n            // set the device state for the control service.\n            this.device.device_flags |= JD_DEVICE_FLAGS_PROPOSING;\n            this.device.communication_rate = JD_DEVICE_DEFAULT_COMMUNICATION_RATE;\n            this.device.rolling_counter = 0;\n        }\n\n        enumerate(device_address?: number): void {\n            if (this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATE) {\n                jacdac.options.log(\"already enumerating\")\n                return;\n            }\n\n            this.initialise(device_address);\n\n            let hostServiceCount = 0;\n\n            for (let s of JACDAC.instance.services)\n            {\n                if (s.mode == JDServiceMode.ClientService || s.mode == JDServiceMode.ControlLayerService)\n                    continue;\n\n                hostServiceCount++;\n            }\n\n            if (hostServiceCount)\n            {\n                this.status |= (JD_CONTROL_SERVICE_STATUS_ENUMERATING | JD_CONTROL_SERVICE_STATUS_ENUMERATE);\n                this.startDeviceTimer();\n            }\n\n            return;\n        }\n\n        /**\n         *\n         **/\n        isEnumerated(): boolean {\n            return (this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATED) ? true : false;\n        }\n\n        /**\n         *\n         **/\n        isEnumerating(): boolean {\n            return (this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATING) ? true : false;\n        }\n\n        disconnect(): void {\n            if (!(this.status & JD_CONTROL_SERVICE_STATUS_ENUMERATE))\n                return;\n\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n            this.deviceDisconnected(this.device);\n            this.status &= ~JD_CONTROL_SERVICE_STATUS_ENUMERATE;\n            return;\n        }\n\n        constructor() {\n            super(JDServiceClass.CONTROL, JDServiceMode.ControlLayerService);\n            this.deviceManager = new JDDeviceManager();\n            this.rngService = new JDRNGService();\n            this.configurationService = new JDConfigurationService();\n            this.nextAddress = JD_CONTROL_MAX_ALLOC_ADDRESS;\n        }\n\n        getRemoteDevice(device_address: number): JDDevice{\n            return this.deviceManager.getRemoteDevice(device_address);\n        }\n\n        routePacket(pkt: JDPacket) {\n            // transmit only\n            if (this.device.device_address == JD_CONTROL_TRANSMIT_ONLY_ADDRESS)\n                return;\n\n            let device: JDDevice = null;\n\n            if (pkt.device_address == JD_CONTROL_TRANSMIT_ONLY_ADDRESS)\n                device = this.deviceManager.getRemoteDeviceUnique(JD_CONTROL_TRANSMIT_ONLY_ADDRESS, pkt.udidh, pkt.udidl)\n            else if (this.device && pkt.device_address == this.device.device_address)\n                device = this.device;\n            else\n                device = this.getRemoteDevice(pkt.device_address);\n\n            // jacdac.options.log(\"RP: a \" + pkt.device_address +  \" sn \" + pkt.service_number +  \" crc \" + pkt.crc);\n\n            const crc = jd_crc(pkt, device); // include size and address in the checksum.\n\n            let crcCheck: boolean = (crc == pkt.crc);\n\n            // console.log(\"crc check: computed \", crc, \"  received: \", pkt.crc);\n\n            if (crcCheck) {\n                if (!device)\n                    this.handlePacket(pkt);\n                else {\n                    // map from device broadcast map to potentially the service number of one of our enumerated broadcast hosts\n                    let host_service_number: number = -1;\n\n                    if (device.servicemap_bitmsk & (1 << pkt.service_number)) {\n                        host_service_number = device.broadcast_servicemap.getUint8(pkt.service_number);\n                        device = this.device;\n                    }\n\n                    let broadcast: boolean = (host_service_number >= 0);\n\n                    // we matched a broadcast host, route to all broadcast hosts on the device.\n                    if (broadcast)\n                    {\n                        let broadcast_class: number = 0;\n\n                        for (let service of JACDAC.instance.services) {\n\n                            if (!service.device || service.mode == JDServiceMode.ClientService || service.mode == JDServiceMode.ControlLayerService)\n                                continue;\n\n                            if (service.device.device_address == device.device_address && service.service_number == host_service_number) {\n                                jacdac.options.log(\"BROADCAST MATCH CL:\" + service.service_class);\n                                broadcast_class = service.service_class;\n                                break;\n                            }\n                        }\n\n                        for (let service of JACDAC.instance.services) {\n                            if (!service.device || service.mode != JDServiceMode.BroadcastHostService)\n                                continue;\n\n                            if (service.service_class == broadcast_class) {\n                                // break if DEVICE_OK is returned (indicates the packet has been handled)\n                                if (service.handlePacket(pkt) == DEVICE_OK)\n                                    break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // route to client / host services\n                        for (let service of JACDAC.instance.services) {\n\n                            if (!service.device || service.mode == JDServiceMode.ControlLayerService)\n                                continue;\n\n                            // jacdac.options.log(\"ITER: \" + service.service_class.toString());\n                            if (service.device && service.device.device_address == device.device_address && service.service_number == pkt.service_number)\n                                if (service.handlePacket(pkt) == DEVICE_OK)\n                                    break;\n                        }\n                    }\n                }\n            }\n        }\n\n        handlePacket(pkt: JDPacket): number {\n            if (pkt.service_number == this.rngService.service_number) {\n                this.rngService.handlePacket(pkt);\n                return DEVICE_OK;\n            }\n\n            if (pkt.service_number == this.configurationService.service_number) {\n                this.configurationService.handlePacket(pkt);\n                return DEVICE_OK;\n            }\n\n            let cp: JDControlPacket = new JDControlPacket(pkt);\n\n\n            // jacdac.options.log(\"HP ControlPacket: \",cp, cp.getBuffer());\n\n            // address collision check\n            if (this.status & (JD_CONTROL_SERVICE_STATUS_ENUMERATING | JD_CONTROL_SERVICE_STATUS_ENUMERATED)) {\n\n                // maintain a \"pointer\" to the next address\n                if (cp.device_address > this.device.device_address && cp.device_address < this.nextAddress)\n                    this.nextAddress = cp.device_address;\n\n                if (this.device.device_address == cp.device_address) {\n                    // a different device is using our address!!\n                    if (!(this.device.udidl == cp.udidl && this.device.udidh == cp.udidh)) {\n                        // if the device is proposing, we can reject (as per the spec)\n                        if (cp.device_flags & JD_DEVICE_FLAGS_PROPOSING) {\n                            // if we're proposing too, the remote device has won the address\n                            if (this.device.device_flags & JD_DEVICE_FLAGS_PROPOSING) {\n                                this.device.rolling_counter = 0;\n                                this.device.device_address = random(JD_CONTROL_MIN_ALLOC_ADDRESS,JD_CONTROL_MAX_ALLOC_ADDRESS);\n                            }\n                            // if our address is established, reject the proposal\n                            else {\n                                let rejectCP = new JDControlPacket();\n\n                                rejectCP.device_address = cp.device_address;\n\n                                // propose a decent next address\n                                if (this.nextAddress != this.device.device_address)\n                                    rejectCP.device_address = this.device.device_address + random(1, (this.nextAddress - this.device.device_address));\n\n                                rejectCP.unique_device_identifier = cp.unique_device_identifier;\n                                rejectCP.device_flags = cp.device_flags | JD_DEVICE_FLAGS_REJECT;\n                                this.send(rejectCP.getBuffer())\n                                jacdac.options.log(\"ASK OTHER TO REASSIGN\");\n                            }\n\n                            return DEVICE_OK; // no further processing required.\n                        }\n                    }\n                    // someone has flagged a conflict with our device address, re-enumerate\n                    else if (cp.device_flags & JD_DEVICE_FLAGS_REJECT) {\n                        this.device.rolling_counter = 0;\n\n                        // we may receive a new recommended address in the rejection\n                        // detect and then subsequently use.\n                        if (cp.device_address != this.device.device_address)\n                            this.device.device_address = cp.device_address;\n                        else\n                            this.device.device_address = random(JD_CONTROL_MIN_ALLOC_ADDRESS, JD_CONTROL_MAX_ALLOC_ADDRESS);\n\n                        return DEVICE_OK;\n                    }\n                }\n            }\n\n            // the device has not got a confirmed address (enumerating)... if there was a collision it would be handled above\n            if (cp.device_flags & JD_DEVICE_FLAGS_PROPOSING)\n                return DEVICE_OK;\n\n            // if a service is relying on a remote device, the control service is maintaining the state.\n            let remoteDevice: JDDevice = this.deviceManager.getRemoteDeviceUnique(cp.device_address, cp.udidh, cp.udidl);\n\n            if (remoteDevice)\n            {\n                // jacdac.options.log(\"TRACKED REMOTE DEVICE \", remoteDevice);\n                this.deviceManager.updateDevice(cp, pkt.communication_rate);\n            }\n            // else\n                // jacdac.options.log (\"UNTRACKED\");\n\n            // if here, address validation has completed successfully... process service information\n            const dataPointer = cp.data;\n            let service_number = 0;\n            let dataIdx = 0;\n\n            // jacdac.options.log(\"USDEV: a %d, s %d, c %d, i %d, t %c%c%c\", this.device.device_address, this.device.unique_device_identifier, this.service_class, this.status & JD_SERVICE_STATUS_FLAGS_INITIALISED ? 1 : 0, this.mode == BroadcastHostService ? 'B' : ' ', this.mode == HostService ? 'H' : ' ', this.mode == ClientService ? 'C' : ' ');\n            while (dataIdx < dataPointer.length) {\n                let serviceInfo = new JDServiceInformation(dataPointer.slice(dataIdx, dataPointer.length));\n                // jacdac.options.log(\"data idx \", dataIdx, \" \", dataPointer.length, \" service \", serviceInfo);\n\n                for (let current of JACDAC.instance.services) {\n\n                    if (current.mode == JDServiceMode.ControlLayerService)\n                        continue;\n\n                    const class_check = current.service_class == serviceInfo.service_class;\n\n                    // if the service is running, route the packet.\n                    if (current.status & JD_SERVICE_STATUS_FLAGS_INITIALISED) {\n                        const address_check = current.device.device_address == cp.device_address && current.service_number == service_number;\n                        const serial_check = cp.udidl == current.device.udidl && cp.udidh == current.device.udidh;\n\n                        // this boolean is used to override stringent address checks (not needed for broadcast services as they receive all packets) to prevent code duplication\n                        const broadcast_override = current.mode == JDServiceMode.BroadcastHostService;\n                        // JD_DMESG(\"INITDSer\", current.device.device_address, current.device.unique_device_identifier, current.service_class, current.status & JD_SERVICE_STATUS_FLAGS_INITIALISED ? 1 : 0, current.mode == BroadcastHostService ? 'B' : ' ', current.mode == HostService ? 'H' : ' ', current.mode == ClientService ? 'C' : ' ');\n\n                        // check if applicable\n                        if ((address_check && serial_check && class_check) || (class_check && broadcast_override)) {\n                            // we are receiving a packet from a remote device for a service in broadcast mode.\n                            if (broadcast_override && cp.device_address != this.device.device_address) {\n                                // create a device representation if none exists\n                                if (!remoteDevice)\n                                    remoteDevice = this.deviceManager.addDevice(cp, pkt.communication_rate);\n\n                                remoteDevice.servicemap_bitmsk |= 1 << service_number;\n                                remoteDevice.broadcast_servicemap.setUint8(service_number, current.service_number);\n                            }\n\n                            // if the service has handled the packet it will return DEVICE_OK.\n                            // any non zero return value will cause packet routing to continue\n                            if (current.handleServiceInformation(remoteDevice, serviceInfo) == DEVICE_OK) {\n                                jacdac.options.log(\"uS ABSORBED \" + current.device.device_address + \" \" + current.service_class);\n                                break;\n                            }\n                        }\n                    }\n                    else if (class_check && current.mode == JDServiceMode.ClientService) {\n                        // this service instance is looking for a specific device (either a unique_device_identifier or name)\n                        if (current.requiredDevice) {\n                            if (current.requiredDevice.unique_device_identifier\n                                && current.requiredDevice.unique_device_identifier.length\n                                && !(current.requiredDevice.udidl == cp.udidl && current.requiredDevice.udidh == cp.udidh))\n                                continue;\n\n                            if (current.requiredDevice.device_name && current.requiredDevice.device_name != cp.device_name)\n                                continue;\n                        }\n\n                        jacdac.options.log(\"FOUND NEW\" + current.service_class);\n                        remoteDevice = this.deviceManager.addDevice(cp, pkt.communication_rate);\n\n                        if (current.handleServiceInformation(remoteDevice, serviceInfo) == DEVICE_OK) {\n                            current.device = remoteDevice;\n                            current.service_number = service_number;\n                            current._hostConnected();\n\n                            if (this.onChange)\n                                this.onChange();\n                            break;\n                        }\n                    }\n                }\n                service_number++;\n                dataIdx += JD_SERVICE_INFO_HEADER_SIZE + serviceInfo.advertisement_size;\n            }\n\n            return DEVICE_OK;\n        }\n\n        setDeviceName(name:string)\n        {\n            return this.name = name;\n        }\n\n        getDeviceName() : string\n        {\n            return this.name;\n        }\n    }\n}",
            "controldebugview.ts": "/// <reference path=\"debugview.ts\"/>\n\nnamespace jacdac{\n\n    export class ControlDebugView extends DebugView\n    {\n        constructor() {\n            super(\"CONTROL\", jacdac.JDServiceClass.CONTROL);\n        }\n\n        renderPacket(pkt:jacdac.JDPacket){\n\n            // only render control packet for now\n            if (pkt.service_number == 0)\n            {\n                const cp = new jacdac.JDControlPacket(pkt);\n                const device = new jacdac.JDDevice(cp);\n\n                let cpFlags = \"\"\n                cpFlags += (device.device_flags & JD_DEVICE_FLAGS_NACK) ? \"NACK | \" : \"\"\n                cpFlags += (device.device_flags & JD_DEVICE_FLAGS_HAS_NAME) ? \"NAME | \" : \"\"\n                cpFlags += (device.device_flags & JD_DEVICE_FLAGS_PROPOSING) ? \"PROP | \" : \"\"\n                cpFlags += (device.device_flags & JD_DEVICE_FLAGS_REJECT) ? \"REG | \" : \"\"\n\n                if (cpFlags.length == 0)\n                    cpFlags = \"NONE\"\n\n                let ss = \"\\r\\nclass\\tflags\\tadvert\\r\\n\"\n                for (let s of device.services) {\n                    ss += `${s.service_class}\\t${s.service_flags}\\t${s.data.toHex()}\\r\\n`\n                }\n\n                return `\\r\\nid: ${(device.device_name) ? device.device_name : device.udid.toHex()}\\r\\naddress: ${device.device_address}\\tflags:${cpFlags} ${ss}\\r\\n`\n            }\n\n            return \"\";\n        }\n    }\n\n}",
            "controllerclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ControllerClient extends Broadcast {\n        state: Buffer;\n        streamingState: jacdac.SensorState;\n        streamingInterval: number;\n        stateUpdateHandler: () => void;\n        lastServerTime: number;\n\n        constructor() {\n            super(\"ctrl\", jacdac.CONTROLLER_DEVICE_CLASS, 3);\n            this.controlData[0] = JDControllerCommand.ControlClient;\n            this.serverAddress = 0;\n            this.playerIndex = 0;\n            this.state = control.createBuffer(2);\n            this.state[0] = JDControllerCommand.ClientButtons;\n            this.streamingState = jacdac.SensorState.Stopped;\n            this.streamingInterval = 25;\n            this.lastServerTime = 0;\n        }\n\n        get serverAddress() {\n            return this.controlData[1];\n        }\n\n        set serverAddress(value: number) {\n            this.controlData[1] = value;\n        }\n\n        get playerIndex(): number {\n            return this.controlData[2];\n        }\n\n        set playerIndex(index: number) {\n            this.controlData[2] = index;\n        }\n\n        isPressed(offset: JDControllerButton): boolean {\n            const msk = 1 << offset;\n            return !!(this.state[1] & msk);\n        }\n\n        setIsPressed(offset: JDControllerButton, down: boolean) {\n            const b = this.state[1];\n            const msk = 1 << offset;\n            this.state[1] = down ? (b | msk) : (~(~b | msk));\n        }\n\n        //% blockCombine blockCombineShadow=toggleOnOff block=\"left is pressed\" blockSetVariable=\"button\"\n        //% group=\"Controller\"\n        get leftIsPressed() {\n            return this.isPressed(JDControllerButton.Left);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set leftIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.Left, value);\n        }\n\n        //% blockCombine block=\"right is pressed\"\n        //% group=\"Controller\"\n        get rightIsPressed() {\n            return this.isPressed(JDControllerButton.Right);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set rightIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.Right, value);\n        }\n\n        //% blockCombine block=\"up is pressed\"\n        //% group=\"Controller\"\n        get upIsPressed() {\n            return this.isPressed(JDControllerButton.Up);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set upIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.Up, value);\n        }\n\n        //% blockCombine block=\"down is pressed\"\n        //% group=\"Controller\"\n        get downIsPressed() {\n            return this.isPressed(JDControllerButton.Down);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set downIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.Down, value);\n        }\n\n        //% blockCombine block=\"A is pressed\"\n        //% group=\"Controller\"\n        get AIsPressed() {\n            return this.isPressed(JDControllerButton.A);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set AIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.A, value);\n        }\n\n        //% blockCombine block=\"B is pressed\"\n        //% group=\"Controller\"\n        get BIsPressed() {\n            return this.isPressed(JDControllerButton.B);\n        }\n\n        //% blockCombine\n        //% group=\"Controller\"\n        set BIsPressed(value: boolean) {\n            this.setIsPressed(JDControllerButton.B, value);\n        }\n\n        /**\n         * Register code to run when the state is about to be sent\n         * @param handler \n         */\n        //% blockId=jdctrlclientonstate block=\"on %controller state update\"\n        //% group=\"Controller\"\n        onStateUpdate(handler: () => void) {\n            this.stateUpdateHandler = handler;\n        }\n\n        isActive(): boolean {\n            return !!this.serverAddress && this.isConnected();\n        }\n\n        handleServiceInformation(device: JDDevice, serviceInfo: JDServiceInformation): number {\n            const data = serviceInfo.data;\n            return this.processPacket(device.device_address, data);\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            return this.processPacket(packet.device_address, data);\n        }\n\n        private processPacket(packetAddress: number, data: Buffer): number {\n            const cmd: JDControllerCommand = data[0];\n            // received a packet from the server\n            if (cmd == JDControllerCommand.ControlServer) {\n                this.log(`server ${toHex8(packetAddress)}`)\n                const address = this.deviceAddress;\n                for (let i = 1; i <= 4; ++i) {\n                    if (data[i] == address) {\n                        // check that we are still connected to the same server\n                        if (this.serverAddress != packetAddress) {\n                            this.serverAddress = packetAddress;\n                            this.playerIndex = i;\n                            this.log(`server ${toHex8(this.serverAddress)}`);\n                        }\n                        this.lastServerTime = control.millis();\n                        // start streaming\n                        this.startStreaming();\n                        return jacdac.DEVICE_OK;\n                    }\n                }\n                // did the server drop us\n                if (address == this.serverAddress) {\n                    this.log(`dropped`);\n                    this.serverAddress = 0; // streaming will stop automatically\n                    this.playerIndex = 0;\n                    this.stopStreaming();\n                }\n\n                // nope, doesn't seem to be our server\n                // do nothing\n            }\n            return jacdac.DEVICE_OK;\n        }\n\n        start() {\n            super.start();\n            this.startStreaming();\n        }\n\n        private startStreaming() {\n            if (this.streamingState != SensorState.Stopped)\n                return;\n\n            this.log(`start`);\n            this.streamingState = SensorState.Streaming;\n            control.runInBackground(() => this.stream());\n        }\n\n        private stream() {\n            while (this.streamingState == SensorState.Streaming) {\n                // alllow handle to update state\n                if (this.stateUpdateHandler)\n                    this.stateUpdateHandler();\n                // send state\n                this.sendPacket(this.state);\n                // waiting for a bit\n                pause(this.streamingInterval);\n                // check if server still alive\n                if (control.millis() - this.lastServerTime > 1000) {\n                    this.serverAddress = 0; // inactive\n                }\n            }\n            this.streamingState = SensorState.Stopped;\n            this.log(`stopped`);\n        }\n\n        private stopStreaming() {\n            if (this.streamingState == SensorState.Streaming) {\n                this.log(`stopping`)\n                this.streamingState = SensorState.Stopping;\n                pauseUntil(() => this.streamingState == SensorState.Stopped);\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"controller client\"\n    export const controllerClient = new ControllerClient();\n}",
            "crc.ts": "namespace jacdac{\n    const JD_CRC_POLYNOMIAL = 0xF13;\n\n    export function jd_crc(pkt: JDPacket, device?: JDDevice): number {\n        let crc: number = 0xfff;\n        if (device) {\n            const udidPtr = device.unique_device_identifier;\n            let i: number = 0;\n\n            while (i < 8) {\n                crc ^= (udidPtr.getUint8(i) << 8);\n                for (let j = 0; j < 8; ++j) {\n                    if (crc & 0x800)\n                        crc = (crc << 1) ^ JD_CRC_POLYNOMIAL;\n                    else\n                        crc = crc << 1;\n                }\n\n                i++;\n            }\n        }\n\n        let len = pkt.size + JD_SERIAL_CRC_HEADER_SIZE + 2;\n        let idx = JD_SERIAL_CRC_HEADER_SIZE;\n        const buf = pkt.getBuffer();\n\n        while (idx < len) {\n            crc ^= (buf.getUint8(idx) << 8);\n            for (let i = 0; i < 8; ++i) {\n                if (crc & 0x800)\n                    crc = (crc << 1) ^ JD_CRC_POLYNOMIAL;\n                else\n                    crc = crc << 1;\n            }\n            idx++;\n        }\n\n        return crc & 0xFFF;\n    }\n}",
            "debugservice.ts": "namespace jacdac{\n\n    export interface DebuggerStruct\n    {\n        pkt: jacdac.JDPacket;\n        view: DebugView;\n        timestamp: number;\n        crcStatus:string;\n        serviceClass: string;\n    }\n\n    export enum DebuggerClassEnums {\n        CONTROL = 0,\n        CONTROL_RNG = 1,\n        CONTROL_CONFIGURATION = 2,\n        CONTROL_TEST = 3,\n\n        JOYSTICK = 4,\n        MESSAGE_BUS = 5,\n        BRIDGE = 6,\n        BUTTON = 7,\n        ACCELEROMETER = 8,\n        CONSOLE = 9\n    }\n\n    export class DebuggerService extends jacdac.JDService {\n        running: boolean;\n        deviceManager: jacdac.JDDeviceManager\n        _intervalId: any;\n        paintDevices:(devices: jacdac.JDDevice[]) => void;\n        paintPacket:(packet: DebuggerStruct) => void;\n\n        constructor(){\n            super(jacdac.JDServiceClass.BRIDGE, jacdac.JDServiceMode.ClientService)\n            jacdac.JACDAC.instance.bridge = this;\n            this.running = true;\n            this.deviceManager = new jacdac.JDDeviceManager();\n\n            this._intervalId = setInterval(()=>{\n                const devices = this.deviceManager.getDeviceList();\n\n                for (let device of devices)\n                {\n                    device.rolling_counter++;\n\n                    if (device.rolling_counter >= jacdac.JD_CONTROL_ROLLING_TIMEOUT_VAL)\n                    {\n                        this.deviceManager.removeDevice(device);\n\n                        if (this.paintDevices)\n                            this.paintDevices(this.deviceManager.getDeviceList());\n                    }\n                }\n            },500)\n        }\n\n        handlePacket(pkt : jacdac.JDPacket) : number\n        {\n            // let packetEntry: DebuggerStruct ={pkt: pkt, view: undefined, timestamp:jacdac.options.getTimeMs(), crcStatus: \"Poo\", serviceClass: \"ABC\"}\n\n            // if (this.paintPacket)\n            //     this.paintPacket(packetEntry);\n\n            // return jacdac.DEVICE_OK;\n\n            if (!this.running)\n                return jacdac.DEVICE_OK;\n\n            // console.log(\"DEBUGGER HANDLE PACKET\", pkt, pkt.device_address, pkt.service_number);\n            if (pkt.device_address == 0 && pkt.service_number == 0)\n            {\n                const cp = new jacdac.JDControlPacket(pkt);\n                // console.log(cp);\n\n                if ((cp.device_flags & (jacdac.JD_DEVICE_FLAGS_REJECT | jacdac.JD_DEVICE_FLAGS_PROPOSING)) == 0)\n                {\n                    const remote = this.deviceManager.addDevice(cp, pkt.communication_rate);\n\n                    if (this.paintDevices)\n                        this.paintDevices(this.deviceManager.getDeviceList());\n\n                    // console.log(\"CP REM \",remote);\n                    remote.update(cp);\n                }\n                // console.log(\"propose \",cp.device_flags & (jacdac.JD_DEVICE_FLAGS_PROPOSING), \" rejecting \",cp.device_flags & (jacdac.JD_DEVICE_FLAGS_REJECT) )\n            }\n\n            const remote = this.deviceManager.getRemoteDevice(pkt.device_address);\n\n            // console.log(\"REMOTE \", pkt.device_address, pkt.service_number, remote, this.deviceManager);\n            const crc = jacdac.jd_crc(pkt,remote);\n\n            let crcString = \"OK\"\n\n            if (crc != pkt.crc)\n                if (!remote)\n                    crcString = \"ERROR - DEVICE NOT FOUND\";\n                else\n                    crcString = \"ERROR - INCORRECT\"\n\n            let serviceString = \"UNKNOWN\";\n\n            let view = undefined;\n            if (remote)\n            {\n                let serviceClass = remote.services[pkt.service_number].service_class;\n                // serviceString =  DebuggerClassEnums[serviceClass] || serviceClass.toString();\n                view = DebugView.find(serviceClass);\n            }\n            else if (pkt.device_address == 0)\n            {\n                serviceString = \"CONTROL\";\n                view = DebugView.find(jacdac.JDServiceClass.CONTROL);\n            }\n\n            let packetEntry ={pkt: pkt, view: view, timestamp:jacdac.options.getTimeMs(), crcStatus: crcString, serviceClass: serviceString}\n\n            if (this.paintPacket)\n                this.paintPacket(packetEntry)\n\n            return jacdac.DEVICE_OK;\n        }\n\n        handleServiceInformation(device: jacdac.JDDevice, serviceInfo: jacdac.JDServiceInformation): number {\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n}",
            "debugview.ts": "namespace jacdac {\n    export class DebugView {\n        static _debugViews: DebugView[];\n        serviceClass: number;\n        name: string;\n\n        constructor(name: string, serviceClass: number) {\n            this.name = name;\n            this.serviceClass = serviceClass;\n\n            if (DebugView._debugViews === undefined)\n            {\n                DebugView._debugViews = [];\n                DebugView.registerDefaultViews();\n            }\n\n            // replace existing debug views.\n            for (let i = 0; i < DebugView._debugViews.length; i++) {\n                if (DebugView._debugViews[i].serviceClass == serviceClass) {\n                    DebugView._debugViews[i] = this;\n                    return;\n                }\n            }\n\n            DebugView._debugViews.push(this);\n        }\n\n        static find(serviceClass: number) {\n            for (let view of DebugView._debugViews) {\n                if (view.serviceClass == serviceClass)\n                    return view;\n            }\n\n            return undefined;\n        }\n\n        static registerDefaultViews(){\n            new jacdac.ControlDebugView();\n        }\n\n        renderControlPacket(device: JDDevice, service_information: JDServiceInformation) {\n            return \"\";\n        }\n\n        renderPacket(packet: JDPacket) {\n            return \"\";\n        }\n    }\n}",
            "debugviews.ts": "namespace jacdac {\n    export class SensorDebugView extends DebugView {\n        constructor(name: string, driverClass: number) {\n            super(name, driverClass);\n        }\n\n        renderControlPacket(device: JDDevice, service_information: JDServiceInformation): string {\n            const data = service_information.data;\n            const state = data[0];\n            switch (state) {\n                case SensorState.Stopping: return \"stopping\";\n                case SensorState.Streaming: return \"stream\";\n                default: return \"stop\";\n            }\n        }\n\n        renderPacket(packet: JDPacket): string {\n            const data = packet.data;\n            const cmd = data[0];\n            switch (cmd) {\n                case SensorCommand.StartStream:\n                    const interval = data.getNumber(NumberFormat.UInt32LE, 1);\n                    return `start stream ${interval ? `(${interval}ms)` : ''}`;\n                case SensorCommand.StopStream:\n                    return `stop stream`;\n                case SensorCommand.LowThreshold:\n                    return `low ${data[1]}`\n                case SensorCommand.HighThreshold:\n                    return `high ${data[1]}`\n                case SensorCommand.Event:\n                    return this.renderEvent(data[1]);\n                case SensorCommand.State:\n                    return `ev ${this.renderState(data.slice(1)) || data[1]}`;\n                default:\n                    return this.renderCustomPacket(cmd, packet);\n            }\n        }\n\n        renderCustomPacket(cmd: number, packet: JDPacket): string {\n            return packet.data.toHex();\n        }\n\n        renderEvent(value: number): string {\n            return value.toString();\n        }\n\n        renderState(data: Buffer): string {\n            return data.toHex();\n        }\n    }\n\n    class LightDebugView extends DebugView {\n        constructor() {\n            super(\"light\", jacdac.LIGHT_DEVICE_CLASS);\n        }\n\n        renderPacket(packet: JDPacket) {\n            const data = packet.data;\n            const cmd = data[0];\n            const payload = data.slice(1, data.length - 1);\n            const names = [\n                \"none\",\n                \"all\",\n                \"bright\",\n                \"rainbow\",\n                \"rlights\",\n                \"colorw\",\n                \"comet\",\n                \"theaterchase\",\n                \"sparkle\"\n            ];\n            return `${names[cmd]} ${payload.toHex()}`\n        }\n    }\n\n    class MusicDebugView extends DebugView {\n        constructor() {\n            super(\"music\", jacdac.MUSIC_DEVICE_CLASS);\n        }\n\n        renderPacket(packet: JDPacket) {\n            const data = packet.data;\n            const cmd = data[0];\n            switch (cmd) {\n                case JDMusicCommand.PlayTone:\n                    return `tone ${data.getNumber(NumberFormat.UInt32LE, 1)} ${data.getNumber(NumberFormat.UInt32LE, 5)}`;\n                default:\n                    return \"\";\n            }\n        }\n    }\n\n    class ConsoleDebugView extends DebugView {\n        constructor() {\n            super(\"log\", jacdac.LOGGER_DEVICE_CLASS);\n        }\n        renderControlPacket(device: JDDevice, service_information: JDServiceInformation): string {\n            const data = service_information.data;\n            return `${[\"off\", \"broad\", \"listen\"][data[0]]} ${data[1]}`;\n        }\n\n        renderPacket(packet: JDPacket) {\n            const data = packet.data;\n            const pri = data[0];\n            const str = bufferToString(data, 1);\n            return `${pri}:${str}`;\n        }\n    }\n\n    class MessageBusDebugView extends DebugView {\n        constructor() {\n            super(MessageBusService.NAME, jacdac.MESSAGE_BUS_DEVICE_CLASS);\n        }\n\n        renderPacket(packet: JDPacket): string {\n            const data = packet.data;\n            return `${data.getNumber(NumberFormat.UInt16LE, 0)} ${data.getNumber(NumberFormat.UInt16LE, 2)}`;\n        }\n    }\n\n    class AccelerometerDebugView extends SensorDebugView {\n        constructor() {\n            super(\"acc\", jacdac.ACCELEROMETER_DEVICE_CLASS);\n        }\n\n        renderEvent(data: number): string {\n            switch (data) {\n                case JDGesture.Shake: return \"shake\";\n                case JDGesture.FreeFall: return \"freefall\";\n            }\n            return \"\";\n        }\n\n        renderState(data: Buffer): string {\n            const x = data.getNumber(NumberFormat.UInt16LE, 0);\n            const y = data.getNumber(NumberFormat.UInt16LE, 2);\n            const z = data.getNumber(NumberFormat.UInt16LE, 4);\n            return `${x} ${y} ${z}`;\n        }\n    }\n\n    class ButtonDebugView extends SensorDebugView {\n        constructor() {\n            super(\"button\", jacdac.BUTTON_DEVICE_CLASS);\n        }\n\n        renderEvent(value: number): string {\n            switch (value) {\n                case JDButtonEvent.Click: return \"click\";\n                case JDButtonEvent.Down: return \"down\";\n                case JDButtonEvent.Up: return \"up\";\n                case JDButtonEvent.LongClick: return \"lg click\"\n                default: return \"\";\n            }\n        }\n\n        renderState(data: Buffer): string {\n            return !!data[0] ? `up` : `down`;\n        }\n    }\n\n    class LightSensorDebugView extends SensorDebugView {\n        constructor() {\n            super(\"lis\", jacdac.LIGHT_SENSOR_DEVICE_CLASS);\n        }\n    }\n\n    class MicrophoneDebugView extends SensorDebugView {\n        constructor() {\n            super(\"mic\", jacdac.MICROPHONE_DEVICE_CLASS);\n        }\n\n        renderEvent(value: number): string {\n            if (value == DAL.SENSOR_THRESHOLD_HIGH)\n                return \"loud\";\n            return \"\";\n        }\n\n        renderState(data: Buffer): string {\n            return `level ${data[0]}`;\n        }\n    }\n\n    class SwitchDebugView extends SensorDebugView {\n        constructor() {\n            super(\"switch\", jacdac.SWITCH_DEVICE_CLASS);\n        }\n\n        renderEvent(value: number): string {\n            switch (value) {\n                case JDSwitchDirection.Left: return \"left\";\n                case JDSwitchDirection.Right: \"right\";\n                default: return \"\";\n            }\n        }\n\n        renderState(data: Buffer): string {\n            return !!data[0] ? `right` : `left`;\n        }\n    }\n\n    class ThermometerDebugView extends SensorDebugView {\n        constructor() {\n            super(\"temp\", jacdac.THERMOMETER_DEVICE_CLASS);\n        }\n    }\n\n    class TouchDebugView extends SensorDebugView {\n        constructor() {\n            super(\"touch\", jacdac.TOUCHBUTTON_DEVICE_CLASS);\n        }\n\n        renderEvent(value: number): string {\n            switch (value) {\n                case JDButtonEvent.Click: return \"click\";\n                case JDButtonEvent.Down: \"down\";\n                case JDButtonEvent.Up: \"up\";\n                case JDButtonEvent.LongClick: return \"lg click\"\n                default: return \"\";\n            }\n        }\n\n        renderState(data: Buffer): string {\n            return `${data.getNumber(NumberFormat.UInt16LE, 0)}`;\n        }\n    }\n\n    // class PixelDebugView extends ActuatorDebugView {\n    //     constructor() {\n    //         super(\"pixel\", jacdac.PIXEL_DEVICE_CLASS);\n    //     }\n    // }\n\n    class ControllerDebugView extends DebugView {\n        constructor() {\n            super(\"ctrl\", jacdac.CONTROLLER_DEVICE_CLASS);\n        }\n\n        renderControlPacket(device: JDDevice, service_information: JDServiceInformation): string {\n            const data = service_information.data;\n            return this.renderData(data);\n        }\n\n        renderPacket(packet: JDPacket): string {\n            const data = packet.data;\n            return this.renderData(data);\n        }\n\n        private renderData(data: Buffer): string {\n            const cmd: JDControllerCommand = data[0];\n            switch (cmd) {\n                case JDControllerCommand.ClientButtons:\n                    const state = data[1];\n                    const left = state & (1 << 1);\n                    const up = state & (1 << 2);\n                    const right = state & (1 << 3);\n                    const down = state & (1 << 4);\n                    const A = state & (1 << 5);\n                    const B = state & (1 << 6);\n                    return `${left ? \"L\" : \"-\"}${up ? \"U\" : \"-\"}${right ? \"R\" : \"-\"}${down ? \"D\" : \"-\"}${A ? \"A\" : \"-\"}${B ? \"B\" : \"-\"}`;\n                case JDControllerCommand.ControlServer:\n                    return `srv> ${data[1] ? toHex8(data[1]) : \"--\"} ${data[2] ? toHex8(data[2]) : \"--\"} ${data[3] ? toHex8(data[3]) : \"--\"} ${data[4] ? toHex8(data[4]) : \"--\"}`;\n                case JDControllerCommand.ControlClient:\n                    return `client> ${data[1] ? toHex8(data[1]) : \"--\"}`;\n                default:\n                    return toHex8(cmd);\n            }\n        }\n    }\n\n    export function registerDebugViews() {\n        new ConsoleDebugView();\n        new MessageBusDebugView();\n        new LightDebugView();\n        new MusicDebugView();\n        new AccelerometerDebugView();\n        new ButtonDebugView();\n        new LightSensorDebugView();\n        new MicrophoneDebugView();\n        new SwitchDebugView();\n        new ThermometerDebugView();\n        new TouchDebugView();\n        // new PixelDebugView();\n        new ControllerDebugView();\n    }\n}",
            "devicemanager.ts": "namespace jacdac {\n    export class JDDeviceManager {\n        devices: JDDevice[];\n\n        constructor() {\n            this.devices = [];\n        }\n\n        getDeviceList(): JDDevice[] {\n            return this.devices.slice(0);\n        }\n\n        getRemoteDevice(device_address: number): JDDevice {\n            return this.devices.find((dev) => { return dev.device_address == device_address });\n        }\n\n        getRemoteDeviceUnique(device_address: number, udidh: number, udidl: number): JDDevice {\n            return this.devices.find((dev) => dev.device_address == device_address && dev.udidh == udidh && dev.udidl == udidl);\n        }\n\n        addDevice(controlPacket: JDControlPacket, communicationRate: number): JDDevice {\n            let dev = this.getRemoteDeviceUnique(controlPacket.device_address, controlPacket.udidh, controlPacket.udidl);\n\n            if (dev)\n                return dev;\n\n            dev = new JDDevice(controlPacket, communicationRate);\n\n            this.devices.push(dev);\n\n            return dev;\n        }\n\n        updateDevice(controlPacket: JDControlPacket, communicationRate: number): void {\n            const dev = this.getRemoteDeviceUnique(controlPacket.device_address, controlPacket.udidh, controlPacket.udidl);\n\n            if (dev)\n                dev.update(controlPacket);\n        }\n\n        removeDevice(device: JDDevice): void {\n            this.devices = this.devices.filter((dev) => !(dev.device_address == device.device_address && device.udidl == dev.udidl && device.udidh == dev.udidh))\n        }\n    }\n}",
            "diagnostics.ts": "namespace jacdac {\n    export class JDDiagnostics\n    {\n        bus_state: number;\n        bus_lo_error: number;\n        bus_uart_error: number;\n        bus_timeout_error: number;\n        packets_sent: number;\n        packets_received: number;\n        packets_dropped: number;\n        bus_status: string;\n\n        constructor(buf: Buffer)\n        {\n            if (!buf || buf.length == 0) {\n                this.bus_lo_error = 0\n                this.bus_uart_error = 0\n                this.bus_timeout_error = 0\n                this.packets_sent = 0\n                this.packets_received = 0\n                this.packets_dropped = 0\n                this.bus_state = 0\n                this.bus_status = \"\";\n            } else {\n                this.bus_state = buf.getNumber(NumberFormat.UInt32LE,0);\n\n                if (this.bus_state == 0)\n                    this.bus_status = \"connected\";\n                else\n                    this.bus_status = \"error\";\n\n                this.bus_lo_error = buf.getNumber(NumberFormat.UInt32LE,4);\n                this.bus_uart_error = buf.getNumber(NumberFormat.UInt32LE,8);\n                this.bus_timeout_error = buf.getNumber(NumberFormat.UInt32LE,12);\n                this.packets_sent = buf.getNumber(NumberFormat.UInt32LE,16);\n                this.packets_received = buf.getNumber(NumberFormat.UInt32LE,20);\n                this.packets_dropped = buf.getNumber(NumberFormat.UInt32LE,24);\n            }\n        }\n    }\n}",
            "driver.ts": "namespace jacdac {\n    //% fixedInstances\n    export class Service extends jacdac.JDService {\n        public name: string;\n        protected supressLog: boolean;\n        private _controlData: Buffer;\n        private _eventId: number;\n\n        constructor(name: string, mode: JDServiceMode, serviceClass: number, controlDataLength = 0) {\n            super(serviceClass, mode)\n\n            this.name = name;\n            this._controlData = control.createBuffer(Math.max(0, controlDataLength));\n            this.supressLog = false;\n            this._eventId = control.allocateNotifyEvent();\n        }\n\n        get eventId() {\n            return this._eventId;\n        }\n\n        get serviceNumber(): number {\n            this.start();\n            return this.service_number;\n        }\n\n        get deviceAddress(): number {\n            const d = this.device();\n            return d ? d.device_address : -1;\n        }\n\n        get deviceName(): string {\n            const d = this.device();\n            return d ? d.device_name : \"\";\n        }\n\n        get controlData(): Buffer {\n            return this._controlData;\n        }\n\n        get isStarted(): boolean {\n            return jacdac.JACDAC.instance.contains(this);\n        }\n\n        addAdvertisementData(): Buffer {\n            return this._controlData;\n        }\n\n        protected log(text: string) {\n            if (!this.supressLog || jacdac.consolePriority < console.minPriority) {\n                let dev = jacdac.JACDAC.instance.getDeviceName();\n                if (!dev) {\n                    const d = this.device;\n                    dev = d ? toHex8(d.device_address) : \"--\";\n                }\n                console.add(jacdac.consolePriority, `${dev}:${toHex8(this.serviceNumber)}>${this.name}>${text}`);\n            }\n        }\n\n        protected sendPacket(pkt: Buffer) {\n            this.start();\n            this.send(pkt);\n        }\n\n        /**\n         * Registers and starts the driver\n         */\n        //% blockId=jacdachoststart block=\"start %service\"\n        //% group=\"Services\"\n        start() {\n            jacdac.start();\n            if (jacdac.JACDAC.instance.add(this)) {\n                this.log(\"start\");\n            }\n        }\n\n        /**\n         * Unregister and stops the driver\n         */\n        //% blockId=jacdachoststop block=\"stop %service\"\n        //% group=\"Services\"\n        stop() {\n            if (jacdac.JACDAC.instance.remove(this)) {\n                this.log(\"stop\")\n            }\n        }\n    }\n\n    //% fixedInstances\n    export class Broadcast extends Service {\n        constructor(name: string, serviceClass: number, controlDataLength?: number) {\n            super(name, JDServiceMode.BroadcastHostService, serviceClass, controlDataLength);\n        }\n    }\n\n    //% fixedInstances\n    export class Host extends Service {\n        constructor(name: string, serviceClass: number, controlDataLength?: number) {\n            super(name, JDServiceMode.HostService, serviceClass, controlDataLength);\n        }\n    }\n\n    //% fixedInstances\n    export class Client extends Service {\n        constructor(name: string, serviceClass: number, controlDataLength?: number) {\n            super(name, JDServiceMode.ClientService, serviceClass, controlDataLength);\n        }\n\n        /**\n         * Gest the required device names\n         */\n        get requiredDeviceName() {\n            return this.requiredDevice && this.requiredDevice.device_name;\n        }\n\n        /** \n         * Sets the required device name\n        */\n        set requiredDeviceName(name: string) {\n            const dev = new jacdac.JDRequiredDevice();\n            dev.device_name = name;\n            this.requiredDevice = dev;\n        }\n\n        /**\n         * Set required device uuid\n         */\n        get requiredDeviceUuid() {\n            return this.requiredDevice && this.requiredDevice.unique_device_identifier;\n        }\n\n        /** \n         * Sets the required device name\n        */\n        set requiredDeviceUuid(uuid: Buffer) {\n            const dev = new jacdac.JDRequiredDevice();\n            dev.unique_device_identifier = uuid;\n            this.requiredDevice = dev;\n        }\n\n        protected registerEvent(value: number, handler: () => void) {\n            control.onEvent(this.eventId, value, handler);\n            this.start();\n        }\n    }\n}",
            "ifaces.ts": "namespace jacdac{\n\n    export interface JDOptions {\n        utf8Encode: (s: string) => Buffer;\n        utf8Decode: (b: Buffer) => string;\n        createBuffer: (size: number) => Buffer;\n        error: (message: string) => void;\n        log: (message: string) => void;\n        getSerialNumber: () => Buffer;\n    }\n\n    export interface JDPhysicalLayer {\n        writeBuffer(buf: Buffer): void;\n        isConnected(): boolean;\n    }\n\n    export interface JDSerializable {\n        getBuffer(): Buffer;\n    }\n}",
            "jacdac.cpp": "\n\n#include \"pxt.h\"\n#include \"JACDAC.h\"\n#include \"JDPhysicalLayer.h\"\n\nnamespace jacdac {\n\nclass WJDPhysicalLayer {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n    CODAL_JACDAC_WIRE_SERIAL sws;\n    JDPhysicalLayer phys;\n#endif    \n\n  public:\n    WJDPhysicalLayer()\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        : sws(*LOOKUP_PIN(JACK_TX))\n        , phys(sws, *pxt::getJACDACTimer(), LOOKUP_PIN(JACK_BUSLED), LOOKUP_PIN(JACK_COMMLED), (PIN(JACK_BUSLED) & CFG_PIN_CONFIG_ACTIVE_LO) > 0, (PIN(JACK_COMMLED) & CFG_PIN_CONFIG_ACTIVE_LO) > 0)\n#endif        \n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        sws.setBaud(1000000);\n#if CONFIG_ENABLED(DEVICE_USB) && CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n        pxt::jacdacDebug.setPhysicalLayer(phys);\n#endif\n#endif\n    }\n\n    void send(Buffer b) {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        phys.send((JDPacket*)b->data,NULL,false);\n#endif        \n    }\n\n    bool isConnected() {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        return phys.isConnected();\n#else\n        return false;\n#endif\n    }\n\n    bool isRunning() {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        return phys.isRunning();\n#else\n        return false;\n#endif\n    }\n\n    int getId()\n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        return phys.id;\n#else\n        return -1;\n#endif\n    }\n\n    JDPacket* getPacket()\n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        auto pkt = phys.getPacket();\n#if CONFIG_ENABLED(DEVICE_USB) && CONFIG_ENABLED(DEVICE_JACDAC_DEBUG)\n        if (pkt)\n            pxt::jacdacDebug.handlePacket(pkt);\n#endif\n        return pkt;\n#else\n        return NULL;\n#endif        \n    }\n\n    void start()\n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        phys.start();\n#endif        \n    }\n\n    void stop()\n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        phys.stop();\n#endif       \n    }\n\n    JDDiagnostics getDiagnostics()\n    {\n#ifdef CODAL_JACDAC_WIRE_SERIAL\n        return phys.getDiagnostics();\n#else\n        JDDiagnostics d;\n        return d;\n#endif       \n    }\n};\n\nSINGLETON_IF_PIN(WJDPhysicalLayer, JACK_TX);\n\n/**\n* Gets the physical layer component id\n**/\n//%\nint __physId() {\n    auto jd = getWJDPhysicalLayer();\n    return jd ? jd->getId() : -1;\n}\n\n/**\n * Write a buffer to the jacdac physical layer.\n **/\n//%\nvoid __physSendPacket(Buffer buf) {\n    auto jd = getWJDPhysicalLayer();\n    if (jd)\n        jd->send(buf);\n}\n\n/**\n* Reads a packet from the queue. NULL if queue is empty\n**/\n//%\nBuffer __physGetPacket() {\n    auto jd = getWJDPhysicalLayer();\n    Buffer buf = NULL;\n    if (jd) {\n        auto pkt = jd->getPacket();\n        if (pkt)\n        {\n            buf = mkBuffer((uint8_t*)pkt, sizeof(JDPacket));\n            free(pkt);\n        }\n    }\n\n    return buf;\n}\n\n/**\n * Returns the connection state of the JACDAC physical layer.\n **/\n//%\nbool __physIsConnected() {\n    auto jd = getWJDPhysicalLayer();\n    return jd && jd->isConnected();\n}\n\n/**\n * Indicates if the bus is running\n **/\n//%\nbool __physIsRunning() {\n    auto jd = getWJDPhysicalLayer();\n    return jd && jd->isRunning();\n}\n\n/**\n * Starts the JACDAC physical layer.\n **/\n//%\nvoid __physStart()\n{\n    auto jd = getWJDPhysicalLayer();\n    if (jd)\n        jd->start();\n}\n\n\n/**\n * Reads the diagnostics struct provided by the physical layer. Returns a buffer or NULL.\n **/\n//%\nBuffer __physGetDiagnostics() {\n    auto jd = getWJDPhysicalLayer();\n    Buffer buf = NULL;\n\n    if (jd) {\n        JDDiagnostics diagnostics = jd->getDiagnostics();\n        buf = mkBuffer((uint8_t*)&diagnostics, sizeof(JDDiagnostics));\n    }\n\n    return buf;\n}\n\n/**\n * Stops the JACDAC physical layer.\n **/\n//%\nvoid __physStop()\n{\n    auto jd = getWJDPhysicalLayer();\n    if (jd)\n        jd->stop();\n}\n\n}",
            "jacdac.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "jacdac.ts": "/// <reference path=\"ifaces.ts\"/>\n\nnamespace jacdac {\n    class JDDummyBus implements JDPhysicalLayer {\n        writeBuffer(buf: Buffer) {\n        }\n\n        isConnected() {\n            return true;\n        }\n    }\n\n    /**\n     * A packet\n     */\n    export class JACDAC {\n        private static _instance: JACDAC;\n        private _controlService: JDControlService;\n        private _consoleService: JDConsoleService;\n        private _bridge: JDService;\n        private _services: JDService[];\n        private _bus: JDPhysicalLayer;\n\n        private state: boolean;\n\n        onIdentificationRequest: () => void;\n        onNameRemotelyChanged: (name: string) => void;\n\n        get bus() {\n            return this._bus;\n        }\n\n        set bus(bus: JDPhysicalLayer) {\n            this._bus = bus;\n        }\n\n        get services(): JDService[] {\n            return this._services.slice(0);\n        }\n\n        get bridge() {\n            return this._bridge;\n        }\n\n        set bridge(bridge: JDService) {\n            this._bridge = bridge;\n        }\n\n        get devices(): JDDevice[] {\n            return this._controlService.deviceManager.getDeviceList();\n        }\n\n        get controlService() {\n            return this._controlService;\n        }\n\n        get consoleService() {\n            if (!this._consoleService) {\n                this._consoleService = new JDConsoleService();\n                this.add(this._consoleService);\n            }\n            return this._consoleService;\n        }\n\n        private constructor() {\n            this._bus = new JDDummyBus();\n            this._services = [];\n            this._controlService = new JDControlService();\n        }\n\n        setDeviceAddress(device_address: number) {\n            this._controlService.disconnect();\n            this._controlService.enumerate(device_address)\n        }\n\n        //packet received instead?\n        routePacket(pkt: JDPacket): void {\n            this._controlService.routePacket(pkt);\n\n            // if we have a bridge service, route all packets to it.\n            if (this._bridge)\n                this._bridge.handlePacket(pkt);\n        }\n\n        start(device_address?:number): void {\n            if (this.state)\n                return;\n\n            this.state = true;\n            this._controlService.enumerate(device_address);\n        }\n\n        stop(): void {\n            if (!this.state)\n                return;\n\n            this.state = false;\n            this._controlService.disconnect();\n        }\n\n        setDeviceName(name: string): void {\n            this._controlService.setDeviceName(name);\n        }\n\n        getDeviceName(): string {\n            return this._controlService.getDeviceName();\n        }\n\n        triggerRemoteIdentification(device_address: number): void {\n            this._controlService.configurationService.triggerRemoteIdentification(device_address);\n        }\n\n        setRemoteDeviceName(device_address: number, name: string): void {\n            this._controlService.configurationService.setRemoteDeviceName(device_address, name);\n        }\n\n        getRemoteDevice(device_address: number): JDDevice {\n            return this._controlService.getRemoteDevice(device_address);\n        }\n\n        isRunning(): boolean {\n            return this.state\n        }\n\n        add(service: JDService): boolean {\n\n            for (let s of this._services)\n                if (s == service)\n                    return false;\n\n            this._services.push(service);\n            jacdac.options.log(`added service cls:${service.service_class}, md:${service.mode} (${this._services.length} services)`);\n\n            // only enumerate if a new host service is added. Enumerate is idempotent.\n            if (service.mode == JDServiceMode.HostService || service.mode == JDServiceMode.BroadcastHostService)\n                this._controlService.enumerate();\n\n            return true;\n        }\n\n        remove(service: JDService): boolean {\n            for (let i = 0; i < this._services.length; ++i) {\n                if (this._services[i] == service) {\n                    jacdac.options.log(`removing service ${service.service_class}`);\n                    const isHost = (service.mode == JDServiceMode.HostService || service.mode == JDServiceMode.BroadcastHostService);\n                    if (isHost)\n                        this._controlService.disconnect();\n                    this._services.splice(i, 1);\n                    if (isHost)\n                        this._controlService.enumerate();\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        contains(service: JDService): boolean {\n            for (let i = 0; i < this._services.length; ++i) {\n                if (this._services[i] == service)\n                    return true;\n            }\n            return false;\n        }\n\n        public static get instance() {\n            return this._instance || (this._instance = new JACDAC());\n        }\n\n        write(buf: Buffer, service_number: number, device_address: number, device: JDDevice) {\n            let packet = new JDPacket();\n\n            if (device_address == jacdac.JD_CONTROL_TRANSMIT_ONLY_ADDRESS)\n                packet.data = device.udid.concat(buf);\n            else\n                packet.data = buf;\n\n            packet.device_address = device_address;\n            packet.service_number = service_number;\n            packet.communication_rate = JD_DEVICE_DEFAULT_COMMUNICATION_RATE;\n\n            if (device)\n                packet.communication_rate = device.communication_rate;\n\n            packet.crc = jd_crc(packet, device);\n\n\n            this.writePacket(packet);\n        }\n\n        writePacket(pkt: JDPacket) {\n            this._bus.writeBuffer(pkt.getBuffer());\n        }\n    }\n\n    /**\n     * Gets the JACDAC instance\n     */\n    export function instance() {\n        return jacdac.JACDAC.instance;\n    }\n\n    /**\n     * Gets a snapshot of the device list\n     */\n    export function devices(): JDDevice[] {\n        return jacdac.JACDAC.instance.devices;\n    }\n\n    /**\n     * Gets a value that indicates if the JACDAC bus is connected.\n     */\n    export function isConnected(): boolean {\n        return jacdac.JACDAC.instance.bus.isConnected()\n            && jacdac.JACDAC.instance.controlService.isConnected();\n    }\n\n    /**\n     * Gets a value that indicates if JACDAC is running.\n     */\n    export function isRunning(): boolean {\n        return jacdac.JACDAC.instance.isRunning();\n    }\n\n    /**\n     * Starts and returns the console service\n     */\n    export function consoleService(): JDConsoleService {\n        return jacdac.JACDAC.instance.consoleService;\n    }\n}\n",
            "jacdacidentification.ts": "namespace jacdac {\n    export class JDIdentification {\n        identifying: boolean;\n\n        constructor() {\n            this.identifying = false;\n            control.onEvent(33,2, () => {\n                this.identify();\n            });\n        }\n\n        identify() {\n            this.identifying = true;\n            // do something to identify the device\n            this.identifying = false;\n        }\n    }\n\n    export class JDGPIOIdentification extends JDIdentification {\n        pin: DigitalInOutPin\n        constructor(pin: DigitalInOutPin) {\n            super();\n            this.pin = pin || pins.pinByCfg(DAL.CFG_PIN_LED);\n        }\n\n        identify() {\n            if (this.identifying || !this.pin)\n                return;\n\n            this.identifying = true;\n\n            let state = false;\n            for (let i = 0; i < 50; i++) {\n                this.pin.digitalWrite(state = !state);\n                pause(100);\n            }\n\n            this.identifying = false;\n        }\n    }\n\n    /**\n     * The identitifiation service\n     */\n    //% fixedInstance whenUsed\n    export const identification: JDIdentification = new JDGPIOIdentification(undefined);\n}",
            "makecodejacdac.ts": "enum JDBusState {\n    Receiving,\n    Transmitting,\n    High,\n    Low,\n    NotSupported = -1\n}\n\nnamespace jacdac {\n\n    class JACDACBus implements jacdac.JDPhysicalLayer {\n        constructor() {\n        }\n\n        start() {\n            __physStart();\n            control.internalOnEvent(__physId(), DAL.JD_SERIAL_EVT_DATA_READY, () => this.handlePacketData());\n        }\n\n        stop() {\n            __physStop();\n        }\n\n        handlePacketData() {\n            let buf: Buffer = undefined;\n            while (buf = __physGetPacket()) {\n                const pkt = new jacdac.JDPacket(buf);\n                jacdac.JACDAC.instance.routePacket(pkt)\n            }\n        }\n\n        writeBuffer(b: Buffer) {\n            __physSendPacket(b);\n        }\n\n        isConnected() {\n            return __physIsConnected()\n        }\n\n        isRunning() {\n            return __physIsRunning();\n        }\n\n        getDiagnostics() {\n            return __physGetDiagnostics();\n        }\n    }\n\n    let jacdacStarted = false;\n    let bus: JACDACBus;\n    export function start(): void {\n        if (jacdacStarted)\n            return;\n\n        jacdacStarted = true;\n        if (!bus) {\n            bus = new JACDACBus();\n            jacdac.JACDAC.instance.bus = bus;\n        }\n\n        // load name from storage\n        const DEVICE_NAME_STORAGE_KEY = \"jddn\"\n\n        if (!jacdac.JACDAC.instance.getDeviceName()) {\n            const deviceName = configStorage.getItem(DEVICE_NAME_STORAGE_KEY);\n            if (deviceName) {\n                console.add(jacdac.consolePriority, `:jd> restoring device name changed to ${deviceName}`)\n                jacdac.JACDAC.instance.setDeviceName(deviceName);\n            }\n        }\n        jacdac.JACDAC.instance.onNameRemotelyChanged = function (name: string) {\n            control.dmesg(`:jd> device name changed to ${name}`);\n            console.add(jacdac.consolePriority, `:jd> device name changed to ${name}`)\n            configStorage.setItem(DEVICE_NAME_STORAGE_KEY, name);\n        };\n\n        jacdac.JACDAC.instance.onIdentificationRequest = function () {\n            // DEVICE_ID_JACDAC_CONFIGURATION_SERVICE = 33\n            // JD_CONTROL_CONFIGURATION_EVT_IDENTIFY = 2\n            control.raiseEvent(33, 2)\n        }\n\n        // start service\n        bus.start();\n        jacdac.JACDAC.instance.start();\n\n        console.addListener(function (pri, msg) {\n            jacdac.JACDAC.instance.consoleService.add(<jacdac.JDConsolePriority><number>pri, msg);\n        });\n    }\n\n    export function diagnostics(): jacdac.JDDiagnostics {\n        if (!bus)\n            return new jacdac.JDDiagnostics(control.createBuffer(0));\n\n        return new jacdac.JDDiagnostics(bus.getDiagnostics());\n    }\n\n    export function stop() {\n        if (jacdacStarted) {\n            jacdacStarted = false;\n            jacdac.JACDAC.instance.stop();\n            bus.stop();\n        }\n    }\n}",
            "makecodeoptions.ts": "namespace jacdac.options\n{\n    let sn: Buffer\n    export function utf8Decode (buf: Buffer) {\n        return buf.toString();\n    }\n\n    export function utf8Encode (str: string) {\n        return control.createBufferFromUTF8(str);\n    }\n\n    export function createBuffer (size: number) {\n        return control.createBuffer(size);\n    }\n\n    export function error (message: string) {\n        console.add(ConsolePriority.Error, \":jd> \" + message);\n    }\n\n    export function log (message: string)  {\n        console.add(jacdac.consolePriority, \":jd> \" + message);\n    }\n\n    export function getSerialNumber ()  {\n        if (!sn) {\n            sn = control.deviceLongSerialNumber();\n        }\n        return sn;\n    }\n    export function getTimeMs() {\n        return control.millis();\n    }\n}",
            "messagebus.ts": "namespace jacdac {\n\n    /**\n     * A driver that listens for message bus events\n     */\n    export class MessageBusService extends Broadcast {\n        suppressForwarding: boolean;\n\n        static NAME = \"bus\";\n        constructor() {\n            super(MessageBusService.NAME, jacdac.MESSAGE_BUS_DEVICE_CLASS);\n            this.suppressForwarding = false;\n        }\n\n        raiseEvent(id: number, value: number) {\n            this.start();\n            const event = control.createBuffer(4);\n            event.setNumber(NumberFormat.UInt16LE, 0, id);\n            event.setNumber(NumberFormat.UInt16LE, 2, value);\n            this.sendPacket(event);\n        }\n\n        broadcastEvent(id: number, value: number) {\n            this.start();\n            //control.dmesg(`jd> msgbus> listen event ${id} ${value}`)        \n            control.onEvent(id, value, () => {\n                if (this.suppressForwarding) return;\n                this.raiseEvent(id, value);\n            }, DAL.MESSAGE_BUS_LISTENER_IMMEDIATE)\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            const id = data.getNumber(NumberFormat.UInt16LE, 0);\n            const value = data.getNumber(NumberFormat.UInt16LE, 2);\n            this.suppressForwarding = true;\n            control.raiseEvent(id, value);\n            this.suppressForwarding = false;\n            return jacdac.DEVICE_OK;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"message bus service\"\n    export const messageBusService = new MessageBusService();\n\n    /**\n     * Pipes specific events through JACDAC\n     */\n    //% block=\"broadcast events|from %src|with value %value\" weight=5\n    //% group=\"Control\"\n    export function broadcastEvent(src: number, value: number) {\n        messageBusService.broadcastEvent(src, value);\n    }\n\n    /**\n     * Gets the message code\n     */\n    //% blockHidden=1 shim=ENUM_GET\n    //% blockId=jacdacMessageCode block=\"$msg\" enumInitialMembers=\"message1\"\n    //% enumName=JacDacMessage enumMemberName=msg enumPromptHint=\"e.g. Start, Stop, Jump...\"\n    //% group=\"Broadcast\"\n    //% enumIsHash\n    export function __message(msg: number): number {\n        return msg;\n    }\n\n    /**\n     * Sends an event over JacDac\n     * @param id \n     * @param value \n     */\n    //% blockid=jacdacraisevent\n    //% block=\"raise event|from %src|with value %value\" weight=5\n    //% group=\"Control\"\n    export function raiseEvent(src: number, value: number) {\n        messageBusService.raiseEvent(src, value);\n    }\n\n    /**\n     * Broadcasts a message over JacDac\n     * @param msg \n     */\n    //% blockId=jacdacBroadcastMessage block=\"jacdac send $msg\"\n    //% msg.shadow=jacdacMessageCode draggableParameters\n    //% weight=200\n    //% blockGap=8\n    //% help=jacdac/send-message\n    //% group=\"Broadcast\"\n    export function sendMessage(msg: number): void {\n        // 0 is MICROBIT_EVT_ANY, shifting by 1\n        messageBusService.raiseEvent(JD_MESSAGE_BUS_ID, msg + 1);\n    }\n\n    /**\n     * Registers code to run for a particular message\n     * @param msg \n     * @param handler \n     */\n    //% blockId=jacdacOnMessageReceived block=\"on jacdac $msg received\"\n    //% msg.shadow=jacdacMessageCode draggableParameters\n    //% weight=199\n    //% help=jacdac/on-received-message\n    //% group=\"Broadcast\"\n    export function onReceivedMessage(msg: number, handler: () => void) {\n        messageBusService.start();\n        control.onEvent(JD_MESSAGE_BUS_ID, msg + 1, handler);\n    }\n}",
            "ns.ts": "//% weight=5 advanced=true\n//% blockGap=8\n//% groups='[\"Broadcast\", \"Console\", \"Controller\", \"Services\", \"Control\"]'\nnamespace jacdac {\n\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"jacdac\",\n  \"description\": \"Plug and play single wire serial protocol - beta\",\n  \"files\": [\n    \"configurationservice.ts\",\n    \"consoleservice.ts\",\n    \"consts.ts\",\n    \"control.ts\",\n    \"controldebugview.ts\",\n    \"crc.ts\",\n    \"debugservice.ts\",\n    \"debugview.ts\",\n    \"debugviews.ts\",\n    \"devicemanager.ts\",\n    \"diagnostics.ts\",\n    \"ifaces.ts\",\n    \"jacdac.ts\",\n    \"rand.ts\",\n    \"rngservice.ts\",\n    \"service.ts\",\n    \"structs.ts\",\n    \"makecodeoptions.ts\",\n    \"makecodejacdac.ts\",\n    \"jacdac.cpp\",\n    \"shims.d.ts\",\n    \"config.ts\",\n    \"driver.ts\",\n    \"sensordriver.ts\",\n    \"jacdac.svg\",\n    \"pxtparts.json\",\n    \"actuator.ts\",\n    \"messagebus.ts\",\n    \"jacdacidentification.ts\",\n    \"controllerclient.ts\",\n    \"ns.ts\",\n    \"README.md\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"yotta\": {\n    \"userConfigs\": [\n      {\n        \"description\": \"JACDAC WebUSB debugging.\",\n        \"config\": {\n          \"DEVICE_JACDAC_DEBUG\": 1\n        }\n      }\n    ]\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/081011394432f1878d7f0c4c018e9b587b43a7b8/static/libs/jacdac.png\"\n}",
            "pxtparts.json": "{\n    \"jacdac\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"jacdac.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 30\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"JACK_TX\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0, 1\n                ]\n            }\n        ]\n    }\n}",
            "rand.ts": "namespace jacdac{\n    export function random(min: number, max: number) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    export function generate_eui64(serial: Buffer) : Buffer {\n        serial.setUint8(6, serial.getUint8(6) & ~(0x02))\n        return serial;\n    }\n}",
            "rngservice.ts": "namespace jacdac{\n\n    const JD_CONTROL_RNG_SERVICE_NUMBER = 2\n\n    const JD_CONTROL_RNG_SERVICE_REQUEST_TYPE_REQ = 1;\n    const JD_CONTROL_RNG_SERVICE_REQUEST_TYPE_RESP = 2;\n\n    export class JDRNGService extends JDService {\n\n        send(buffer: Buffer): void {\n            if (JACDAC.instance.bus.isConnected())\n                JACDAC.instance.write(buffer, this.service_number, 0, null);\n        }\n\n        constructor() {\n            super(JDServiceClass.CONTROL_RNG, JDServiceMode.ControlLayerService);\n            this.service_number = JD_CONTROL_RNG_SERVICE_NUMBER;\n        }\n\n        // no imp for now.\n    }\n\n}",
            "sensordriver.ts": "namespace jacdac {\n    export enum SensorState {\n        None = 0,\n        Stopped = 0x01,\n        Stopping = 0x02,\n        Streaming = 0x04,\n    }\n\n    export enum SensorCommand {\n        State,\n        Event,\n        StartStream,\n        StopStream,\n        LowThreshold,\n        HighThreshold,\n        Calibrate\n    }\n\n    export function bufferEqual(l: Buffer, r: Buffer): boolean {\n        if (!l || !r) return !!l == !!r;\n        if (l.length != r.length) return false;\n        for (let i = 0; i < l.length; ++i) {\n            if (l.getNumber(NumberFormat.UInt8LE, i) != r.getNumber(NumberFormat.UInt8LE, i))\n                return false;\n        }\n        return true;\n    }\n\n    export function bufferToString(buf: Buffer, offset: number): string {\n        let str = \"\";\n        for (let i = offset; (i < buf.length) && !!buf[i]; i++)\n            str += String.fromCharCode(buf[i]);\n        return str;\n    }\n    \n    /**\n     * JacDac service running on sensor and streaming data out\n     */\n    export class SensorHost extends Host {\n        public streamingInterval: number; // millis\n\n        constructor(name: string, deviceClass: number, controlLength = 0) {\n            super(name, deviceClass, 1 + controlLength);\n            this.sensorState = SensorState.Stopped;\n            this.streamingInterval = 100;\n        }\n\n        get sensorState(): SensorState {\n            return this.controlData[0];\n        }\n\n        set sensorState(value: SensorState) {\n            this.controlData[0] = value;\n        }\n\n        public updateControlPacket() {\n            // send streaming state in control package\n            const buf = this.sensorControlPacket();\n            if (buf)\n                this.controlData.write(1, buf);\n        }\n\n        protected sensorControlPacket(): Buffer {\n            return undefined;\n        }\n\n        public handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            const command = data.getNumber(NumberFormat.UInt8LE, 0);\n            this.log(`hpkt ${command}`);\n            switch (command) {\n                case SensorCommand.StartStream:\n                    const interval = data.getNumber(NumberFormat.UInt32LE, 1);\n                    if (interval)\n                        this.streamingInterval = Math.max(20, interval);\n                    this.startStreaming();\n                    return jacdac.DEVICE_OK;\n                case SensorCommand.StopStream:\n                    this.stopStreaming();\n                    return jacdac.DEVICE_OK;\n                case SensorCommand.LowThreshold:                \n                    this.setThreshold(true, data.getNumber(NumberFormat.UInt32LE, 1));\n                    return jacdac.DEVICE_OK;\n                case SensorCommand.HighThreshold:\n                    this.setThreshold(false, data.getNumber(NumberFormat.UInt32LE, 1));\n                    return jacdac.DEVICE_OK;\n                case SensorCommand.Calibrate:\n                    return this.handleCalibrateCommand(packet);\n                default:\n                    // let the user deal with it\n                    return this.handleCustomCommand(command, packet);\n            }\n        }\n\n        // override\n        protected serializeState(): Buffer {\n            return undefined;\n        }\n\n        // override\n        protected setThreshold(low: boolean, value: number) {\n\n        }\n\n        // override\n        protected handleCalibrateCommand(pkt: JDPacket): number {\n            return jacdac.DEVICE_OK;\n        }\n\n        protected handleCustomCommand(command: number, pkt: JDPacket): number {\n            return jacdac.DEVICE_OK;\n        }\n\n        protected raiseHostEvent(value: number) {\n            const pkt = control.createBuffer(4);\n            pkt.setNumber(NumberFormat.UInt8LE, 0, SensorCommand.Event);\n            pkt.setNumber(NumberFormat.UInt16LE, 1, value);\n            this.sendPacket(pkt);\n        }\n\n        public setStreaming(on: boolean) {\n            if (on) this.startStreaming();\n            else this.stopStreaming();\n        }\n\n        private startStreaming() {\n            if (this.sensorState != SensorState.Stopped)\n                return;\n\n            this.log(`start`);\n            this.sensorState = SensorState.Streaming;\n            control.runInBackground(() => {\n                while (this.sensorState == SensorState.Streaming) {\n                    // run callback                    \n                    const state = this.serializeState();\n                    if (!!state) {\n                        // did the state change?\n                        if (this.isConnected()) {\n                            // send state and record time\n                            const pkt = control.createBuffer(state.length + 1);\n                            pkt.setNumber(NumberFormat.UInt8LE, 0, SensorCommand.State);\n                            pkt.write(1, state);\n                            this.sendPacket(pkt);\n                        }\n                    }\n                    // check streaming interval value\n                    if (this.streamingInterval < 0)\n                        break;\n                    // waiting for a bit\n                    pause(this.streamingInterval);\n                }\n                this.sensorState = SensorState.Stopped;\n                this.log(`stopped`);\n            })\n        }\n\n        private stopStreaming() {\n            if (this.sensorState == SensorState.Streaming) {\n                this.log(`stopping`)\n                this.sensorState = SensorState.Stopping;\n                pauseUntil(() => this.sensorState == SensorState.Stopped);\n            }\n        }\n    }\n}",
            "service.ts": "namespace jacdac{\n\n    export const enum JDServiceMode {\n        ClientService = 1,\n        HostService = 2,\n        BroadcastHostService = 3,\n        ControlLayerService = 4\n    }\n\n    export const enum JDServiceClass {\n        CONTROL = 0,\n        CONTROL_RNG = 1,\n        CONTROL_CONFIGURATION = 2,\n        CONTROL_TEST = 3,\n\n        JOYSTICK = 4,\n        MESSAGE_BUS = 5,\n        BRIDGE = 6,\n        BUTTON = 7,\n        ACCELEROMETER = 8,\n        CONSOLE = 9\n    }\n\n    export class JDService {\n        device?: JDDevice;\n        private _service_class: number;\n        service_number: number;\n        private _mode: JDServiceMode;\n        status: number;\n        service_flags: number;\n        requiredDevice?: JDRequiredDevice;\n\n        onConnected?: () => void;\n        onDisconnected?: () => void;\n\n        constructor(service_class: number, mode: JDServiceMode) {\n            this._service_class = service_class;\n            this.service_number = JD_SERVICE_NUMBER_UNITIALISED_VAL;\n            this.status = 0;\n            this._mode = mode;\n            this.service_flags = 0\n        }\n\n        get service_class() {\n            return this._service_class;\n        }\n\n        get mode() {\n            return this._mode;\n        }\n\n        addAdvertisementData(): Buffer {\n            return jacdac.options.createBuffer(0);\n        }\n\n        handleServiceInformation(device: JDDevice, serviceInfo: JDServiceInformation): number {\n            return DEVICE_OK;\n        }\n\n        handlePacket(pkt: JDPacket): number {\n            return DEVICE_OK;\n        }\n\n\n        isConnected(): boolean {\n            return (this.status & JD_SERVICE_STATUS_FLAGS_INITIALISED) ? true : false;\n        }\n\n        send(buffer: Buffer): void {\n            if (this.device && JACDAC.instance.bus.isConnected())\n                JACDAC.instance.write(buffer, this.service_number, this.device.device_address, this.device);\n        }\n\n\n        _hostConnected(): void {\n            jacdac.options.log(\"Host Connected\");\n            this.status |= JD_SERVICE_STATUS_FLAGS_INITIALISED;\n\n            if (this.onConnected)\n                this.onConnected();\n        }\n\n        _hostDisconnected(): void {\n            jacdac.options.log(\"Host disconnected\");\n            this.status &= ~JD_SERVICE_STATUS_FLAGS_INITIALISED;\n\n            if (this.onDisconnected)\n                this.onDisconnected();\n        }\n\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace jacdac {\n\n    /**\n     * Gets the physical layer component id\n     **/\n    //% shim=jacdac::__physId\n    function __physId(): int32;\n\n    /**\n     * Write a buffer to the jacdac physical layer.\n     **/\n    //% shim=jacdac::__physSendPacket\n    function __physSendPacket(buf: Buffer): void;\n\n    /**\n     * Reads a packet from the queue. NULL if queue is empty\n     **/\n    //% shim=jacdac::__physGetPacket\n    function __physGetPacket(): Buffer;\n\n    /**\n     * Returns the connection state of the JACDAC physical layer.\n     **/\n    //% shim=jacdac::__physIsConnected\n    function __physIsConnected(): boolean;\n\n    /**\n     * Indicates if the bus is running\n     **/\n    //% shim=jacdac::__physIsRunning\n    function __physIsRunning(): boolean;\n\n    /**\n     * Starts the JACDAC physical layer.\n     **/\n    //% shim=jacdac::__physStart\n    function __physStart(): void;\n\n    /**\n     * Reads the diagnostics struct provided by the physical layer. Returns a buffer or NULL.\n     **/\n    //% shim=jacdac::__physGetDiagnostics\n    function __physGetDiagnostics(): Buffer;\n\n    /**\n     * Stops the JACDAC physical layer.\n     **/\n    //% shim=jacdac::__physStop\n    function __physStop(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "structs.ts": "namespace jacdac {\n    export class JDPacket implements JDSerializable {\n        _buffer: Buffer;\n\n        constructor(buf?: Buffer) {\n            if (buf) {\n                if (buf.length != JD_SERIAL_HEADER_SIZE + JD_SERIAL_MAX_PAYLOAD_SIZE + 1)\n                    jacdac.options.error(\"Buffer packet size mismatch. Buffer size: \" + buf.length + \" expected size: \" + (JD_SERIAL_HEADER_SIZE + JD_SERIAL_MAX_PAYLOAD_SIZE + 1));\n\n                this._buffer = buf\n            }\n            else\n                this._buffer = jacdac.options.createBuffer(JD_SERIAL_MAX_PAYLOAD_SIZE + JD_SERIAL_HEADER_SIZE + 1);\n        }\n\n        get crc(): number {\n            return this._buffer.getUint8(0) | ((this._buffer.getUint8(1) & 0x0f) << 8)\n        }\n        set crc(crc: number) {\n            this._buffer.setUint8(0, crc & 0xff);\n            this._buffer.setUint8(1, (this._buffer.getUint8(1) & 0xf0) | (crc & 0xF00) >> 8);\n        }\n\n        get device_address(): number {\n            return this._buffer.getUint8(2);\n        }\n        set device_address(address: number) {\n            this._buffer.setUint8(2, address & 0xff);\n        }\n\n        get udidh() : number {\n            return (this.device_address == JD_CONTROL_TRANSMIT_ONLY_ADDRESS) ? this._buffer.getNumber(NumberFormat.UInt32LE, JD_SERIAL_HEADER_SIZE + 4) : 0;\n        }\n        get udidl() : number {\n            return (this.device_address == JD_CONTROL_TRANSMIT_ONLY_ADDRESS) ? this._buffer.getNumber(NumberFormat.UInt32LE, JD_SERIAL_HEADER_SIZE) : 0;\n        }\n\n        get size(): number {\n            return this._buffer.getUint8(3);\n        }\n        set size(size: number) {\n            this._buffer.setUint8(3, size & 0xFF);\n        }\n\n        get service_number(): number {\n            return (this._buffer.getUint8(1) & 0xF0) >> 4;\n        }\n        set service_number(service_number: number) {\n            this._buffer.setUint8(1, (this._buffer.getUint8(1) & 0x0F) | ((service_number & 0x0F) << 4));\n        }\n\n        get data(): Buffer {\n            if (this.device_address != JD_CONTROL_TRANSMIT_ONLY_ADDRESS)\n                return this._buffer.slice(JD_SERIAL_HEADER_SIZE, this.size)\n\n            return this._buffer.slice(JD_SERIAL_HEADER_SIZE + JD_SERIAL_UDID_SIZE, this.size - JD_SERIAL_UDID_SIZE);\n        }\n\n        set data(buf: Buffer) {\n            this.size = buf.length;\n\n            for (let i = 0; i < Math.min(buf.length, this._buffer.length - 1); i++)\n                this._buffer.setUint8(JD_SERIAL_HEADER_SIZE + i, buf.getUint8(i));\n        }\n\n        get communication_rate(): JDBaudRate {\n            return this._buffer.getUint8(JD_SERIAL_HEADER_SIZE + JD_SERIAL_MAX_PAYLOAD_SIZE);\n        }\n\n        set communication_rate(communicate_rate: JDBaudRate) {\n            this._buffer.setUint8(JD_SERIAL_HEADER_SIZE + JD_SERIAL_MAX_PAYLOAD_SIZE, communicate_rate);\n        }\n\n        getBuffer(): Buffer {\n            return this._buffer;\n        }\n\n        toString(): string {\n            return this._buffer.toHex();\n        }\n    }\n\n    export class JDControlPacket implements JDSerializable {\n        unique_device_identifier: Buffer;\n        device_address: number;\n        device_flags: number;\n        _device_name: string;\n        data: Buffer;\n\n        constructor(p?: JDPacket) {\n            this._device_name = \"\";\n            if (p) {\n                // jacdac.options.log(\"Making control packet from: a \" + p.device_address + \" sn \" + p.service_number + \" at \" + JDBaudRate[p.communication_rate] + \" with size \" + p.size)\n                const buf = p.data;\n\n                this.unique_device_identifier = buf.slice(0, 8);\n\n                let idx = 8;\n                this.device_address = buf.getUint8(idx++);\n                this.device_flags = buf.getUint8(idx++);\n\n                if (this.device_flags & JD_DEVICE_FLAGS_HAS_NAME) {\n                    let nameLen = buf.getUint8(idx++);\n                    this._device_name = jacdac.options.utf8Decode(buf.slice(idx, nameLen));\n                    idx += nameLen;\n\n                    if (nameLen != this._device_name.length)\n                        jacdac.options.error(\"Control packet name length mismatch. Expected: \" + nameLen + \" got: \" + this.device_name.length);\n                }\n\n                this.data = buf.slice(idx, buf.length);\n            }\n            else\n                this.data = jacdac.options.createBuffer(0);\n        }\n\n        getBuffer(): Buffer {\n\n            let size = 0;\n\n            if (this._device_name.length)\n                size += this.device_name.length + 1;\n\n            let buffer = jacdac.options.createBuffer(JD_CONTROL_PACKET_HEADER_SIZE + size + this.data.length);\n\n            let idx = 0;\n            while (idx < this.unique_device_identifier.length) {\n                buffer.setUint8(idx, this.unique_device_identifier.getUint8(idx));\n                idx++\n            }\n\n            buffer.setUint8(idx++, this.device_address & 0xff);\n            buffer.setUint8(idx++, this.device_flags & 0xff);\n\n            if (this.device_flags & JD_DEVICE_FLAGS_HAS_NAME) {\n                buffer.setUint8(idx++, this._device_name.length);\n                let encoded = jacdac.options.utf8Encode(this._device_name);\n                for (let i = 0; i < this._device_name.length; i++)\n                    buffer.setUint8(idx++, encoded.getUint8(i));\n            }\n\n            for (let i = 0; i < this.data.length; i++)\n                buffer.setUint8(idx++, this.data.getUint8(i));\n\n            return buffer;\n        }\n\n        get udidh() {\n            return this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 4);\n        }\n\n        get udidl() {\n            return this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 0);\n        }\n\n        get udid() {\n            return this.unique_device_identifier;\n        }\n\n        get device_name(): string {\n            if (this._device_name && this._device_name.length)\n                return this._device_name;\n            else\n                return null;\n        }\n\n        set device_name(device_name: string) {\n            if (device_name && device_name.length) {\n                this.device_flags |= JD_DEVICE_FLAGS_HAS_NAME;\n                this._device_name = device_name;\n            }\n        }\n\n        append(buffer: Buffer) {\n            let newBuf = jacdac.options.createBuffer(this.data.length + buffer.length);\n\n            let idx = 0;\n            for (let i = 0; i < this.data.length; i++)\n                newBuf.setUint8(idx++, this.data.getUint8(i));\n\n            for (let i = 0; i < buffer.length; i++)\n                newBuf.setUint8(idx++, buffer.getUint8(i));\n\n            this.data = newBuf;\n        }\n    }\n\n    export class JDRequiredDevice {\n        unique_device_identifier: Buffer;\n        device_name: string;\n        get udidh() {\n            return this.unique_device_identifier && this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 4);\n        }\n        get udidl() {\n            return this.unique_device_identifier && this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 0);\n        }\n    }\n\n    export class JDDevice {\n        unique_device_identifier: Buffer;\n        device_address: number;\n        device_flags: number;\n        device_name: string;\n        private _services: JDServiceInformation[];\n        rolling_counter: number;\n        broadcast_servicemap: Buffer;\n        servicemap_bitmsk: number;\n        communication_rate: JDBaudRate;\n\n        constructor(cp?: JDControlPacket, communication_rate?: JDBaudRate) {\n            this.broadcast_servicemap = jacdac.options.createBuffer(JD_DEVICE_MAX_HOST_SERVICES);\n            this.servicemap_bitmsk = 0;\n\n            if (cp) {\n                this.communication_rate = communication_rate;\n                this.update(cp);\n            }\n            else {\n                this.unique_device_identifier = jacdac.options.createBuffer(0);\n                this.device_address = 0;\n                this.device_flags = 0;\n                this._services = []\n                this.rolling_counter = 0;\n            }\n        }\n\n        get services(): JDServiceInformation[] {\n            return this._services ? this._services.slice(0) : [];\n        }\n\n        update(cp: JDControlPacket): void {\n            this.rolling_counter = 0;\n            this._services = []\n            this.unique_device_identifier = cp.unique_device_identifier;\n            this.device_address = cp.device_address;\n            this.device_name = cp.device_name;\n            this.device_flags = cp.device_flags;\n\n            let idx = 0;\n            const buf = cp.data;\n\n            while (idx < buf.length) {\n                let service = new JDServiceInformation(buf.slice(idx, buf.length));\n                idx += JD_SERVICE_INFO_HEADER_SIZE + service.advertisement_size;\n                this._services.push(service);\n            }\n        }\n\n        get udidh() {\n            return this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 4);\n        }\n\n        get udidl() {\n            return this.unique_device_identifier.getNumber(NumberFormat.UInt32LE, 0);\n        }\n\n        get udid() {\n            return this.unique_device_identifier;\n        }\n\n        toString(): string {\n            let service_numbers = \"\"\n            for (let s of this.services)\n                service_numbers += s.service_class.toString() + \" \";\n\n            return `${this.device_name || this.udid.toHex()} [${this.device_address}]: ${service_numbers}`;\n        }\n    }\n\n    export class JDServiceInformation implements JDSerializable {\n        service_class: number;\n        service_flags: number;\n        advertisement_size: number;\n        data: Buffer;\n\n        constructor(buf?: Buffer) {\n            if (buf) {\n                let idx = 0;\n                for (let i = 0; i < 4; i++)\n                    this.service_class |= buf.getUint8(idx++) << (8 * i);\n\n                this.service_flags = buf.getUint8(idx++);\n                this.advertisement_size = buf.getUint8(idx++);\n\n                if (this.advertisement_size)\n                    this.data = buf.slice(idx, this.advertisement_size);\n            }\n            if (!this.data)\n                this.data = jacdac.options.createBuffer(0);\n        }\n\n        getBuffer(): Buffer {\n\n            let header = jacdac.options.createBuffer(JD_SERVICE_INFO_HEADER_SIZE + this.data.length);\n\n            let idx = 0;\n\n            for (idx; idx < 4; idx++)\n                header.setUint8(idx, (this.service_class & (0xff << (idx * 8))) >> (idx * 8));\n\n            header.setUint8(idx++, this.service_flags & 0xff);\n            header.setUint8(idx++, this.advertisement_size & 0xff);\n\n            for (let i = 0; i < this.data.length; i++)\n                header.setUint8(idx++, this.data.getUint8(i));\n\n            return header;\n        }\n    }\n\n    export class JDConfigurationPacket implements JDSerializable {\n        device_address: number;\n        request_type: number;\n        new_name: string;\n\n        constructor(p?: JDPacket) {\n            if (p) {\n                const buf = p.data\n                let idx = 0;\n                this.device_address = buf.getUint8(idx++);\n                this.request_type = buf.getUint8(idx++);\n\n                if (p.size > JD_CONTROL_CONFIGURATION_SERVICE_PACKET_HEADER_SIZE) {\n                    let nameLen = buf.getUint8(idx++);\n                    this.new_name = jacdac.options.utf8Decode(buf.slice(idx, nameLen));\n                }\n            } else {\n                this.device_address = 0;\n                this.request_type = -1;\n                this.new_name = \"\";\n            }\n        }\n\n        getBuffer(): Buffer {\n\n            let size = JD_CONTROL_CONFIGURATION_SERVICE_PACKET_HEADER_SIZE;\n\n            if (this.new_name.length)\n                size += this.new_name.length + 1;\n\n            let header = jacdac.options.createBuffer(size);\n\n            let idx = 0;\n            header.setUint8(idx++, this.device_address & 0xff);\n            header.setUint8(idx++, this.request_type & 0xff);\n\n            if (this.new_name.length) {\n                header.setUint8(idx++, this.new_name.length);\n\n                let encoded = jacdac.options.utf8Encode(this.new_name)\n\n                for (let i = 0; i < encoded.length; i++)\n                    header.setUint8(idx++, encoded.getUint8(i));\n            }\n\n            return header;\n        }\n    }\n\n    export class JDConsolePacket implements JDSerializable {\n        priority: number;\n        packetType: JDConsolePacketType;\n        message: string;\n\n        constructor(p?: JDPacket) {\n            if (p) {\n\n                const buf = p.data\n                let idx = 0;\n                this.priority = buf.getUint8(idx++);\n                this.packetType = buf.getUint8(idx++);\n\n                let end = idx;\n                while (end < buf.length) {\n                    if (buf.getUint8(end) == 0)\n                        break;\n                    end++\n                }\n                this.message = jacdac.options.utf8Decode(buf.slice(idx, end - idx));\n            } else {\n                this.priority = -1;\n                this.packetType = JDConsolePacketType.Message;\n                this.message = \"\";\n            }\n        }\n\n\n        getBuffer(): Buffer {\n            if (this.message.length == 0)\n                jacdac.options.error(\"Console message length cannot be 0\");\n\n            const encoded = jacdac.options.utf8Encode(this.message)\n            const size = JD_CONSOLE_SERVICE_PACKET_HEADER_SIZE\n                + 2 /* packet type, priority */\n                + encoded.length /* utf8 encoded string */;\n            const header = jacdac.options.createBuffer(size);\n\n            let idx = 0;\n            header.setUint8(idx++, this.packetType & 0xff);\n            header.setUint8(idx++, this.priority & 0xff);\n\n\n            header.write(idx, encoded);\n            idx += encoded.length;\n            if (idx < header.length)\n                header.setUint8(idx++, 0); // null terminator\n\n            return header;\n        }\n    }\n}",
            "test.ts": "// outdated\n"
        },
        "jacdac-services": {
            "accelerometerclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class AccelerometerClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.ACCELEROMETER_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        get x(): number {\n            return this.get(JDDimension.X);\n        }\n\n        /**\n         * Reads the current y value from the sensor\n         */\n        get y(): number {\n            return this.get(JDDimension.Y);\n        }\n\n        /**\n         * Reads the current z value from the sensor\n         */\n        get z(): number {\n            return this.get(JDDimension.Z);\n        }\n\n        /**\n         * Reads the current strength value from the sensor\n         */\n        get strength(): number {\n            return this.get(JDDimension.Strength);\n        }\n\n\n        /**\n         * Reads a value of the sensor\n         * @param dimension which channel to read\n         */\n        //% blockId=jacdacaccget block=\"jacdac %accelerometer %dimension\"\n        //% group=\"Accelerometer\" weight=5\n        get(dimension: JDDimension): number {\n            const s = this.state;\n            if (!s || s.length < 6) return 0;\n            switch (dimension) {\n                case JDDimension.X:\n                case JDDimension.Y:\n                case JDDimension.Z:\n                    return s.getNumber(NumberFormat.Int16LE, dimension * 2);\n                default: // strength\n                    let r = 0;\n                    for (let i = 0; i < 3; ++i) {\n                        const x = s.getNumber(NumberFormat.Int16LE, i * 2);\n                        r += x * x;\n                    }\n                    return Math.sqrt(r);\n            }\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadacacconevent block=\"jacdac %accelerometer on %gesture\"\n        //% group=\"Accelerometer\"\n        onEvent(gesture: JDGesture, handler: () => void) {\n            this.registerEvent(gesture, handler);\n        }\n\n        onCustomGesture(id: number, handler: () => void) {\n            this.registerEvent(JDGesture.Shake + id, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"accelerometer client\"\n    export const accelerometerClient = new AccelerometerClient(\"acc\");\n}",
            "buttonclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ButtonClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.BUTTON_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jacadacbtispressed block=\"jacdac %button is pressed\"\n        //% group=\"Buttons\"\n        isPressed(): boolean {\n            const s = this.state;\n            if (!s || s.length < 1) return false;\n            return !!s.getNumber(NumberFormat.UInt8LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadacbtnonevent block=\"jacdac %button on %event\"\n        //% group=\"Buttons\"\n        onEvent(event: JDButtonEvent, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"button client\"\n    export const buttonClient = new ButtonClient(\"btn\");\n\n}",
            "colorsensorclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ColorSensorClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.COLOR_SENSOR_DEVICE_CLASS);\n        }\n\n        /**\n         * Uses a color sensor to capture the ambient color as a RGB value.\n         */\n        //% blockId=jdsensor_lightcolor block=\"%colorsensor light color\"\n        //% group=\"Color Sensor\"\n        lightColor(): number {\n            const s = this.state;\n            if (!s || s.length < 4) return 0;\n            return s.getNumber(NumberFormat.UInt32LE, 0);\n        }\n\n        /**\n         * Returns the hue of the color\n         */\n        lightHue(): number {\n            const c = this.lightColor();\n            const h = ColorSensorClient.mapRgbToColor(c);\n            console.log(`color ${c} -> ${h}`)\n            return h;\n        }\n\n        private static mapRgbToColor(col: number): number {\n            const r = ((col >> 16) & 0xff) / 255;\n            const g = ((col >> 8) & 0xff) / 255;\n            const b = ((col) & 0xff) / 255;\n\n            const cmax = Math.max(r, Math.max(g, b));\n            const cmin = Math.min(r, Math.min(g, b));\n            const c = cmax - cmin;\n            let hue: number;\n            if (c == 0) {\n                hue = 0;\n            } else {\n                switch (cmax) {\n                    case r: {\n                        const segment = (g - b) / c;\n                        let shift = 0 / 60;       // R° / (360° / hex sides)\n                        if (segment < 0) {          // hue > 180, full rotation\n                            shift = 360 / 60;         // R° / (360° / hex sides)\n                        }\n                        hue = segment + shift;\n                        break;\n                    }\n                    case g: {\n                        const segment = (b - r) / c;\n                        const shift = 120 / 60;     // G° / (360° / hex sides)\n                        hue = segment + shift;\n                        break;\n                    }\n                    case b: {\n                        const segment = (r - g) / c;\n                        const shift = 240 / 60;     // B° / (360° / hex sides)\n                        hue = segment + shift;\n                        break;\n                    }\n                }\n            }\n            hue = hue / 0.6 * 255; // hue is in [0,6], scale it up\n            return hue | 0;\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"button client\"\n    export const colorSensorClient = new ColorSensorClient(\"btn\");\n\n}",
            "gamepadclient.ts": "enum JDGamepadButton {\n    //% enumval=0\n    B = 0,\n    //% enumval=1\n    A = 1,\n    //% enumval=2\n    Y = 2,\n    //% enumval=3\n    X = 3,\n    //% block=\"left bumper\"\n    //% enumval=4\n    LeftBumper = 4,\n    //% block=\"right bumper\"\n    //% enumval=5\n    RightBumper = 5,\n    //% block=\"left trigger\"\n    //% enumval=6\n    LeftTrigger = 6,\n    //% block=\"right trigger\"\n    //% enumval=7\n    RightTrigger = 7,\n    //% block=\"select\"\n    //% enumval=8\n    Select = 8,\n    //% block=\"start\"\n    //% enumval=9\n    Start = 9,\n    //% block=\"left stick\"\n    //% enumval=10\n    LeftStick = 10,\n    //% block=\"right stick\"\n    //% enumval=11\n    RightStick = 11,\n    //% block=\"up\"\n    //% enumval=12\n    Up = 12,\n    //% block=\"down\"\n    //% enumval=13\n    Down = 13,\n    //% block=\"left\"\n    //% enumval=14\n    Left = 14,\n    //% block=\"right\"\n    //% enumval=15\n    Right = 15\n}\n\nnamespace jacdac {\n    /**\n     * Maps to a standard layout button to the button index\n     * @param button the name of the button\n     */\n    //% blockId=jdjoystickStandardButton block=\"%button\"\n    //% shim=TD_ID blockHidden=1\n    export function gamepadButton(button: JDGamepadButton): number {\n        return button;\n    }\n\n    //% fixedInstances\n    export class GamepadClient extends Client {\n        constructor() {\n            super(\"gpad\", jacdac.GAMEPAD_DEVICE_CLASS);\n        }\n\n        /** \n         * Sets the button state to down\n         */\n        //% blockId=jdjoystickSetButton block=\"%gamepad button %index=jdjoystickStandardButton|%down=toggleDownUp\"\n        //% weight=100 group=\"Gamepad\"\n        setButton(index: number, down: boolean): void {\n            const buf = control.createBuffer(4);\n            buf[0] = JDGamepadCommand.Button;\n            buf[1] = index;\n            buf[2] = down ? 1 : 0;\n            this.sendPacket(buf);\n        }\n\n        /**\n         * Sets the current move on the gamepad\n         **/\n        //% blockId=gamepadMove block=\"%gamepad %index|move by x %x|y %y\"\n        //% help=gamepad/move\n        //% index.min=0 index.max=1\n        //% blockGap=8 group=\"Gamepad\"\n        move(index: number, x: number, y: number): void {\n            const buf = control.createBuffer(4);\n            buf[0] = JDGamepadCommand.Move;\n            buf[1] = index;\n            buf.setNumber(NumberFormat.Int8LE, 2, x);\n            buf.setNumber(NumberFormat.Int8LE, 3, y);\n            this.sendPacket(buf);\n        }\n\n        /** \n         * Sets the throttle state\n         */\n        //% blockId=gamepadSetThrottle block=\"%gamepad set throttle %index|to %value\"\n        //% gamepad/set-throttle blockHidden=1\n        //% index.min=0 index.max=1\n        //% value.min=0 value.max=31\n        //% group=\"Gamepad\"\n        setThrottle(index: number, value: number): void {\n            const buf = control.createBuffer(4);\n            buf[0] = JDGamepadCommand.Move;\n            buf[1] = index;\n            buf.setNumber(NumberFormat.Int8LE, 2, value);\n            this.sendPacket(buf);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"gamepad client\"\n    export const gamepadClient = new GamepadClient();\n}",
            "keyboardclient.ts": "enum JDKeyboardMediaKey {\n    //% block=\"mute\"\n    Mute = 0,\n    //% block=\"volume up\"\n    VolumeUp = 1,\n    //% block=\"volume down\"\n    VolumeDown = 2,\n    //% block=\"play pause\"\n    PlayPause = 3,\n    //% block=\"stop\"\n    Stop = 4,\n    //% block=\"previous track\"\n    PreviousTrack = 5,\n    //% block=\"next track\"\n    NextTrack = 6,\n    //% block=\"mail\"\n    Mail = 7,\n    //% block=\"calculator\"\n    Calculator = 8,\n    //% block=\"web search\"\n    WebSearch = 9,\n    //% block=\"web home\"\n    WebHome = 10,\n    //% block=\"web favourites\"\n    WebFavourites = 11,\n    //% block=\"web refresh\"\n    WebRefresh = 12,\n    //% block=\"web stop\"\n    WebStop = 13,\n    //% block=\"web forward\"\n    WebForward = 14,\n    //% block=\"web back\"\n    WebBack = 15,\n}\n\n\nenum JDKeyboardFunctionKey {\n    //% block=\"F1\"\n    F1Key = 0,\n    //% block=\"F2\"\n    F2Key = 1,\n    //% block=\"F3\"\n    F3Key = 2,\n    //% block=\"F4\"\n    F4Key = 3,\n    //% block=\"F5\"\n    F5Key = 4,\n    //% block=\"F6\"\n    F6Key = 5,\n    //% block=\"F7\"\n    F7Key = 6,\n    //% block=\"F8\"\n    F8Key = 7,\n    //% block=\"F9\"\n    F9Key = 8,\n    //% block=\"F0\"\n    F10Key = 9,\n    //% block=\"F11\"\n    F11Key = 10,\n    //% block=\"F12\"\n    F12Key = 11,\n\n    //% block=\"print screen\"\n    PrintScreen = 12,\n    //% block=\"scroll lock\"\n    ScrollLock = 13,\n    //% block=\"pause\"\n    Pause = 14,\n    //% block=\"insert\"\n    Insert = 15,\n    //% block=\"home\"\n    Home = 16,\n    //% block=\"page up\"\n    PageUp = 17,\n    //% block=\"delete\"\n    DeleteForward = 18,\n    //% block=\"end\"\n    End = 19,\n    //% block=\"page down\"\n    PageDown = 20,\n\n    //% block=\"right arrow\"\n    RightArrow = 21,\n    //% block=\"left arrow\"\n    LeftArrow = 22,\n    //% block=\"down arrow\"\n    DownArrow = 23,\n    //% block=\"up arrow\"\n    UpArrow = 24,\n}\n\nenum JDKeyboardKeyEvent {\n    //% block=\"press\"\n    Press = 0,\n    //% block=\"up\"\n    Up = 1,\n    //% block=\"down\"\n    Down = 2,\n}\n\nnamespace jacdac {\n    //% fixedInstances\n    export class KeyboardClient extends Client {\n        constructor() {\n            super(\"keyb\", jacdac.KEYBOARD_DEVICE_CLASS);\n        }\n\n        /**\n        * Sends a sequence of keystrokes to the keyboard\n        */\n        //% blockId=jdkeyboardType block=\"%keyboard type %text\"\n        //% blockGap=8 weight=100\n        //% text.shadowOptions.toString=true\n        //% group=\"Keyboard\"\n        type(type: string) {\n            const buf = control.createBuffer(jacdac.JD_SERIAL_MAX_PAYLOAD_SIZE)\n            buf[0] = JDKeyboardCommand.Type;\n            let n = 0;\n            while (n < type.length) {\n                const chunk = type.substr(n, buf.length - 1);\n                let i = 0;\n                for (i = 0; i < chunk.length; ++i)\n                    buf[i + 1] = chunk.charCodeAt(i);\n                if (i != chunk.length)\n                    buf[i] = 0;\n                this.sendPacket(buf);\n                n += chunk.length;\n            }\n        }\n\n        /**\n        * Sends a key command\n        */\n        //% blockId=jdkeyboardStandardKey block=\"%keyboard key %key|%event\"\n        //% blockGap=8 weight=99\n        //% group=\"Keyboard\"\n        key(key: string, event: JDKeyboardKeyEvent) {\n            const buf = control.createBuffer(4);\n            buf[0] = JDKeyboardCommand.Key;\n            buf[1] = key.charCodeAt(0);\n            buf[2] = event;\n            this.sendPacket(buf);\n        }\n\n        /**\n        * Sends a media key command\n        */\n        //% blockId=jdkeyboardMediaKey block=\"%keyboard media key %key|%event\"\n        //% blockGap=8\n        //% group=\"Keyboard\"\n        mediaKey(key: JDKeyboardMediaKey, event: JDKeyboardKeyEvent) {\n            const buf = control.createBuffer(4);\n            buf[0] = JDKeyboardCommand.MediaKey;\n            buf[1] = key;\n            buf[2] = event;\n            this.sendPacket(buf);\n        }\n\n        /**\n        *\n        */\n        //% blockId=keyboardFunctionKey block=\"%keyboard function key %key|%event\"\n        //% blockGap=8\n        //% group=\"Keyboard\"\n        functionKey(key: JDKeyboardFunctionKey, event: JDKeyboardKeyEvent) {\n            const buf = control.createBuffer(4);\n            buf[0] = JDKeyboardCommand.FunctionKey;\n            buf[1] = key;\n            buf[2] = event;\n            this.sendPacket(buf);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"keyboard client\"\n    export const keyboardClient = new KeyboardClient();\n}",
            "lcdclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LCDClient extends ActuatorClient {\n        constructor(name: string) {\n            super(name, jacdac.LCD_DEVICE_CLASS, 17);\n            this.setDisplay(true);\n        }\n\n        /**\n         * Shows a string on the LCD screen\n         * @param text the text to show\n         */\n        //% blockId=jdlcdshowstring block=\"jacdac %client show string %text\"\n        //% group=\"LCD\" blockGap=8\n        showString(text: string) {\n            // test for change\n            const n = text.length;\n            let changed = false;\n            for (let i = 1; i < this.state.length; ++i) {\n                const c = i < n ? text.charCodeAt(i) : 0;\n                changed = changed || this.state[i] != c;\n                this.state[i] = c;\n            }\n            if (changed)\n                this.notifyChange();\n        }\n\n        /**\n         * Shows a number on the LCD screen\n         * @param value the number to show\n         */\n        //% blockId=jdlcdshownumber block=\"jacdac %client show number %value\"\n        //% group=\"LCD\" blockGap=8\n        showNumber(value: number) {\n            this.showString(value.toString());\n        }\n\n        /**\n         * Clears the screen\n         */\n        //% blockId=jdlcdclear block=\"jacdac clear %client\"\n        //% group=\"LCD\" blockGap=8\n        clear() {\n            this.showString(\"\");\n        }\n\n        private setFlag(flag: JDLCDFlags, enabled: boolean) {\n            if (!!(this.state[0] & flag) == enabled) return;\n            if (enabled)\n                this.state[0] = this.state[0] | flag;\n            else\n                this.state[0] = ~(~this.state[0] | flag);\n            this.notifyChange();\n        }\n\n        /**\n         * Enables or disables display\n         * @param enabled true to turn the display on; false otherwise\n         */\n        //% blockId=jdlcdsetdisplay block=\"jacdac set %client display %enabled\"\n        //% enabled.shadow=toggleOnOff\n        //% group=\"LCD\" blockGap=8\n        setDisplay(enabled: boolean) {\n            this.setFlag(JDLCDFlags.Display, enabled);\n        }\n\n        /**\n         * Enables or disables blinking\n         * @param enabled true to blink\n         */\n        //% blockId=jdlcdsetblink block=\"jacdac set %client blink %enabled\"\n        //% enabled.shadow=toggleOnOff\n        //% group=\"LCD\" blockGap=8\n        setBlink(enabled: boolean) {\n            this.setFlag(JDLCDFlags.Blink, enabled);\n        }\n\n        /**\n         * Show or hide cursor\n         * @param enabled true to display cursor, false otherwise\n         */\n        //% blockId=jdlcdsetcursor block=\"jacdac set %client cursor %enabled\"\n        //% enabled.shadow=toggleOnOff\n        //% group=\"LCD\" blockGap=8\n        setCursor(enabled: boolean) {\n            this.setFlag(JDLCDFlags.Cursor, enabled);\n        }\n    }\n\n    /**\n     * A character LCD client\n     */\n    //% fixedInstance whenUsed block=\"lcd client\"\n    export const lcdClient = new LCDClient(\"lcd\");\n}",
            "lightclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LightClient extends Client {\n        constructor(name: string) {\n            super(name, jacdac.LIGHT_DEVICE_CLASS);\n        }\n\n        private sendCmd(cmd: number, value: number) {\n            const buf = control.createBuffer(9);\n            buf.setNumber(NumberFormat.UInt8LE, 0, cmd);\n            buf.setNumber(NumberFormat.UInt32LE, 1, value);\n            this.sendPacket(buf);\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"jdlight_set_brightness\" block=\"set %strip brightness %brightness\"\n        //% brightness.min=0 brightness.max=255\n        //% weight=2 blockGap=8\n        //% group=\"Light\"\n        setBrightness(brightness: number): void {\n            this.sendCmd(JDLightCommand.SetBrightness, brightness);\n        }\n\n        /**\n         * Set all of the pixels on the strip to one RGB color.\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"jdlight_set_strip_color\" block=\"set %strip all pixels to %rgb=colorNumberPicker\"\n        //% weight=80 blockGap=8\n        //% group=\"Light\"\n        setAll(rgb: number) {\n            this.sendCmd(JDLightCommand.SetAll, rgb);\n        }\n\n        /**\n         * Show an animation or queue an animation in the animation queue\n         * @param animation the animation to run\n         * @param duration the duration to run in milliseconds, eg: 500\n         */\n        //% blockId=jdlight_show_animation block=\"show %strip animation %animation for %duration=timePicker ms\"\n        //% weight=90 blockGap=8\n        //% group=\"Light\"\n        showAnimation(animation: JDLightAnimation, duration: number) {\n            this.sendCmd(animation, duration);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"light client\"\n    export const lightClient = new LightClient(\"light\");\n}",
            "lightsensorclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LightSensorClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.LIGHT_SENSOR_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jacdaclightsensorlevel block=\"jacdac %lightsensor light level\"\n        //% group=\"Light sensor\"\n        get lightLevel(): number {\n            const s = this.state;\n            if (!s || s.length < 1) return 0;\n            return s.getNumber(NumberFormat.UInt8LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadaclightsensoronevent block=\"jacdac %client on %event\"\n        //% group=\"Light sensor\"\n        onEvent(event: JDLightCondition, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n\n        /**\n         * Sets the threshold value for the event\n         * @param level \n         * @param value \n         */\n        //% blockId=jacdaclightsetthrshold block=\"jacdac %lightsensor set threshold %level to %value\"\n        //% group=\"Light sensor\"\n        setLightConditionThreshold(level: JDLightCondition, value: number) {\n            this.setThreshold(level == JDLightCondition.Dark, value);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"light sensor client\"\n    export const lightSensorClient = new LightSensorClient(\"lis\");\n}",
            "lightspectrumsensorclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class LightSpectrumSensorClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.LIGHT_SPECTRUM_SENSOR_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the full spectrum \n         */\n        //% blockId=jdlightspectrumfull block=\"jacdac %client full\"\n        //% group=\"Light spectrum sensor\"\n        get full(): number {\n            const s = this.state;\n            if (!s || s.length < 6) return -1;\n            return s.getNumber(NumberFormat.UInt16LE, 0);\n        }\n\n        /**\n         * Reads the full spectrum \n         */\n        //% blockId=jdlightspectruminfrared block=\"jacdac %client infrared\"\n        //% group=\"Light spectrum sensor\"\n        get infrared(): number {\n            const s = this.state;\n            if (!s || s.length < 6) return -1;\n            return s.getNumber(NumberFormat.UInt16LE, 2);\n        }\n\n        /**\n         * Reads the full spectrum \n         */\n        //% blockId=jdlightspectrumvisible block=\"jacdac %client visible\"\n        //% group=\"Light spectrum sensor\"\n        get visible(): number {\n            const s = this.state;\n            if (!s || s.length < 6) return -1;\n            return s.getNumber(NumberFormat.UInt16LE, 4);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadaclightsensorspectrumonevent block=\"jacdac %client on %event\"\n        //% group=\"Light sensor\"\n        onEvent(event: JDLightSpectrumEvent, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"light spectrum sensor client\"\n    export const lightSpectrumSensorClient = new LightSpectrumSensorClient(\"lspec\");\n}",
            "microphoneclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class MicrophoneClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.MICROPHONE_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jacdacmicrophonevent block=\"jacdac %microphone sound level\"\n        //% group=\"Microphone\"\n        get soundLevel(): number {\n            const s = this.state;\n            if (!s || s.length < 1) return 0;\n            return s.getNumber(NumberFormat.UInt8LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadacmicrophoneonevent block=\"jacdac %microphone on loud sound\"\n        //% group=\"Microphone\"\n        onLoudSound(handler: () => void) {\n            this.registerEvent(DAL.SENSOR_THRESHOLD_HIGH, handler);\n        }\n\n        /**\n         * Sets the threshold value for the event\n         * @param level \n         * @param value \n         */\n        //% blockId=jacdacmicrophonesetthreshold block=\"jacdac %microphone set loud sound threshold to %value\"\n        //% group=\"Microphone\"\n        setLoudSoundThreshold(value: number) {\n            this.setThreshold(false, value);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"microphone client\"\n    export const microphoneClient = new MicrophoneClient(\"mic\");\n}",
            "mouseclient.ts": "const enum JDMouseButton {\n    //% block=\"right\" enumval=1\n    Right = 0x01,\n    //% block=\"middle\" enumval=4\n    Middle = 0x04,\n    //% block=\"left\" enumval=2\n    Left = 0x02,\n}\n\nnamespace jacdac {\n    //% fixedInstances\n    export class MouseClient extends Client {\n        constructor() {\n            super(\"mous\", jacdac.MOUSE_DEVICE_CLASS);\n        }\n\n        /** \n         * Sets the mouse button state to down\n         */\n        //% blockId=jdmouseSetButton block=\"%mouse button %index|%down=toggleDownUp\"\n        //% group=\"Mouse\"\n        setButton(button: JDMouseButton, down: boolean): void {\n            const buf = control.createBuffer(4);\n            buf[0] = JDMouseCommand.Button;\n            buf[1] = button;\n            buf[2] = down ? 1 : 0;\n            this.sendPacket(buf);\n        }\n\n        /**\n         * Moves the mouse\n         **/\n        //% help=mouse/move\n        //% blockId=mouseMove block=\"%mouse move x %x|y %y\"\n        //% x.min=-128 x.max=127\n        //% y.min=-128 y.max=127\n        //% group=\"Mouse\"\n        move(x: number, y: number): void {\n            const buf = control.createBuffer(4);\n            buf[0] = JDMouseCommand.Move;\n            buf.setNumber(NumberFormat.Int8LE, 1, x);\n            buf.setNumber(NumberFormat.Int8LE, 2, y);\n            this.sendPacket(buf);\n        }\n\n        /**\n         * Moves the mouse\n         **/\n        //% help=mouse/wheel\n        //% blockId=mouseWheel block=\"%mouse turn wheel %w\"\n        //% w.min=-128 w.max=127\n        //% group=\"Mouse\"\n        turnWheel(w: number): void {\n            const buf = control.createBuffer(2);\n            buf[0] = JDMouseCommand.TurnWheel;\n            buf.setNumber(NumberFormat.Int8LE, 1, w);\n            this.sendPacket(buf);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"mouse client\"\n    export const mouseClient = new MouseClient();\n}",
            "musicclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class MusicClient extends Client {\n        constructor() {\n            super(\"mus\", jacdac.MUSIC_DEVICE_CLASS);\n        }\n\n        /**\n         * Play a tone through the speaker for some amount of time.\n         * @param frequency pitch of the tone to play in Hertz (Hz), eg: 440\n         * @param ms tone duration in milliseconds (ms), eg: 500\n         */\n        //% blockId=jdmusic_play_note block=\"play %music tone|at %note|for %duration\"\n        //% note.defl=440\n        //% duration.defl=500\n        //% weight=76 blockGap=8\n        //% group=\"Music\"\n        playTone(frequency: number, ms: number): void {\n            const buf = control.createBuffer(9);\n            buf[0] = JDMusicCommand.PlayTone;\n            buf.setNumber(NumberFormat.UInt32LE, 1, frequency);\n            buf.setNumber(NumberFormat.UInt32LE, 5, ms);\n            this.sendPacket(buf);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"music client\"\n    export const musicClient = new MusicClient();\n}",
            "pixelclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class PixelClient extends ActuatorClient {\n        constructor(name: string) {\n            super(name, jacdac.PIXEL_DEVICE_CLASS, 4);\n        }\n\n        /**\n         * Set the brightness of the neopixel. This flag only applies to future operations.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"jacdacpixelsetbrightess\" block=\"set %pixel brightness %brightness\"\n        //% weight=98\n        //% brightness.min=0 brightness.max=255\n        //% group=\"Pixel\"\n        setBrightness(value: number) {\n            this.state.setNumber(NumberFormat.UInt8LE, 0, value & 0xff);\n            this.notifyChange();\n        }\n\n        /**\n         * Set the on-board pixel to a given color.\n         * @param color RGB color of the LED\n         */\n        //% blockId=\"jadacpixelsetcolor\" block=\"jacdac set %pixel color %rgb=colorNumberPicker\"\n        //% weight=99\n        //% blockGap=8\n        //% group=\"Pixel\"\n        setColor(value: number) {\n            this.state.setNumber(NumberFormat.UInt8BE, 1, (value >> 16) & 0xff)\n            this.state.setNumber(NumberFormat.UInt8BE, 2, (value >> 8) & 0xff)\n            this.state.setNumber(NumberFormat.UInt8BE, 3, (value >> 0) & 0xff)\n            this.notifyChange();\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"pixel client\"\n    export const pixelClient = new PixelClient(\"pixel\");\n}",
            "proximityclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ProximityClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.PROXIMITY_DEVICE_CLASS);\n        }\n\n        /**\n         * Gets the distance measure by the sensor. Negative if missing\n         */\n        //% blockId=jdproximtitydistance block=\"jacdac %client distance\"\n        //% group=\"Promixity\"\n        get distance(): number {\n            const s = this.state;\n            if (!s || s.length < 4) return -1;\n            return (s.getNumber(NumberFormat.UInt32LE, 0) / 10);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture\n         * @param handler\n         */\n        //% blockId=jdproximityevent block=\"jacdac %client on %event\"\n        //% group=\"Promixity\"\n        onEvent(event: JDPromixityEvent, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n\n    }\n\n    //% fixedInstance whenUsed block=\"light sensor client\"\n    export const proximityClient = new ProximityClient(\"proxi\");\n}\n",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"jacdac-services\",\n  \"description\": \"Services for jacdac\",\n  \"files\": [\n    \"sensorclient.ts\",\n    \"buttonclient.ts\",\n    \"lightsensorclient.ts\",\n    \"accelerometerclient.ts\",\n    \"touchbuttonclient.ts\",\n    \"microphoneclient.ts\",\n    \"thermometerclient.ts\",\n    \"switchclient.ts\",\n    \"lightclient.ts\",\n    \"keyboardclient.ts\",\n    \"mouseclient.ts\",\n    \"gamepadclient.ts\",\n    \"pixelclient.ts\",\n    \"musicclient.ts\",\n    \"servoclient.ts\",\n    \"lcdclient.ts\",\n    \"colorsensorclient.ts\",\n    \"proximityclient.ts\",\n    \"lightspectrumsensorclient.ts\",\n    \"rotaryencoderclient.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/081011394432f1878d7f0c4c018e9b587b43a7b8/static/libs/jacdac-services.png\"\n}",
            "rotaryencoderclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class RotaryEncoderClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.ROTARY_ENCODER_DEVICE_CLASS);\n        }\n\n        /**\n         * Gets the position of the rotary encoder\n         */\n        //% blockId=jacdacrotaryencoderposition block=\"jacdac %encoder position\"\n        //% group=\"Rotary Encoder\"\n        get position(): number {\n            const st = this.state;\n            if (!st || st.length < 4) return 0;\n            return st.getNumber(NumberFormat.Int32LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadacrotaryencoderonevent block=\"jacdac %client on %event\"\n        //% group=\"Light sensor\"\n        onEvent(event: JDRotaryEncoderEvent, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n    }\n\n    /**\n     * Default rotary encoder\n     */\n    //% fixedInstance block=\"rotary encoder client\"\n    export const rotaryEncoderClient = new RotaryEncoderClient(\"crank\");\n}",
            "sensorclient.ts": "namespace jacdac {\n    //% fixedInstances\n    //% weight=1\n    export class SensorClient extends Client {\n        // virtual mode only\n        protected _localTime: number;\n        protected _lastState: Buffer;\n        private _stateChangedHandler: () => void;\n\n        private _sensorState: SensorState;\n\n        constructor(name: string, deviceClass: number) {\n            super(name, deviceClass);\n            this._lastState = control.createBuffer(0);\n            this._sensorState = SensorState.None;\n        }\n\n        public get state() {\n            this.start();\n            return this._lastState;\n        }\n\n        /**\n         * Enables or disable streaming the sensor internal state\n         * @param on streaming enabled\n         */\n        //% blockid=jacdacsensorstreaming block=\"jacdac %sensor set streaming %on\"\n        //% on.shadow=toggleOnOff weight=1\n        //% group=\"Services\"\n        public setStreaming(on: boolean) {\n            this.start();\n            this._sensorState = on ? SensorState.Streaming : SensorState.Stopped;\n            this.sync();\n        }\n\n        /**\n         * Requests the sensor to calibrate\n         */\n        public calibrate() {\n            this.start();\n            const buf = control.createBuffer(2);\n            const cmd = SensorCommand.Calibrate;\n            buf.setNumber(NumberFormat.UInt8LE, 0, cmd);\n            this.sendPacket(buf);\n        }\n\n        private sync() {\n            if (this._sensorState == SensorState.None) return;\n\n            const buf = control.createBuffer(2);\n            const cmd = (this._sensorState & SensorState.Streaming)\n                ? SensorCommand.StartStream : SensorCommand.StopStream;\n            buf.setNumber(NumberFormat.UInt8LE, 0, cmd);\n            this.sendPacket(buf);\n        }\n\n        public onStateChanged(handler: () => void) {\n            this._stateChangedHandler = handler;\n            this.start();\n        }\n\n        handleServiceInformation(device: JDDevice, serviceInfo: JDServiceInformation): number {\n            if (this._sensorState == SensorState.None) return DEVICE_OK;\n            const data = serviceInfo.data;\n            const state = data.getNumber(NumberFormat.UInt8LE, 1);\n            if ((this._sensorState & SensorState.Streaming) != (state & SensorState.Streaming))\n                this.sync(); // start            \n            return DEVICE_OK;\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            const command = data.getNumber(NumberFormat.UInt8LE, 0);\n            this.log(`vpkt ${command}`)\n            switch (command) {\n                case SensorCommand.State: {\n                    const state = data.slice(1);\n                    const changed = !jacdac.bufferEqual(this._lastState, state);\n                    const r = this.handleVirtualState(state);\n                    this._lastState = state;\n                    this._localTime = control.millis();\n                    if (changed && this._stateChangedHandler)\n                        this._stateChangedHandler();\n                    return r;\n                }\n                case SensorCommand.Event: {\n                    const value = data.getNumber(NumberFormat.UInt16LE, 1);\n                    control.raiseEvent(this.eventId, value);\n                    return jacdac.DEVICE_OK;\n                }\n                default:\n                    return this.handleCustomCommand(command, packet);\n            }\n        }\n\n        protected handleCustomCommand(command: number, pkt: JDPacket): number {\n            return jacdac.DEVICE_OK;\n        }\n\n        protected handleVirtualState(state: Buffer): number {\n            return jacdac.DEVICE_OK;\n        }\n\n        protected setThreshold(low: boolean, value: number) {\n            this.start();\n            const buf = control.createBuffer(6);\n            const cmd = low ? SensorCommand.LowThreshold : SensorCommand.HighThreshold;\n            buf.setNumber(NumberFormat.UInt8LE, 0, cmd);\n            buf.setNumber(NumberFormat.Int32LE, 1, value);\n            this.sendPacket(buf);\n        }\n    }\n}",
            "servoclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ServoClient extends ActuatorClient {\n        constructor(name: string) {\n            super(name, jacdac.SERVO_DEVICE_CLASS, 5);\n        }\n\n        /**\n         * Set the servo angle\n         */\n        //% group=\"Servos\"\n        //% weight=100\n        //% blockId=jdservoservosetangle block=\"jacdac set %servo angle to %degrees=protractorPicker °\"\n        //% degrees.defl=90\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% blockGap=8        \n        setAngle(degrees: number) {\n            if (!this.state[0] || this.state.getNumber(NumberFormat.Int16LE, 1) != degrees) {\n                this.state[0] = 1;\n                this.state.setNumber(NumberFormat.Int16LE, 1, degrees);\n                this.notifyChange();\n            }\n        }\n\n        /**\n         * Set the throttle on a continuous servo\n         * @param speed the throttle of the motor from -100% to 100%\n         */\n        //% group=\"Servos\"\n        //% weight=99\n        //% blockId=jdservoservorun block=\"jacdac continuous %servo run at %speed=speedPicker \\\\%\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        run(speed: number): void {\n            this.setAngle(Math.map(speed, -100, 100, 0, 180));\n        }\n\n        /*\n         * Set the pulse width to the servo in microseconds\n         */\n        //% group=\"Servos\"\n        //% weight=10 help=servos/set-pulse\n        //% blockId=jdservoservosetpulse block=\"jacdac set %servo pulse to %micros μs\"\n        //% micros.min=500 micros.max=2500\n        //% micros.defl=1500\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        setPulse(micros: number) {\n            micros = micros | 0;\n            micros = Math.clamp(500, 2500, micros);\n            if (this.state.getNumber(NumberFormat.UInt16LE, 3) != micros) {\n                this.state.setNumber(NumberFormat.UInt16LE, 3, micros);\n                this.notifyChange();\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"servo client\"\n    export const servoClient = new ServoClient(\"servo\");\n\n    //% fixedInstances\n    export class ServosClient extends ActuatorClient {\n        constructor(name: string, length: number) {\n            super(name, jacdac.SERVOS_DEVICE_CLASS, 4 * length, 2 * length);\n        }\n\n        /**\n         * Set the servo angle\n         */\n        //% group=\"Servos\"\n        //% weight=100\n        //% blockId=jdservoservossetangle block=\"jacdac set %servo %index angle to %degrees=protractorPicker °\"\n        //% degrees.defl=90\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% blockGap=8        \n        setAngle(index: number, degrees: number) {\n            this.ensureState((index + 1) * 4);\n            const k = index * 4;\n            this.state.setNumber(NumberFormat.UInt8LE, k, 1);\n            this.state.setNumber(NumberFormat.Int16LE, k + 1, degrees);\n            this.notifyChange();\n        }\n\n        /**\n         * Set the throttle on a continuous servo\n         * @param speed the throttle of the motor from -100% to 100%\n         */\n        //% group=\"Servos\"\n        //% weight=99\n        //% blockId=jdservosservorun block=\"jacdac continuous %servo %index run at %speed=speedPicker \\\\%\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        run(index: number, speed: number): void {\n            this.setAngle(index, Math.map(speed, -100, 100, 0, 180));\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"servos client\"\n    export const servosClient = new ServosClient(\"servos\", 2);\n}",
            "switchclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class SwitchClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.SWITCH_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jacdacswitchright block=\"jacdac %switch right\"\n        //% group=\"Switch\"\n        right(): boolean {\n            const s = this.state;\n            if (!s || s.length < 1) return false;\n            return !!s.getNumber(NumberFormat.UInt8LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacdacswitchonevent block=\"jacdac %switch on %event\"\n        //% group=\"Switch\"\n        onEvent(event: JDSwitchDirection, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"switch client\"\n    export const switchClient = new SwitchClient(\"switch\");\n}",
            "test.ts": "jacdac.broadcastEvent(9008, DAL.DEVICE_BUTTON_EVT_CLICK);\ncontrol.onEvent(9008, DAL.DEVICE_BUTTON_EVT_CLICK, function () {\n    console.log('click')\n})",
            "thermometerclient.ts": "enum JDTemperatureCondition {\n    //% block=\"hot\"\n    Hot = DAL.SENSOR_THRESHOLD_HIGH,  // ANALOG_THRESHOLD_HIGH\n    //% block=\"cold\"\n    Cold = DAL.SENSOR_THRESHOLD_LOW  // ANALOG_THRESHOLD_LOW\n}\n\n\nenum JDTemperatureUnit {\n    //% block=\"°C\"\n    Celsius = 0,\n    //% block=\"°F\"\n    Fahrenheit = 1,\n}\n\nnamespace jacdac {\n    //% fixedInstances\n    export class ThermometerClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.THERMOMETER_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jddevice_temperature block=\"temperature in %unit\"\n        //% group=\"Thermometer\"\n        //% weight=26\n        temperature(unit: JDTemperatureUnit): number {\n            const s = this.state;\n            if (!s || s.length < 2) return 0;\n            const t = s.getNumber(NumberFormat.Int16LE, 0);\n            switch(unit) {\n                case JDTemperatureUnit.Fahrenheit: (t * 18) / 10 + 32;\n                default: return t;\n            }\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadacthermoonevent block=\"jacdac %lightsensor on %lightCondition\"\n        //% group=\"Thermometer\"\n        onTemperatureConditionChanged(condition: JDTemperatureCondition, temperature: number, unit: JDTemperatureUnit, handler: () => void): void {\n            if (unit == JDTemperatureUnit.Fahrenheit)\n                temperature = (temperature - 32) * 5 / 9;\n            this.setThreshold(condition == JDTemperatureCondition.Cold, temperature);\n            control.onEvent(this.eventId, condition, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"thermometer client\"\n    export const thermometerClient = new ThermometerClient(\"temp\");\n}",
            "touchbuttonclient.ts": "namespace jacdac {\n    //% fixedInstances\n    export class TouchButtonClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.TOUCHBUTTON_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jacadactouchispressed block=\"jacdac %button value\"\n        //% group=\"Touch\"\n        value(): number {\n            const s = this.state;\n            if (!s || s.length < 2) return -1;\n            return s.getNumber(NumberFormat.UInt16LE, 0);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jacadactouchonevent block=\"jacdac %button on %event\"\n        //% group=\"Touch\"\n        onEvent(event: JDButtonEvent, handler: () => void) {\n            this.registerEvent(event, handler);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"touch button client\"\n    export const touchButtonClient = new TouchButtonClient(\"touch\");\n\n    /**\n     * A client of multiple buttons\n     */\n    export class TouchButtonsClient extends SensorClient {\n        constructor(name: string) {\n            super(name, jacdac.TOUCH_BUTTONS_DEVICE_CLASS);\n        }\n\n        /**\n         * Reads the current x value from the sensor\n         */\n        //% blockId=jdtoubhbuttonsvalue block=\"jacdac %button value\"\n        //% group=\"Touch\"\n        value(index: number): number {\n            const s = this.state;\n            if (!s || s.length + 1 < 2 * index) return -1;\n            return s.getNumber(NumberFormat.UInt16LE, index * 2);\n        }\n\n        /**\n         * Runs code when an event happens on the sensor\n         * @param gesture \n         * @param handler \n         */\n        //% blockId=jdtouchbuttonsevent block=\"jacdac %client %index on %event\"\n        //% group=\"Touch\"\n        onEvent(index: number, event: JDButtonEvent, handler: () => void) {\n            const j = jacdac.BUTTON_EVENTS.indexOf(<number>event);\n            if (j > -1) {\n                const k = DAL.ACCELEROMETER_EVT_SHAKE + 1\n                    + index * jacdac.BUTTON_EVENTS.length + j;\n                this.registerEvent(k, handler);\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"touch buttons client\"\n    export const touchButtonsClient = new TouchButtonsClient(\"tch\");\n}"
        },
        "jacdac-game": {
            "controllerservice.ts": "namespace jacdac {\n    //% fixedInstances\n    export class ControllerService extends Broadcast {\n        promptedServers: number[];\n        prompting: boolean;\n\n        constructor() {\n            super(\"ctrl\", jacdac.CONTROLLER_DEVICE_CLASS, 5);\n            this.promptedServers = [];\n            this.prompting = false;\n            this.controlData[0] = JDControllerCommand.ControlServer;\n        }\n\n        private connectClient(address: number, serverAddress: number, receivedPlayerIndex: number): number {\n            // fast path: check if player is current\n            if (!!serverAddress\n                && receivedPlayerIndex > 0\n                && receivedPlayerIndex < this.controlData.length\n                && address == this.controlData[receivedPlayerIndex]) {\n                // player index and server address match\n                return receivedPlayerIndex;\n            }\n\n            // search existing player index\n            for (let i = 1; i < this.controlData.length; ++i)\n                if (address == this.controlData[i]) {\n                    if (!serverAddress)\n                        this.sendPacket(this.controlData);\n                    return i;\n                }\n\n            this.log(`new player ${toHex8(address)}`);\n            const devices = jacdac.devices();\n            const players = controller.players();\n            const ids: number[] = [0, 0, 0, 0, 0]; // player 0 is not used\n            players.forEach(p => ids[p.playerIndex] = 1);\n\n            // did it move?\n            // clean dead players\n            for (let i = 1; i < this.controlData.length; ++i) {\n                const ci = this.controlData[i];\n                if (ci && !devices.some(d => d.device_address == ci)) {\n                    this.log(`del ${toHex8(this.controlData[i])} from ${i}`);\n                    this.controlData[i] = 0;\n                    const p = players.find(p => p.playerIndex == i);\n                    if (p) p.connected = false;\n                }\n            }\n\n            // add new player\n            // try receivedPlayerIndex first\n            if (receivedPlayerIndex\n                && this.controlData[receivedPlayerIndex] == 0\n                && ids[receivedPlayerIndex]) {\n                this.log(`client ${toHex8(address)} -> p${receivedPlayerIndex}`);\n                this.controlData[receivedPlayerIndex] = address;\n                return receivedPlayerIndex;\n            }\n\n            // try other positions 2,3,4 first\n            for (let i = 2; i < this.controlData.length; ++i) {\n                // if slot is free and there is such a player\n                if (this.controlData[i] == 0 && ids[i]) {\n                    this.log(`client ${toHex8(address)} -> p${i}`);\n                    this.controlData[i] = address;\n                    return i;\n                }\n            }\n            // try player 1\n            if (this.controlData[1] == 0 && ids[1]) {\n                this.log(`client ${toHex8(address)} -> ${1}`);\n                this.controlData[1] = address;\n                return 1;\n            }\n\n            // no slots available\n            this.log(`no player for ${toHex8(address)}`);\n            return -1;\n        }\n\n        handleServiceInformation(device: JDDevice, serviceInfo: JDServiceInformation): number {\n            const data = serviceInfo.data;\n            return this.processPacket(device.device_address, data);\n        }\n\n        handlePacket(packet: JDPacket): number {\n            const data = packet.data;\n            return this.processPacket(packet.device_address, data);\n        }\n\n        private processPacket(address: number, data: Buffer): number {\n            const cmd: JDControllerCommand = data[0];\n            switch (cmd) {\n                case JDControllerCommand.ControlClient:\n                    this.connectClient(address, data[1], data[2]);\n                    return DAL.DEVICE_OK;\n                case JDControllerCommand.ClientButtons:\n                    return this.processClientButtons(address, data);\n                case JDControllerCommand.ControlServer:\n                    return this.processControlServer(address, data);\n                default:\n                    return DAL.DEVICE_OK;\n            }\n        }\n\n        private processControlServer(address: number, data: Buffer): number {\n            // already prompting for another server\n            if (this.prompting) return DAL.DEVICE_OK;\n            // so there's another server on the bus,\n            // if we haven't done so yet, prompt the user if he wants to join the game\n            const device = jacdac.devices().find(d => d.device_address == address);\n            if (!device) // can't find any device at that address\n                return DAL.DEVICE_OK;\n\n            // check if prompted already\n            if (this.promptedServers.indexOf(device.udidl) >= 0)\n                return DAL.DEVICE_OK;\n\n            this.prompting = true;\n            control.runInParallel(() => {\n                const join = this.askJoin(device);\n                if (join)\n                    joinGame();\n                this.prompting = false;\n            });\n\n            return DAL.DEVICE_OK;\n        }\n\n        private hasPlayers(): boolean {\n            for (let i = 1; i < this.controlData.length; ++i)\n                if (this.controlData[i]) return true;\n            return false;\n        }\n\n        private askJoin(device: JDDevice): boolean {\n            game.eventContext(); // initialize the game\n            control.pushEventContext();\n            game.showDialog(\"Arcade Detected\", \"Join?\", \"A = OK, B = CANCEL\");\n            let answer: boolean = null;\n            controller.A.onEvent(ControllerButtonEvent.Pressed, () => answer = true);\n            controller.B.onEvent(ControllerButtonEvent.Pressed, () => answer = false);\n            pauseUntil(() =>\n                // user answered\n                answer !== null\n                // server got joined\n                || this.hasPlayers()\n                // other driver dissapeared\n                || !jacdac.devices().find(d => d.device_address == device.device_address)\n            );\n            // wait until we have an answer or the service\n            control.popEventContext();\n\n            // cache user answer\n            if (answer !== null)\n                this.promptedServers.push(device.udidl);\n\n            // check that we haven't been join by then\n            return !!answer\n                && !this.hasPlayers()\n                && !!jacdac.devices().find(d => d.device_address == device.device_address);\n        }\n\n        private processClientButtons(address: number, data: Buffer): number {\n            const playerIndex = this.connectClient(address, -1, 0);\n            if (playerIndex < 0) {\n                this.log(`no player for ${toHex8(address)}`);\n                return DAL.DEVICE_BUSY;\n            }\n            const player = controller.players().find(p => p.playerIndex == playerIndex);\n            if (!player) {\n                this.log(`no player ${player.playerIndex}`);\n                return DAL.DEVICE_OK;\n            }\n            const state = data[1];\n            const btns = player.buttons;\n            for (let i = 0; i < btns.length; ++i)\n                btns[i].setPressed(!!(state & (1 << (i + 1))));\n            return DAL.DEVICE_OK;\n        }\n\n        sendState() {\n            this.sendPacket(this.controlData);\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"controller service\"\n    export const controllerService = new ControllerService();\n\n    function joinGame() {\n        // stop server service\n        jacdac.controllerService.stop();\n        // remove game enterily\n        game.popScene();\n        // push empty game\n        game.pushScene();\n        // start client\n        console.log(`connecting to server...`);\n        jacdac.controllerClient.stateUpdateHandler = function () {\n            jacdac.controllerClient.setIsPressed(JDControllerButton.A, controller.A.isPressed());\n            jacdac.controllerClient.setIsPressed(JDControllerButton.B, controller.B.isPressed());\n            jacdac.controllerClient.setIsPressed(JDControllerButton.Left, controller.left.isPressed());\n            jacdac.controllerClient.setIsPressed(JDControllerButton.Up, controller.up.isPressed());\n            jacdac.controllerClient.setIsPressed(JDControllerButton.Right, controller.right.isPressed());\n            jacdac.controllerClient.setIsPressed(JDControllerButton.Down, controller.down.isPressed());\n        }\n        game.onPaint(() => {\n            if (jacdac.controllerClient.isActive())\n                game.showDialog(\n                    `connected`,\n                    `player ${jacdac.controllerClient.playerIndex}`);\n            else\n                game.showDialog(\n                    `disconnected`,\n                    `connect jacdac`);\n        });\n        jacdac.controllerClient.start();\n    }\n    // auto start server\n    // jacdac.controllerService.start();\n    // // TODO: fix control packages in broadcast mode\n    // control.runInParallel(function () {\n    //     while (jacdac.controllerService.isStarted) {\n    //         jacdac.controllerService.sendState();\n    //         pause(500);\n    //     }\n    // })\n}",
            "debugger.ts": "namespace jacdac.dbg {\n\n    export const JACDAC_DEBUG_ICON = img`\n        . . . . . c . . . . c . . 1 . .\n        . . . 1 . . c c c c . . . . . 1\n        . f f f f f 5 c c 5 f f f f f .\n        . f . . . . c c c c . . . . f .\n        . f . 1 . c . . . . c 1 . . f 1\n        . f . . . . . . . . . . . . f .\n        f f f f f f f . . f f f f f f f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f 4 f f f 4 f . . f 5 f f f 5 f\n        f 4 f d f 4 f . . f 5 f d f 5 f\n        f 4 f d f 4 f . . f 5 f d f 5 f\n        f 4 f f f 4 f . . f 5 f f f 5 f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f 4 f 4 f 4 f . . f 5 f 5 f 5 f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f f f f f f f . . f f f f f f f\n        `;\n\n    export const JACDAC_CONSOLE_ICON = img`\n        . . . . . 1 . 1 . . . . . 1 . .\n        . . . 1 . . . . . 1 . . . . . 1\n        . . . . . f f f f f f f f f f .\n        . . . . . f . . . . . . . . f .\n        . . . 1 . f . 1 . . . 1 . . f 1\n        . . . . . f . . . . . . . . f .\n        f f f f f f f . . f f f f f f f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f 4 f f f 4 f . . f 5 f f f 5 f\n        f 4 f d f 4 f . . f 5 f d f 5 f\n        f 4 f d f 4 f . . f 5 f d f 5 f\n        f 4 f f f 4 f . . f 5 f f f 5 f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f 4 f 4 f 4 f . . f 5 f 5 f 5 f\n        f 4 4 4 4 4 f . . f 5 5 5 5 5 f\n        f f f f f f f . . f f f f f f f\n        `;\n\n    enum Mode {\n        Diagnostics,\n        Packets,\n        Devices\n    }\n\n    class DebugMenu {\n        private started: boolean;\n        private mode: Mode;\n        private consoleVisible: boolean;\n        private debugFont: image.Font;\n        private marginx: number;\n        private marginy: number;\n        private debuggerService: jacdac.DebuggerService;\n        private hideControl: boolean\n\n        constructor() {\n            this.debugFont = image.font5;\n            this.marginy = 2;\n            this.marginx = 4;\n            this.mode = Mode.Diagnostics;\n            this.hideControl = false;\n            this.consoleVisible = game.consoleOverlay.isVisible();\n            jacdac.registerDebugViews();\n            this.debuggerService = new jacdac.DebuggerService();\n            this.debuggerService.paintPacket = (packet: DebuggerStruct) => {\n                if (packet.pkt.device_address == 0 && this.hideControl)\n                    return;\n\n                if (this.mode == Mode.Packets)\n                    console.log(`${packet.pkt.device_address}[${(packet.view) ? packet.view.name : \"??\"}]: ${(packet.view) ? packet.view.renderPacket(packet.pkt) : packet.pkt.data.toHex()}`)\n            }\n\n            this.debuggerService.paintDevices = (devices: JDDevice[]) => {\n                if (this.mode == Mode.Devices) {\n                    game.consoleOverlay.clear();\n                    console.log(`${devices.length} device(s)`)\n                    console.log(`-----------------------`);\n                    devices.forEach(d => {\n                        let serviceString = \"\"\n                        for (let s of d.services) {\n                            const view = DebugView.find(s.service_class);\n                            serviceString += ((view) ? view.name : s.service_class.toString()) + \" \";\n                        }\n\n                        console.log(`id: ${d.device_name || d.udid.toHex()}\\r\\naddress: ${d.device_address}\\r\\n\\tServices\\r\\n\\t----\\r\\n\\t${serviceString}`)\n                        console.log(`-----------------------`);\n                    });\n                    console.log(\"\");\n                }\n            }\n        }\n\n        makeDiagnostic(label:string, value:string, horizontalOffset: number, color: number, barHeight: number)\n        {\n            const charCount = Math.max(value.length, label.length)\n            let size = this.debugFont.charWidth * charCount + this.marginx\n            screen.fillRect(horizontalOffset,screen.height - barHeight,size, barHeight,color);\n\n            screen.print(label, (this.marginx / 2) + horizontalOffset, screen.height - barHeight + this.marginy, 1, this.debugFont);\n            screen.print(value, (this.marginx / 2) + horizontalOffset, screen.height - (this.debugFont.charHeight + (2 * this.marginy)), 1, this.debugFont);\n\n            horizontalOffset += size + 1\n\n            return horizontalOffset;\n        }\n\n        paintDiagnosticsBar(){\n            if (this.mode != Mode.Diagnostics)\n                return 0;\n            const diag = jacdac.diagnostics();\n            let background = 1\n            if (diag.bus_state)\n                background = 2\n            const height = 2 * (this.debugFont.charHeight + (2 * this.marginy))\n            screen.fillRect(0, screen.height - height, screen.width, height, background);\n            const errorCount = diag.bus_lo_error + diag.bus_uart_error + diag.bus_timeout_error;\n\n            let horiz = 1;\n            horiz = this.makeDiagnostic(\"TX\", diag.packets_sent.toString(), horiz, 6, height);\n            horiz = this.makeDiagnostic(\"RX\", diag.packets_received.toString(), horiz, 7, height);\n            horiz = this.makeDiagnostic(\"DR\", diag.packets_dropped.toString(),horiz, 2, height);\n            horiz = this.makeDiagnostic(\"ERR\", errorCount.toString(),horiz, 2, height);\n\n            return height\n        }\n\n        stop() {\n            if (!this.started) return;\n            this.started = false;\n\n            game.popScene();\n            game.consoleOverlay.setVisible(false);\n\n            controller._setUserEventsEnabled(true);\n        }\n\n        start() {\n            game.pushScene();\n            controller._setUserEventsEnabled(false);\n            game.onShade(() => {\n                this.paintDiagnosticsBar();\n            });\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.mode = Mode.Packets;\n                game.consoleOverlay.clear();\n            })\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.mode = Mode.Devices;\n                game.consoleOverlay.clear();\n            })\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.mode = Mode.Diagnostics;\n                game.consoleOverlay.clear();\n                console.log(`jacdac dashboard`);\n                console.log(` LEFT for packets`)\n                console.log(` RIGHT for devices`)\n                console.log(` B for exit`)\n            })\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.hideControl = !this.hideControl;\n            })\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                // done\n                if (_menu) {\n                    _menu.stop();\n                    _menu = undefined;\n                }\n            })\n\n            game.consoleOverlay.setVisible(true);\n            console.log(`jacdac dashboard`);\n            console.log(` LEFT for packets`)\n            console.log(` RIGHT for devices`)\n            console.log(` UP for diagnostics`)\n            console.log(` DOWN to hide control packets`)\n            console.log(` B for exit`)\n        }\n    }\n\n    let _menu: DebugMenu;\n    /**\n     * Shows a basic debugger interface\n     */\n    export function show() {\n        if (_menu)\n            _menu.stop();\n        _menu = new DebugMenu();\n        _menu.start();\n    }\n\n    scene.systemMenu.addEntry(\n        () => \"jacdac dashboard\",\n        show, JACDAC_DEBUG_ICON);\n\n    scene.systemMenu.addEntry(\n        () => jacdac.consoleService().consoleMode == JDConsoleMode.Listen ? \"hide jacdac console\" : \"show jacdac console\",\n        () => {\n            if (jacdac.consoleService().consoleMode == JDConsoleMode.Listen) {\n                game.consoleOverlay.setVisible(false);\n                jacdac.consoleService().consoleMode = JDConsoleMode.Off;\n            }\n            else {\n                game.consoleOverlay.setVisible(true);\n                jacdac.consoleService().consoleMode = JDConsoleMode.Listen;\n                console.log(`listening to jacdac...`);\n            }\n        },\n        JACDAC_CONSOLE_ICON\n    );\n}\n",
            "pxt.json": "{\n  \"name\": \"jacdac-game\",\n  \"description\": \"JacDac services for games - beta\",\n  \"files\": [\n    \"debugger.ts\",\n    \"controllerservice.ts\"\n  ],\n  \"testFiles\": [],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "power": {
            "power.ts": "/**\n * Power and sleep management\n */\n//% advanced=true icon=\"\\uf011\" color=\"#898989\"\n//% weight=1 blockGap=8\nnamespace power {\n    let _poked: number;\n    let _timeout: number;\n\n    /**\n     * Set the no-activity duration after which the device should go to deep sleep.\n     * @param seconds duration in seconds until the device should be put in lower power mode\n     */\n    //% blockId=powersetdeepsleeptimout block=\"power set deep sleep timeout to %seconds s\"\n    //% seconds.defl=60\n    //% help=/power/set-deep-sleep-timeout\n    export function setDeepSleepTimeout(seconds: number) {\n        init();\n        _timeout = seconds * 1000;\n    }\n\n    /**\n     * Poke the activity watcher to keep the device awake.\n     */\n    //% blockId=powerpke block=\"power poke\"\n    //% help=/power/poke\n    export function poke() {\n        init();\n        _poked = control.millis();\n    }\n\n    /**\n     * Check if the device has had any \"pokes\" and needs to go into deep sleep mode.\n     */\n    //% blockId=powercheckdeepsleep block=\"power check deep sleep\"\n    //% help=/power/check-deep-sleep\n    export function checkDeepSleep() {\n        init();\n        const p = _poked || 0;\n        const to = _timeout || 0;\n        if (to > 0 && \n            control.millis() - p > to &&\n            !control.isUSBInitialized()) {\n            // going to deep sleep\n            deepSleep();\n        }\n    }\n\n    /**\n     * Put the device into a deep sleep state.\n     */\n    //% blockId=powerdeepsleep block=\"power deep sleep\"\n    //% shim=pxt::deepSleep\n    //% help=/power/deep-sleep\n    export function deepSleep() {\n    }\n\n    function init() {\n        if (_timeout !== undefined) return;\n\n        // read default value\n        _timeout = control.getConfigValue(DAL.CFG_POWER_DEEPSLEEP_TIMEOUT, -1) * 1000;\n        // ensure deepsleep is long enough\n        const minDeepSleepTimeout = 300000;\n        if (_timeout > 0 && _timeout < minDeepSleepTimeout)\n            _timeout = minDeepSleepTimeout;\n    }\n}\n",
            "pxt.json": "{\n  \"name\": \"power\",\n  \"description\": \"Power and sleep management\",\n  \"files\": [\n    \"power.ts\"\n  ],\n  \"testFiles\": [],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "controller": {
            "README.md": "# Controller\n\nExtra features for Aracde controllers\n",
            "accelerometer.ts": "enum ControllerGesture {\n    /**\n     * Shake gesture\n     */\n    //% block=\"shake\"\n    Shake = 11,  // ACCELEROMETER_EVT_SHAKE\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = 1,  // ACCELEROMETER_EVT_TILT_UP\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = 2,  // ACCELEROMETER_EVT_TILT_DOWN\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = 3,  // ACCELEROMETER_EVT_TILT_LEFT\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = 4,  // ACCELEROMETER_EVT_TILT_RIGHT\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"screen up\"\n    ScreenUp = 5,  // ACCELEROMETER_EVT_FACE_UP\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"screen down\"\n    ScreenDown = 6,  // ACCELEROMETER_EVT_FACE_DOWN\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = 12,  // ACCELEROMETER_EVT_2G\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = 8,  // ACCELEROMETER_EVT_3G\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = 9,  // ACCELEROMETER_EVT_6G\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = 10,  // ACCELEROMETER_EVT_8G\n}\n\nenum ControllerDimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n}\n\nnamespace controller {\n    /**\n     * Do something when a gesture happens (like shaking the board).\n     * @param gesture the type of gesture to track\n     * @param body code to run when gesture is raised\n     */\n    //% blockId=ctrlongesture block=\"on |%NAME\"\n    //% parts=\"accelerometer\"\n    //% gesture.fieldEditor=\"gridpicker\"\n    //% gesture.fieldOptions.width=220\n    //% gesture.fieldOptions.columns=3\n    //% group=\"Extras\"\n    export function onGesture(gesture: ControllerGesture, handler: () => void) {\n        controller.__internal.onGesture(gesture, handler);\n    }\n\n    /**\n     * Register a customer gesture for the controller\n     * @param id \n     * @param update\n     * @param handler\n     */\n    export function onCustomGesture(id: number, update: () => boolean, handler: () => void) {\n        controller.__internal.onCustomGesture(id, update, handler);\n    }\n\n    /**\n     * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n     * x=0, y=0 and z=-1023)\n     * @param dimension the axis along which the acceleration if measured\n     */\n    //% blockId=ctrlaccelerationvalue block=\"acceleration (mg)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% dimension.fieldEditor=\"gridpicker\"\n    //% dimension.fieldOptions.width=180\n    //% dimension.fieldOptions.columns=2\n    //% group=\"Extras\"\n    export function acceleration(dimension: ControllerDimension): number {\n        return controller.__internal.acceleration(dimension);\n    }\n}",
            "controller.ts": "namespace controller {\n    /**\n     * Configures the timing of the on button repeat event for all of the controller buttons\n     * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n     * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n     */\n    //% blockId=repeatDefaultDelayInterval block=\"set button repeat delay $delay ms interval $interval ms\"\n    //% weight=10\n    //% group=\"Single Player\"\n    export function configureRepeatEventDefaults(delay: number, interval: number) {\n        controller.setRepeatDefault(delay, interval);\n    }\n}",
            "controllerimpl.ts": "namespace controller.__internal {\n    export function onGesture(gesture: ControllerGesture, handler: () => void) {\n        const state = sceneState();\n        if (!state.gestureHandlers) state.gestureHandlers = {};\n        state.gestureHandlers[gesture] = handler;\n\n        input.onGesture(<Gesture><number>gesture, function () {\n            const st = sceneState();\n            st.lastGesture = gesture;\n        })\n    }\n\n    export function onCustomGesture(id: number, update: () => boolean, handler: () => void) {\n        const state = sceneState();\n        if (!state.customGestureHandlers) state.customGestureHandlers = {};\n        state.customGestureHandlers[id] = <CustomGestureHandler>{ update, handler };\n\n        input.onCustomGesture(id,\n            function () {\n                const st = sceneState();\n                const h = st.customGestureHandlers && st.customGestureHandlers[id];\n                return h && h.update();\n            }, function () {\n                const st = sceneState();\n                st.lastCustomGesture = id;\n            })\n    }\n\n    export function acceleration(dimension: ControllerDimension): number {\n        return input.acceleration(<Dimension><number>dimension);\n    }\n}\n\nnamespace controller {\n    /**\n     * Configures the pins used by the crank\n     * @param pinA \n     * @param pinB \n     */\n    //% blockId=controller_crank_setpins block=\"set crank pinA $pinA pin B $pinB\"\n    //% weight=28 blockGap=8\n    //% group=\"Extras\"\n    export function setCrankPins(pinA: DigitalInOutPin, pinB: DigitalInOutPin) {\n        controller.__internal.setCrankPins(pinA, pinB);\n    }\n}\n\nnamespace controller.__internal {\n    let crankEncoder: RotaryEncoder;\n    export function crankPosition(): number {\n        const crank = crankEncoder || encoders.defaultEncoder;\n        return crank ? crank.position() : 0;\n    }\n\n    export function setCrankPins(pinA: DigitalInOutPin, pinB: DigitalInOutPin) {\n        crankEncoder = encoders.createRotaryEncoder(pinA, pinB);\n    }\n}\n\nnamespace controller {\n    /**\n     * Shows an animation on the controller lights\n     * @param animation \n     * @param duration \n     */\n    //% blockId=controller_show_animation block=\"start light animation %animation=light_animation_picker|for %duration=timePicker|ms\"\n    //% weight=30 blockGap=8\n    //% group=\"Extras\"\n    export function startLightAnimation(animation: light.NeoPixelAnimation, duration: number) {\n        controller.__internal.startLightAnimation(animation, duration);\n    }\n}\n\nnamespace controller.__internal {\n    const ANIM_KEY = \"ctrllightanim\";\n    const ANIM_TIME_KEY = \"ctrllightanimend\";\n\n    export function startLightAnimation(animation: light.NeoPixelAnimation, duration: number) {\n        if (duration <= 0) return;\n\n        const strip = light.onboardStrip();\n        if (!strip || !strip.length()) return;\n\n        const scene = game.currentScene();\n        let anim = scene.data[ANIM_KEY] as light.NeoPixelAnimation;\n        // schedule animation\n        if (anim === undefined) { // undefined means the game.update hasn't been registered\n            strip.setBuffered(true);\n            game.onUpdateInterval(50, renderLightFrame);\n        }\n\n        // don't blind users\n        strip.stopBrightnessTransition();\n        const brightess = control.getConfigValue(DAL.CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS, 32);\n        strip.setBrightness(brightess);\n        // record data for animation\n        scene.data[ANIM_KEY] = animation;\n        scene.data[ANIM_TIME_KEY] = game.runtime() + duration;\n    }\n\n    export function startLightPulse(rgb: number, duration: number) {\n        if (duration <= 0) return;\n\n        const strip = light.onboardStrip();\n        if (!strip || !strip.length()) return;\n\n        const scene = game.currentScene();\n        let anim = scene.data[ANIM_KEY] as light.NeoPixelAnimation;\n        if (anim)\n            scene.data[ANIM_KEY] = null; // stop any running animation\n\n        // start a brightness transition\n        const brightess = control.getConfigValue(DAL.CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS, 8);\n        strip.setBrightness(0);\n        strip.setAll(rgb);\n        strip.startBrightnessTransition(0, brightess, duration, 2, true);\n    }\n\n    function renderLightFrame() {\n        const scene = game.currentScene();\n        if (!scene) return;\n\n        // anything to animate?\n        let anim = scene.data[ANIM_KEY] as light.NeoPixelAnimation;\n        if (!anim) return;\n\n        // expired?\n        let animend = scene.data[ANIM_TIME_KEY] || 0;\n        if (game.runtime() > animend) { // invalidate key\n            anim = scene.data[ANIM_KEY] = null; // make sure to use null\n        }\n\n        const strip = light.onboardStrip();\n        if (anim)\n            strip.showAnimationFrame(anim);\n        else\n            strip.clear();\n        strip.show();\n    }\n}\n\nnamespace controller.__internal {\n    export function lightLevel(): number {\n        return input.lightLevel();\n    }\n\n\n    export function onLightConditionChanged(condition: ControllerLightCondition, handler: () => void): void {\n        const state = sceneState();\n        if (!state.lightHandlers) state.lightHandlers = {};\n        state.lightHandlers[condition] = handler;\n        input.onLightConditionChanged(<LightCondition><number>condition, function () {\n            const st = sceneState();\n            st.lastLightCondition = condition;\n        })\n    }\n}\n\nnamespace controller.__internal {\n    export function temperature(unit: ControllerTemperatureUnit): number {\n        return input.temperature(<TemperatureUnit><number>unit);\n    }\n}\n\nnamespace controller.__internal {\n    let vibrationPin: DigitalInOutPin;\n    let vibrationEnd: number;\n\n    function updateVibration() {\n        // turn off vibration if needed\n        if (vibrationEnd > 0 && vibrationEnd < control.millis()) {\n            if (vibrationPin)\n                vibrationPin.digitalWrite(false);\n            vibrationEnd = -1;\n        }\n    }\n\n    function initVibration(s: scene.Scene) {\n        if (!vibrationPin)\n            vibrationPin = pins.pinByCfg(DAL.CFG_PIN_VIBRATION);\n        vibrationEnd = -1;\n        s.eventContext.registerFrameHandler(scene.UPDATE_PRIORITY, updateVibration);\n    }\n\n    export function vibrate(millis: number) {\n        const off = vibrationEnd <= 0;\n        vibrationEnd = millis <= 0 ? -1 : (control.millis() + Math.min(3000, millis));\n        if (off) {\n            if (vibrationPin)\n                vibrationPin.digitalWrite(true);\n        }\n    }\n\n    scene.Scene.initializers.push(initVibration);\n}",
            "crank.ts": "namespace controller {\n    /**\n     * Gets the current position of the crank.\n     */\n    //% blockId=controller_crank_position block=\"crank position\"\n    //% weight=29 blockGap=8\n    //% group=\"Extras\"\n    export function crankPosition(): number {\n        return controller.__internal.crankPosition();\n    }\n}\n",
            "light.ts": "namespace controller {\n    /**\n     * Shows a color pulse\n     * @param rgb RGB color of the LED\n     */\n    //% blockId=\"ctrllightpulse\" block=\"start light pulse %rgb=colorNumberPicker|for %duration=timePicker|ms\"\n    //% weight=80 blockGap=8\n    //% group=\"Extras\"\n    export function startLightPulse(rgb: number, duration: number) {\n        controller.__internal.startLightPulse(rgb, duration);\n    }\n}\n\n//% advanced=true\nnamespace light {\n\n}",
            "lightsensor.ts": "enum ControllerLightCondition {\n    //% block=\"dark\"\n    Dark = 1,  // SENSOR_THRESHOLD_LOW\n    //% block=\"bright\"\n    Bright = 2,  // SENSOR_THRESHOLD_HIGH\n}\n\nnamespace controller {\n    /**\n     * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n     */\n    //% blockId=ctrllightlevel block=\"light level\"\n    //% parts=\"lightsensor\"\n    //% weight=30 blockGap=8\n    //% group=\"Extras\"\n    export function lightLevel(): number {\n        return controller.__internal.lightLevel();\n    }\n\n\n    /**\n     * Register an event that runs when light conditions (darker or brighter) change.\n     * @param condition the condition that event triggers on\n     */\n    //% blockId=ctrlonlightcondition block=\"on light %condition\"\n    //% parts=\"lightsensor\"\n    //% weight=84 blockGap=12\n    //% group=\"Extras\"\n    export function onLightConditionChanged(condition: ControllerLightCondition, handler: () => void): void {\n        controller.__internal.onLightConditionChanged(condition, handler);\n    } \n}",
            "pxt.json": "{\n  \"weight\": 99,\n  \"name\": \"controller\",\n  \"description\": \"Extra game controller functionalities\",\n  \"files\": [\n    \"README.md\",\n    \"state.ts\",\n    \"vibration.ts\",\n    \"accelerometer.ts\",\n    \"lightsensor.ts\",\n    \"thermometer.ts\",\n    \"controller.ts\",\n    \"light.ts\",\n    \"crank.ts\",\n    \"controllerimpl.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"accelerometer\": \"*\",\n    \"lightsensor\": \"*\",\n    \"thermometer\": \"*\",\n    \"game\": \"*\",\n    \"light\": \"*\",\n    \"rotary-encoder\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/f2a7258a9398a8be904c4188e4fad2794b31c256/static/libs/controller.png\"\n}",
            "state.ts": "namespace controller {\n    export interface ControllerSceneState {\n        lastGesture?: ControllerGesture;\n        gestureHandlers?: any;\n        lastCustomGesture?: number;\n        customGestureHandlers?: any;\n        lastLightCondition?: ControllerLightCondition;\n        lightHandlers?: any;\n    }\n\n    export interface CustomGestureHandler {\n        update: () => boolean;\n        handler: () => void;\n    }\n\n    export function sceneState(): ControllerSceneState {\n        const sc = game.currentScene();\n        let state = sc.data[\"controller.state\"];\n        if (!state) {\n            state = sc.data[\"controller.state\"] = <ControllerSceneState>{\n            };\n        }\n        return state;\n    }\n\n\n    function updateController() {\n        const state = sceneState();\n        // accelerometer\n        if (state.lastGesture !== undefined) {\n            const handler = state.gestureHandlers && state.gestureHandlers[state.lastGesture];\n            if (handler) {\n                state.lastGesture = undefined;\n                handler();\n            }\n        }\n        if (state.lastCustomGesture !== undefined) {\n            const customHandler = state.customGestureHandlers && state.customGestureHandlers[state.lastCustomGesture] as CustomGestureHandler;\n            if (customHandler) {\n                state.lastCustomGesture = undefined;\n                customHandler.handler();\n            }\n        }\n\n        // light sensor\n        if (state.lightHandlers\n            && state.lastLightCondition !== undefined\n            && state.lightHandlers[state.lastLightCondition]) {\n            const handler = state.lightHandlers[state.lastLightCondition];\n            state.lastLightCondition = undefined;\n            handler();\n        }\n    }\n\n    function initController(s: scene.Scene) {\n        s.eventContext.registerFrameHandler(scene.UPDATE_CONTROLLER_PRIORITY, updateController);\n    }\n\n    scene.Scene.initializers.push(initController);\n}",
            "thermometer.ts": "const enum ControllerTemperatureUnit {\n    //% block=\"°C\"\n    Celsius = 0,\n    //% block=\"°F\"\n    Fahrenheit = 1,\n}\n\n\nnamespace controller {\n    /**\n     * Get the temperature in Celsius or Fahrenheit degrees.\n     */\n    //% blockId=ctrltemperature block=\"temperature in %unit\"\n    //% parts=\"thermometer\"\n    //% weight=26\n    //% group=\"Extras\"\n    export function temperature(unit: ControllerTemperatureUnit): number {\n        return controller.__internal.temperature(unit);\n    }\n}",
            "vibration.ts": "namespace controller {\n    /**\n     * Vibrates the controller for the given duration (in milli seconds)\n     * @param millis \n     */\n    //% blockId=ctrlvibrate block=\"vibrate $millis ms\"\n    //% millis.shadow=timePicker\n    //% group=\"Extras\"\n    export function vibrate(millis: number) {\n        controller.__internal.vibrate(millis);\n    }\n}"
        },
        "controller---none": {
            "README.md": "# Controller\n\nExtra features for Aracde controllers\n",
            "accelerometer.ts": "enum ControllerGesture {\n    /**\n     * Shake gesture\n     */\n    //% block=\"shake\"\n    Shake = 11,  // ACCELEROMETER_EVT_SHAKE\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = 1,  // ACCELEROMETER_EVT_TILT_UP\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = 2,  // ACCELEROMETER_EVT_TILT_DOWN\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = 3,  // ACCELEROMETER_EVT_TILT_LEFT\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = 4,  // ACCELEROMETER_EVT_TILT_RIGHT\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"screen up\"\n    ScreenUp = 5,  // ACCELEROMETER_EVT_FACE_UP\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"screen down\"\n    ScreenDown = 6,  // ACCELEROMETER_EVT_FACE_DOWN\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = 12,  // ACCELEROMETER_EVT_2G\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = 8,  // ACCELEROMETER_EVT_3G\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = 9,  // ACCELEROMETER_EVT_6G\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = 10,  // ACCELEROMETER_EVT_8G\n}\n\nenum ControllerDimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n}\n\nnamespace controller {\n    /**\n     * Do something when a gesture happens (like shaking the board).\n     * @param gesture the type of gesture to track\n     * @param body code to run when gesture is raised\n     */\n    //% blockId=ctrlongesture block=\"on |%NAME\"\n    //% parts=\"accelerometer\"\n    //% gesture.fieldEditor=\"gridpicker\"\n    //% gesture.fieldOptions.width=220\n    //% gesture.fieldOptions.columns=3\n    //% group=\"Extras\"\n    export function onGesture(gesture: ControllerGesture, handler: () => void) {\n        controller.__internal.onGesture(gesture, handler);\n    }\n\n    /**\n     * Register a customer gesture for the controller\n     * @param id \n     * @param update\n     * @param handler\n     */\n    export function onCustomGesture(id: number, update: () => boolean, handler: () => void) {\n        controller.__internal.onCustomGesture(id, update, handler);\n    }\n\n    /**\n     * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n     * x=0, y=0 and z=-1023)\n     * @param dimension the axis along which the acceleration if measured\n     */\n    //% blockId=ctrlaccelerationvalue block=\"acceleration (mg)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% dimension.fieldEditor=\"gridpicker\"\n    //% dimension.fieldOptions.width=180\n    //% dimension.fieldOptions.columns=2\n    //% group=\"Extras\"\n    export function acceleration(dimension: ControllerDimension): number {\n        return controller.__internal.acceleration(dimension);\n    }\n}",
            "controller.ts": "namespace controller {\n    /**\n     * Configures the timing of the on button repeat event for all of the controller buttons\n     * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n     * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n     */\n    //% blockId=repeatDefaultDelayInterval block=\"set button repeat delay $delay ms interval $interval ms\"\n    //% weight=10\n    //% group=\"Single Player\"\n    export function configureRepeatEventDefaults(delay: number, interval: number) {\n        controller.setRepeatDefault(delay, interval);\n    }\n}",
            "controllerimpl.ts": "namespace controller.__internal {\n    export function onGesture(gesture: ControllerGesture, handler: () => void) {\n    }\n\n    export function onCustomGesture(id: number, update: () => boolean, handler: () => void) {\n    }\n\n    export function acceleration(dimension: ControllerDimension): number {\n        return 0;\n    }\n}\n\nnamespace controller.__internal {\n    export function crankPosition(): number {\n        return 0;\n    }\n\n    //export function setCrankPins(pinA: DigitalInOutPin, pinB: DigitalInOutPin) {\n    //}\n}\n\nnamespace controller.__internal {\n    //export function startLightAnimation(animation: light.NeoPixelAnimation, duration: number) {\n    //}\n\n    export function startLightPulse(rgb: number, duration: number) {\n    }\n}\n\nnamespace controller.__internal {\n    export function lightLevel(): number {\n        return 0;\n    }\n\n\n    export function onLightConditionChanged(condition: ControllerLightCondition, handler: () => void): void {\n    }\n}\n\nnamespace controller.__internal {\n    export function temperature(unit: ControllerTemperatureUnit): number {\n        return 0;\n    }\n}\n\nnamespace controller.__internal {\n    export function vibrate(millis: number) {\n    }\n}",
            "crank.ts": "namespace controller {\n    /**\n     * Gets the current position of the crank.\n     */\n    //% blockId=controller_crank_position block=\"crank position\"\n    //% weight=29 blockGap=8\n    //% group=\"Extras\"\n    export function crankPosition(): number {\n        return controller.__internal.crankPosition();\n    }\n}\n",
            "light.ts": "namespace controller {\n    /**\n     * Shows a color pulse\n     * @param rgb RGB color of the LED\n     */\n    //% blockId=\"ctrllightpulse\" block=\"start light pulse %rgb=colorNumberPicker|for %duration=timePicker|ms\"\n    //% weight=80 blockGap=8\n    //% group=\"Extras\"\n    export function startLightPulse(rgb: number, duration: number) {\n        controller.__internal.startLightPulse(rgb, duration);\n    }\n}\n\n//% advanced=true\nnamespace light {\n\n}",
            "lightsensor.ts": "enum ControllerLightCondition {\n    //% block=\"dark\"\n    Dark = 1,  // SENSOR_THRESHOLD_LOW\n    //% block=\"bright\"\n    Bright = 2,  // SENSOR_THRESHOLD_HIGH\n}\n\nnamespace controller {\n    /**\n     * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n     */\n    //% blockId=ctrllightlevel block=\"light level\"\n    //% parts=\"lightsensor\"\n    //% weight=30 blockGap=8\n    //% group=\"Extras\"\n    export function lightLevel(): number {\n        return controller.__internal.lightLevel();\n    }\n\n\n    /**\n     * Register an event that runs when light conditions (darker or brighter) change.\n     * @param condition the condition that event triggers on\n     */\n    //% blockId=ctrlonlightcondition block=\"on light %condition\"\n    //% parts=\"lightsensor\"\n    //% weight=84 blockGap=12\n    //% group=\"Extras\"\n    export function onLightConditionChanged(condition: ControllerLightCondition, handler: () => void): void {\n        controller.__internal.onLightConditionChanged(condition, handler);\n    } \n}",
            "pxt.json": "{\n  \"name\": \"controller---none\",\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"game\": \"*\"\n  },\n  \"description\": \"Extra game controller functionalities\",\n  \"files\": [\n    \"README.md\",\n    \"state.ts\",\n    \"vibration.ts\",\n    \"accelerometer.ts\",\n    \"lightsensor.ts\",\n    \"thermometer.ts\",\n    \"controller.ts\",\n    \"light.ts\",\n    \"crank.ts\",\n    \"controllerimpl.ts\"\n  ],\n  \"public\": true,\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "state.ts": "namespace controller {\n    export interface ControllerSceneState {\n        lastGesture?: ControllerGesture;\n        gestureHandlers?: any;\n        lastCustomGesture?: number;\n        customGestureHandlers?: any;\n        lastLightCondition?: ControllerLightCondition;\n        lightHandlers?: any;\n    }\n\n    export interface CustomGestureHandler {\n        update: () => boolean;\n        handler: () => void;\n    }\n\n    export function sceneState(): ControllerSceneState {\n        const sc = game.currentScene();\n        let state = sc.data[\"controller.state\"];\n        if (!state) {\n            state = sc.data[\"controller.state\"] = <ControllerSceneState>{\n            };\n        }\n        return state;\n    }\n\n\n    function updateController() {\n        const state = sceneState();\n        // accelerometer\n        if (state.lastGesture !== undefined) {\n            const handler = state.gestureHandlers && state.gestureHandlers[state.lastGesture];\n            if (handler) {\n                state.lastGesture = undefined;\n                handler();\n            }\n        }\n        if (state.lastCustomGesture !== undefined) {\n            const customHandler = state.customGestureHandlers && state.customGestureHandlers[state.lastCustomGesture] as CustomGestureHandler;\n            if (customHandler) {\n                state.lastCustomGesture = undefined;\n                customHandler.handler();\n            }\n        }\n\n        // light sensor\n        if (state.lightHandlers\n            && state.lastLightCondition !== undefined\n            && state.lightHandlers[state.lastLightCondition]) {\n            const handler = state.lightHandlers[state.lastLightCondition];\n            state.lastLightCondition = undefined;\n            handler();\n        }\n    }\n\n    function initController(s: scene.Scene) {\n        s.eventContext.registerFrameHandler(scene.UPDATE_CONTROLLER_PRIORITY, updateController);\n    }\n\n    scene.Scene.initializers.push(initController);\n}",
            "thermometer.ts": "const enum ControllerTemperatureUnit {\n    //% block=\"°C\"\n    Celsius = 0,\n    //% block=\"°F\"\n    Fahrenheit = 1,\n}\n\n\nnamespace controller {\n    /**\n     * Get the temperature in Celsius or Fahrenheit degrees.\n     */\n    //% blockId=ctrltemperature block=\"temperature in %unit\"\n    //% parts=\"thermometer\"\n    //% weight=26\n    //% group=\"Extras\"\n    export function temperature(unit: ControllerTemperatureUnit): number {\n        return controller.__internal.temperature(unit);\n    }\n}",
            "vibration.ts": "namespace controller {\n    /**\n     * Vibrates the controller for the given duration (in milli seconds)\n     * @param millis \n     */\n    //% blockId=ctrlvibrate block=\"vibrate $millis ms\"\n    //% millis.shadow=timePicker\n    //% group=\"Extras\"\n    export function vibrate(millis: number) {\n        controller.__internal.vibrate(millis);\n    }\n}"
        },
        "edge-connector": {
            "README.md": "# Edge connector\n\nSupport for 20 pin edge connector.\n\n## Config\n\nPin mapping must be specified in config key section.",
            "device.d.ts": "declare namespace pins {\n    /**\n     * Pin P0 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P0)\n    const P0: PwmPin;\n\n    /**\n     * Pin P1 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P1)\n    const P1: PwmPin;\n\n    /**\n     * Pin P2 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P2)\n    const P2: PwmPin;\n\n    /**\n     * Pin P3 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P3)\n    const P3: AnalogInPin;\n\n    /**\n     * Pin P3 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P4)\n    const P4: AnalogInPin;\n\n    /**\n     * Pin P5 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P5)\n    const P5: DigitalInOutPin;\n\n    /**\n     * Pin P6 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P6)\n    const P6: DigitalInOutPin;\n\n    /**\n     * Pin P7 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P7)\n    const P7: DigitalInOutPin;\n\n    /**\n     * Pin P8 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P8)\n    const P8: DigitalInOutPin;\n\n    /**\n     * Pin P9 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P9)\n    const P9: DigitalInOutPin;\n\n    /**\n     * Pin P10 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P10)\n    const P10: AnalogInPin;\n\n    /**\n     * Pin P11 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P11)\n    const P11: DigitalInOutPin;\n\n    /**\n     * Pin P12 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P12)\n    const P12: DigitalInOutPin;\n\n    /**\n     * Pin P13 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P13)\n    const P13: DigitalInOutPin;\n\n    /**\n     * Pin P14 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P14)\n    const P14: DigitalInOutPin;\n\n    /**\n     * Pin P15 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P15)\n    const P15: DigitalInOutPin;\n\n    /**\n     * Pin P16 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P16)\n    const P16: PwmPin;\n\n    /**\n     * Pin P19 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P19)\n    const P19: DigitalInOutPin;\n\n    /**\n     * Pin P20 on the edge connector\n     */\n    //% fixedInstance shim=pxt::lookupPinCfg(CFG_PIN_P20)\n    const P20: DigitalInOutPin;\n}\n",
            "pinscompat.ts": "// this type alias is required for backward compatibility\n// it gets overriden in microbit (DigitalPin is an enum over there)\nenum DigitalPin {\n    P0 = DAL.CFG_PIN_P0,\n    P1 = DAL.CFG_PIN_P1,\n    P2 = DAL.CFG_PIN_P2,\n    P3 = DAL.CFG_PIN_P3,\n    P4 = DAL.CFG_PIN_P4,\n    P5 = DAL.CFG_PIN_P5,\n    P6 = DAL.CFG_PIN_P6,\n    P7 = DAL.CFG_PIN_P7,\n    P8 = DAL.CFG_PIN_P8,\n    P9 = DAL.CFG_PIN_P9,\n    P10 = DAL.CFG_PIN_P10,\n    P11 = DAL.CFG_PIN_P11,\n    P12 = DAL.CFG_PIN_P12,\n    P13 = DAL.CFG_PIN_P13,\n    P14 = DAL.CFG_PIN_P14,\n    P15 = DAL.CFG_PIN_P15,\n    P16 = DAL.CFG_PIN_P16,\n    P19 = DAL.CFG_PIN_P19,\n    P20 = DAL.CFG_PIN_P20\n}\n\nenum AnalogPin {\n    P0 = DAL.CFG_PIN_P0,\n    P1 = DAL.CFG_PIN_P1,\n    P2 = DAL.CFG_PIN_P2,\n    P3 = DAL.CFG_PIN_P3,\n    P4 = DAL.CFG_PIN_P4,\n    P10 = DAL.CFG_PIN_P10,\n    P5 = DAL.CFG_PIN_P5,\n    P6 = DAL.CFG_PIN_P6,\n    P7 = DAL.CFG_PIN_P7,\n    P8 = DAL.CFG_PIN_P8,\n    P9 = DAL.CFG_PIN_P9,\n    P11 = DAL.CFG_PIN_P11,\n    P12 = DAL.CFG_PIN_P12,\n    P13 = DAL.CFG_PIN_P13,\n    P14 = DAL.CFG_PIN_P14,\n    P15 = DAL.CFG_PIN_P15,\n    P16 = DAL.CFG_PIN_P16,\n    P19 = DAL.CFG_PIN_P19,\n    P20 = DAL.CFG_PIN_P20\n}\n\nnamespace pins {\n    /**\n     * Sets the pin pull\n     * @param pin \n     * @param mode \n     */\n    //% deprecated=1\n    export function setPull(pin: DigitalPin, mode: PinPullMode) {\n        const p = pins.pinByCfg(pin);\n        if (p)\n            p.setPull(mode);\n    }\n\n    /**\n     * Sets the digital pin status\n     * @param pin\n     * @param value \n     */\n    //% deprecated=1\n    export function digitalWritePin(pin: DigitalPin, value: number) {\n        const p = pins.pinByCfg(pin);\n        if (p)\n            p.digitalWrite(!!value);\n    }\n\n    /**\n     * Reads the pin status\n     * @param pin \n     */\n    //% deprecated=1\n    export function digitalReadPin(pin: DigitalPin): number {\n        const p = pins.pinByCfg(pin);\n        return p && p.digitalRead() ? 1 : 0;\n    }\n\n    /**\n     * Sets the digital pin status\n     * @param pin \n     * @param value \n     */\n    //% deprecated=1\n    export function analogWritePin(pin: AnalogPin, value: number) {\n        const p = pins.pinByCfg(pin) as AnalogOutPin;\n        if (p)\n            p.analogWrite(value);\n    }\n\n    /**\n     * Reads the pin status\n     * @param pin \n     */\n    //% deprecated=1\n    export function analogReadPin(pin: AnalogPin): number {\n        const p = pins.pinByCfg(pin) as AnalogInPin;\n        if (p)\n            return p.analogRead();\n        else \n            return 0;\n    }\n\n    /**\n    * Make this pin a digital input, and create events where the timestamp is the duration\n    * that this pin was either ``high`` or ``low``.\n    */\n    //% deprecated=1\n    export function onPulsed(pin: DigitalPin, pulse: PulseValue, body: () => void): void {\n        const p = pins.pinByCfg(pin);\n        if (p)\n            p.onPulsed(pulse, body);\n    }\n\n    /**\n    * Register code to run when a pin event occurs. \n    */\n    //% deprecated=1\n    export function onEvent(pin: DigitalPin, event: PinEvent, body: () => void): void {\n        const p = pins.pinByCfg(pin);\n        if (p)\n            p.onEvent(event, body);\n    }\n\n    /**\n    * Return the duration of a pulse in microseconds\n    * @param name the pin which measures the pulse\n    * @param value the value of the pulse (default high)\n    * @param maximum duration in micro-seconds\n    */\n    //% deprecated=1\n    export function pulseIn(pin: DigitalPin, value: PulseValue, maxDuration?: number): number {\n        const p = pins.pinByCfg(pin);\n        if (p)\n            return p.pulseIn(value, maxDuration);\n        else \n            return 0;\n    }\n\n    export function map(value: number, fromLow: number, fromHigh: number, toLow: number, toHigh: number): number {\n        return Math.map(value, fromLow, fromHigh, toLow, toHigh);\n    }\n}",
            "pxt.json": "{\n  \"requiredCategories\": [\n    \"pins\"\n  ],\n  \"name\": \"edge-connector\",\n  \"description\": \"20 pin Edge Connector\",\n  \"files\": [\n    \"README.md\",\n    \"device.d.ts\",\n    \"pinscompat.ts\"\n  ],\n  \"public\": true,\n  \"hidden\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/a6ed99808384f0beb9f13ab494675dbb7f5ae5e6/static/libs/edge-connector.png\"\n}"
        },
        "esp32spi": {
            "README.md": "# WiFi\n\n## ESP32 SPI\n\nPorted from Adafruit Circuit Python \nhttps://github.com/adafruit/Adafruit_CircuitPython_ESP32SPI.",
            "esp32spi.ts": "namespace esp32spi {\n    export function monotonic(): number {\n        return control.millis() / 1000.0;\n    }\n\n    export function print(msg: string) {\n        console.log(msg);\n    }\n    \n    export class AccessPoint {\n        rssi: number;\n        encryption: number;\n        constructor(public ssid: string) { }\n    }\n\n    // pylint: disable=bad-whitespace\n    const _SET_NET_CMD = 0x10\n    const _SET_PASSPHRASE_CMD = 0x11\n    const _SET_DEBUG_CMD = 0x1A\n    const _GET_TEMP_CMD = 0x1B\n    const _GET_CONN_STATUS_CMD = 0x20\n    const _GET_IPADDR_CMD = 0x21\n    const _GET_MACADDR_CMD = 0x22\n    const _GET_CURR_SSID_CMD = 0x23\n    const _GET_CURR_RSSI_CMD = 0x25\n    const _GET_CURR_ENCT_CMD = 0x26\n    const _SCAN_NETWORKS = 0x27\n    const _GET_SOCKET_CMD = 0x3F\n    const _GET_STATE_TCP_CMD = 0x29\n    const _DATA_SENT_TCP_CMD = 0x2A\n    const _AVAIL_DATA_TCP_CMD = 0x2B\n    const _GET_DATA_TCP_CMD = 0x2C\n    const _START_CLIENT_TCP_CMD = 0x2D\n    const _STOP_CLIENT_TCP_CMD = 0x2E\n    const _GET_CLIENT_STATE_TCP_CMD = 0x2F\n    const _DISCONNECT_CMD = 0x30\n    const _GET_IDX_RSSI_CMD = 0x32\n    const _GET_IDX_ENCT_CMD = 0x33\n    const _REQ_HOST_BY_NAME_CMD = 0x34\n    const _GET_HOST_BY_NAME_CMD = 0x35\n    const _START_SCAN_NETWORKS = 0x36\n    const _GET_FW_VERSION_CMD = 0x37\n    const _PING_CMD = 0x3E\n    const _SEND_DATA_TCP_CMD = 0x44\n    const _GET_DATABUF_TCP_CMD = 0x45\n    const _SET_ENT_IDENT_CMD = 0x4A\n    const _SET_ENT_UNAME_CMD = 0x4B\n    const _SET_ENT_PASSWD_CMD = 0x4C\n    const _SET_ENT_ENABLE_CMD = 0x4F\n    const _SET_PIN_MODE_CMD = 0x50\n    const _SET_DIGITAL_WRITE_CMD = 0x51\n    const _SET_ANALOG_WRITE_CMD = 0x52\n    const _START_CMD = 0xE0\n    const _END_CMD = 0xEE\n    const _ERR_CMD = 0xEF\n    const _REPLY_FLAG = 1 << 7\n    const _CMD_FLAG = 0\n    export const SOCKET_CLOSED = 0\n    export const SOCKET_LISTEN = 1\n    export const SOCKET_SYN_SENT = 2\n    export const SOCKET_SYN_RCVD = 3\n    export const SOCKET_ESTABLISHED = 4\n    export const SOCKET_FIN_WAIT_1 = 5\n    export const SOCKET_FIN_WAIT_2 = 6\n    export const SOCKET_CLOSE_WAIT = 7\n    export const SOCKET_CLOSING = 8\n    export const SOCKET_LAST_ACK = 9\n    export const SOCKET_TIME_WAIT = 10\n    export const WL_NO_SHIELD = 0xFF\n    export const WL_NO_MODULE = 0xFF\n    export const WL_IDLE_STATUS = 0\n    export const WL_NO_SSID_AVAIL = 1\n    export const WL_SCAN_COMPLETED = 2\n    export const WL_CONNECTED = 3\n    export const WL_CONNECT_FAILED = 4\n    export const WL_CONNECTION_LOST = 5\n    export const WL_DISCONNECTED = 6\n    export const WL_AP_LISTENING = 7\n    export const WL_AP_CONNECTED = 8\n    export const WL_AP_FAILED = 9\n\n    export const TCP_MODE = 0\n    export const UDP_MODE = 1\n    export const TLS_MODE = 2\n\n\n    function buffer1(ch: number) {\n        const b = control.createBuffer(1)\n        b[0] = ch\n        return b\n    }\n\n    export class SPIController {\n        private _socknum_ll: Buffer[];\n        private _locked: boolean;\n\n        static instance: SPIController;\n\n        public wasConnected: boolean;\n\n        constructor(\n            private _spi: SPI,\n            private _cs: DigitalInOutPin,\n            private _busy: DigitalInOutPin,\n            private _reset: DigitalInOutPin,\n            private _gpio0: DigitalInOutPin = null,\n            public debug = 0\n        ) {\n            // if nothing connected, pretend the device is ready -\n            // we'll check for timeout waiting for response instead\n            this._busy.setPull(PinPullMode.PullDown);\n            this._busy.digitalRead();\n            this._socknum_ll = [buffer1(0)]\n            SPIController.instance = this;\n            this._spi.setFrequency(8000000);\n            this.reset();\n            this._locked = false;\n        }\n\n        private log(priority: number, msg: string) {\n            if (priority < this.debug)\n                console.log(msg);\n        }\n\n        private fail(msg: string) {\n            control.fail(msg)\n        }\n\n        /** \n         * Hard reset the ESP32 using the reset pin \n        */\n        public reset(): void {\n            if (this._gpio0)\n                this._gpio0.digitalWrite(true);\n            this._cs.digitalWrite(true)\n            this._reset.digitalWrite(false)\n            // reset\n            pause(10)\n            this._reset.digitalWrite(true)\n            // wait for it to boot up\n            pause(750)\n            if (this._gpio0)\n                this._gpio0.digitalRead();\n            this.log(0, 'reseted esp32')\n        }\n\n        private readByte(): number {\n            const r = buffer1(0)\n            this.spiTransfer(null, r)\n            return r[0]\n        }\n\n        private checkData(desired: number, msg?: string): boolean {\n            const r = this.readByte()\n            if (r != desired)\n                this.fail(`Expected ${desired} but got ${r}; ` + (msg || \"\"))\n            return false;\n        }\n\n        /** Read a byte with a time-out, and if we get it, check that its what we expect */\n        private waitSPIChar(desired: number): boolean {\n            let times = control.millis()\n            while (control.millis() - times < 100) {\n                let r = this.readByte()\n                if (r == _ERR_CMD) {\n                    this.log(0, \"error response to command\")\n                    return false\n                }\n\n                if (r == desired) {\n                    return true\n                }\n                //this.log(0, `read char ${r}, expected ${desired}`)\n            }\n            this.log(0, \"timed out waiting for SPI char\")\n            return false;\n        }\n\n        /**\n         * Wait until the ready pin goes low\n         */\n        private waitForReady() {\n            this.log(1, `wait for ready ${this._busy.digitalRead()}`);\n            if (this._busy.digitalRead()) {\n                pauseUntil(() => !this._busy.digitalRead(), 10000);\n                this.log(1, `busy = ${this._busy.digitalRead()}`);\n                // pause(1000)\n            }\n            if (this._busy.digitalRead()) {\n                this.log(0, \"timed out waiting for ready\")\n                return false\n            }\n\n            return true\n        }\n\n        private _sendCommand(cmd: number, params?: Buffer[], param_len_16?: boolean) {\n            params = params || [];\n\n            // compute buffer size\n            let n = 3; // START_CMD, cmd, length\n            params.forEach(param => {\n                n += 1 + (param_len_16 ? 1 : 0) + param.length;\n            })\n            n += 1; // END_CMD\n            // padding\n            while (n % 4) n++;\n\n            const packet = control.createBuffer(n);\n            let k = 0;\n            packet[k++] = _START_CMD;\n            packet[k++] = cmd & ~_REPLY_FLAG;\n            packet[k++] = params.length;\n\n            params.forEach(param => {\n                if (param_len_16)\n                    packet[k++] = (param.length >> 8) & 0xFF;\n                packet[k++] = param.length & 0xFF;\n                packet.write(k, param);\n                k += param.length;\n            })\n            packet[k++] = _END_CMD;\n            while (k < n)\n                packet[k++] = 0xff;\n\n            if (this.debug > 1)\n                console.log(`send cmd ${packet.toHex()}`)\n            if (!this.waitForReady())\n                return false\n            this._cs.digitalWrite(false)\n            this.spiTransfer(packet, null)\n            this._cs.digitalWrite(true)\n            this.log(1, `send done`);\n            return true\n        }\n\n        private spiTransfer(tx: Buffer, rx: Buffer) {\n            if (!tx) tx = control.createBuffer(rx.length)\n            if (!rx) rx = control.createBuffer(tx.length)\n            this._spi.transfer(tx, rx);\n        }\n\n        private _waitResponseCmd(cmd: number, num_responses?: number, param_len_16?: boolean) {\n            this.log(1, `wait response cmd`);\n            if (!this.waitForReady())\n                return null\n\n            this._cs.digitalWrite(false)\n\n            let responses: Buffer[] = []\n            if (!this.waitSPIChar(_START_CMD)) {\n                this._cs.digitalWrite(true)\n                return null\n            }\n            this.checkData(cmd | _REPLY_FLAG)\n            if (num_responses !== undefined)\n                this.checkData(num_responses, cmd + \"\")\n            else\n                num_responses = this.readByte();\n            for (let num = 0; num < num_responses; ++num) {\n                let param_len = this.readByte()\n                if (param_len_16) {\n                    param_len <<= 8\n                    param_len |= this.readByte()\n                }\n                this.log(1, `\\tParameter #${num} length is ${param_len}`)\n                const response = control.createBuffer(param_len);\n                this.spiTransfer(null, response)\n                responses.push(response);\n            }\n            this.checkData(_END_CMD);\n\n            this._cs.digitalWrite(true)\n\n            this.log(1, `responses ${responses.length}`);\n            return responses;\n        }\n\n        private lock() {\n            while (this._locked) {\n                pauseUntil(() => !this._locked)\n            }\n            this._locked = true\n        }\n\n        private unlock() {\n            if (!this._locked)\n                this.fail(\"not locked!\")\n            this._locked = false;\n        }\n\n        private sendCommandGetResponse(cmd: number, params?: Buffer[],\n            reply_params = 1, sent_param_len_16 = false, recv_param_len_16 = false) {\n\n            this.lock()\n            this._sendCommand(cmd, params, sent_param_len_16)\n            const resp = this._waitResponseCmd(cmd, reply_params, recv_param_len_16)\n            this.unlock();\n            return resp\n        }\n\n        get status(): number {\n            const resp = this.sendCommandGetResponse(_GET_CONN_STATUS_CMD)\n            if (!resp)\n                return WL_NO_SHIELD\n            this.log(0, `Status: ${resp[0][0]}`);\n            // one byte response\n            return resp[0][0];\n        }\n\n        /** A string of the firmware version on the ESP32 */\n        get firmwareVersion(): string {\n            let resp = this.sendCommandGetResponse(_GET_FW_VERSION_CMD)\n            if (!resp)\n                return \"not connected\"\n            return resp[0].toString();\n        }\n\n        /** A bytearray containing the MAC address of the ESP32 */\n        get MACaddress(): Buffer {\n            let resp = this.sendCommandGetResponse(_GET_MACADDR_CMD, [hex`ff`])\n            if (!resp)\n                return null\n            // for whatever reason, the mac adderss is backwards\n            const res = control.createBuffer(6)\n            for (let i = 0; i < 6; ++i)\n                res[i] = resp[0][5 - i]\n            return res\n        }\n\n        /** Begin a scan of visible access points. Follow up with a call\n    to 'get_scan_networks' for response\n*/\n        private startScanNetworks(): void {\n            let resp = this.sendCommandGetResponse(_START_SCAN_NETWORKS)\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to start AP scan\")\n            }\n\n        }\n\n        /** The results of the latest SSID scan. Returns a list of dictionaries with\n    'ssid', 'rssi' and 'encryption' entries, one for each AP found\n*/\n        private getScanNetworks(): AccessPoint[] {\n            let names = this.sendCommandGetResponse(_SCAN_NETWORKS, undefined, undefined)\n            // print(\"SSID names:\", names)\n            // pylint: disable=invalid-name\n            let APs = []\n            let i = 0\n            for (let name of names) {\n                let a_p = new AccessPoint(name.toString())\n                let rssi = this.sendCommandGetResponse(_GET_IDX_RSSI_CMD, [buffer1(i)])[0]\n                a_p.rssi = pins.unpackBuffer(\"<i\", rssi)[0]\n                let encr = this.sendCommandGetResponse(_GET_IDX_ENCT_CMD, [buffer1(1)])[0]\n                a_p.encryption = encr[0]\n                APs.push(a_p)\n                i++\n            }\n            return APs\n        }\n\n        /** Scan for visible access points, returns a list of access point details.\n     Returns a list of dictionaries with 'ssid', 'rssi' and 'encryption' entries,\n     one for each AP found\n    */\n        public scanNetworks(): AccessPoint[] {\n            this.startScanNetworks()\n            // attempts\n            for (let _ = 0; _ < 10; ++_) {\n                pause(2000)\n                // pylint: disable=invalid-name\n                let APs = this.getScanNetworks()\n                if (APs) {\n                    return APs\n                }\n\n            }\n            return null\n        }\n\n        /** Tells the ESP32 to set the access point to the given ssid */\n        public wifiSetNetwork(ssid: string): void {\n            const ssidbuf = control.createBufferFromUTF8(ssid);\n            let resp = this.sendCommandGetResponse(_SET_NET_CMD, [ssidbuf])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set network\")\n            }\n\n        }\n\n        /** Sets the desired access point ssid and passphrase */\n        public wifiSetPassphrase(ssid: string, passphrase: string): void {\n            const ssidbuf = control.createBufferFromUTF8(ssid);\n            const passphrasebuf = control.createBufferFromUTF8(passphrase);\n            let resp = this.sendCommandGetResponse(_SET_PASSPHRASE_CMD, [ssidbuf, passphrasebuf])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set passphrase\")\n            }\n        }\n\n        /** Sets the WPA2 Enterprise anonymous identity */\n        public wifiSetEntidentity(ident: string): void {\n            const ssidbuf = control.createBufferFromUTF8(ident);\n            let resp = this.sendCommandGetResponse(_SET_ENT_IDENT_CMD, [ssidbuf])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set enterprise anonymous identity\")\n            }\n\n        }\n\n        /** Sets the desired WPA2 Enterprise username */\n        public wifiSetEntusername(username: string): void {\n            const usernamebuf = control.createBufferFromUTF8(username);\n            let resp = this.sendCommandGetResponse(_SET_ENT_UNAME_CMD, [usernamebuf])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set enterprise username\")\n            }\n\n        }\n\n        /** Sets the desired WPA2 Enterprise password */\n        public wifiSetEntpassword(password: string): void {\n            const passwordbuf = control.createBufferFromUTF8(password);\n            let resp = this.sendCommandGetResponse(_SET_ENT_PASSWD_CMD, [passwordbuf])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set enterprise password\")\n            }\n\n        }\n\n        /** Enables WPA2 Enterprise mode */\n        public wifiSetEntenable(): void {\n            let resp = this.sendCommandGetResponse(_SET_ENT_ENABLE_CMD)\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to enable enterprise mode\")\n            }\n\n        }\n\n\n        get ssid(): Buffer {\n            let resp = this.sendCommandGetResponse(_GET_CURR_SSID_CMD, [hex`ff`])\n            return resp[0]\n        }\n\n        get rssi(): number {\n            let resp = this.sendCommandGetResponse(_GET_CURR_RSSI_CMD, [hex`ff`])\n            return pins.unpackBuffer(\"<i\", resp[0])[0]\n        }\n\n        get networkData(): any {\n            let resp = this.sendCommandGetResponse(_GET_IPADDR_CMD, [hex`ff`])\n            return resp[0]; //?\n        }\n\n        get ipAddress(): string {\n            return this.networkData[\"ip_addr\"]\n        }\n\n        get isConnected(): boolean {\n            return this.status == WL_CONNECTED\n        }\n\n        /** Connect to an access point using a secrets dictionary\n    that contains a 'ssid' and 'password' entry\n    */\n        public connect(secrets: any): void {\n            this.connectAP(secrets[\"ssid\"], secrets[\"password\"])\n        }\n\n        /** Connect to an access point with given name and password.\n    Will retry up to 10 times and return on success\n    */\n        public connectAP(ssid: string, password: string): number {\n            this.log(0, `Connect to AP ${ssid}`)\n            if (password) {\n                this.wifiSetPassphrase(ssid, password)\n            } else {\n                this.wifiSetNetwork(ssid)\n            }\n\n            // retries\n            let stat;\n            for (let _ = 0; _ < 10; ++_) {\n                stat = this.status\n                if (stat == WL_CONNECTED) {\n                    this.wasConnected = true;\n                    return stat;\n                }\n                pause(1000)\n            }\n            if ([WL_CONNECT_FAILED, WL_CONNECTION_LOST, WL_DISCONNECTED].indexOf(stat) >= 0) {\n                this.log(1, `Failed to connect to \"${ssid}\" (${stat})`)\n            }\n\n            if (stat == WL_NO_SSID_AVAIL) {\n                this.log(1, `No such ssid: \"${ssid}\"`)\n            }\n\n            return stat;\n        }\n\n        /** \n         * Convert a hostname to a packed 4-byte IP address. Returns\n    a 4 bytearray\n    */\n        public hostbyName(hostname: string): Buffer {\n            let resp = this.sendCommandGetResponse(_REQ_HOST_BY_NAME_CMD, [control.createBufferFromUTF8(hostname)])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to request hostname\")\n            }\n\n            resp = this.sendCommandGetResponse(_GET_HOST_BY_NAME_CMD)\n            return resp[0];\n        }\n\n        /** Ping a destination IP address or hostname, with a max time-to-live\n    (ttl). Returns a millisecond timing value\n    */\n        public ping(dest: string, ttl: number = 250): number {\n            if (!this.wasConnected)\n                return -1\n\n            // convert to IP address\n            let ip = this.hostbyName(dest)\n\n            // ttl must be between 0 and 255\n            ttl = Math.max(0, Math.min(ttl | 0, 255))\n            let resp = this.sendCommandGetResponse(_PING_CMD, [ip, buffer1(ttl)])\n            return pins.unpackBuffer(\"<H\", resp[0])[0];\n        }\n\n        /** Request a socket from the ESP32, will allocate and return a number that\n    can then be passed to the other socket commands\n    */\n        public socket(): number {\n            this.log(0, \"*** Get socket\")\n\n            let resp0 = this.sendCommandGetResponse(_GET_SOCKET_CMD)\n            let resp = resp0[0][0]\n            if (resp == 255) {\n                this.fail(\"No sockets available\")\n            }\n\n            if (this.debug) {\n                // %d\" % resp)\n                print(\"Allocated socket #\" + resp)\n            }\n\n            return resp\n        }\n\n        /** Open a socket to a destination IP address or hostname\n    using the ESP32's internal reference number. By default we use\n    'conn_mode' TCP_MODE but can also use UDP_MODE or TLS_MODE\n    (dest must be hostname for TLS_MODE!)\n    */\n        public socketOpen(socket_num: number, dest: Buffer | string, port: number, conn_mode = TCP_MODE): void {\n            this._socknum_ll[0][0] = socket_num\n            if (this.debug) {\n                print(\"*** Open socket: \" + dest + \":\" + port)\n            }\n\n            let port_param = pins.packBuffer(\">H\", [port])\n            let resp: Buffer[]\n            // use the 5 arg version\n            if (typeof dest == \"string\") {\n                const dest2 = control.createBufferFromUTF8(dest)\n                resp = this.sendCommandGetResponse(_START_CLIENT_TCP_CMD, [dest2, hex`00000000`, port_param, this._socknum_ll[0], buffer1(conn_mode)])\n            } else {\n                // ip address, use 4 arg vesion\n                resp = this.sendCommandGetResponse(_START_CLIENT_TCP_CMD, [dest, port_param, this._socknum_ll[0], buffer1(conn_mode)])\n            }\n\n            if (resp[0][0] != 1) {\n                this.fail(\"Could not connect to remote server\")\n            }\n\n        }\n\n        /** Get the socket connection status, can be SOCKET_CLOSED, SOCKET_LISTEN,\n    SOCKET_SYN_SENT, SOCKET_SYN_RCVD, SOCKET_ESTABLISHED, SOCKET_FIN_WAIT_1,\n    SOCKET_FIN_WAIT_2, SOCKET_CLOSE_WAIT, SOCKET_CLOSING, SOCKET_LAST_ACK, or\n    SOCKET_TIME_WAIT\n    */\n        public socketStatus(socket_num: number): number {\n            this._socknum_ll[0][0] = socket_num\n            let resp = this.sendCommandGetResponse(_GET_CLIENT_STATE_TCP_CMD, this._socknum_ll)\n            return resp[0][0]\n        }\n\n        /** Test if a socket is connected to the destination, returns boolean true/false */\n        public socket_connected(socket_num: number): boolean {\n            return this.socketStatus(socket_num) == SOCKET_ESTABLISHED\n        }\n\n        /** Write the bytearray buffer to a socket */\n        public socketWrite(socket_num: number, buffer: Buffer): void {\n            if (this.debug > 1) {\n                print(\"Writing:\" + buffer.length)\n            }\n\n            this._socknum_ll[0][0] = socket_num\n            let resp = this.sendCommandGetResponse(_SEND_DATA_TCP_CMD, [this._socknum_ll[0], buffer], 1, true)\n            let sent = resp[0].getNumber(NumberFormat.UInt16LE, 0)\n            if (sent != buffer.length) {\n                this.fail(`Failed to send ${buffer.length} bytes (sent ${sent})`)\n            }\n\n            resp = this.sendCommandGetResponse(_DATA_SENT_TCP_CMD, this._socknum_ll)\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to verify data sent\")\n            }\n\n        }\n\n        /** Determine how many bytes are waiting to be read on the socket */\n        public socketAvailable(socket_num: number): number {\n            this._socknum_ll[0][0] = socket_num\n            let resp = this.sendCommandGetResponse(_AVAIL_DATA_TCP_CMD, this._socknum_ll)\n            let reply = pins.unpackBuffer(\"<H\", resp[0])[0]\n            this.log(1, `ESPSocket: ${reply} bytes available`)\n            return reply\n        }\n\n        /** Read up to 'size' bytes from the socket number. Returns a bytearray */\n        public socketRead(socket_num: number, size: number): Buffer {\n            this.log(1, `Reading ${size} bytes from ESP socket with status ${this.socketStatus(socket_num)}`)\n            this._socknum_ll[0][0] = socket_num\n            let resp = this.sendCommandGetResponse(_GET_DATABUF_TCP_CMD,\n                [this._socknum_ll[0], pins.packBuffer(\"<H\", [size])],\n                1, true, true)\n            if (this.debug >= 2)\n                this.log(2, `buf >>${resp[0].toString()}<<`)\n            return resp[0]\n        }\n\n        /** Open and verify we connected a socket to a destination IP address or hostname\n    using the ESP32's internal reference number. By default we use\n    'conn_mode' TCP_MODE but can also use UDP_MODE or TLS_MODE (dest must\n    be hostname for TLS_MODE!)\n    */\n        public socketConnect(socket_num: number, dest: string | Buffer, port: number, conn_mode = TCP_MODE): boolean {\n            if (this.debug) {\n                print(\"*** Socket connect mode \" + conn_mode)\n            }\n\n            this.socketOpen(socket_num, dest, port, conn_mode)\n            let times = monotonic()\n            // wait 3 seconds\n            while (monotonic() - times < 3) {\n                if (this.socket_connected(socket_num)) {\n                    return true\n                }\n\n                pause(10)\n            }\n            this.fail(\"Failed to establish connection\")\n            return false\n        }\n\n        /** Close a socket using the ESP32's internal reference number */\n        public socketClose(socket_num: number): void {\n            if (this.debug) {\n                // %d\" % socket_num)\n                print(\"*** Closing socket #\" + socket_num)\n            }\n\n            this._socknum_ll[0][0] = socket_num\n            let resp = this.sendCommandGetResponse(_STOP_CLIENT_TCP_CMD, this._socknum_ll)\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to close socket\")\n            }\n\n        }\n\n        /** Enable/disable debug mode on the ESP32. Debug messages will be\n    written to the ESP32's UART.\n    */\n        public setESPdebug(enabled: boolean) {\n            let resp = this.sendCommandGetResponse(_SET_DEBUG_CMD, [buffer1(enabled ? 1 : 0)])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set debug mode\")\n            }\n        }\n\n        public getTemperature() {\n            let resp = this.sendCommandGetResponse(_GET_TEMP_CMD, [])\n            if (resp[0].length != 4) {\n                this.fail(\"Failed to get temp\")\n            }\n            return resp[0].getNumber(NumberFormat.Float32LE, 0)\n        }\n\n        /** \n    Set the io mode for a GPIO pin.\n    \n    :param int pin: ESP32 GPIO pin to set.\n    :param value: direction for pin, digitalio.Direction or integer (0=input, 1=output).\n     \n    */\n        public setPinMode(pin: number, pin_mode: number): void {\n\n            let resp = this.sendCommandGetResponse(_SET_PIN_MODE_CMD, [buffer1(pin), buffer1(pin_mode)])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to set pin mode\")\n            }\n\n        }\n\n        /** \n    Set the digital output value of pin.\n    \n    :param int pin: ESP32 GPIO pin to write to.\n    :param bool value: Value for the pin.\n     \n    */\n        public setDigitalWrite(pin: number, value: number): void {\n            let resp = this.sendCommandGetResponse(_SET_DIGITAL_WRITE_CMD, [buffer1(pin), buffer1(value)])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to write to pin\")\n            }\n\n        }\n\n        /** \n    Set the analog output value of pin, using PWM.\n    \n    :param int pin: ESP32 GPIO pin to write to.\n    :param float value: 0=off 1.0=full on\n     \n    */\n        public setAnalogWrite(pin: number, analog_value: number) {\n            let value = Math.trunc(255 * analog_value)\n            let resp = this.sendCommandGetResponse(_SET_ANALOG_WRITE_CMD, [buffer1(pin), buffer1(value)])\n            if (resp[0][0] != 1) {\n                this.fail(\"Failed to write to pin\")\n            }\n\n        }\n    }\n\n    //% shim=esp32spi::flashDevice\n    export function flashDevice() {\n        return\n    }\n}",
            "net.ts": "namespace esp32spi {\n    export class Net extends net.Net {\n        constructor() {\n            super();\n        }\n\n        createSocket(host: string, port: number): net.Socket {\n            const socket = new Socket(host, port);\n            return socket;\n        }\n    }\n\n    export class NetTLS extends net.Net {\n        constructor() {\n            super();\n        }\n\n        createSocket(host: string, port: number): net.Socket {\n            const socket = new Socket(host, port, TLS_MODE);\n            return socket;\n        }\n    }\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"esp32spi\",\n  \"description\": \"ESP32 over SPI - beta\",\n  \"files\": [\n    \"esp32spi.ts\",\n    \"socket.ts\",\n    \"requests.ts\",\n    \"wifimanager.ts\",\n    \"net.ts\",\n    \"README.md\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"net\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "requests.ts": "namespace esp32spi {\n    export class Response {\n        socket: Socket\n        _cached: Buffer\n        status_code: number\n        reason: string\n        _read_so_far: number\n        headers: StringMap\n\n        /** The response from a request, contains all the headers/content */\n        constructor(sock: Socket) {\n            this.socket = sock\n            this._cached = null\n            this.status_code = null\n            this.reason = null\n            this._read_so_far = 0\n            this.headers = {}\n        }\n\n        public close() {\n            /** Close, delete and collect the response data */\n            if (this.socket) {\n                this.socket.close()\n                this.socket = null\n            }\n            this._cached = null\n        }\n\n        get content() {\n            /** The HTTP content direct from the socket, as bytes */\n            let content_length = parseInt(this.headers[\"content-length\"]) || 0\n\n            // print(\"Content length:\", content_length)\n            if (this._cached === null) {\n                this._cached = this.socket.read(content_length)\n                this.socket.close()\n                this.socket = null\n            }\n\n            // print(\"Buffer length:\", len(self._cached))\n            return this._cached\n        }\n\n        /** The HTTP content, encoded into a string according to the HTTP\n    header encoding\n*/\n        get text() {\n            return this.content.toString()\n        }\n\n        get json() {\n            return JSON.parse(this.text)\n        }\n\n        public toString() {\n            return `HTTP ${this.status_code}; ${Object.keys(this.headers).length} headers; ${this._cached ? this._cached.length : -1} bytes content`\n        }\n    }\n\n    export type StringMap = { [v: string]: string; };\n\n    export interface RequestOptions {\n        data?: string | Buffer;\n        json?: any; // will call JSON.stringify()\n        headers?: StringMap;\n        stream?: boolean;\n        timeout?: number; // in ms\n    }\n\n    export function dataAsBuffer(data: string | Buffer): Buffer {\n        if (data == null)\n            return null\n        if (typeof data == \"string\")\n            return control.createBufferFromUTF8(data)\n        return data\n    }\n\n    // TODO move to PXT\n    // also note this doesn't handle unicode, but neither does JS (there's toLocaleLowerCase())\n    export function toLowerCase(s: string) {\n        let r = \"\"\n        let prev = 0\n        for (let i = 0; i < s.length; i++) {\n            const c = s.charCodeAt(i)\n            if (65 <= c && c <= 90) {\n                r += s.slice(prev, i) + String.fromCharCode(c + 32)\n                prev = i + 1\n            }\n        }\n        r += s.slice(prev)\n        return r\n    }\n\n    /*\n    >>> \"a,b,c,d,e\".split(\",\", 2)\n    ['a', 'b', 'c,d,e']\n    */\n    function pysplit(str: string, sep:string, limit: number) {\n        const arr = str.split(sep)\n        if (arr.length >= limit) {\n            return arr.slice(0, limit).concat([arr.slice(limit).join(sep)])\n        } else {\n            return arr\n        }\n    }\n\n\n    /** Perform an HTTP request to the given url which we will parse to determine\nwhether to use SSL ('https://') or not. We can also send some provided 'data'\nor a json dictionary which we will stringify. 'headers' is optional HTTP headers\nsent along. 'stream' will determine if we buffer everything, or whether to only\nread only when requested\n \n*/\n    export function request(method: string, url: string, options?: RequestOptions): Response {\n        if (!options) options = {};\n        if (!options.headers) {\n            options.headers = {}\n        }\n\n        const tmp = pysplit(url, \"/\", 3)\n        let proto = tmp[0]\n        let host = tmp[2]\n        let path = tmp[3] || \"\"\n        // replace spaces in path\n        // TODO\n        // path = path.replace(\" \", \"%20\")\n\n        let port = 0\n        if (proto == \"http:\") {\n            port = 80\n        } else if (proto == \"https:\") {\n            port = 443\n        } else {\n            control.fail(\"Unsupported protocol: \" + proto)\n        }\n\n        if (host.indexOf(\":\") >= 0) {\n            const tmp = host.split(\":\")\n            host = tmp[0]\n            port = parseInt(tmp[1])\n        }\n\n        let ipaddr = esp32spi.SPIController.instance.hostbyName(host)\n\n        let sock: Socket;\n        let conntype = esp32spi.TCP_MODE\n        if (proto == \"https:\") {\n            conntype = esp32spi.TLS_MODE\n            // for SSL we need to know the host name\n            sock = new Socket(host, port, conntype)\n        } else {\n            sock = new Socket(ipaddr, port, conntype)\n        }\n        // our response\n        let resp = new Response(sock)\n        // socket read timeout\n        sock.setTimeout(options.timeout)\n\n        sock.connect();\n        sock.send(`${method} /${path} HTTP/1.0\\r\\n`)\n\n        if (!options.headers[\"Host\"])\n            sock.send(`Host: ${host}\\r\\n`)\n\n        if (!options.headers[\"User-Agent\"])\n            sock.send(\"User-Agent: MakeCode ESP32\\r\\n\")\n\n        // Iterate over keys to avoid tuple alloc\n        for (let k of Object.keys(options.headers))\n            sock.send(`${k}: ${options.headers[k]}\\r\\n`)\n\n        if (options.json != null) {\n            control.assert(options.data == null, 100)\n            options.data = JSON.stringify(options.json)\n            sock.send(\"Content-Type: application/json\\r\\n\")\n        }\n\n        let dataBuf = dataAsBuffer(options.data)\n\n        if (dataBuf)\n            sock.send(`Content-Length: ${dataBuf.length}\\r\\n`)\n\n        sock.send(\"\\r\\n\")\n        if (dataBuf)\n            sock.send(dataBuf)\n\n        let line = sock.readLine()\n        // print(line)\n        let line2 = pysplit(line, \" \", 2)\n        let status = parseInt(line2[1])\n        let reason = \"\"\n        if (line2.length > 2) {\n            reason = line2[2]\n        }\n\n        while (true) {\n            line = sock.readLine()\n            if (!line || line == \"\\r\\n\") {\n                break\n            }\n\n            // print(\"**line: \", line)\n            const tmp = pysplit(line, \": \", 1)\n            let title = tmp[0]\n            let content = tmp[1]\n            if (title && content) {\n                resp.headers[toLowerCase(title)] = toLowerCase(content)\n            }\n        }\n\n        /*\n\nelif line.startswith(b\"Location:\") and not 200 <= status <= 299:\nraise NotImplementedError(\"Redirects not yet supported\")\n*/\n\n        if ((resp.headers[\"transfer-encoding\"] || \"\").indexOf(\"chunked\") >= 0)\n            control.fail(\"not supported chunked encoding\")\n\n        resp.status_code = status\n        resp.reason = reason\n        return resp\n    }\n\n    /** Send HTTP HEAD request */\n    export function head(url: string, options?: RequestOptions) {\n        return request(\"HEAD\", url, options)\n    }\n\n    /** Send HTTP GET request */\n    export function get(url: string, options?: RequestOptions) {\n        return request(\"GET\", url, options)\n    }\n\n    /** Send HTTP POST request */\n    export function post(url: string, options?: RequestOptions) {\n        return request(\"POST\", url, options)\n    }\n\n    /** Send HTTP PATCH request */\n    export function patch(url: string, options?: RequestOptions) {\n        return request(\"PATCH\", url, options)\n    }\n\n    /** Send HTTP PUT request */\n    export function put(url: string, options?: RequestOptions) {\n        return request(\"PUT\", url, options)\n    }\n\n    /** Send HTTP DELETE request */\n    export function del(url: string, options?: RequestOptions) {\n        return request(\"DELETE\", url, options)\n    }\n\n}\n",
            "socket.ts": "namespace esp32spi {\n\n    export const SOCK_STREAM = 1\n    export const AF_INET = 2\n    export const MAX_PACKET = 4000\n\n    export class Socket implements net.Socket {\n        _buffer: Buffer;\n        _socknum: number;\n        _timeout: number;\n        _closed: boolean;\n        _openHandler: () => void;\n        _closeHandler: () => void;\n        _errorHandler: (msg: string) => void;\n        _messageHandler: (data: Buffer) => void;\n\n        /** A simplified implementation of the Python 'socket' class, for connecting\n    through an interface to a remote device\n */\n        constructor(private host: string | Buffer, private port: number, private conntype: number = null) {\n            if (this.conntype === null) {\n                this.conntype = esp32spi.TCP_MODE\n            }\n            this._buffer = hex``\n            this._socknum = esp32spi.SPIController.instance.socket()\n            this.setTimeout(0)\n        }\n\n        /** Connect the socket to the 'address' (which can be 32bit packed IP or\n    a hostname string). 'conntype' is an extra that may indicate SSL or not,\n    depending on the underlying interface\n*/\n        public connect() {\n            if (!esp32spi.SPIController.instance.socketConnect(this._socknum, this.host, this.port, this.conntype)) {\n                this.error(`failed to connect to ${this.host}`)\n                return;\n            }\n\n            this._buffer = hex``\n\n            if (this._openHandler)\n                this._openHandler();\n        }\n\n        /** Send some data to the socket */\n        public send(data: string | Buffer) {\n            //console.log(\"sock wr: \" + data)\n            esp32spi.SPIController.instance.socketWrite(this._socknum, dataAsBuffer(data))\n        }\n\n        private error(msg: string) {\n            if (this._errorHandler)\n                this._errorHandler(msg)\n        }\n\n        onOpen(handler: () => void): void {\n            this._openHandler = handler;\n        }\n        onClose(handler: () => void): void {\n            this._closeHandler = handler;\n        }\n        onError(handler: (msg: string) => void): void {\n            this._errorHandler = handler;\n        }\n        onMessage(handler: (data: Buffer) => void): void {\n            if (this._messageHandler === undefined) {\n                control.runInParallel(() => {\n                    while (!this._closed) {\n                        let buf = this.read()\n                        if (buf.length) {\n                            if (this._messageHandler)\n                                this._messageHandler(buf)\n                        } else {\n                            pause(200)\n                        }\n                    }\n                })\n            }\n            this._messageHandler = handler || null;\n        }\n\n        /** Attempt to return as many bytes as we can up to but not including '\\r\\n' */\n        public readLine(): string {\n            // print(\"Socket readline\")\n            let stamp = monotonic()\n            while (this._buffer.indexOf(hex`0d0a`) < 0) {\n                // there's no line already in there, read some more\n                let avail = Math.min(esp32spi.SPIController.instance.socketAvailable(this._socknum), MAX_PACKET)\n                if (avail) {\n                    this._buffer = this._buffer.concat(esp32spi.SPIController.instance.socketRead(this._socknum, avail))\n                } else if (this._timeout > 0 && monotonic() - stamp > this._timeout) {\n                    // Make sure to close socket so that we don't exhaust sockets.\n                    this.close()\n                    control.fail(\"Didn't receive full response, failing out\")\n                }\n\n            }\n            const pos = this._buffer.indexOf(hex`0d0a`)\n            const pref = this._buffer.slice(0, pos)\n            this._buffer = this._buffer.slice(pos + 2)\n            // print(\"rd: \" + this._buffer.length + \" / \" + pref.length + \" :\" + pref.toString())\n            return pref.toString()\n        }\n\n        /** Read up to 'size' bytes from the socket, this may be buffered internally! If 'size' isnt specified, return everything in the buffer. */\n        public read(size: number = 0): Buffer {\n            // print(\"Socket read\", size)\n            if (size == 0) {\n                if (this._buffer.length == 0) {\n                    let avail = Math.min(esp32spi.SPIController.instance.socketAvailable(this._socknum), MAX_PACKET)\n                    if (avail)\n                        this._buffer = this._buffer.concat(esp32spi.SPIController.instance.socketRead(this._socknum, avail))\n                }\n                let ret = this._buffer\n                this._buffer = hex``\n                return ret\n            }\n\n            let stamp = monotonic()\n            let to_read = size - this._buffer.length\n            let received = []\n            while (to_read > 0) {\n                // print(\"Bytes to read:\", to_read)\n                let avail = Math.min(esp32spi.SPIController.instance.socketAvailable(this._socknum), MAX_PACKET)\n                if (avail) {\n                    stamp = monotonic()\n                    let recv = esp32spi.SPIController.instance.socketRead(this._socknum, Math.min(to_read, avail))\n                    received.push(recv)\n                    to_read -= recv.length\n                }\n\n                if (this._timeout > 0 && monotonic() - stamp > this._timeout) {\n                    break\n                }\n\n            }\n            // print(received)\n            received.unshift(this._buffer)\n            this._buffer = pins.concatBuffers(received)\n            let ret = null\n            if (this._buffer.length == size) {\n                ret = this._buffer\n                this._buffer = hex``\n            } else {\n                ret = this._buffer.slice(0, size)\n                this._buffer = this._buffer.slice(size)\n            }\n\n            return ret\n        }\n\n        /** Set the read timeout for sockets, if value is 0 it will block */\n        public setTimeout(value: number) {\n            this._timeout = value\n        }\n\n        /** Close the socket, after reading whatever remains */\n        public close() {\n            this._closed = true;\n            esp32spi.SPIController.instance.socketClose(this._socknum)\n            if (this._closeHandler)\n                this._closeHandler();\n        }\n    }\n}\n",
            "test.ts": "export interface Secrets {\n    connString: string;\n    wifi: pxt.StringMap;\n}\n// this is to be overridden in a separate file\nexport let secrets: Secrets;\nfunction test() {\n\n    const log = console.log;\n    const esp = new esp32spi.SPIController(pins.spi(),\n        pins.D13, pins.D11, pins.D12, pins.D10, 1)\n\n    if (esp.status != esp32spi.WL_IDLE_STATUS)\n        return\n\n    log(`Firmware vers. ${esp.firmwareVersion}`)\n    log(`MAC addr: ${esp.MACaddress.toHex()}`)\n    log(\"Temp: \" + esp.getTemperature())\n\n    const networks = esp.scanNetworks()\n\n    log(JSON.stringify(secrets.wifi))\n\n    for (const ap of networks)\n        log(`\\t${ap.ssid}\\t\\tRSSI: ${ap.rssi}`)\n\n    for (let k of Object.keys(secrets.wifi)) {\n        if (networks.some(n => n.ssid == k)) {\n            log(\"connecting to \" + k)\n            esp.connectAP(k, secrets.wifi[k])\n            break\n        }\n    }\n\n    if (!esp.isConnected) {\n        log(\"can't connect\")\n        return\n    }\n\n    log(\"ping: \" + esp.ping(\"bing.com\"))\n}\n\ntest();",
            "wifimanager.ts": "namespace esp32spi {\n\n    export class WiFiManager {\n        esp: SPIController;\n        debug: boolean;\n\n        constructor(\n            private ssid: string,\n            private password: string,\n            private statuspix: DigitalInOutPin = null,\n            private attempts: number = 2\n        ) {\n            this.esp = SPIController.instance;\n            this.debug = false\n            this.pixelStatus(0)\n        }\n\n        private pixelStatus(color: number) {\n            // TODO handle neopixels\n        }\n\n        /** \n         * Perform a hard reset on the ESP32 \n        */\n        public reset(): void {\n            if (this.debug) {\n                print(\"Resetting ESP32\")\n            }\n            this.esp.reset()\n        }\n\n        /** \n         * Attempt to connect to WiFi using the current settings \n         **/\n        public connect(): void {\n            if (this.debug) {\n                if (this.esp.status == esp32spi.WL_IDLE_STATUS) {\n                    print(\"ESP32 found and in idle mode\")\n                }\n                print(`Firmware vers. ${this.esp.firmwareVersion}`)\n                print(`MAC addr: ${this.esp.MACaddress.toHex()}`)\n                for (let access_pt of this.esp.scanNetworks()) {\n                    print(`\t${access_pt[\"ssid\"]}\t\tRSSI: ${access_pt[\"rssi\"]}`)\n                }\n            }\n\n            let failure_count = 0\n            while (!this.esp.isConnected) {\n                if (this.debug) {\n                    print(\"Connecting to AP...\")\n                }\n                this.pixelStatus(0xe00000)\n                const stat = this.esp.connectAP(this.ssid, this.password)\n                if (stat == esp32spi.WL_CONNECTED) {\n                    failure_count = 0\n                    this.pixelStatus(0x00e000)\n                } else {\n                    if (this.debug)\n                        print(`Failed to connect ${stat}, retrying`)\n                    failure_count += 1\n                    if (failure_count >= this.attempts) {\n                        failure_count = 0\n                        this.reset()\n                    }\n                }\n            }\n        }\n\n        /** \n    Pass the Get request to requests and update status LED\n \n    :param str url: The URL to retrieve data from\n    :param dict data: (Optional) Form data to submit\n    :param dict json: (Optional) JSON data to submit. (Data must be None)\n    :param dict header: (Optional) Header data to include\n    :param bool stream: (Optional) Whether to stream the Response\n    :return: The response from the request\n    :rtype: Response\n    \n*/\n        public get(url: string, options?: RequestOptions): Response {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            let return_val = esp32spi.get(url, options)\n            this.pixelStatus(0)\n            return return_val\n        }\n\n        /** \n    Pass the Post request to requests and update status LED\n \n    :param str url: The URL to post data to\n    :param dict data: (Optional) Form data to submit\n    :param dict json: (Optional) JSON data to submit. (Data must be None)\n    :param dict header: (Optional) Header data to include\n    :param bool stream: (Optional) Whether to stream the Response\n    :return: The response from the request\n    :rtype: Response\n    \n*/\n        public post(url: string, options?: RequestOptions): Response {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            if (this.debug)\n                print(`post ${url}`);\n            let return_val = esp32spi.post(url, options)\n            this.pixelStatus(0)\n            return return_val;\n        }\n\n        /** \n    Pass the put request to requests and update status LED\n \n    :param str url: The URL to PUT data to\n    :param dict data: (Optional) Form data to submit\n    :param dict json: (Optional) JSON data to submit. (Data must be None)\n    :param dict header: (Optional) Header data to include\n    :param bool stream: (Optional) Whether to stream the Response\n    :return: The response from the request\n    :rtype: Response\n    \n*/\n        public put(url: string, options?: RequestOptions): Response {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            let return_val = esp32spi.put(url, options)\n            this.pixelStatus(0)\n            return return_val\n        }\n\n        /** \n    Pass the patch request to requests and update status LED\n\n    :param str url: The URL to PUT data to\n    :param dict data: (Optional) Form data to submit\n    :param dict json: (Optional) JSON data to submit. (Data must be None)\n    :param dict header: (Optional) Header data to include\n    :param bool stream: (Optional) Whether to stream the Response\n    :return: The response from the request\n    :rtype: Response\n    \n*/\n        public patch(url: string, options?: RequestOptions): Response {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            let return_val = esp32spi.patch(url, options)\n            this.pixelStatus(0)\n            return return_val\n        }\n\n        /** \n    Pass the delete request to requests and update status LED\n \n    :param str url: The URL to PUT data to\n    :param dict data: (Optional) Form data to submit\n    :param dict json: (Optional) JSON data to submit. (Data must be None)\n    :param dict header: (Optional) Header data to include\n    :param bool stream: (Optional) Whether to stream the Response\n    :return: The response from the request\n    :rtype: Response\n    \n*/\n        public delete(url: string, options?: RequestOptions): Response {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            let return_val = esp32spi.del(url, options)\n            this.pixelStatus(0)\n            return return_val\n        }\n\n        /** \n    Pass the Ping request to the ESP32, update status LED, return response time\n\n    :param str host: The hostname or IP address to ping\n    :param int ttl: (Optional) The Time To Live in milliseconds for the packet (default=250)\n    :return: The response time in milliseconds\n    :rtype: int\n    \n*/\n        public ping(host: string, ttl = 250): number {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            // TODO: (below) types not compatible: number[] and number; \n            this.pixelStatus(0x0000e0)\n            let response_time = this.esp.ping(host)\n            this.pixelStatus(0)\n            return response_time\n        }\n\n        /** Returns a formatted local IP address, update status pixel. */\n        public get ip_address(): string {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n\n            this.pixelStatus(0x0000e0)\n            this.pixelStatus(0)\n            return this.esp.ipAddress;\n        }\n\n        /** Returns receiving signal strength indicator in dBm */\n        public get signalStrength(): number {\n            if (!this.esp.isConnected) {\n                this.connect()\n            }\n            return this.esp.rssi;\n        }\n    }\n}\n"
        },
        "mqtt": {
            "README.md": "# MQTT\n\nMQTT communication layer. A port of https://github.com/rovale/micro-mqtt for MakeCode.\n",
            "mqtt.ts": "namespace mqtt {\n    /**\n     * Connect flags\n     * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349229\n     */\n    export const enum ConnectFlags {\n        UserName = 128,\n        Password = 64,\n        WillRetain = 32,\n        WillQoS2 = 16,\n        WillQoS1 = 8,\n        Will = 4,\n        CleanSession = 2\n    }\n\n    /**\n     * Connect Return code\n     * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256\n     */\n    export const enum ConnectReturnCode {\n        Unknown = -1,\n        Accepted = 0,\n        UnacceptableProtocolVersion = 1,\n        IdentifierRejected = 2,\n        ServerUnavailable = 3,\n        BadUserNameOrPassword = 4,\n        NotAuthorized = 5\n    }\n\n    /**\n     * A message received in a Publish packet.\n     */\n    export interface IMessage {\n        pid?: number;\n        topic: string;\n        content: Buffer;\n        qos: number;\n        retain: number;\n    }\n\n    /**\n     * MQTT Control Packet type\n     * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc353481061\n     */\n    export const enum ControlPacketType {\n        Connect = 1,\n        ConnAck = 2,\n        Publish = 3,\n        PubAck = 4,\n        // PubRec = 5,\n        // PubRel = 6,\n        // PubComp = 7,\n        Subscribe = 8,\n        SubAck = 9,\n        Unsubscribe = 10,\n        UnsubAck = 11,\n        PingReq = 12,\n        PingResp = 13,\n        Disconnect = 14\n    }\n\n    /**\n     * Optimization, the TypeScript compiler replaces the constant enums.\n     */\n    export const enum Constants {\n        PingInterval = 40,\n        WatchDogInterval = 50,\n        DefaultQos = 0,\n        Uninitialized = -123,\n        FixedPackedId = 1,\n        KeepAlive = 60\n    }\n\n    /**\n     * The options used to connect to the MQTT broker.\n     */\n    export interface IConnectionOptions {\n        host: string;\n        port?: number;\n        username?: string;\n        password?: string;\n        clientId: string;\n        will?: IConnectionOptionsWill;\n    }\n\n    export interface IConnectionOptionsWill {\n        topic: string;\n        message: string;\n        qos?: number;\n        retain?: boolean;\n    }\n\n    /**\n     * The specifics of the MQTT protocol.\n     */\n    export module Protocol {\n        function strChr(codes: number[]): Buffer {\n            return pins.createBufferFromArray(codes)\n        }\n\n        /**\n         * Encode remaining length\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718023\n         */\n        function encodeRemainingLength(remainingLength: number): number[] {\n            let length: number = remainingLength;\n            const encBytes: number[] = [];\n            do {\n                let encByte: number = length & 127;\n                length = length >> 7;\n                // if there are more data to encode, set the top bit of this byte\n                if (length > 0) {\n                    encByte += 128;\n                }\n                encBytes.push(encByte);\n            } while (length > 0);\n\n            return encBytes;\n        }\n\n        /**\n         * Connect flags\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349229\n         */\n        function createConnectFlags(options: IConnectionOptions): number {\n            let flags: number = 0;\n            flags |= (options.username) ? ConnectFlags.UserName : 0;\n            flags |= (options.username && options.password) ? ConnectFlags.Password : 0;\n            flags |= ConnectFlags.CleanSession;\n\n            if (options.will) {\n                flags |= ConnectFlags.Will;\n                flags |= (options.will.qos || 0) << 3;\n                flags |= (options.will.retain) ? ConnectFlags.WillRetain : 0;\n            }\n\n            return flags;\n        }\n\n        // Returns the MSB and LSB.\n        function getBytes(int16: number): number[] {\n            return [int16 >> 8, int16 & 255];\n        }\n\n        /**\n         * Structure of UTF-8 encoded strings\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Figure_1.1_Structure\n         */\n        function pack(s: string): Buffer {\n            const buf = control.createBufferFromUTF8(s);\n            return strChr(getBytes(buf.length)).concat(buf);\n        }\n\n        /**\n         * Structure of an MQTT Control Packet\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800392\n         */\n        function createPacket(byte1: number, variable: Buffer, payload?: Buffer): Buffer {\n            if (payload == null) payload = control.createBuffer(0);\n            const byte2: number[] = encodeRemainingLength(variable.length + payload.length);\n            return strChr([byte1])\n                .concat(strChr(byte2))\n                .concat(variable)\n                .concat(payload)\n        }\n\n        /**\n         * CONNECT - Client requests a connection to a Server\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028\n         */\n        export function createConnect(options: IConnectionOptions): Buffer {\n            const byte1: number = ControlPacketType.Connect << 4;\n\n            const protocolName = pack('MQTT');\n            const nums = control.createBuffer(4)\n            nums[0] = 4; // protocol level\n            nums[1] = createConnectFlags(options)\n            nums[2] = 0\n            nums[3] = Constants.KeepAlive\n\n            let payload = pack(options.clientId);\n\n            if (options.will) {\n                payload = payload\n                    .concat(pack(options.will.topic)\n                        .concat(pack(options.will.message)));\n            }\n\n            if (options.username) {\n                payload = payload.concat(pack(options.username));\n                if (options.password) {\n                    payload = payload.concat(pack(options.password));\n                }\n            }\n\n            return createPacket(\n                byte1,\n                protocolName.concat(nums),\n                payload\n            );\n        }\n\n        /** PINGREQ - PING request\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800454\n         */\n        export function createPingReq() {\n            return strChr([ControlPacketType.PingReq << 4, 0]);\n        }\n\n        /**\n         * PUBLISH - Publish message\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800410\n         */\n        export function createPublish(topic: string, message: Buffer, qos: number, retained: boolean) {\n            let byte1: number = ControlPacketType.Publish << 4 | (qos << 1);\n            byte1 |= (retained) ? 1 : 0;\n\n            const pid = strChr(getBytes(Constants.FixedPackedId));\n            const variable = (qos === 0) ? pack(topic) : pack(topic).concat(pid);\n\n            return createPacket(byte1, variable, message);\n        }\n\n        export function parsePublish(cmd: number, payload: Buffer): IMessage {\n            const qos: number = (cmd & 0b00000110) >> 1;\n\n            const topicLength = payload.getNumber(NumberFormat.UInt16BE, 0);\n            let variableLength: number = 2 + topicLength;\n            if (qos > 0) {\n                variableLength += 2;\n            }\n\n            const message: IMessage = {\n                topic: payload.slice(2, topicLength).toString(),\n                content: payload.slice(variableLength),\n                qos: qos,\n                retain: cmd & 1\n            };\n\n            if (qos > 0)\n                message.pid = payload.getNumber(NumberFormat.UInt16BE, variableLength - 2);\n\n            return message;\n        }\n\n        /**\n         * PUBACK - Publish acknowledgement\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800416\n         */\n        export function createPubAck(pid: number) {\n            const byte1: number = ControlPacketType.PubAck << 4;\n\n            return createPacket(byte1, strChr(getBytes(pid)));\n        }\n\n        /**\n         * SUBSCRIBE - Subscribe to topics\n         * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800436\n         */\n        export function createSubscribe(topic: string, qos: number): Buffer {\n            const byte1: number = ControlPacketType.Subscribe << 4 | 2;\n            const pid = strChr(getBytes(Constants.FixedPackedId));\n\n            return createPacket(byte1,\n                pid,\n                pack(topic).concat(strChr([qos])))\n        }\n    }\n\n    export type EventHandler = (arg?: string | IMessage) => void;\n\n    export class EventEmitter {\n        private handlers: { [index: string]: EventHandler[] };\n\n        constructor() {\n            this.handlers = {};\n        }\n\n        public on(event: string, listener: EventHandler): void {\n            if (!event || !listener) return;\n\n            let listeners = this.handlers[event];\n            if (!listeners)\n                this.handlers[event] = listeners = [];\n            listeners.push(listener);\n        }\n        protected emit(event: string, arg?: string | IMessage): boolean {\n            let listeners = this.handlers[event];\n            if (listeners) {\n                listeners.forEach(listener => listener(arg));\n            }\n            return true;\n        }\n    }\n\n    class MQTTHandler {\n        constructor(\n            public topic: string,\n            public handler: (m: IMessage) => void\n        ) { }\n    }\n\n    export class Client extends EventEmitter {\n        public logPriority : ConsolePriority;\n        private log(msg: string) {\n            console.add(this.logPriority, `mqtt: ${msg}`);\n        }\n\n        public opt: IConnectionOptions;\n\n        private net: net.Net;\n        private sct?: net.Socket;\n\n        private wdId: number;\n        private piId: number;\n\n        private buf: Buffer;\n\n        public connected: boolean;\n\n        private mqttHandlers: MQTTHandler[];\n\n        constructor(opt: IConnectionOptions, net: net.Net) {\n            super();\n\n            this.wdId = Constants.Uninitialized;\n            this.piId = Constants.Uninitialized;\n            this.logPriority = ConsolePriority.Silent;\n            this.connected = false;\n            opt.port = opt.port || 8883;\n            opt.clientId = opt.clientId;\n\n            if (opt.will) {\n                opt.will.qos = opt.will.qos || Constants.DefaultQos;\n                opt.will.retain = opt.will.retain || false;\n            }\n\n            this.opt = opt;\n            this.net = net;\n        }\n\n        private static describe(code: ConnectReturnCode): string {\n            let error: string = 'Connection refused, ';\n            switch (code) {\n                case ConnectReturnCode.UnacceptableProtocolVersion:\n                    error += 'unacceptable protocol version.';\n                    break;\n                case ConnectReturnCode.IdentifierRejected:\n                    error += 'identifier rejected.';\n                    break;\n                case ConnectReturnCode.ServerUnavailable:\n                    error += 'server unavailable.';\n                    break;\n                case ConnectReturnCode.BadUserNameOrPassword:\n                    error += 'bad user name or password.';\n                    break;\n                case ConnectReturnCode.NotAuthorized:\n                    error += 'not authorized.';\n                    break;\n                default:\n                    error += `unknown return code: ${code}.`;\n            }\n\n            return error;\n        }\n\n        public disconnect(): void {\n            if (this.wdId !== Constants.Uninitialized) {\n                clearInterval(this.wdId);\n                this.wdId = Constants.Uninitialized;\n            }\n\n            if (this.piId !== Constants.Uninitialized) {\n                clearInterval(this.piId);\n                this.piId = Constants.Uninitialized;\n            }\n\n            if (this.sct) {\n                //this.sct.removeAllListeners('connect');\n                //this.sct.removeAllListeners('data');\n                //this.sct.removeAllListeners('close');\n                this.sct.close();\n            }\n        }\n\n        public connect(): void {\n            this.log(`Connecting to ${this.opt.host}:${this.opt.port}`);\n            if (this.wdId === Constants.Uninitialized) {\n                this.wdId = setInterval(() => {\n                    if (!this.connected) {\n                        this.emit('disconnected');\n                        this.emit('error', 'No connection. Retrying.');\n                        this.disconnect();\n                        this.connect();\n                    }\n                }, Constants.WatchDogInterval * 1000);\n            }\n\n            this.sct = this.net.createSocket(this.opt.host, this.opt.port);\n            this.sct.onOpen(() => {\n                this.log('Network connection established.');\n                this.emit('connect');\n                this.send(Protocol.createConnect(this.opt));\n            });\n            this.sct.onMessage((msg: Buffer) => {\n                this.log(\"incoming \" + msg.length + \" bytes\")\n                this.handleMessage(msg);\n            });\n            this.sct.onError(() => {\n                this.log('Error.');\n                this.emit('error');\n            });\n            this.sct.onClose(() => {\n                this.log('Close.');\n                this.emit('disconnected');\n                this.connected = false;\n            });\n            this.sct.connect();\n        }\n\n        // Publish a message\n        public publish(topic: string, message?: string | Buffer, qos: number = Constants.DefaultQos, retained: boolean = false): void {\n            const buf = typeof message == \"string\" ? control.createBufferFromUTF8(message) : message\n            this.send(Protocol.createPublish(topic, buf, qos, retained));\n        }\n\n        // Subscribe to topic\n        public subscribe(topic: string, handler?: (msg: IMessage) => void, qos: number = Constants.DefaultQos): void {\n            this.send(Protocol.createSubscribe(topic, qos));\n            if (handler) {\n                if (topic[topic.length - 1] == \"#\")\n                    topic = topic.slice(0, topic.length - 1)\n                if (!this.mqttHandlers) this.mqttHandlers = []\n                this.mqttHandlers.push(new MQTTHandler(topic, handler))\n            }\n        }\n\n        private send(data: Buffer): void {\n            if (this.sct) {\n                //this.log(\"send: \" + data[0] + \" / \" + data.length + \" bytes\")\n                this.log(\"send: \" + data[0] + \" / \" + data.length + \" bytes: \" + data.toString())\n                this.sct.send(data);\n            }\n        }\n\n        private handleMessage(data: Buffer) {\n            if (this.buf) {\n                data = this.buf.concat(data)\n                this.buf = null\n            }\n            if (data.length < 2)\n                return\n            let len = data[1]\n            let payloadOff = 2\n            if (len & 0x80) {\n                if (data.length < 3)\n                    return\n                if (data[2] & 0x80) {\n                    this.emit('error', `too large packet.`);\n                    this.buf = null\n                    return\n                }\n                len = (data[2] << 7) | (len & 0x7f)\n                payloadOff++\n            }\n\n            const payloadEnd = payloadOff + len\n            if (data.length < payloadEnd)\n                return // wait for the rest of data\n\n            const cmd = data[0]\n            const controlPacketType: ControlPacketType = cmd >> 4;\n            // this.emit('debug', `Rcvd: ${controlPacketType}: '${data}'.`);\n\n            const payload = data.slice(payloadOff, payloadEnd - payloadOff)\n\n            switch (controlPacketType) {\n                case ControlPacketType.ConnAck:\n                    const returnCode: number = payload[0];\n                    if (returnCode === ConnectReturnCode.Accepted) {\n                        this.log('MQTT connection accepted.');\n                        this.emit('connected');\n                        this.connected = true;\n                        this.piId = setInterval(() => this.ping(), Constants.PingInterval * 1000);\n                    } else {\n                        const connectionError: string = Client.describe(returnCode);\n                        this.emit('error', connectionError);\n                    }\n                    break;\n                case ControlPacketType.Publish:\n                    const message: IMessage = Protocol.parsePublish(cmd, payload);\n                    let handled = false\n                    if (this.mqttHandlers)\n                        for (let h of this.mqttHandlers)\n                            if (message.topic.slice(0, h.topic.length) == h.topic) {\n                                h.handler(message)\n                                handled = true\n                            }\n                    if (!handled)\n                        this.emit('receive', message);\n                    if (message.qos > 0) {\n                        setTimeout(() => {\n                            this.send(Protocol.createPubAck(message.pid || 0));\n                        }, 0);\n                    }\n                    break;\n                case ControlPacketType.PingResp:\n                case ControlPacketType.PubAck:\n                case ControlPacketType.SubAck:\n                    break;\n                default:\n                    this.emit('error', `MQTT unexpected packet type: ${controlPacketType}.`);\n            }\n\n            if (data.length > payloadEnd)\n                this.handleMessage(data.slice(payloadEnd))\n        }\n\n        private ping() {\n            this.send(Protocol.createPingReq());\n            this.emit('debug', 'Sent: Ping request.');\n        }\n    }\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"mqtt\",\n  \"description\": \"MQTT for MakeCode - beta\",\n  \"files\": [\n    \"README.md\",\n    \"mqtt.ts\"\n  ],\n  \"tests\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"net\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}"
        },
        "net": {
            "README.md": "# Net\n\nNetworking abstractions\n",
            "net.ts": "namespace net {\n    export let logPriority = ConsolePriority.Silent;\n    export function log(msg: string) {\n        console.add(logPriority, `net: ` + msg);\n    }\n\n    export interface Socket {\n        connect(): void;\n        send(data: string | Buffer): void;\n        read(contentLength: number): Buffer;\n        close(): void;\n        onOpen(handler: () => void): void;\n        onClose(handler: () => void): void;\n        onError(handler: (msg: string) => void): void;\n        onMessage(handler: (data: Buffer) => void): void;\n    }\n\n    export class Net {\n        constructor() {}\n        createSocket(host: string, port: number): Socket {\n            return undefined;\n        }\n    }\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"net\",\n  \"description\": \"Networking abstractions\",\n  \"files\": [\n    \"README.md\",\n    \"net.ts\",\n    \"requests.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "requests.ts": "namespace net {\n    export class Response {\n        _cached: Buffer\n        status_code: number\n        reason: string\n        _read_so_far: number\n        headers: StringMap;\n\n        /** The response from a request, contains all the headers/content */\n        constructor(private socket: Socket) {\n            this._cached = null\n            this.status_code = null\n            this.reason = null\n            this._read_so_far = 0\n            this.headers = {}\n        }\n\n        /** Close, delete and collect the response data */\n        public close() {\n            if (this.socket) {\n                this.socket.close()\n                this.socket = null\n            }\n            this._cached = null\n        }\n\n        /** The HTTP content direct from the socket, as bytes */\n        get content() {\n            let content_length = parseInt(this.headers[\"content-length\"]) || 0\n\n            // print(\"Content length:\", content_length)\n            if (this._cached === null) {\n                this._cached = this.socket.read(content_length)\n                this.socket.close()\n                this.socket = null\n            }\n\n            // print(\"Buffer length:\", len(self._cached))\n            return this._cached\n        }\n\n        /** \n         * The HTTP content, encoded into a string according to the HTTP header encoding\n        */\n        get text() {\n            return this.content.toString()\n        }\n\n        public json() {\n            return JSON.parse(this.text)\n        }\n    }\n\n    export interface RequestOptions {\n        data?: string | Buffer;\n        json?: any; // will call JSON.stringify()\n        headers?: StringMap;\n        stream?: boolean;\n        timeout?: number; // in ms\n    }\n\n    export function dataAsBuffer(data: string | Buffer): Buffer {\n        if (data == null)\n            return null\n        if (typeof data == \"string\")\n            return control.createBufferFromUTF8(data)\n        return data\n    }\n}"
        },
        "azureiot": {
            "README.md": "# Azure IoT support - beta\n\nAzure MQTT communication layer. \nA port of https://github.com/rovale/micro-mqtt for MakeCode.\n",
            "azureiot.ts": "const enum AzureIotEvent {\n    Connected = 1,\n    Disconnected = 2,\n    Error = 3\n}\n\nnamespace azureiot {\n    export let logPriority = ConsolePriority.Silent;\n\n    type SMap<T> = { [s: string]: T; }\n    export type Json = any;\n\n    let _mqttClient: mqtt.Client;\n    let _messageBusId: number;\n    let _receiveHandler: (msg: Json) => void;\n    let _methodHandlers: SMap<(msg: Json) => Json>;\n\n    function log(msg: string) {\n        console.add(logPriority, \"azureiot: \" + msg);\n    }\n\n    export function mqttClient(): mqtt.Client {\n        if (!_mqttClient)\n            _mqttClient = createMQTTClient();\n        return _mqttClient;\n    }\n\n    export let network: net.Net\n    export let connString = \"\"\n\n    function createMQTTClient() {\n        _messageBusId = control.allocateNotifyEvent(); // TODO\n\n        const connStringParts = parsePropertyBag(connString, \";\");\n        const iotHubHostName = connStringParts[\"HostName\"];\n        const deviceId = connStringParts[\"DeviceName\"];\n        const sasToken = connStringParts[\"SharedAccessSignature\"];\n\n        const opts: mqtt.IConnectionOptions = {\n            host: iotHubHostName,\n            /* port: 8883, overriden based on platform */\n            username: `${iotHubHostName}/${deviceId}/api-version=2018-06-30`,\n            password: \"SharedAccessSignature \" + sasToken,\n            clientId: deviceId\n        }\n        const c = new mqtt.Client(opts, network);\n        c.on('connected', () => {\n            log(\"connected\")\n            control.raiseEvent(_messageBusId, AzureIotEvent.Connected)\n        });\n        c.on('disconnected', () => {\n            log(\"disconnected\")\n            control.raiseEvent(_messageBusId, AzureIotEvent.Disconnected)\n        });\n        c.on('error', (msg) => {\n            log(\"error: \" + msg)\n            control.raiseEvent(_messageBusId, AzureIotEvent.Error)\n        });\n        c.on('receive', (packet: mqtt.IMessage) => {\n            log(\"unhandled msg: \" + packet.topic + \" / \" + packet.content.toString())\n        });\n        c.connect();\n        return c;\n    }\n\n    function splitPair(kv: string): string[] {\n        let i = kv.indexOf('=');\n        if (i < 0)\n            return [kv, \"\"];\n        else\n            return [kv.slice(0, i), kv.slice(i + 1)];\n    }\n\n    function parsePropertyBag(msg: string, separator?: string): any {\n        let r: any = {};\n        msg.split(separator || \"&\")\n            .map(kv => splitPair(kv))\n            .forEach(parts => r[parts[0]] = parts[1]);\n        return r;\n    }\n\n    function decodeQuery(msg: string, separator?: string): any {\n        const r = parsePropertyBag(msg, separator);\n        // TODO uridecode\n        Object.keys(r).forEach(k => r[k] = JSON.parse(r[k]));\n        return r;\n    }\n\n    function encodeQuery(props: any): string {\n        // TODO uriencode\n        return Object.keys(props)\n            .map(k => `${k}=${JSON.stringify(props[k])}`)\n            .join('&');\n    }\n\n    /**\n     * Connects to the IoT hub\n     */\n    export function connect() {\n        const c = mqttClient();\n        // wait for connection\n        if (!c.connected)\n            control.waitForEvent(_messageBusId, AzureIotEvent.Connected);\n    }\n\n    /**\n     * Registers code when the mqtt client gets connector or disconnected\n     * @param event \n     * @param handler \n     */\n    export function onEvent(event: AzureIotEvent, handler: () => void) {\n        const c = mqttClient();\n        control.onEvent(_messageBusId, event, handler);\n        if (c.connected) // raise connected event by default\n            control.raiseEvent(_messageBusId, AzureIotEvent.Connected);\n    }\n\n    /**\n     * Indicates if the MQTT client is connected\n     */\n    //%\n    export function isConnected(): boolean {\n        const c = mqttClient();\n        return !!c.connected;\n    }\n\n    /**\n     * Send a message via mqtt\n     * @param msg \n     */\n    //%\n    export function publishMessage(msg: any, sysProps?: any) {\n        const c = mqttClient();\n        let topic = `devices/${c.opt.clientId}/messages/events/`;\n        if (sysProps)\n            topic += encodeQuery(sysProps);\n        // qos, retained are not supported\n        c.publish(topic, JSON.stringify(msg));\n    }\n\n    /**\n     * Registers code to run when a message is received\n     * @param handler \n     */\n    //%\n    export function onMessageReceived(handler: (msg: any) => void) {\n        const c = mqttClient();\n        if (!_receiveHandler) {\n            c.subscribe(`devices/${c.opt.clientId}/messages/devicebound/#`, handleDeviceBound);\n\n            /*\n            c.subscribe(`devices/${c.opt.clientId}/messages/events/#`);\n            c.subscribe('$iothub/twin/PATCH/properties/desired/#')\n            c.subscribe(\"$iothub/twin/res/#\")\n            c.publish(\"$iothub/twin/GET/?$rid=foobar\")\n            */\n        }\n        _receiveHandler = handler;\n    }\n\n    function parseTopicArgs(topic: string) {\n        const qidx = topic.indexOf(\"?\")\n        if (qidx >= 0)\n            return parsePropertyBag(topic.slice(qidx + 1))\n        return {}\n    }\n\n    function handleDeviceBound(packet: mqtt.IMessage) {\n        if (!_receiveHandler) return; // nobody's listening\n        // TODO this needs some testing\n        const props = parseTopicArgs(packet.topic)\n        _receiveHandler(props);\n    }\n\n    function handleMethod(msg: mqtt.IMessage) {\n        const props = parseTopicArgs(msg.topic)\n        const qidx = msg.topic.indexOf(\"/?\")\n        const methodName = msg.topic.slice(21, qidx)\n        log(\"method: '\" + methodName + \"'; \" + JSON.stringify(props))\n        let status = 200\n        let resp: any = {}\n        if (!_methodHandlers[methodName]) {\n            log(\"method not found: '\" + methodName + \"'\")\n            status = 404\n        } else {\n            const h = _methodHandlers[methodName]\n            const resp2 = h(JSON.parse(msg.content.toString()))\n            if (resp2)\n                resp = resp2\n            if (resp[\"_status\"] != null) {\n                status = resp[\"_status\"]\n                resp[\"_status\"] = null\n            }\n            log(\"method: '\" + methodName + \"' status=\" + status)\n        }\n\n        const c = mqttClient();\n        c.publish('$iothub/methods/res/' + status + \"/?$rid=\" + props[\"$rid\"], JSON.stringify(resp))\n    }\n\n    export function onMethod(methodName: string, handler: (msg: Json) => Json) {\n        const c = mqttClient();\n        if (!_methodHandlers) {\n            if (!c.connected)\n                control.fail(\"not connected\")\n            _methodHandlers = {}\n            c.subscribe('$iothub/methods/POST/#', handleMethod)\n        }\n        _methodHandlers[methodName] = handler\n    }\n}\n",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"azureiot\",\n  \"description\": \"Azure IoT - beta\",\n  \"files\": [\n    \"azureiot.ts\",\n    \"README.md\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"mqtt\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  }\n}",
            "test.ts": "interface Secrets {\n    connString: string;\n    wifi: pxt.StringMap;\n}\n// this is to be overridden in a separate file\nlet secrets: Secrets;\nfunction test() {\n\n    const log = console.log;\n    const esp = new esp32spi.SPIController(pins.spi(),\n        pins.D13, pins.D11, pins.D12, pins.D10, 1)\n\n    if (esp.status != esp32spi.WL_IDLE_STATUS)\n        return\n\n    log(`Firmware vers. ${esp.firmwareVersion}`)\n    log(`MAC addr: ${esp.MACaddress.toHex()}`)\n    log(\"Temp: \" + esp.getTemperature())\n\n    const networks = esp.scanNetworks()\n\n    log(JSON.stringify(secrets.wifi))\n\n    for (const ap of networks)\n        log(`\\t${ap.ssid}\\t\\tRSSI: ${ap.rssi}`)\n\n    for (let k of Object.keys(secrets.wifi)) {\n        if (networks.some(n => n.ssid == k)) {\n            log(\"connecting to \" + k)\n            esp.connectAP(k, secrets.wifi[k])\n            break\n        }\n    }\n\n    if (!esp.isConnected) {\n        log(\"can't connect\")\n        return\n    }\n\n    log(\"ping: \" + esp.ping(\"bing.com\"))\n\n    azureiot.network = new esp32spi.NetTLS()\n    azureiot.connString = secrets.connString\n    azureiot.connect()\n    log(\"mqtt connected\")\n\n    azureiot.onMessageReceived((msg) => {\n        log(\"MSG:\" + JSON.stringify(msg))\n    })\n\n    azureiot.onMethod(\"echo\", msg => {\n        log(\"ECHO \" + msg.displayedValue)\n        msg.type = \"echo\"\n        return {}\n    })\n}\n\ntest();"
        },
        "color": {
            "README.md": "# Colors\n\nColor manipulation",
            "colorbuffer.ts": "namespace color {\n    export enum ColorBufferLayout {\n        /**\n         * 24bit RGB color\n         */\n        RGB,\n        /**\n         * 32bit RGB color with alpha\n         */\n        ARGB\n    }\n\n    /**\n     * A buffer of colors\n     */\n    export class ColorBuffer {\n        layout: ColorBufferLayout;\n        buf: Buffer;\n\n        constructor(length: number, layout?: ColorBufferLayout) {\n            this.layout = layout || ColorBufferLayout.RGB;\n            this.buf = control.createBuffer((length | 0) * this.stride);\n        }\n\n        static fromBuffer(buffer: Buffer, layout: ColorBufferLayout) {\n            const b = new ColorBuffer(0, layout);\n            b.buf = buffer;\n            return b;\n        }\n\n        get stride() {\n            return this.layout == ColorBufferLayout.RGB ? 3 : 4;\n        }\n\n        get length() {\n            return Math.idiv(this.buf.length, this.stride);\n        }\n\n        color(index: number): number {\n            index = index | 0;\n            if (index < 0 || index >= this.length) return -1;\n\n            const s = this.stride;\n            const start = index * s;\n            let c = 0;\n            for (let i = 0; i < s; ++i)\n                c = (c << 8) | (this.buf[start + i] & 0xff);\n            return c;\n        }\n\n        setColor(index: number, color: number) {\n            index = index | 0;\n            if (index < 0 || index >= this.length) return;\n\n            const s = this.stride;\n            const start = index * s;\n            for (let i = s - 1; i >= 0; --i) {\n                this.buf[start + i] = color & 0xff;\n                color = color >> 8;\n            }\n        }\n\n        slice(start?: number, length?: number): ColorBuffer {\n            const s = this.stride;\n            if (start === undefined)\n                start = 0;\n            start = start | 0;\n            if (start < 0)\n                start = this.length - start;\n            if (length === undefined)\n                length = this.length;\n            else if (length < 0)\n                length = this.length - length;\n            length = Math.min(length | 0, this.length - length - start);\n            const b = new ColorBuffer(length, this.layout);\n            for (let i = 0; i < length; ++i) {\n                b.setColor(i, this.color(start + i));\n            }\n            return b;\n        }\n\n        /**\n         * Writes the content of the src color buffer starting at the start dstOffset in the current buffer\n         * @param dstOffset \n         * @param src \n         */\n        write(dstOffset: number, src: ColorBuffer): void {\n            if (this.layout == src.layout) {\n                const d = (dstOffset | 0) * this.stride;\n                this.buf.write(d, src.buf);\n            } else {\n                // different color layout\n                const n = Math.min(src.length, this.length - dstOffset);\n                for (let i = 0; i < n; ++i)\n                    this.setColor(dstOffset + i, src.color(i));\n            }\n        }\n    }\n\n    /**\n     * Converts an array of colors into a color buffer\n     */\n    export function createBuffer(colors: number[], layout?: ColorBufferLayout): color.ColorBuffer {\n        const p = new ColorBuffer(colors.length, layout);\n        const n = colors.length;\n        for (let i = 0; i < n; i++) {\n            p.setColor(i, colors[i]);\n        }\n        return p;\n    }\n}",
            "colors.ts": "/**\n * Well known colors\n */\nconst enum Colors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFF7F00,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xA033E5,\n    //% block=pink\n    Pink = 0xFF007F,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Well known color hues\n */\nconst enum ColorHues {\n    //% block=red\n    Red = 0,\n    //% block=orange\n    Orange = 29,\n    //% block=yellow\n    Yellow = 43,\n    //% block=green\n    Green = 86,\n    //% block=aqua\n    Aqua = 125,\n    //% block=blue\n    Blue = 170,\n    //% block=purple\n    Purple = 191,\n    //% block=magenta\n    Magenta = 213,\n    //% block=pink\n    Pink = 234\n}\n\n/**\n * Color manipulation\n */\n//% advanced=1\nnamespace color {\n    /**\n * Converts red, green, blue channels into a RGB color\n * @param red value of the red channel between 0 and 255. eg: 255\n * @param green value of the green channel between 0 and 255. eg: 255\n * @param blue value of the blue channel between 0 and 255. eg: 255\n */\n    //% blockId=\"colorsrgb\" block=\"red %red|green %green|blue %blue\"\n    //% red.min=0 red.max=255 green.min=0 green.max=255 blue.min=0 blue.max=255\n    //% help=\"colors/rgb\"\n    //% weight=19 blockGap=8\n    //% blockHidden=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);\n    }\n\n    export function argb(alpha: number, red: number, green: number, blue: number): number {\n        return ((alpha & 0xFF) << 24) | ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);\n    }\n\n    /**\n    * Get the RGB value of a known color\n    */\n    //% blockId=colorscolors block=\"%color\"\n    //% help=\"colors/well-known\"\n    //% shim=TD_ID\n    //% weight=20 blockGap=8\n    //% blockHidden=true\n    export function wellKnown(color: Colors): number {\n        return color;\n    }\n\n    /**\n     * Convert an HSV (hue, saturation, value) color to RGB\n     * @param hue value of the hue channel between 0 and 255. eg: 255\n     * @param sat value of the saturation channel between 0 and 255. eg: 255\n     * @param val value of the value channel between 0 and 255. eg: 255\n     */\n\n    //% blockId=\"colorshsv\" block=\"hue %hue|sat %sat|val %val\"\n    //% hue.min=0 hue.max=255 sat.min=0 sat.max=255 val.min=0 val.max=255\n    //% help=\"colors/hsv\"\n    //% weight=17\n    //% blockHidden=true\n    export function hsv(hue: number, sat: number = 255, val: number = 255): number {\n        let h = (hue % 255) >> 0;\n        if (h < 0) h += 255;\n        // scale down to 0..192\n        h = (h * 192 / 255) >> 0;\n\n        //reference: based on FastLED's hsv2rgb rainbow algorithm [https://github.com/FastLED/FastLED](MIT)\n        let invsat = 255 - sat;\n        let brightness_floor = ((val * invsat) / 255) >> 0;\n        let color_amplitude = val - brightness_floor;\n        let section = (h / 0x40) >> 0; // [0..2]\n        let offset = (h % 0x40) >> 0; // [0..63]\n\n        let rampup = offset;\n        let rampdown = (0x40 - 1) - offset;\n\n        let rampup_amp_adj = ((rampup * color_amplitude) / (255 / 4)) >> 0;\n        let rampdown_amp_adj = ((rampdown * color_amplitude) / (255 / 4)) >> 0;\n\n        let rampup_adj_with_floor = (rampup_amp_adj + brightness_floor);\n        let rampdown_adj_with_floor = (rampdown_amp_adj + brightness_floor);\n\n        let r: number;\n        let g: number;\n        let b: number;\n        if (section) {\n            if (section == 1) {\n                // section 1: 0x40..0x7F\n                r = brightness_floor;\n                g = rampdown_adj_with_floor;\n                b = rampup_adj_with_floor;\n            } else {\n                // section 2; 0x80..0xBF\n                r = rampup_adj_with_floor;\n                g = brightness_floor;\n                b = rampdown_adj_with_floor;\n            }\n        } else {\n            // section 0: 0x00..0x3F\n            r = rampdown_adj_with_floor;\n            g = rampup_adj_with_floor;\n            b = brightness_floor;\n        }\n        return rgb(r, g, b);\n    }\n\n    /**\n     * Fade the color by the brightness\n     * @param color color to fade\n     * @param brightness the amount of brightness to apply to the color, eg: 128\n     */\n    //% blockId=\"colorsfade\" block=\"fade %color=neopixel_colors|by %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/fade\"\n    //% group=\"Color\" weight=18 blockGap=8\n    //% blockHidden=true\n    export function fade(color: number, brightness: number): number {\n        brightness = Math.max(0, Math.min(255, brightness >> 0));\n        if (brightness < 255) {\n            let red = unpackR(color);\n            let green = unpackG(color);\n            let blue = unpackB(color);\n\n            red = (red * brightness) >> 8;\n            green = (green * brightness) >> 8;\n            blue = (blue * brightness) >> 8;\n\n            color = rgb(red, green, blue);\n        }\n        return color;\n    }\n\n    export function blend(color: number, alpha: number, otherColor: number) {\n        alpha = Math.max(0, Math.min(0xff, alpha | 0));\n        const malpha = 0xff - alpha;\n        const r = (unpackR(color) * malpha + unpackR(otherColor) * alpha) >> 8;\n        const g = (unpackG(color) * malpha + unpackG(otherColor) * alpha) >> 8;\n        const b = (unpackB(color) * malpha + unpackB(otherColor) * alpha) >> 8;\n        return rgb(r, g, b);\n    }\n\n    export function gradient(startColor: number, endColor: number, steps: number): ColorBuffer {\n        steps = Math.max(2, steps | 0);\n        const b = new ColorBuffer(steps);\n        b.setColor(0, startColor);\n        b.setColor(b.length - 1, endColor);\n        for (let i = 1; i < steps - 1; ++i) {\n            const alpha = Math.idiv(0xff * i, steps);\n            const c = blend(startColor, alpha, endColor);\n            b.setColor(i, c);\n        }\n        return b;\n    }\n\n    export function unpackR(rgb: number): number {\n        return (rgb >> 16) & 0xFF;\n    }\n    export function unpackG(rgb: number): number {\n        return (rgb >> 8) & 0xFF;\n    }\n    export function unpackB(rgb: number): number {\n        return (rgb >> 0) & 0xFF;\n    }\n\n    export function parseColor(color: string): number {\n        switch (color) {\n            case \"RED\":\n            case \"red\":\n                return Colors.Red;\n            case \"GREEN\":\n            case \"green\":\n                return Colors.Green;\n            case \"BLUE\":\n            case \"blue\":\n                return Colors.Blue;\n            case \"WHITE\":\n            case \"white\":\n                return Colors.White;\n            case \"ORANGE\":\n            case \"orange\":\n                return Colors.Orange;\n            case \"PURPLE\":\n            case \"purple\":\n                return Colors.Purple;\n            case \"YELLOW\":\n            case \"yellow\":\n                return Colors.Yellow;\n            case \"PINK\":\n            case \"pink\":\n                return Colors.Pink;\n            default:\n                return parseInt(color) || 0;\n        }\n    }\n}",
            "pxt.json": "{\n  \"name\": \"color\",\n  \"description\": \"Color manipulation\",\n  \"files\": [\n    \"colors.ts\",\n    \"colorbuffer.ts\",\n    \"README.md\"\n  ],\n  \"public\": true,\n  \"weight\": 1,\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/8f99e7871b7dc24196702de079c50476b792f17a/static/libs/color.png\"\n}"
        },
        "palette": {
            "README.md": "# Palette\n\nHelpers to manipulate palette in games.",
            "palette.ts": "/**\n * Update the current scene palette\n */\nnamespace palette {\n    /**\n     * The default palette buffer for the project\n     */\n    //% whenUsed\n    const defaultPaletteBuffer = hex`__palette`\n\n    /**\n     * Returns a clone of the default palette\n     */\n    export function defaultPalette(): color.ColorBuffer {\n        return color.ColorBuffer.fromBuffer(defaultPaletteBuffer.slice(), color.ColorBufferLayout.RGB);\n    }\n\n    const FIELD = \"__palette\";\n    /**\n     * Dynamically set all or part of the game's current palette\n     *\n     * @param palette The colors to set\n     * @param pOffset The offset to start copying from the palette\n     */\n    export function setColors(palette: color.ColorBuffer, pOffset = 0) {\n        const scene = game.currentScene();\n        let userPalette = scene.data[FIELD] as color.ColorBuffer;\n        if (!userPalette)\n            userPalette = scene.data[FIELD] = defaultPalette();\n        userPalette.write(pOffset, palette);\n        image.setPalette(userPalette.buf);\n\n        // make sure to clean up\n        game.addScenePushHandler(scenePush);\n        game.addScenePopHandler(scenePop);\n    }\n\n    function scenePush(scene: scene.Scene) {\n        if (scene.data[FIELD]) {\n            const userPalette = scene.data[FIELD] as color.ColorBuffer;\n            image.setPalette(userPalette.buf);\n        }\n    }\n\n    function scenePop(scene: scene.Scene) {\n        if (scene.data[FIELD]) {\n            scene.data[FIELD] = undefined;\n            image.setPalette(defaultPaletteBuffer);\n        }\n    }\n\n    /**\n     * Reset to default palette\n     */\n    export function reset() {\n        const scene = game.currentScene();\n        scene.data[FIELD] = undefined;\n        image.setPalette(defaultPaletteBuffer);\n    }\n}\n",
            "pxt.json": "{\n  \"weight\": 75,\n  \"name\": \"palette\",\n  \"description\": \"Palette manipulations\",\n  \"files\": [\n    \"palette.ts\",\n    \"README.md\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"color\": \"*\",\n    \"game\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/1f1493550902e3b7db3e77d37fe8bfbe3dfcffc7/static/libs/palette.png\"\n}",
            "test.ts": "\nlet mySprite = sprites.create(img`\n0 1 2 3\n4 5 6 7\n8 9 a b\nc d e f\n`.doubled().doubled().doubled().doubled(), SpriteKind.Player)\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    const p = palette.defaultPalette();\n    for (let i = 0; i < p.length; ++i) {\n        p.setColor(i, color.rgb(i * 16, 0, 255 - i * 16));\n    }\n    p.setColor(0, 0)\n    palette.setColors(p)\n})\n\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n    palette.reset()\n})\n\n"
        },
        "storyboard": {
            "README.md": "# Storyboard\n\nOrchestrate scenes",
            "loader.ts": "namespace storyboard {\n    function loader(done: () => void) {\n        const font = image.font8;\n        let m = 40;\n        let w = screen.width - 2 * m;\n        let c = 2;\n        let y = screen.height / 2 - c;\n        let x = 0;\n        game.onPaint(function() {\n            screen.printCenter(\"MakeCode Arcade\", y - font.charHeight - c, 1, font);\n            screen.drawRect(m, y, w, 2 * c, 1)\n            screen.fillRect(m, y + 1, x, 2 * c - 2, 3);\n\n            x++;\n            if (x == w) done();\n        })\n    }\n\n    /**\n     * Default boot sequence\n     */\n    //% block=\"loader\" fixedInstance whenUsed\n    export const loaderBootSequence = new BootSequence(loader, 0);\n}",
            "pxt.json": "{\n  \"weight\": 81,\n  \"name\": \"storyboard\",\n  \"description\": \"Scene manager\",\n  \"files\": [\n    \"storyboard.ts\",\n    \"loader.ts\",\n    \"README.md\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"game\": \"*\",\n    \"color\": \"*\",\n    \"palette\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/97d8e0e9ecf7fa591e254c41ea4aceef69e35087/static/libs/storyboard.png\"\n}",
            "storyboard.ts": "/**\n * A manager of scenes\n */\n//% icon=\"\\uf009\"\n//% weight=87 color=\"#401255\"\nnamespace storyboard {\n    export interface FrameOptions {\n        background?: number;\n    }\n\n    export class Frame {\n        start: () => void;\n        options: FrameOptions;\n\n        constructor(start: () => void, options: FrameOptions) {\n            this.start = start;\n            this.options = options || {};\n        }\n    }\n\n    //% fixedInstances\n    export class BootSequence {\n        start: (done: () => void) => void;\n        background: number;\n        constructor(start: (done: () => void) => void, background: number) {\n            this.start = start;\n            this.background = background;\n        }\n\n        /**\n         * Registers the boot sequence\n         */\n        //% block=\"storyboard register %boot| boot sequence\" blockId=storyboardregister\n        register() {\n            registerBootSequence(this);\n        }\n    }\n\n    let _boots: BootSequence[];\n    let _scenes: {\n        [index: string]: Frame\n    };\n    let _nav: Frame[];\n\n    function registerBootSequence(boot: BootSequence) {\n        if (!_boots)\n            _boots = [];\n        if (_boots.indexOf(boot) < 0)\n            _boots.push(boot);\n    }\n\n    /**\n     * Registers a scene\n     * @param name \n     * @param scene \n     */\n    export function registerScene(name: string, start: () => void, options?: FrameOptions) {\n        if (!name) return;\n        if (!_scenes) {\n            _scenes = {};\n        }\n        _scenes[name] = new Frame(start, options);\n    }\n\n    function fadeBackground(last: BootSequence, next: BootSequence) {\n        if (last.background == next.background) return;\n\n        const fadeLength = palette.defaultPalette().length;\n        const fadeGradient = color.gradient(\n            last.background,\n            next.background,\n            fadeLength\n        );\n\n        palette.setColors(fadeGradient);\n        for (let i = 0; i < fadeLength; i++) {\n            scene.setBackgroundColor(i);\n            pause(50);\n        }\n        scene.setBackgroundColor(0xf);\n        palette.reset();\n    }\n\n    function consumeBootSequence() {\n        // run boot sequences if any\n        let boot: BootSequence;\n        let previous: BootSequence;\n        while (boot = _boots && _boots.shift()) {\n            game.pushScene();\n            if (previous)\n                fadeBackground(previous, boot);\n            let isDone = false;\n            boot.start(() => isDone = true);\n            pauseUntil(() => isDone);\n            game.popScene();\n            previous = boot;\n        }\n    }\n\n    /**\n     * Starts the story board by running boot sequences then entering a scene\n     * @param name \n     */\n    //% block=\"storyboard start at $name\" blockId=storyboardstart\n    export function start(name?: string) {\n        consumeBootSequence();\n        // grab the first frame\n        push(name || (_scenes && Object.keys(_scenes)[0]));\n    }\n\n    function isActive(name: string): boolean {\n        const scene = name && _scenes && _scenes[name];\n        return scene && (_nav && _nav.length && _nav[_nav.length - 1] == scene);\n    }\n\n    /**\n     * Replace the current scene with the given scene\n     * @param name \n     */\n    //% block=\"storyboard replace scene $name\" blockId=storyboardreplace\n    export function replace(name: string) {\n        if (isActive(name)) return;\n\n        const scene = name && _scenes && _scenes[name];\n        if (!scene) return; // not found\n\n        if (!_nav) _nav = [];\n        if (_nav.length) {\n            _nav.pop();\n            game.popScene();\n        }\n        _nav.push(scene);\n        game.pushScene();\n        scene.start();\n    }\n\n    /**\n     * Transition to a registered scene\n     * @param name \n     */\n    //% block=\"storyboard push scene $name\" blockId=storyboardpush\n    export function push(name: string) {\n        if (isActive(name)) return;\n\n        const scene = name && _scenes && _scenes[name];\n        if (!scene) return; // not found\n\n        if (!_nav) _nav = [];\n        if (_nav.length) {\n            game.popScene();\n        }\n        _nav.push(scene);\n        game.pushScene();\n        scene.start();\n    }\n\n    /**\n     * Stops the current scene and restart the previous scene\n     */\n    //% block=\"storyboard pop frame\" blockId=storyboardpop\n    export function pop() {\n        const n = _nav && _nav.pop();\n        if (n) {\n            game.popScene();\n        }\n        // restart previous\n        if (_nav && _nav.length) {\n            const sc = _nav[_nav.length - 1];\n            game.pushScene();\n            sc.start();\n        }\n    }\n}",
            "test.ts": "let mySprite = sprites.create(img`\n    . . . . . . b b b b a a . . . .\n    . . . . b b d d d 3 3 3 a a . .\n    . . . b d d d 3 3 3 3 3 3 a a .\n    . . b d d 3 3 3 3 3 3 3 3 3 a .\n    . b 3 d 3 3 3 3 3 b 3 3 3 3 a b\n    . b 3 3 3 3 3 a a 3 3 3 3 3 a b\n    b 3 3 3 3 3 a a 3 3 3 3 d a 4 b\n    b 3 3 3 3 b a 3 3 3 3 3 d a 4 b\n    b 3 3 3 3 3 3 3 3 3 3 d a 4 4 e\n    a 3 3 3 3 3 3 3 3 3 d a 4 4 4 e\n    a 3 3 3 3 3 3 3 d d a 4 4 4 e .\n    a a 3 3 3 d d d a a 4 4 4 e e .\n    . e a a a a a a 4 4 4 4 e e . .\n    . . e e b b 4 4 4 4 b e e . . .\n    . . . e e e e e e e e . . . . .\n    . . . . . . . . . . . . . . . .\n`, SpriteKind.Player)\nmySprite.x = 10\ncontroller.moveSprite(mySprite)\nstoryboard.loaderBootSequence.register()\nstoryboard.registerScene(\"lemon\", function () {\n    let mySprite2 = sprites.create(img`\n        4 4 4 . . 4 4 4 4 4 . . . . . .\n        4 5 5 4 4 5 5 5 5 5 4 4 . . . .\n        b 4 5 5 1 5 1 1 1 5 5 5 4 . . .\n        . b 5 5 5 5 1 1 5 5 1 1 5 4 . .\n        . b d 5 5 5 5 5 5 5 5 1 1 5 4 .\n        b 4 5 5 5 5 5 5 5 5 5 5 1 5 4 .\n        c d 5 5 5 5 5 5 5 5 5 5 5 5 5 4\n        c d 4 5 5 5 5 5 5 5 5 5 5 1 5 4\n        c 4 5 5 5 d 5 5 5 5 5 5 5 5 5 4\n        c 4 d 5 4 5 d 5 5 5 5 5 5 5 5 4\n        . c 4 5 5 5 5 d d d 5 5 5 5 5 b\n        . c 4 d 5 4 5 d 4 4 d 5 5 5 4 c\n        . . c 4 4 d 4 4 4 4 4 d d 5 d c\n        . . . c 4 4 4 4 4 4 4 4 5 5 5 4\n        . . . . c c b 4 4 4 b b 4 5 4 4\n        . . . . . . c c c c c c b b 4 .\n    `, SpriteKind.Player)\n    mySprite2.y = 20\n    controller.moveSprite(mySprite2)\n    controller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n        storyboard.push(\"burger\");\n    })\n    controller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n        storyboard.pop();\n    })\n})\nstoryboard.registerScene(\"burger\", function () {\n    let mySprite3 = sprites.create(img`\n        . . . . c c c b b b b b . . . .\n        . . c c b 4 4 4 4 4 4 b b b . .\n        . c c 4 4 4 4 4 5 4 4 4 4 b c .\n        . e 4 4 4 4 4 4 4 4 4 5 4 4 e .\n        e b 4 5 4 4 5 4 4 4 4 4 4 4 b c\n        e b 4 4 4 4 4 4 4 4 4 4 5 4 4 e\n        e b b 4 4 4 4 4 4 4 4 4 4 4 b e\n        . e b 4 4 4 4 4 5 4 4 4 4 b e .\n        8 7 e e b 4 4 4 4 4 4 b e e 6 8\n        8 7 2 e e e e e e e e e e 2 7 8\n        e 6 6 2 2 2 2 2 2 2 2 2 2 6 c e\n        e c 6 7 6 6 7 7 7 6 6 7 6 c c e\n        e b e 8 8 c c 8 8 c c c 8 e b e\n        e e b e c c e e e e e c e b e e\n        . e e b b 4 4 4 4 4 4 4 4 e e .\n        . . . c c c c c e e e e e . . .\n    `, SpriteKind.Player)\n    mySprite3.y = 80\n    controller.moveSprite(mySprite3)\n    controller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n        storyboard.replace(\"lemon\");\n    })\n    controller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n        storyboard.pop()\n    })\n})\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    storyboard.start(\"lemon\")\n})\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n    storyboard.start(\"burger\")\n})\n\n"
        },
        "rotary-encoder": {
            "README.md": "# Rotary Encoder\n\n## Configuration\n\nMap the following pins in your bootloader to configure the default \"crank\".\n\n```typescript\nPIN_ROTARY_ENCODER_A\nPIN_ROTARY_ENCODER_B\n```\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace encoders {\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "jacdac.ts": "namespace jacdac {\n    const ROT_EV_CHANGED = 0x2233;\n    //% fixedInstances\n    export class RotaryEncoderHost extends SensorHost {\n        encoder: RotaryEncoder;\n        constructor(encoder: RotaryEncoder) {\n            super(\"crank\", jacdac.ROTARY_ENCODER_DEVICE_CLASS);\n            this.encoder = encoder;\n            this.encoder.onChanged(() => this.raiseHostEvent(JDRotaryEncoderEvent.Changed))\n        }\n\n        serializeState(): Buffer {\n            const buf = control.createBuffer(4);\n            buf.setNumber(NumberFormat.Int32LE, 0, this.encoder.position());\n            return buf;\n        }\n    }\n\n    /**\n     * A rotary encoder JACDAC host\n     */\n    //% whenUsed fixedInstance block=\"rotary encoder host\"\n    export const rotaryEncoder = new RotaryEncoderHost(encoders.defaultEncoder);\n}",
            "ns.ts": "/**\n * Rotary encoders\n */\n//% color=\"#03AA74\" weight=87 icon=\"\\uf021\"\nnamespace encoders {\n\n    /**\n     * Gets the default rotary encoder if any\n     */\n    //% block=\"encoder\" fixedInstance whenUsed\n    export const defaultEncoder = encoders.createRotaryEncoder(undefined, undefined);\n}",
            "pxt.json": "{\n  \"hidden\": true,\n  \"name\": \"rotary-encoder\",\n  \"description\": \"Driver for rotary encoder\",\n  \"files\": [\n    \"rotary.cpp\",\n    \"enums.d.ts\",\n    \"shims.d.ts\",\n    \"ns.ts\",\n    \"targetoverrides.ts\",\n    \"jacdac.ts\",\n    \"README.md\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"jacdac\": \"*\"\n  },\n  \"targetVersions\": {\n    \"target\": \"0.14.9\"\n  },\n  \"icon\": \"@cdnUrl@/blob/92e1a3b2b7090a14ece327e819c9869dffb6739f/static/libs/rotary-encoder.png\"\n}",
            "rotary.cpp": "#include \"pxt.h\"\n\n// update sim if modifying these\n#define ROT_EV_TIMER 0x1233\n#define ROT_EV_CHANGED 0x2233\n\nconst static int8_t posMap[] = {0, +1, -1, +2, -1, 0, -2, +1, +1, -2, 0, -1, +2, -1, +1, 0};\n\nclass RotaryEncoder_ {\n  public:\n    uint16_t id;\n    uint16_t state;\n    int position;\n    Pin &pinA, &pinB;\n\n    void process(Event) {\n        // based on comments in https://github.com/PaulStoffregen/Encoder/blob/master/Encoder.h\n        uint16_t s = state & 3;\n        if (pinA.getDigitalValue())\n            s |= 4;\n        if (pinB.getDigitalValue())\n            s |= 8;\n\n        state = (s >> 2);\n        if (posMap[s]) {\n            int lastPosition = position;\n            position += posMap[s];\n            if ((lastPosition >> 2) != (position >> 2)) {\n                Event ev(id, ROT_EV_CHANGED);\n            }\n        }\n    }\n\n    RotaryEncoder_(Pin &pinA, Pin &pinB) : pinA(pinA), pinB(pinB) {\n        position = 0;\n        id = pinA.id;\n\n        pinA.setPull(codal::PullMode::Up);\n        pinB.setPull(codal::PullMode::Up);\n\n        // don't do exactly 1000us, so that it doesn't occur exactly at scheduler ticks\n        system_timer_event_every_us(973, id, ROT_EV_TIMER);\n        EventModel::defaultEventBus->listen(id, ROT_EV_TIMER, this, &RotaryEncoder_::process,\n                                            MESSAGE_BUS_LISTENER_IMMEDIATE);\n    }\n};\n\ntypedef class RotaryEncoder_ *RotaryEncoder;\n\n/**\n * Rotary and other encoders\n */\nnamespace encoders {\n/**\n * Create a new rotary encoder connected to given pins\n */\n//% weight=99\nRotaryEncoder createRotaryEncoder(DigitalInOutPin pinA, DigitalInOutPin pinB) {\n    if (!pinA && !pinB) {\n        pinA = LOOKUP_PIN(ROTARY_ENCODER_A);\n        pinB = LOOKUP_PIN(ROTARY_ENCODER_B);\n        // not configured?\n        if (!pinA && !pinB)\n            return NULL;\n    }\n\n    if (!pinA || !pinB)\n        target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n\n    return new RotaryEncoder_(*pinA, *pinB);\n}\n} // namespace pins\n\n//% noRefCounting fixedInstances\nnamespace RotaryEncoderMethods {\n/**\n * Do something when a rotary encoder changes position\n */\n//% blockNamespace=\"encoders\"\n//% blockId=rotaryencoderonchaned block=\"on %this changed\"\n//% weight=80 blockGap=8\nvoid onChanged(RotaryEncoder encoder, Action body) {\n    registerWithDal(encoder->id, ROT_EV_CHANGED, body);\n}\n\n/**\n * Get current encoder position.\n */\n//% blockNamespace=\"encoders\"\n//% blockId=rotaryencoderposition block=\"%this position\"\n//% weight=79 blockGap=8\nint position(RotaryEncoder encoder) {\n    // the position always changes by 4 per tick\n    return encoder->position >> 2;\n}\n\n} // namespace RotaryEncoderMethods\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n    /**\n     * Rotary and other encoders\n     */\n\ndeclare namespace encoders {\n\n    /**\n     * Create a new rotary encoder connected to given pins\n     */\n    //% weight=99 shim=encoders::createRotaryEncoder\n    function createRotaryEncoder(pinA: DigitalInOutPin, pinB: DigitalInOutPin): RotaryEncoder;\n}\n\n\n\n    //% noRefCounting fixedInstances\ndeclare interface RotaryEncoder {\n    /**\n     * Do something when a rotary encoder changes position\n     */\n    //% blockNamespace=\"encoders\"\n    //% blockId=rotaryencoderonchaned block=\"on %this changed\"\n    //% weight=80 blockGap=8 shim=RotaryEncoderMethods::onChanged\n    onChanged(body: () => void): void;\n\n    /**\n     * Get current encoder position.\n     */\n    //% blockNamespace=\"encoders\"\n    //% blockId=rotaryencoderposition block=\"%this position\"\n    //% weight=79 blockGap=8 shim=RotaryEncoderMethods::position\n    position(): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "targetoverrides.ts": "// target specific\n"
        }
    }
}

}
/*
     FILE ARCHIVED ON 13:51:25 Dec 29, 2019 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 23:08:31 Apr 27, 2023.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
*/
/*
playback timings (ms):
  captures_list: 247.065
  exclusion.robots: 0.072
  exclusion.robots.policy: 0.064
  cdx.remote: 0.052
  esindex: 0.007
  LoadShardBlock: 207.128 (3)
  PetaboxLoader3.datanode: 85.484 (4)
  load_resource: 240.507
  PetaboxLoader3.resolve: 153.713
*/